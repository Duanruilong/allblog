<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React开发常用设计模式-展示型组件和容器型组件]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[展示型组件和容器型组件万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。 我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 Clock 组件，它接收 Date 对象作为属性并显示实时时间。12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: this.props.time &#125;; this._update = this._updateTime.bind(this); &#125; render() &#123; const time = this._formatTime(this.state.time); return ( &lt;h1&gt; &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125; &lt;/h1&gt; ); &#125; componentDidMount() &#123; this._interval = setInterval(this._update, 1000); &#125; componentWillUnmount() &#123; clearInterval(this._interval); &#125; _formatTime(time) &#123; var [ hours, minutes, seconds ] = [ time.getHours(), time.getMinutes(), time.getSeconds() ].map(num =&gt; num &lt; 10 ? '0' + num : num); return &#123; hours, minutes, seconds &#125;; &#125; _updateTime() &#123; this.setState(&#123; time: new Date(this.state.time.getTime() + 1000) &#125;); &#125;&#125;;ReactDOM.render(&lt;Clock time=&#123; new Date() &#125;/&gt;, ...); 在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 setInterval ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: _formatTime 和_updateTime 。_formatTime 用来提取时分秒并确保它们是两位数的形式。_updateTime 用来将time 对象设置为当前时间加一秒。 问题这个组件中它做了好几件事，似乎承担了太多的职责。 它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。 _formatTime 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。 提取出容器型组件容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 高阶组件 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。 下面是 ClockContainer 的代码:12345678910111213141516171819202122232425262728293031// Clock/index.jsimport Clock from './Clock.jsx'; // &lt;-- 展示型组件export default class ClockContainer extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: props.time &#125;; this._update = this._updateTime.bind(this); &#125; render() &#123; return &lt;Clock &#123; ...this._extract(this.state.time) &#125;/&gt;; &#125; componentDidMount() &#123; this._interval = setInterval(this._update, 1000); &#125; componentWillUnmount() &#123; clearInterval(this._interval); &#125; _extract(time) &#123; return &#123; hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() &#125;; &#125; _updateTime() &#123; this.setState(&#123; time: new Date(this.state.time.getTime() + 1000) &#125;); &#125;&#125;; 它接收 time (date 对象) 属性，使用setInterval 循环并了解数据 (getHours、getMinutes 和 getSeconds) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。 展示型组件展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 无状态组件，它们没有内部状态。 在本示例中，展示型组件只包含两位数的检查并返回 &lt;h1&gt; 标签:12345678910// Clock/Clock.jsxexport default function Clock(props) &#123; var [ hours, minutes, seconds ] = [ props.hours, props.minutes, props.seconds ].map(num =&gt; num &lt; 10 ? '0' + num : num); return &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;&#125;; 优点将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。 容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 render 方法中的 ·· 组件。 测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。 结语容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅——个人申请]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。 小程序开发注册传送门，按照步骤完成注册认证就可以开始开发咯。 注册完之后就登录进入开发 填写个人资料 填写个人资料 注意事项： 1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。 2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。 3.每次登录都需要扫码认证，确认成功后就可以正常登录了。 个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具： 我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目 新建一个项目文件，输入自己的APPID，确定 进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！ 注意事项： 1.每次登录都需要扫码登录 2.需要输入自己的APPID 3.每次修改完代码都要编译 总结是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-受控输入和非受控输入]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[受控输入和非受控输入在 React 表单管理中有两个经常使用的术语: 受控输入和非受控输入。 受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个&lt;input&gt; 字段，它就是受控的:123456789 class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; &#125; render() &#123; return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;; &#125;&#125;; 上面代码的结果是我们可以操作input 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让input正常工作的话，需要为其添加onChange 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 input中输入的文字。123456789101112131415161718class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; this._change = this._handleInputChange.bind(this); &#125; render() &#123; return ( &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; onChange=&#123; this._change &#125; /&gt; ); &#125; _handleInputChange(e) &#123; this.setState(&#123; value: e.target.value &#125;); &#125;&#125;; 与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 defaultValue 属性来提供初始值，此后浏览器将负责保存输入的状态。123456789class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; &#125; render() &#123; return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt; &#125;&#125;; 上面的 &lt;input&gt;元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用 Refs 来获取 DOM 元素的实际引用。12345678910111213141516171819class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; this._change = this._handleInputChange.bind(this); &#125; render() &#123; return ( &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; onChange=&#123; this._change &#125; ref=&#123; input =&gt; this.input = input &#125;/&gt; ); &#125; _handleInputChange() &#123; this.setState(&#123; value: this.input.value &#125;); &#125;&#125;; ref属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量input中。之后当 onChange事件触发时，我们将 input 中的最新值保存到 App 组件的状态里。 大量使用refs 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。 结语使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-组合 (composition)]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88-composition%2F</url>
    <content type="text"><![CDATA[组合 ( composition )React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。 我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 React 组件 —App、Header 和 Navigation 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:1&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt; 组合这些组件的简单方法是在需要它们的时候引用即可。123456789101112131415161718// app.jsximport Header from './Header.jsx';export default function App() &#123; return &lt;Header /&gt;;&#125;// Header.jsximport Navigation from './Navigation.jsx';export default function Header() &#123; return &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;&#125;// Navigation.jsxexport default function Navigation() &#123; return (&lt;nav&gt; ... &lt;/nav&gt;);&#125; 但是，这种方式会引入一些问题: 我们可以把 App 看作是主要的组合场所。Header 可能还有其他元素，比如 logo、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 Navigation 的 Header 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。 代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 Navigation 组件出了问题，那么 Header 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: 浅层渲染 ( shallow rendering ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。) 使用 React children APIReact 提供了便利的 children 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 Header 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:12345678910export default function App() &#123; return ( &lt;Header&gt; &lt;Navigation /&gt; &lt;/Header&gt; );&#125;export default function Header(&#123; children &#125;) &#123; return &lt;header&gt;&#123; children &#125;&lt;/header&gt;;&#125;; 注意，如果不在 Header 中使用 { children }的话，那么 Navigation 组件永远不会渲染。 现在 Header 组件的测试变得更简单了，因为完全可以使用空 &lt;div&gt; 来渲染 Header 组件。这会使用组件更独立，并让我们专注于应用的一小部分。 将 child 作为 prop 传入每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。123456789101112131415161718const Title = function () &#123; return &lt;h1&gt;Hello there!&lt;/h1&gt;;&#125;const Header = function (&#123; title, children &#125;) &#123; return ( &lt;header&gt; &#123; title &#125; &#123; children &#125; &lt;/header&gt; );&#125;function App() &#123; return ( &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt; &lt;Navigation /&gt; &lt;/Header&gt; );&#125;; 运行结果： 当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。 高阶组件很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 装饰器模式 十分相似，因为它是对组件的包装与增强。 从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:1234567891011121314151617var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; render() &#123; return ( &lt;Component &#123;...this.props&#125; /&gt; ) &#125; &#125;;var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle);class App extends React.Component &#123; render() &#123; return &lt;EnhancedTitle /&gt;; &#125;&#125;; 高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有OriginalTitle所需要的配置:12345678910111213141516var config = require('path/to/configuration');var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; render() &#123; return ( &lt;Component &#123;...this.props&#125; title=&#123; config.appTitle &#125; /&gt; ) &#125; &#125;;var OriginalTitle = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle); appTitle 是封装在高阶组件内部的。OriginalTitle 只知道它所接收的 title 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建mocks 。 这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 OriginalTitle 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 OriginalTitle 。1234567891011121314151617181920212223242526var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; remoteTitle: null &#125;; &#125; componentDidMount() &#123; fetchRemoteData('path/to/endpoint').then(data =&gt; &#123; this.setState(&#123; remoteTitle: data.title &#125;); &#125;); &#125; render() &#123; return ( &lt;Component &#123;...this.props&#125; title=&#123; config.appTitle &#125; remoteTitle=&#123; this.state.remoteTitle &#125; /&gt; ) &#125; &#125;;var OriginalTitle = (&#123; title, remoteTitle &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle); 这次，OriginalTitle 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。 关于高阶组件的创建问题，Dan Abramov 提出了一个 非常棒的观点，像调用 enhanceComponent 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 将函数作为 children 传入和 render propReact 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 children 属性都是 React 组件。然而，有一种新的模式越来越受欢迎，children 属性是一个 JSX 表达式。我们先从传入一个简单对象开始。123456789101112131415161718function UserName(&#123; children &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;, &#123; children.firstName &#125; &lt;/div&gt; );&#125;function App() &#123; const user = &#123; firstName: 'Krasimir', lastName: 'Tsonev' &#125;; return ( &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt; );&#125; 运行结果： 这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。TodoList 组件只是简单地封装了所需的 HTML 标记。1234567891011121314151617181920212223242526272829function TodoList(&#123; todos, children &#125;) &#123; return ( &lt;section className='main-section'&gt; &lt;ul className='todo-list'&gt;&#123; todos.map((todo, i) =&gt; ( &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt; )) &#125;&lt;/ul&gt; &lt;/section&gt; );&#125;function App() &#123; const todos = [ &#123; label: 'Write tests', status: 'done' &#125;, &#123; label: 'Sent report', status: 'progress' &#125;, &#123; label: 'Answer emails', status: 'done' &#125; ]; const isCompleted = todo =&gt; todo.status === 'done'; return ( &lt;TodoList todos=&#123; todos &#125;&gt; &#123; todo =&gt; isCompleted(todo) ? &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label &#125; &lt;/TodoList&gt; );&#125; 运行结果： 注意观察 App 组件是如何不暴露数据结构的。TodoList 完全不知道 label 和 `status 属性。 名为 render prop 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 render 属性，而不是 children 。1234567891011121314151617181920function TodoList(&#123; todos, render &#125;) &#123; return ( &lt;section className='main-section'&gt; &lt;ul className='todo-list'&gt;&#123; todos.map((todo, i) =&gt; ( &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt; )) &#125;&lt;/ul&gt; &lt;/section&gt; );&#125;return ( &lt;TodoList todos=&#123; todos &#125; render=&#123; todo =&gt; isCompleted(todo) ? &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label &#125; /&gt;); 运行结果： 这两种模式 将函数作为 children 传入 和 render prop 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。1234567891011121314class DataProvider extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: null &#125;; setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000); &#125; render() &#123; if (this.state.data === null) return null; return ( &lt;section&gt;&#123; this.props.render(this.state.data) &#125;&lt;/section&gt; ); &#125;&#125; DataProvider 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个&lt;section&gt;，&lt;section&gt; 的内容是由 render 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。1&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt; 我们描述了我们想要做的事，而不是如何去做。细节都封装在了 DataProvider 中。最近，使用这种模式，某些界面限制只对具有 read:products 权限的用户开放。我们使用的是render prop 模式。123&lt;Authorize permissionsInclude=&#123;[ 'read:products' ]&#125; render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt; 这种声明式的方式相当不错，不言自明。Authorize 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 ProductList。 结语 你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-事件处理]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[事件处理对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。123456const theLogoIsClicked = () =&gt; alert('Clicked');&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;&lt;input type='text' onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt; 通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法: 123456789101112 class Switcher extends React.Component &#123; render() &#123; return ( &lt;button onClick=&#123; this._handleButtonClick &#125;&gt; click me &lt;/button&gt; ); &#125; _handleButtonClick() &#123; console.log(&apos;Button is clicked&apos;); &#125;&#125;; 这样使用完全可以，因为 _handleButtonClick 是一个函数，而我们也确实将这个函数传给了 onClick 属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 _handleButtonClick 函数中使用 this 来获取 Switcher 组件的引用时将会报错。通常，我们使用 bind 来解决:123&lt;button onClick=&#123; this._handleButtonClick.bind(this) &#125;&gt; click me&lt;/button&gt; 但是，这样做的话 bind 函数会一次又一次地被调用，这是因为 button 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:1234567891011121314151617class Switcher extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: 'React in patterns' &#125;; this._buttonClick = this._handleButtonClick.bind(this); &#125; render() &#123; return ( &lt;button onClick=&#123; this._buttonClick &#125;&gt; click me &lt;/button&gt; ); &#125; _handleButtonClick() &#123; console.log(`Button is clicked inside $&#123; this.state.name &#125;`); &#125;&#125;; 运行结果： 附带一提，在处理函数需要和组件的上下文保持统一时，Facebook 推荐 的也是此技巧。 构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。12345678910111213141516171819class Form extends React.Component &#123; constructor(props) &#123; super(props); this._onNameChanged = this._onFieldChange.bind(this, 'name'); this._onPasswordChanged = this._onFieldChange.bind(this, 'password'); &#125; render() &#123; return ( &lt;form&gt; &lt;input onChange=&#123; this._onNameChanged &#125; /&gt; &lt;input onChange=&#123; this._onPasswordChanged &#125; /&gt; &lt;/form&gt; ); &#125; _onFieldChange(field, event) &#123; console.log(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`); &#125;&#125;; 运行结果： 结语对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-组件通讯]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[组件通讯每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。 输入React 组件的输入是它的 props 。传递数据的方式如下:123456789101112131415// Demo.jsxfunction Demo(props) &#123; return &lt;h1&gt;&#123; props.text &#125;&lt;/h1&gt;;&#125;Demo.propTypes = &#123; text: PropTypes.string&#125;;Demo.defaultProps = &#123; text: 'Hello world'&#125;;// App.jsxfunction App() &#123; return &lt;Demo text='Hello React' /&gt;;&#125; Demo 组件只有一个输入属性 text 。父组件 (App) 在使用 &lt;Demo&gt; 标签时提供此属性。在定义组件的同时我们还定义了 propTypes 。在 propTypes 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。 React 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:12345678function SomethingElse(&#123; answer &#125;) &#123; return &lt;div&gt;The answer is &#123; answer &#125;&lt;/div&gt;;&#125;function Answer() &#123; return &lt;span&gt;42&lt;/span&gt;;&#125;&lt;SomethingElse answer=&#123; &lt;Answer /&gt; &#125; /&gt; 还有一个 props.children 属性，它可以让我们访问父组件标签内的子元素。例如:123456789101112131415function Title(&#123; text, children &#125;) &#123; return ( &lt;h1&gt; &#123; text &#125; &#123; children &#125; &lt;/h1&gt; );&#125;function App() &#123; return ( &lt;Title text='Hello React'&gt; &lt;span&gt;community&lt;/span&gt; &lt;/Title&gt; );&#125; 运行结果： 在这个示例中，App 组件中的 &lt;span&gt;community&lt;/span&gt; 就是 Title 组件中的 children 属性。注意，如果我们将 { children } 从 Title 组件中移除，那么 &lt;span&gt; 标签将不会渲染。 16.3 版本之前，组件还有一种间接输入，叫做context 。整个 React 组件树可能有一个 context 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 依赖注入 章节。 输出React 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。 在下面的示例中，有一个组件&lt;NameField /&gt;，它接受用户的输入并能将结果发送出去。12345678910111213141516171819202122function NameField(&#123; valueUpdated &#125;) &#123; return ( &lt;input onChange=&#123; event =&gt; valueUpdated(event.target.value) &#125; /&gt; );&#125;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: '' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;NameField valueUpdated=&#123; name =&gt; this.setState(&#123; name &#125;) &#125; /&gt; Name: &#123; this.state.name &#125; &lt;/div&gt; ); &#125;&#125;; 运行结果： 通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。123456789101112class ResultsPage extends React.Component &#123; componentDidMount() &#123; this.props.getResults(); &#125; render() &#123; if (this.props.results) &#123; return &lt;List results=&#123; this.props.results &#125; /&gt;; &#125; else &#123; return &lt;LoadingScreen /&gt; &#125; &#125;&#125; 假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 /results 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在componentDidMount 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 &lt;List&gt; 组件。 结语我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 开发常用设计模式-前言]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[React 模式介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。 Web https://sangka.github.io/react-in-patterns-cn/ GitHub https://github.com/SangKa/react-in-patterns-cn]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则速查表]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2FJavascript%E6%AD%A3%E5%88%99%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[replace:1234// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.function getLen(str) &#123; return str.replace(/[^\x00-\xff]/g, &apos;xx&apos;).length;&#125; test:123456789// 匹配是否符合邮件规则var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// test返回一个布尔值, 表示是否匹配到制定字符串var mail = reg.test(&apos;anran758@gmail.com&apos;)if (mail) &#123; // 如果邮件格式正确的话, 就可以做点啥了(雾&#125; 表单验证1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/; 网络相关1234567891011//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;// 匹配JSON格式var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ 联系方式1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/; 字符串相关123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\w+$/;// 匹配空白行的正则表达式var reg = /\n\s*\r/;// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/;var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/g; 匹配特定数字1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/;// 匹配负整数var reg = /^-[1-9]\d*$/;// 匹配整数var reg = /^-?[1-9]\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;// 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Rax，以及 Rax 的特点]]></title>
    <url>%2Fblog%2F2018%2F05%2F11%2F%E4%BB%80%E4%B9%88%E6%98%AF-Rax%EF%BC%8C%E4%BB%A5%E5%8F%8A-Rax-%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Rax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax. Rax经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。 Rax 与 ReactReact 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。 Rax 的特点1、设计上支持不同容器Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。 2、体积足够小如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。 3、支持返回多个同级节点任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：123456789import &#123;createElement, Component, render&#125; from &apos;rax&apos;;class Test extends Component &#123; render() &#123; return [1, 2, 3].map((item) =&gt; &#123; return &lt;p&gt;&#123;item&#125;&lt;/p&gt;; &#125;); &#125;&#125; 这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。 4、标准化在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。 未来Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?了解更多 Rax 相关内容，欢迎访问 alibaba.github.io/rax来自Rax 团队敬上。原文链接https://alibaba.github.io/rax/blog/whats-rax]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React一些路由]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2FReact%E4%B8%80%E4%BA%9B%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[1、Prompt组件 除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。 它有一个必须的属性message，用于给用户提示信息。基本使用：1&lt;Prompt message=&quot;给用户提示信息&quot;/&gt; 有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。基本使用方式：1&lt;Prompt when=&#123;true&#125; message=&quot;给用户提示信息&quot;/&gt; 2、Redirect组件 在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。 Redirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。基本使用：12&lt;Redirect to=&apos;/new-path&apos; /&gt;&lt;Route path=&apos;/new-path&apos; component=&#123;NewPage&#125;/&gt; 1&lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt; Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它基本使用方式：1234567891011121314151617181920212223242526272829303132333435363738394041424344import React,&#123; Component &#125; from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;class Index extends Component&#123; render()&#123; return ( &lt;div&gt;this a Index page&lt;/div&gt; ) &#125;&#125;class Other extends Component&#123; render()&#123; return ( &lt;div&gt;this a Other page&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; toast: false, &#125; &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/index&quot;&gt;这是首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;这是其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt; &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;//因为重定向，所以每个路由展示界面都是other界面render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;)); 3、Switch组件 它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。 基本使用方式：123456import &#123; Switch &#125; from &quot;react-router-dom&quot;;&lt;Switch&gt; &lt;Route path=&quot;/&quot; component=&#123;Test1&#125; /&gt; &lt;Route path=&quot;/Test&quot; component=&#123;Test2&#125; /&gt;&lt;/Switch&gt; 以下实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React,&#123; Component &#125; from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &quot;react-router-dom&quot;;class Home extends Component&#123; render()&#123; return ( &lt;div&gt;Home&lt;/div&gt; ) &#125;&#125;class Other extends Component&#123; render()&#123; return ( &lt;div&gt;Other&lt;/div&gt; ) &#125;&#125;class Switchs extends Component&#123; render()&#123; return ( &lt;div&gt;Switchs test&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&quot;/:id&quot; component=&#123;Switchs&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;)); 4、Match对象 match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。 在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。 Match的获取方式：在Route component中，组件通过this.props.match获取。在Route render 和Route children中，通过传递一个参数的方式获取。12345678910111213141516171819202122232425262728293031323334以下实例：```hashimport &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;class Match extends Component&#123; render()&#123; return ( &lt;div&gt;id:&#123;this.props.match.params.id&#125;&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/:id&quot; component=&#123;Match&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;//id是路径匹配参数。render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Hexo文章里的图片不显示问题]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E6%96%87%E7%AB%A0%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[First1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 3 等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 Second4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg) 也可以直接使用如下方式：1&#123;% asset_img long.png 记一次Hexo文章里的图片不显示问题 %&#125; 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题模板一些配置]]></title>
    <url>%2Fblog%2F2018%2F05%2F05%2Fnext%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.修改文章底部的那个带#号的标签实现效果图 具体实现方法 123456/themes/next/layout/_macro/post.swig找到 rel="tag"&gt;#修改为&lt;i class="fa fa-tag"&gt;&lt;/i&gt;完整的应该是这样的： &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 2.在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 12345678910111213141516在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：&lt;div&gt;&#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125;&#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 3.修改“代码块自定义样式具体实现方法打开 \themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 4.侧边栏社交小图标设置具体实现方法打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可123456789101112131415161718192021222324252627# 社交链接# Social Linkssocial:GitHub: https://github.com/DuanruilongCSDN: https://github.com/Duanruilong微博: https://github.com/DuanruilongQQ: https://github.com/Duanruilong知乎: https://github.com/Duanruilong# Social Links Icons/设定链接的图标social_icons:enable: trueicons_only: falsetransition: true# Icon Mappings.# KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesomeGitHub: githubE-Mail: envelopeGoogle: googleTwitter: twitterInstagram: instagramStackOverflow: stack-overflow微博: weibo知乎: envelopeQQ: qq微信: weixinCSDN: crosshairslinks_title: discord 5.在网站底部加上访问量具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上这句话：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： 1.pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 6.添加热度具体实现方法next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃：12345&#123;% if theme.post_meta.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;&#123;% endif %&#125;&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;&lt;span&gt;℃&lt;/span&gt; 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了12345678910111213post: created: 创建于 modified: 更新于 sticky: 置顶 posted: 发表于 in: 分类于 read_more: 阅读全文 untitled: 未命名 toc_empty: 此文章未包含目录 visitors: 热度 wordcount: 字数统计 min2read: 阅读时长 copyright: 7.网站底部字数统计具体方法实现切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 8.添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为:1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 9.设置网站的图标Favicon在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 11.实现统计功能在根目录下安装 hexo-wordcount,运行：1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 12.添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，添加如下代码12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条. 13.在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:description: copyright: categories:--- 这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/2018/05/05/next主题模板一些配置/,那么在根目录下_config.yml中写成类似这样：）123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://duanruilong.github.io/root: /blogpermalink: :year/:month/:day/:title/permalink_defaults: 14.修改网页底部的桃心打开themes/next/layout/_partials/footer.swig，找到：123&lt;span class=&quot;with-love&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.authoricon &#125;&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/i&gt;&lt;/span&gt; 然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 15.文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; alert(&apos;密码错误！&apos;); if (history.length === 1) &#123; location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:description: copyright: categories:password: password--- 16.添加jiathis分享在主题配置文件中，jiathis为true，就行了1234# Share 分享jiathis: true# Warning: JiaThis does not support https.#add_this_id: 如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改就可以了1234567891011121314&lt;!-- JiaThis Button BEGIN --&gt;&lt;div class=&quot;jiathis_style&quot;&gt; &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_kaixin001&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://www.jiathis.com/share&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;&lt;/div&gt; 17.博文置顶或者排序修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如12345678---title: 第一篇blogdate: 2018-05-04 23:38:11tags: 生活description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面copyright: truetop: 12--- 18.修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base =16px 19.修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 20.点击爆炸效果跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下：1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：12345&#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下：12# Fireworksfireworks: true 21.DaoVoice 在线联系首先在 daovoice 注册账号,邀请码是0f81ff2f，注册完成后会得到一个 app_id : 1234daovoice(&apos;init&apos;, &#123; app_id: &quot;0000000&quot;&#125;);daovoice(&apos;update&apos;); 记下这个 app_id的值，然后打开/themes/next/layout/_partials/head.swig,写下如下代码：123456789101112&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125;``````````````````````````````````````````` 12345接着打开主题配置文件，在最后写下如下代码：```hash# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 重新 hexo g &amp;&amp; hexo s 就能看到效果了。安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式 22.添加跟帖(来必力)有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Github搭建个人博客详细配置]]></title>
    <url>%2Fblog%2F2018%2F05%2F05%2F%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇blog]]></title>
    <url>%2Fblog%2F2018%2F05%2F04%2F%E7%AC%AC%E4%B8%80%E7%AF%87blog%2F</url>
    <content type="text"><![CDATA[前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； copyright —- 是不是有权限]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F05%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
