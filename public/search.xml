<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Taro+dva+Typescript 搭建微信小程序架构]]></title>
    <url>%2Fblog%2F2019%2F07%2F24%2FTaro-dva-Typescript%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[微信小程序的开发目前是很热的一个领域，有很多的开发模式，找到一种属于自己的方法才会使得开发顺心顺利。 此架构是使用 Taro + dva + typescript 构建前端开发 京东凹凸实验室的React框架Taro很成熟，又是大厂在维护更新迭代，不用担心没人维护的问题，他有自己的UI还有物料社区，比起原生小程序方便很多，支持多端，一处代码，多处运行，微信小程序、H5、百度小程序、支付宝小程序、字节跳动小程序、QQ轻应用、快应用、ReactNative； 数据管理是Redux集成的dva框架，是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架； TypeScript就是所谓的JavaScript超集。它不是JavaScript的替代品，也不会为JavaScript代码添加任何新功能。相反，TypeScript允许程序员在其代码中使用面向对象的构造，然后将其转换为JavaScript。它还包括类型安全和编译时类型检查等便利功能。 资料 Taro官网地址：https://taro.aotu.io/dva官网地址：https://dvajs.com/guide/ 开始前期工作准备cli 工具安装: 12345678# 使用 npm 安装 cli$ npm install -g @tarojs/cli# OR 使用 yarn 安装 cli$ yarn global add @tarojs/cli# OR 安装了 cnpm，使用 cnpm 安装 cli$ cnpm install -g @tarojs/cli 使用命令创建模板项目: 12$ taro init Taro_dva_Typescript 安装配置文件安装dva cnpm install --save dva-core dva-loading dva-core：封装了 redux 和 redux-saga的一个插件 dva-loading：管理页面的loading状态 安装@tarojs/redux cnpm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger 配置项目文件去除不需要的文件，添加实际需要的一些文件，先删除./ssrc/page下的index文件夹，后期使用命令行生成完整结构的文件夹。 在/src`目录下根据自己的实际需求进行一下配置： assets: 一些静态资源，比如：image、iconfont config: 项目配置文件 components: 项目编写的一些共用组件 types: 项目公共的Typescript类型声明 models: 项目dva插件model函数的引用或者是一些共用的js文件 utils: 项目里封装的一些插件 项目一些具体配置操作1、在./src/config下创建index.ts，添加项目配置信息12345678910111213141516171819202122232425262728/** * 这里为了方便测试使用 Easy Mock 模拟接口数据 * * https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist*/export const ONLINEHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';/** * mock 接口 * */ export const MOCKHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';/** * 是否mock*/export const ISMOCK = true;/** * 这是一个全局的分享信息 不用每一个都去写 */export const SHAREINFO = &#123; 'title': '分享标题', 'path': '路径', 'imageUrl': '图片' &#125; 2、在./src/utils下创建dva.ts，配置dva12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; create &#125; from "dva-core";import &#123; createLogger &#125; from "redux-logger";import createLoading from "dva-loading";let applet storelet dispatchlet registeredfunction createApp(opt) &#123; // redux 的日志 opt.onAction = [createLogger()] app = create(opt) app.use(createLoading(&#123;&#125;)) if (!registered) &#123; opt.models.forEach(model =&gt; app.model(model)); &#125; registered = true; app.start() store = app._store; app.getStore = () =&gt; store; app.use(&#123; onError(err)&#123; console.log(err); &#125; &#125;) dispatch = store.dispatch; app.dispatch = dispatch; return app;&#125;export default&#123; createApp, getDispatch()&#123; return app.dispatch &#125;&#125; 3、在./src/utils下创建tips.ts，整合封装微信原生弹窗12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import Taro from "@tarojs/taro";import &#123; node &#125; from "_@types_prop-types@15.7.1@@types/prop-types";/** * 整合封装微信的原生弹窗 * 提示、加载、工具类*/export default class Tips &#123; static isLoading = false; /** * 提示信息 */ static toast(title: string, onHide?: () =&gt; void) &#123; Taro.showToast(&#123; title: title, icon: 'node', mask: true, duration: 1500 &#125;); // 去除结束回调函数 if (onHide) &#123; setTimeout(() =&gt; &#123; onHide(); &#125;, 500); &#125; &#125; /** * 加载提示弹窗 */ static loding(title:'加载中',force = false)&#123; if (this.isLoading &amp;&amp; !force) &#123; return &#125; this.isLoading = true; if (Taro.showLoading) &#123; Taro.showLoading(&#123; title:title, mask:true &#125;) &#125;else&#123; Taro.showNavigationBarLoading() //导航条加载动画 &#125; &#125; /** * 加载完成 */ static loaded()&#123; let duration = 0; if (this.isLoading) &#123; this.isLoading = false; if (Taro.hideLoading) &#123; Taro.hideLoading() &#125; else &#123; Taro.hideNavigationBarLoading(); //导航条加载动画 &#125; duration = 500; &#125; // 设定隐藏的动画时长为500ms,防止直接toast时出现问题 return new Promise(resolve =&gt; setTimeout(resolve,duration)) &#125; /** * 弹出提示框 */ static success(title,duration = 1500)&#123; Taro.showToast(&#123; title: title, icon: 'success', duration: duration, mask:true &#125;) if (duration &gt; 0) &#123; return new Promise(resolve =&gt; setTimeout(resolve,duration)) &#125; &#125;&#125; 4、在./src/config下创建requestConfig.ts，统一配置请求接口12345678910111213/** * 请求公共参数*/export const commonParame = &#123;&#125;/** * 请求的映射文件*/export const requestConfig = &#123; loginUrl:'/api/user/wechat-auth' // 微信的登陆接口&#125; 5、在./src/utils下创建common.ts，共用函数12345678910111213141516171819/** * 共用函数*/export const repeat = (str = '0', times) =&gt; (new Array(times + 1)).join(str);// 时间前面 +0 export const pad = (num, maxLength = 2) =&gt; repeat('0', maxLength - num.toString().length) + num;// 全局的公共变量export let globalData: any = &#123;&#125;// 时间格式装换函数export const formatTime = time =&gt; &#123; `$&#123;pad(time.getHours())&#125;:$&#123;pad(time.getMinutes())&#125;:$&#123;pad(time.getSeconds())&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;`&#125; 6、在./src/utils下创建logger.ts，封装log函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 封装logo函数*/import &#123; formatTime &#125; from './common';const defaults = &#123; level: 'log', logger: console, logErrors: true, colors: &#123; title:'logger', req:'#9e9e9e', res:'#4caf50', error:'#f20404', &#125;&#125;function printBuffer(logEntry, options)&#123; const &#123;logger,colors&#125; = options; let &#123;title,started,req,res&#125; = logEntry; // Message const headerCSS = ['color:gray; font-weight:lighter;'] const styles = s =&gt; `color $&#123;s&#125;; font-weight: bold`; // render logger.group(`%c $&#123;title&#125; @$&#123;formatTime(started)&#125;`, ...headerCSS); logger.log('%c req', styles(colors.req), req) logger.log('%c res', styles(colors.res), res) logger.groupEnd()&#125;interface LogEntry&#123; started ? : object // 触发时间&#125;function createLogger(options: LogEntry = &#123;&#125;)&#123; const loggerOptions = Object.assign(&#123;&#125;, defaults, options) const logEntry = options logEntry.started = new Date(); printBuffer(logEntry, Object.assign(&#123;&#125;, loggerOptions))&#125;export &#123; defaults, createLogger,&#125; 7、在./src/utils下创建request.ts，封装http请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import Taro,&#123; Component &#125; from "@tarojs/taro";import &#123; ISMOCK,MAINHOST &#125; from "../config";import &#123; commonParame,requestConfig &#125; from "../config/requestConfig";import Tips from "./tips";// 封装请求declare type Methohs = "GET" | "OPTIONS" | "HEAD" | "PUT" | "DELETE" | "TRACE" | "CONNECT";declare type Headers = &#123; [key :string]:string&#125;;declare type Datas = &#123;method : Methohs; [key: string] : any;&#125;;interface Options&#123; url: string; host?: string; method?: Methohs; data?: Datas; header?: Headers;&#125;export class Request &#123; // 登陆时的promise static loginReadyPromise: Promise&lt;any&gt; = Promise.resolve() // 正在登陆 static isLoading: boolean = false // 导出的API对象 static apiLists: &#123; [key: string]: () =&gt; any;&#125; = &#123;&#125; // token static token: string = '' // 开始处理options static conbineOptions(opts, data: Datas, method: Methohs): Options &#123; typeof opts === 'string' &amp;&amp; (opts = &#123;url: opts&#125;) return &#123; data: &#123; ...commonParame, ...opts.data, ...data &#125;, method: opts.method || data.method || method || 'GET', url: `$&#123;opts.host || MAINHOST&#125;$&#123;opts.url&#125;` &#125; &#125; static getToken()&#123; !this.token &amp;&amp; (this.token = Taro.getStorageSync('token')) return this.token &#125; // 登陆 static login()&#123; if (!this.isLoading) &#123; this.loginReadyPromise = this.onLogining() &#125; return this.loginReadyPromise &#125; static onLogining()&#123; this.isLoading = true; return new Promise(async (resolve, reject) =&gt; &#123; // 获取code const &#123; code &#125; = await Taro.login(); const &#123; data &#125; = await Taro.request(&#123; url: `$&#123;MAINHOST&#125;$&#123;requestConfig.loginUrl&#125;`, data:&#123;code: code&#125; &#125;) if (data.code !== 0 || !data.data || !data.data.token) &#123; reject() return &#125; &#125;) &#125; /** * 基于 Taro.request 的 request 请求 * * */ static async request(opts: Options) &#123; // Taro.request 请求 const res = await Taro.request(opts); // 是否mock if(ISMOCK) return res.data; // 请求失败 if (res.data.code === 99999) &#123; await this.login(); return this.request(opts) &#125; // 请求成功 if (res.data) &#123; return res.data &#125; // 请求错误 const edata = &#123; ...res.data, err : (res.data &amp;&amp; res.data.msg) || '网络错误 ~'&#125; Tips.toast(edata.err) throw new Error(edata.err) &#125; /** * 创建请求函数 */ static creatRequests(opts: Options | string) : () =&gt; &#123;&#125; &#123; console.log('opts==&gt;',opts); return async (data=&#123;&#125;, method: Methods = "GET") =&gt; &#123; const _opts = this.conbineOptions(opts, data, method) const res = await this.request(_opts) return res; &#125; &#125; /** * 抛出API方法 */ static getApiList(requestConfig)&#123; if (!Object.keys(requestConfig).length) &#123; return &#123;&#125; &#125; Object.keys(requestConfig).forEach((key)=&gt;&#123; this.apiLists[key] = this.creatRequests(requestConfig[key]) &#125;) return this.apiLists &#125;&#125;const Api = Request.getApiList(requestConfig)Component.prototype.$api = Apiexport default Api as any 注： 在这里tslint会报这样的错：类型“Component&lt;any, any&gt;”上不存在属性“$api”。，因为没有添加声明，需在./src目录下创建app-shim.d.ts 1234567891011121314151617/** * 添加taro等自定义类型*/import Taro,&#123; Component &#125; from '@tarojs/taro'// 在Component上定义自定义方法类型declare module '@tarojs/taro' &#123; interface Component &#123; $api: any &#125;&#125;// 声明declare let require: any;declare let dispatch: any 8、在./src/config下创建taroConfig.ts，封装taro小程序的一些方法12345678910111213141516171819202122232425262728import Taro,&#123; Component &#125; from '@tarojs/taro'import &#123; SHAREINFO &#125; from '../config/index'/** * 封装taro小程序的一些方法 * - 方法改写 * - utils 挂载*/// navigateTo 超过8次后，强行进行redirectTo,避免页面卡顿 const nav = Taro.navigateTo Taro.navigateTo = (data) =&gt; &#123; if (Taro.getCurrentPages().length &gt; 8) &#123; return Taro.redirectTo(data) &#125; return nav(data) &#125;// 挂载分享方法 ComponentComponent.prototype.onShareAppMessage = function () &#123; return SHAREINFO&#125; 配置文件生成脚本1、在根目录下创建scripts文件夹，添加./scripts/template.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * pages 页面快速生成脚本 * * npm run tem '文件名‘*/const fs = require('fs')const dirName = process.argv[2]const capPirName = dirName.substring(0, 1).toUpperCase() + dirName.substring(1);if (!dirName) &#123; console.log('文件名不能为空'); console.log('用法：npm run tem test'); process.exit(0);&#125;// 页面模板构建const indexTep = ` import Taro, &#123; Component, Config &#125; from '@tarojs/taro' import &#123; View &#125; from '@tarojs/components' // import &#123; connect &#125; from '@tarojs/redux' // import Api from '../../utils/request' // import Tips from '../../utils/tips' import &#123; $&#123;capPirName&#125;Props, $&#123;capPirName&#125;State &#125; from './$&#123;dirName&#125;.interface' import './$&#123;dirName&#125;.scss' // import &#123; &#125; from '../../components' // @connect((&#123; $&#123;dirName&#125; &#125;) =&gt; (&#123; // ...$&#123;dirName&#125;, // &#125;)) class $&#123;capPirName&#125; extends Component&lt;$&#123;capPirName&#125;Props,$&#123;capPirName&#125;State &gt; &#123; config:Config = &#123; navigationBarTitleText: '页面标题' &#125; constructor(props: $&#123;capPirName&#125;Props) &#123; super(props) this.state = &#123;&#125; &#125; componentDidMount() &#123; &#125; render() &#123; return ( &lt;View className='fx-$&#123;dirName&#125;-wrap'&gt; 页面内容 &lt;/View&gt; ) &#125; &#125; export default $&#123;capPirName&#125;`// scss 文件模板const scssTep = ` @import "../../assets/scss/variables"; .#&#123;$prefix&#125; &#123; &amp;-$&#123;dirName&#125;-wrap &#123; width: 100%; min-height: 100Vh; &#125; &#125;`// config 接口地址配置模板const configTep =` export default &#123; test:'/wechat/perfect-info', //XX接口 &#125;`// 接口请求模板const serviceTep =` import Api from '../../utils/request' export const testApi = data =&gt; Api.test( data )`// model 模板const modelTep = ` // import Taro from '@tarojs/taro'; // import * as $&#123;dirName&#125;Api from './service'; export default &#123; namespace: '$&#123;dirName&#125;', state: &#123; &#125;, effects: &#123;&#125;, reducers: &#123;&#125; &#125;`const interfaceTep = `/** * $&#123;dirName&#125;.state 参数类型 * * @export * @interface $&#123;capPirName&#125;State */export interface $&#123;capPirName&#125;State &#123;&#125;/** * $&#123;dirName&#125;.props 参数类型 * * @export * @interface $&#123;capPirName&#125;Props */export interface $&#123;capPirName&#125;Props &#123;&#125;`fs.mkdirSync(`./src/pages/$&#123;dirName&#125;`); // mkdir $1process.chdir(`./src/pages/$&#123;dirName&#125;`); // cd $1fs.writeFileSync(`$&#123;dirName&#125;.tsx`, indexTep); //tsxfs.writeFileSync(`$&#123;dirName&#125;.scss`, scssTep); // scssfs.writeFileSync('config.ts', configTep); // configfs.writeFileSync('service.ts', serviceTep); // servicefs.writeFileSync('model.ts', modelTep); // modelfs.writeFileSync(`$&#123;dirName&#125;.interface.ts`, interfaceTep); // interfaceprocess.exit(0); 最后 在根目录的package.json的scripts里加上对应的命令 123456"scripts": &#123; ... "tep": "node scripts/template", "com": "node scripts/component"&#125; 2、自动生成脚本文件夹cnpm run tep index page文件夹下生成了一个index的文件夹，里面包含 config.ts index.interface.ts index.scss index.tsx model.ts service.ts 配置业务代码1、先在src目录下创建models文件夹，集合项目里的model关系。1234567import index from '../pages/index/model';export default[ index] 项目目前只有index页面，export default这里的数组就只有index，需要注意这里是[]数组。 2、修改非常主要的文件app.tsx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import Taro, &#123; Component, Config &#125; from '@tarojs/taro'import "@tarojs/async-await";import &#123; Provider &#125; from "@tarojs/redux";import dva from './utils/dva';import './utils/request';import &#123; globalData &#125; from './utils/common';import models from './models'import Index from './pages/index'import './app.scss'// 如果需要在 h5 环境中开启 React Devtools// 取消以下注释：// if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.TARO_ENV === 'h5') &#123;// require('nerv-devtools')// &#125;const dvaApp = dva.createApp(&#123; initialState:&#123;&#125;, models: models,&#125;)const store = dvaApp.getStore();class App extends Component &#123; /** * 指定config的类型声明为: Taro.Config * * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型 * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型 */ config: Config = &#123; pages: [ 'pages/index/index' ], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125; /** * * 1.小程序打开的参数 globalData.extraData.xx * 2.从二维码进入的参数 globalData.extraData.xx * 3.获取小程序的设备信息 globalData.systemInfo */ async componentDidMount () &#123; // 获取参数 const referrerInfo = this.$router.params.referrerInfo const query = this.$router.params.query !globalData.extraData &amp;&amp; (globalData.extraData = &#123;&#125;) if (referrerInfo &amp;&amp; referrerInfo.extraData) &#123; globalData.extraData = referrerInfo.extraData &#125; if (query) &#123; globalData.extraData = &#123; ...globalData.extraData, ...query &#125; &#125; // 获取设备信息 const sys = await Taro.getSystemInfo() sys &amp;&amp; (globalData.systemInfo = sys) &#125; componentDidShow () &#123;&#125; componentDidHide () &#123;&#125; componentDidCatchError () &#123;&#125; render () &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Index /&gt; &lt;/Provider&gt; ) &#125;&#125;Taro.render(&lt;App /&gt;, document.getElementById('app')) 3、修改接口请求./src/pages/index/config.ts文件一个获取列表数据接口 1234export default &#123; getList: '/getlist', //getlist接口&#125; 4、修改./src/config/requestConfig.ts文件的映射关系引入index页面的刚刚创建的config文件 123456789101112131415161718import index from "../pages/index/config"; // index的接口/** * 请求公共参数*/export const commonParame = &#123;&#125;/** * 请求的映射文件*/export const requestConfig = &#123; loginUrl:'/api/user/wechat-auth', // 微信的登陆接口 ...index&#125; 5、修改./src/pages/index/service.ts里的接口请求还是依据之前的getlist接口 12345678import Api from '../../utils/request'export const getList = (data) =&gt; &#123; return Api.getList(data)&#125; 6、修改./src/pages/index/index.interface.ts里的参数类型根据项目具体的参数，自行进行配置 123456789101112131415161718192021222324252627/** * index.state 参数类型 * @interface IndexState */export interface IndexState &#123;&#125;/** * index.props 参数类型 * * @export * @interface IndexProps */export interface IndexProps &#123; dispatch?: any, data?: Array&lt;DataInterface&gt;&#125;export interface DataInterface &#123; des:string, lunar:string, thumbnail_pic_s:string, title:string, _id:string&#125; 7、修改./src/pages/index/model.ts里effects函数在这里创建页面需要请求的接口，链接service里的接口发起数据请求,这里以getList为例。 123456789101112131415161718192021222324252627282930313233343536// import Taro from '@tarojs/taro';import * as indexApi from './service';export default &#123; namespace: 'index', state: &#123; data:[], v:'1.0', &#125;, effects: &#123; *getList(&#123; payload &#125;,&#123;select, call, put&#125;)&#123; const &#123; error, result&#125; = yield call(indexApi.getList,&#123; ...payload &#125;) console.log('数据接口返回',result); if (!error) &#123; yield put(&#123; type: 'save', payload: &#123; data:result.data &#125;, &#125;) &#125; &#125; &#125;, reducers: &#123; save(state, &#123; payload &#125;) &#123; return &#123; ...state, ...payload &#125;; &#125;, &#125;&#125; 8、修改./src/pages/index/index.tsx里页面结构这里简单的实现列表新闻页面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import Taro, &#123; Component, Config &#125; from '@tarojs/taro'import &#123; View, Text&#125; from '@tarojs/components'import &#123; connect &#125; from '@tarojs/redux'// import Api from '../../utils/request'// import Tips from '../../utils/tips'import &#123; IndexProps, IndexState &#125; from './index.interface'import './index.scss'// import &#123; &#125; from '../../components'@connect((&#123; index &#125;) =&gt; (&#123; ...index,&#125;))class Index extends Component&lt;IndexProps,IndexState &gt; &#123; config:Config = &#123; navigationBarTitleText: 'taro_dva_typescript' &#125; constructor(props: IndexProps) &#123; super(props) this.state = &#123;&#125; &#125; async getList() &#123; await this.props.dispatch(&#123; type: 'index/getList', payload: &#123;&#125; &#125;) &#125; componentDidMount() &#123; this.getList() &#125; render() &#123; const &#123; data &#125; = this.props console.log('this.props===&gt;&gt;',data); return ( &lt;View className='fx-index-wrap'&gt; &lt;View className='index-topbar'&gt;New资讯&lt;/View&gt; &lt;View className='index-data'&gt; &#123; data &amp;&amp; data.map((item,index) =&gt; &#123; return ( &lt;View className='index-list' key=&#123;index&#125;&gt; &lt;View className='index-title'&gt;&#123;item.title&#125;&lt;/View&gt; &lt;View className='index-img' style=&#123;`background-image: url($&#123;item.thumbnail_pic_s&#125;)`&#125;&gt;&lt;/View&gt; &lt;/View&gt; ) &#125;) &#125; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;export default Index 9、修改./src/pages/index/index.scss首页的样式这里的写法是sass的语法糖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@import "../../assets/scss/variables";.#&#123;$prefix&#125; &#123; &amp;-index-wrap &#123; width: 100%; min-height: 100vh; .index &#123; &amp;-topbar &#123; padding: 10rpx 50rpx; text-align: center; font-weight: bold; color: #333; font-size: 30rpx; &#125; // &amp;-data &#123; // &#125; &amp;-title &#123; font-size: 28rpx; color: #666; width: 100%; font-weight: bold; &#125; &amp;-list&#123; border-bottom: 1rpx solid #eee; padding-bottom: 20rpx; margin: 20rpx 24rpx; display: flex; flex-direction: row; justify-content: space-between; align-items: center &#125; &amp;-img &#123; width: 70%; height: 200rpx; background-repeat: no-repeat; background-size: contain; background-position: right center; &#125; &#125; &#125; &#125; 项目启动运行小程序编译命令 cnpm run dev:weapp 等待项目编译完成，会在项目根目录下生成一个dist,打开微信小程序开发者根据，导入本地刚刚生成的dist文件，就成功启动了项目。 效果预览图： 如有啥问题欢迎讨论，共同学习。 项目示例Github地址：https://github.com/Duanruilong/taro_dva_typescript]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>dva</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQL 基本语法&用法]]></title>
    <url>%2Fblog%2F2019%2F07%2F01%2FAQL-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArangoDB查询语言（AQL）类似于结构化查询语言（SQL） 在它的目的。两者都支持读取和修改集合数据，但AQL不支持数据定义操作，例如创建和删除数据库，集合和索引。 虽然有些关键字重叠，但AQL语法与SQL不同。例如，SQL WHERE和AQL FILTER子句是等效的，因为它们都定义了返回结果的条件。但是，SQL使用预定义的序列来确定WHERE语句必须在哪里出现。在AQL中，子句从左到右执行，因此FILTER查询中子句的位置决定了它的优先级。 尽管有这些差异，任何具有SQL背景的人都应该没有学习AQL的困难。 一、数据预览本次使用的数据共有43条，每条数据包含姓氏、年龄、活动状态和特征等六个字段 其中每个特征都有一个随机字母作为文档密钥。特质标签有英文和德文。 地点由地名和经纬度组成： 二、基本的CRUD创建集合：在创建文档之前，需要创造一个放置它的集合，集合可以通过Web界面，arangosh或驱动程序来创建。AQL无法创建集合。 单击Web界面中的COLLECTIONS，然后单击Add Collection并键入 Charactersname。使用保存确认。新集合就出现在了列表中。 插入单个对象：使用AQL插入文档 1234567INSERT &#123; "name": "Ned", "surname": "Stark", "alive": true, "age": 41, "traits": ["A","H","C","N","P"]&#125; INTO Characters 语法： INSERT document INTO collectionName 该文档是一个对象，由属性键和值对组成。属性键的引号在AQL中是可选的。键总是字符串，而属性值可以有不同的类型： null boolean (true, false) number (integer and floating point) string array object 批量插入对象：AQL不允许INSERT在单个查询中针对同一集合的多个操作。但是可以使用FOR循环体，插入多个文档。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647LET data = [ &#123; "name": "Robert", "surname": "Baratheon", "alive": false, "traits": ["A","H","C"] &#125;, &#123; "name": "Jaime", "surname": "Lannister", "alive": true, "age": 36, "traits": ["A","F","B"] &#125;, &#123; "name": "Catelyn", "surname": "Stark", "alive": false, "age": 40, "traits": ["D","H","C"] &#125;, &#123; "name": "Cersei", "surname": "Lannister", "alive": true, "age": 36, "traits": ["H","E","F"] &#125;, &#123; "name": "Daenerys", "surname": "Targaryen", "alive": true, "age": 16, "traits": ["D","H","C"] &#125;, &#123; "name": "Jorah", "surname": "Mormont", "alive": false, "traits": ["A","B","C","F"] &#125;, &#123; "name": "Petyr", "surname": "Baelish", "alive": false, "traits": ["E","G","F"] &#125;, &#123; "name": "Viserys", "surname": "Targaryen", "alive": false, "traits": ["O","L","N"] &#125;, &#123; "name": "Jon", "surname": "Snow", "alive": true, "age": 16, "traits": ["A","B","C","F"] &#125;, &#123; "name": "Sansa", "surname": "Stark", "alive": true, "age": 13, "traits": ["D","I","J"] &#125;, &#123; "name": "Arya", "surname": "Stark", "alive": true, "age": 11, "traits": ["C","K","L"] &#125;, &#123; "name": "Robb", "surname": "Stark", "alive": false, "traits": ["A","B","C","K"] &#125;, &#123; "name": "Theon", "surname": "Greyjoy", "alive": true, "age": 16, "traits": ["E","R","K"] &#125;, &#123; "name": "Bran", "surname": "Stark", "alive": true, "age": 10, "traits": ["L","J"] &#125;, &#123; "name": "Joffrey", "surname": "Baratheon", "alive": false, "age": 19, "traits": ["I","L","O"] &#125;, &#123; "name": "Sandor", "surname": "Clegane", "alive": true, "traits": ["A","P","K","F"] &#125;, &#123; "name": "Tyrion", "surname": "Lannister", "alive": true, "age": 32, "traits": ["F","K","M","N"] &#125;, &#123; "name": "Khal", "surname": "Drogo", "alive": false, "traits": ["A","C","O","P"] &#125;, &#123; "name": "Tywin", "surname": "Lannister", "alive": false, "traits": ["O","M","H","F"] &#125;, &#123; "name": "Davos", "surname": "Seaworth", "alive": true, "age": 49, "traits": ["C","K","P","F"] &#125;, &#123; "name": "Samwell", "surname": "Tarly", "alive": true, "age": 17, "traits": ["C","L","I"] &#125;, &#123; "name": "Stannis", "surname": "Baratheon", "alive": false, "traits": ["H","O","P","M"] &#125;, &#123; "name": "Melisandre", "alive": true, "traits": ["G","E","H"] &#125;, &#123; "name": "Margaery", "surname": "Tyrell", "alive": false, "traits": ["M","D","B"] &#125;, &#123; "name": "Jeor", "surname": "Mormont", "alive": false, "traits": ["C","H","M","P"] &#125;, &#123; "name": "Bronn", "alive": true, "traits": ["K","E","C"] &#125;, &#123; "name": "Varys", "alive": true, "traits": ["M","F","N","E"] &#125;, &#123; "name": "Shae", "alive": false, "traits": ["M","D","G"] &#125;, &#123; "name": "Talisa", "surname": "Maegyr", "alive": false, "traits": ["D","C","B"] &#125;, &#123; "name": "Gendry", "alive": false, "traits": ["K","C","A"] &#125;, &#123; "name": "Ygritte", "alive": false, "traits": ["A","P","K"] &#125;, &#123; "name": "Tormund", "surname": "Giantsbane", "alive": true, "traits": ["C","P","A","I"] &#125;, &#123; "name": "Gilly", "alive": true, "traits": ["L","J"] &#125;, &#123; "name": "Brienne", "surname": "Tarth", "alive": true, "age": 32, "traits": ["P","C","A","K"] &#125;, &#123; "name": "Ramsay", "surname": "Bolton", "alive": true, "traits": ["E","O","G","A"] &#125;, &#123; "name": "Ellaria", "surname": "Sand", "alive": true, "traits": ["P","O","A","E"] &#125;, &#123; "name": "Daario", "surname": "Naharis", "alive": true, "traits": ["K","P","A"] &#125;, &#123; "name": "Missandei", "alive": true, "traits": ["D","L","C","M"] &#125;, &#123; "name": "Tommen", "surname": "Baratheon", "alive": true, "traits": ["I","L","B"] &#125;, &#123; "name": "Jaqen", "surname": "H'ghar", "alive": true, "traits": ["H","F","K"] &#125;, &#123; "name": "Roose", "surname": "Bolton", "alive": true, "traits": ["H","E","F","A"] &#125;, &#123; "name": "The High Sparrow", "alive": true, "traits": ["H","M","F","O"] &#125;]FOR d IN data INSERT d INTO Characters 语法： LET variableName = valueExpression LET关键字定义了同名称的变量数据和对象值的数列，格式为[ {...}, {...}, ... ] FOR variableName IN expression 用于迭代数据数组的每个元素 。在每个循环中，将一个元素分配给变量d。然后在INSERT语句中使用此变量。相当于下面的格式： 12345678910111213141516INSERT &#123; "name": "Robert", "surname": "Baratheon", "alive": false, "traits": ["A","H","C"]&#125; INTO CharactersINSERT &#123; "name": "Jaime", "surname": "Lannister", "alive": true, "age": 36, "traits": ["A","F","B"]&#125; INTO Characters... 检索检索集合中的所有文档： 12FOR c IN Characters RETURN c 语法： FOR variableName IN collectionName 对于集合中的每个文档，依次分配给变量c，然后根据循环体返回该文档。 选取其中一个文档如下： 12345678910&#123; &quot;_key&quot;: &quot;2861650&quot;, &quot;_id&quot;: &quot;Characters/2861650&quot;, &quot;_rev&quot;: &quot;_V1bzsXa---&quot;, &quot;name&quot;: &quot;Ned&quot;, &quot;surname&quot;: &quot;Stark&quot;, &quot;alive&quot;: true, &quot;age&quot;: 41, &quot;traits&quot;: [&quot;A&quot;,&quot;H&quot;,&quot;C&quot;,&quot;N&quot;,&quot;P&quot;] &#125;, 该文档包含我们存储的四个属性，以及数据库系统添加的另外三个属性： _key：文档键，用户可以在创建文档时提供文档键，也可以自动分配唯一值，不能改变，只读 _id：集合名/文档键，只读 _rev：系统管理的修订版ID，只读 检索特定文档：123RETURN DOCUMENT("Characters", "2861650")// --- or ---RETURN DOCUMENT("Characters/2861650") 返回： 123456789101112[ &#123; "_key": "2861650", "_id": "Characters/2861650", "_rev": "_V1bzsXa---", "name": "Ned", "surname": "Stark", "alive": true, "age": 41, "traits": ["A","H","C","N","P"] &#125;] 语法： DOCUMENT() 使用_key或_id检索特定文档，该函数还允许一次获取多个文档 123RETURN DOCUMENT("Characters", ["2861650", "2861653"])// --- or ---RETURN DOCUMENT(["Characters/2861650", "Characters/2861653"]) 更新文档：修改现有文件： 123UPDATE "2861650" WITH &#123; alive: false &#125; IN Characters语法：UPDATE documentKey WITH object IN collectionName 用列出的属性更新指定的文档（如果它们不存在则添加它们），但保持其余不变。要替换整个文档内容，则要使用REPLACE函数： 1234567REPLACE "2861650" WITH &#123; name: "Ned", surname: "Stark", alive: false, age: 41, traits: ["A","H","C","N","P"]&#125; IN Characters 该函数也适用于循环，例如为所有文档添加新属性： 12FOR c IN Characters UPDATE c WITH &#123; season: 1 &#125; IN Characters 删除文件：语法： REMOVE _key IN Collectiosname 要从集合中完全删除文档，需要执行REMOVE操作。它的工作方式与其他修改操作类似，但没有WITH子句： 1REMOVE "2861650" IN Characters 三、匹配文件语法： FILTER 查找满足比_key相等更复杂的条件的文档，能够为要匹配的文档制定任意条件。 等于条件： 123FOR c IN Characters FILTER c.name == "Ned" RETURN c 过滤条件如下：“ 字符文档的属性name必须等于字符串Ned ”。如果条件适用，则返回字符文档。 范围条件：123FOR c IN Characters FILTER c.age &gt;= 13 RETURN c.name 多种条件： 12345678910FOR c IN Characters FILTER c.age &lt; 13 FILTER c.age != null RETURN &#123; name: c.name, age: c.age &#125;//orFOR c IN Characters FILTER c.age &lt; 13 AND c.age != null RETURN &#123; name: c.name, age: c.age &#125; 替代条件： 123FOR c IN Characters FILTER c.name == "Jon" OR c.name == "Joffrey" RETURN &#123; name: c.name, surname: c.surname &#125; 四、排序和限制限制语法：LIMIT() LIMIT后面跟着一个最大显示数的数字,限制结果显示行数。 123FOR c IN Characters LIMIT 5 RETURN c.name 还可以使用LIMIT来跳过一定数量的记录返回下一个n个文档： 123FOR c IN Characters LIMIT 2, 5 RETURN c.name 排序语法：SORT() DESC降序来反转排序顺序 1234FOR c IN Characters SORT c.name DESC LIMIT 10 RETURN c.name 多个字段排序12345678FOR c IN Characters FILTER c.surname SORT c.surname, c.name LIMIT 10 RETURN &#123; surname: c.surname, name: c.name &#125; 此处FILTER的作用是仅保留surname为非空记录 五、组合语法：MERGE() MERGE()的功能是将对象组合在一起。因为使用了原始字符属性{ traits: … }，所以后者被合并覆盖。 12FOR c IN Characters RETURN MERGE(c, &#123; traits: DOCUMENT("Traits", c.traits)[*].en &#125; ) 六、图操作创建图： 语法： INSERT { _from: _id(A), _to: _id(B) } INTO ChildOf 实例：首先，创建一个新的集合，并确保将集合类型更改为Edge。 然后，通过查询多个集合的数据，将结果存入边集合中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364LET data = [ //关系数据 &#123; "parent": &#123; "name": "Ned", "surname": "Stark" &#125;, "child": &#123; "name": "Robb", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Ned", "surname": "Stark" &#125;, "child": &#123; "name": "Sansa", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Ned", "surname": "Stark" &#125;, "child": &#123; "name": "Arya", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Ned", "surname": "Stark" &#125;, "child": &#123; "name": "Bran", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Catelyn", "surname": "Stark" &#125;, "child": &#123; "name": "Robb", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Catelyn", "surname": "Stark" &#125;, "child": &#123; "name": "Sansa", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Catelyn", "surname": "Stark" &#125;, "child": &#123; "name": "Arya", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Catelyn", "surname": "Stark" &#125;, "child": &#123; "name": "Bran", "surname": "Stark" &#125; &#125;, &#123; "parent": &#123; "name": "Ned", "surname": "Stark" &#125;, "child": &#123; "name": "Jon", "surname": "Snow" &#125; &#125;, &#123; "parent": &#123; "name": "Tywin", "surname": "Lannister" &#125;, "child": &#123; "name": "Jaime", "surname": "Lannister" &#125; &#125;, &#123; "parent": &#123; "name": "Tywin", "surname": "Lannister" &#125;, "child": &#123; "name": "Cersei", "surname": "Lannister" &#125; &#125;, &#123; "parent": &#123; "name": "Tywin", "surname": "Lannister" &#125;, "child": &#123; "name": "Tyrion", "surname": "Lannister" &#125; &#125;, &#123; "parent": &#123; "name": "Cersei", "surname": "Lannister" &#125;, "child": &#123; "name": "Joffrey", "surname": "Baratheon" &#125; &#125;, &#123; "parent": &#123; "name": "Jaime", "surname": "Lannister" &#125;, "child": &#123; "name": "Joffrey", "surname": "Baratheon" &#125; &#125;]FOR rel in data LET parentId = FIRST( //FIRST()提取第一个元素 FOR c IN Characters FILTER c.name == rel.parent.name //筛选条件 FILTER c.surname == rel.parent.surname LIMIT 1 RETURN c._id //返回_id ) LET childId = FIRST( FOR c IN Characters FILTER c.name == rel.child.name FILTER c.surname == rel.child.surname LIMIT 1 RETURN c._id ) FILTER parentId != null AND childId != null //剔除_id都为空的记录 INSERT &#123; _from: childId, _to: parentId &#125; INTO ChildOf //将数据插入边集合 RETURN NEW //返回数据 也可以直接创建边数据： 1INSERT &#123; _from: "Characters/robb", _to: "Characters/ned" &#125; INTO ChildOf 遍历图： 语法： 12345FOR v IN 1..1 OUTBOUND _id ChildOf RETURN v.name其中1..1为遍历深度 实例： 1234FOR c IN Characters FILTER c.name == "Bran" FOR v IN 1..1 OUTBOUND c ChildOf RETURN v.name 返回 1234[ "Ned", "Catelyn"] 遍历的情况如下图： 若是反向遍历，则需要使用到INBOUND关键字： 123456789FOR c IN Characters FILTER c.name == "Tywin" FOR v IN 2..2 INBOUND c ChildOf RETURN DISTINCT v.name输出：[ "Joffrey"] 遍历情况如下： 需要注意的是，“1..1”限制了遍历深度为1，“2..2”限制了遍历深度为2，而”1..2”限制遍历深度既可以为1也可以为2。 七、地理空间查询地点数据创建地点集合： 录入地点数据： 12345678910111213LET places = [ &#123; "name": "Dragonstone", "coordinate": [ 55.167801, -6.815096 ] &#125;, &#123; "name": "King's Landing", "coordinate": [ 42.639752, 18.110189 ] &#125;, &#123; "name": "The Red Keep", "coordinate": [ 35.896447, 14.446442 ] &#125;, &#123; "name": "Yunkai", "coordinate": [ 31.046642, -7.129532 ] &#125;, &#123; "name": "Astapor", "coordinate": [ 31.50974, -9.774249 ] &#125;, &#123; "name": "Winterfell", "coordinate": [ 54.368321, -5.581312 ] &#125;, &#123; "name": "Vaes Dothrak", "coordinate": [ 54.16776, -6.096125 ] &#125;, &#123; "name": "Beyond the wall", "coordinate": [ 64.265473, -21.094093 ] &#125;]FOR place IN places INSERT place INTO Locations 设置地理空间索引： 在COLLECTIONS界面，添加新的Indexes，设置为coordinate字段： 查找附近的位置语法： NEAR() 找到最接近的坐标参考点 123456FOR loc IN NEAR(Locations, 53.35, -6.26, 3) RETURN &#123; name: loc.name, latitude: loc.coordinate[0], longitude: loc.coordinate[1] &#125; 输出： 1234567891011121314151617[ &#123; "name": "Vaes Dothrak", "latitude": 54.16776, "longitude": -6.096125 &#125;, &#123; "name": "Winterfell", "latitude": 54.368321, "longitude": -5.581312 &#125;, &#123; "name": "Dragonstone", "latitude": 55.167801, "longitude": -6.815096 &#125;] 查找半径内的位置语法： WITHIN() 从参考点搜索给定半径内的位置 123456FOR loc IN WITHIN(Locations, 53.35, -6.26, 200 * 1000) RETURN &#123; name: loc.name, latitude: loc.coordinate[0], longitude: loc.coordinate[1] &#125; 输出 123456789101112[ &#123; "name": "Vaes Dothrak", "latitude": 54.16776, "longitude": -6.096125 &#125;, &#123; "name": "Winterfell", "latitude": 54.368321, "longitude": -5.581312 &#125;] 按距离查找位置：语法： NEAR()或WITHIN() 通过添加一个可选的第五个参数返回到参考点的距离。必须是一个字符串： 1234567FOR loc IN NEAR(Locations, 53.35, -6.26, 3, "distance") RETURN &#123; name: loc.name, latitude: loc.coordinate[0], longitude: loc.coordinate[1], distance: loc.distance / 1000 &#125; 输出： 1234567891011121314151617181920[ &#123; "name": "Vaes Dothrak", "latitude": 54.16776, "longitude": -6.096125, "distance": 91.56658640314431 &#125;, &#123; "name": "Winterfell", "latitude": 54.368321, "longitude": -5.581312, "distance": 121.66399816395028 &#125;, &#123; "name": "Dragonstone", "latitude": 55.167801, "longitude": -6.815096, "distance": 205.31879386198324 &#125;] 使用AQL遇到的问题： 问题1：如何对查询结果进行计数并返回？ 解决方法： 1RETURN COUNT(FOR v IN visitors FILTER v.ip == "127.0.0.1" RETURN 1)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>工具</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React利用react-to-print实现打印功能]]></title>
    <url>%2Fblog%2F2019%2F06%2F28%2FReact%E5%88%A9%E7%94%A8react-to-print%E5%AE%9E%E7%8E%B0%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近需要在react项目中实现打印功能，刚开始想到的都是基于window.print(),但是window.print()如果直接在钉钉应用内部打印的话，直接报错，用户交互很不好。 于是就找到了react-to-print 下面分享下。 react-to-printreact-to-print的github地址 项目开始在项目中安装依赖： npm install react-to-print --save-dev 在项目中引入依赖： 12import ReactToPrint from "react-to-print"; 在项目中使用： 123456789101112131415&lt;div ref=&#123;el =&gt; (this.componentRef = el)&#125;&gt; &lt;div style=&#123;&#123;textAlign: 'center',color: 'red',fontSize: '40px',marginBottom: '10px',marginTop: '40px'&#125;&#125;&gt;活动二维码&lt;/div&gt; &lt;div style=&#123;&#123;fontSize: '26px',textAlign: 'center'&#125;&#125;&gt;活动标题&lt;/div&gt; &lt;img id='imgCode' style=&#123;&#123;width: '100%'&#125;&#125; src=&#123;this.state.qrcodeImg&#125; alt="二维码" &gt;&lt;/img&gt;&lt;/div&gt;&lt;Button style=&#123;&#123; marginRight: 16,marginLeft: 30 &#125;&#125; onClick=&#123;() =&gt; this.handleCancel()&#125;&gt;取消&lt;/Button&gt;&lt;ReactToPrint trigger=&#123;() =&gt; &lt;a &gt;&lt;Button type="primary"&gt;打印二维码&lt;/Button&gt;&lt;/a&gt;&#125; content=&#123;() =&gt; this.componentRef&#125; onAfterPrint=&#123;()=&gt;&#123; message.success('打印成功！'); &#125;&#125;/&gt; 实例完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from "react";import ReactToPrint from "react-to-print";import PropTypes from "prop-types";class ComponentToPrint extends React.Component &#123; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;th&gt;column 1&lt;/th&gt; &lt;th&gt;column 2&lt;/th&gt; &lt;th&gt;column 3&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;data 1&lt;/td&gt; &lt;td&gt;data 2&lt;/td&gt; &lt;td&gt;data 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;data 1&lt;/td&gt; &lt;td&gt;data 2&lt;/td&gt; &lt;td&gt;data 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;data 1&lt;/td&gt; &lt;td&gt;data 2&lt;/td&gt; &lt;td&gt;data 3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;class Example extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ReactToPrint trigger=&#123;() =&gt; &lt;a href="#"&gt;Print this out!&lt;/a&gt;&#125; content=&#123;() =&gt; this.componentRef&#125; /&gt; &lt;ComponentToPrint ref=&#123;el =&gt; (this.componentRef = el)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default Example; APIT该组件接受以下API: 名称 类型 描述 trigger function 一个返回React Component或HTML元素的函数 content function 返回组件引用值的函数。然后将该参考值的内容用于打印 copyStyles boolean 将所有和从父窗口中复制到打印窗口中。（默认值：true） onBeforePrint function 在打印之前触发的回调函数 onAfterPrint function 打印后触发的回调函数 closeAfterPrint boolean 操作后关闭打印窗口 pageStyle string 覆盖默认打印窗口样式 bodyClass string 传递给打印窗体的可选类 常问问题为什么react-to-print跳过&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;标签？ &lt;link&gt;带有空href属性的s 是INVALID HTML。此外，它们可能导致各种不良行为。例如，许多浏览器（包括现代浏览器）在显示时将尝试加载当前页面。有些人甚至尝试加载当前页面的父目录。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Ant Design</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant Design + qrcode实现打印功能]]></title>
    <url>%2Fblog%2F2019%2F06%2F13%2FAnt-Design-qrcode%E5%AE%9E%E7%8E%B0%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[react本身有一些打印的组件，但都不好用，都是基于window.print()，window.print()直接打印的话，处理直接当前网页的body设置为你要打印的区域，但是当你取消打印的时候你会发现整个网页都被你要打印的区域占满了，你还得用window.reload()重新加载一下页面，用户交互很不好，建议不要采用这种方式。 QRCode.js 生成二维码QRCode.js 是一个用于生成二维码图片的插件。 使用方法载入 JavaScript 文件1&lt;script src="qrcode.js"&gt;&lt;/script&gt; DOM 结构1&lt;div id="qrcode"&gt;&lt;/div&gt; 调用12345678910111213141516// 简单方式new QRCode(document.getElementById('qrcode'), 'your content');// 设置参数方式var qrcode = new QRCode('qrcode', &#123; text: 'your content', width: 256, height: 256, colorDark : '#000000', colorLight : '#ffffff', correctLevel : QRCode.CorrectLevel.H&#125;);// 使用 APIqrcode.clear();qrcode.makeCode('new content'); Ant Design里使用react中一般生成二维码都是用react.qrcode，但是发现这玩意生成的是canvas，不是图片，打印的时候预览不出来。所以我想进一切办法去把canvas转成图片，无奈拿不到这个canvas标签。最后还是用js的qrcode来生成二维码，这样生成的默认是base64位的图片，打印正常。代码如下： 安装cnpm install qrcode --save 在页面上引入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; Component&#125; from 'react';import styles from './ActivityDetail.less';import &#123; Button, message&#125; from 'antd';import * as QrCodeEs from 'qrcode';class ActivityDetail extends Component &#123; state = &#123; qrcodeImg:'', // 二维码图片地址 &#125;; // 生成二维码点击 pathQRCodeClick(item) &#123; QrCodeEs.toDataURL(item._id) .then(url =&gt; &#123; console.log('url=====&lt;&lt;&lt;&lt;',url) this.setState(&#123; qrcodeImg:url &#125;) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) &#125; // 确定-打印二维码 handleOk = e =&gt; &#123; const &#123; item &#125; = this.props.location; const win = window.open('','printwindow'); let codeHtml = '&lt;div style="text-align: center;color: red;font-size: 40px;margin-bottom: 10px;margin-top: 40px"&gt;活动二维码&lt;/div&gt;&lt;br/&gt;\n' + '&lt;div style="font-size: 26px;text-align: center;"&gt;'+ item.name +'&lt;/div&gt;&lt;br/&gt;\n' + '&lt;img style="font-size: 26px;width: 340px;position: absolute;left: 50%;margin-left: -170px;" src='+ this.state.qrcodeImg +' alt="教科所" /&gt;\n' win.document.write(codeHtml); win.print(); win.close() message.success('打印成功！'); this.setState(&#123; visible: false, &#125;); &#125;; render()&#123; return( &lt;div&gt; &lt;Button onClick=&#123;()=&gt;&#123;this.pathQRCodeClick(item)&#125;&#125; style=&#123;&#123;marginLeft:'24px'&#125;&#125; type="primary"&gt;生成二维码&lt;/Button&gt; &lt;div style=&#123;&#123;width:'50%',margin:'auto'&#125;&#125;&gt; &lt;img id='imgCode' style=&#123;&#123;width: '100%'&#125;&#125; src=&#123;this.state.qrcodeImg&#125; alt="二维码" &gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default ActivityDetail;]]></content>
      <categories>
        <category>Ant Design</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dva.js学习梳理集]]></title>
    <url>%2Fblog%2F2019%2F05%2F22%2Fdva-js%E5%AD%A6%E4%B9%A0%E6%A2%B3%E7%90%86%E9%9B%86%2F</url>
    <content type="text"><![CDATA[dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架 疑惑 es6 特性那么多，我需要全部学会吗? react component 有 3 种写法，我需要全部学会吗? reducer 的增删改应该怎么写? 怎么做全局/局部的错误处理? 怎么发异步请求? 怎么处理复杂的异步业务逻辑? 怎么配置路由? … 这篇文档梳理了基于 dva-cli 使用 dva 的最小知识集，让你可以用最少的时间掌握创建类似 dva-hackernews 的全部知识，并且不需要掌握额外的冗余知识。 JavaScript 语言变量声明const 和 let不要用 var，而是用 const 和 let，分别表示常量和变量。不同于 var 的函数作用域，const 和 let 都是块级作用域。 1234const DELAY = 1000;let count = 0;count = count + 1; 模板字符串模板字符串提供了另一种做字符串组合的方法。 12345678const user = 'world';console.log(`hello $&#123;user&#125;`); // hello world// 多行const content = ` Hello $&#123;firstName&#125;, Thanks for ordering $&#123;qty&#125; tickets to $&#123;event&#125;.`; 默认参数12345function logActivity(activity = 'skiing') &#123; console.log(activity);&#125;logActivity(); // skiing 箭头函数函数的快捷写法，不需要通过 function 关键字创建函数，并且还可以省略 return 关键字。 同时，箭头函数还会继承当前上下文的 this 关键字。 比如： 1[1, 2, 3].map(x =&gt; x + 1); // [2, 3, 4] 等同于： 123[1, 2, 3].map((function(x) &#123; return x + 1;&#125;).bind(this)); 模块的 Import 和 Exportimport 用于引入模块，export 用于导出模块。 比如： 1234567891011121314// 引入全部import dva from 'dva';// 引入部分import &#123; connect &#125; from 'dva';import &#123; Link, Route &#125; from 'dva/router';// 引入全部并作为 github 对象import * as github from './services/github';// 导出默认export default App;// 部分导出，需 import &#123; App &#125; from './file'; 引入export class App extend Component &#123;&#125;; ES6 对象和数组析构赋值析构赋值让我们从 Object 或 Array 里取部分数据存为变量。 123456789// 对象const user = &#123; name: 'guanguan', age: 2 &#125;;const &#123; name, age &#125; = user;console.log(`$&#123;name&#125; : $&#123;age&#125;`); // guanguan : 2// 数组const arr = [1, 2];const [foo, bar] = arr;console.log(foo); // 1 我们也可以析构传入的函数参数。 123const add = (state, &#123; payload &#125;) =&gt; &#123; return state.concat(payload);&#125;; 析构时还可以配 alias，让代码更具有语义。 123const add = (state, &#123; payload: todo &#125;) =&gt; &#123; return state.concat(todo);&#125;; 对象字面量改进这是析构的反向操作，用于重新组织一个 Object 。 1234const name = 'duoduo';const age = 8;const user = &#123; name, age &#125;; // &#123; name: 'duoduo', age: 8 &#125; 定义对象方法时，还可以省去 function 关键字。 12345678app.model(&#123; reducers: &#123; add() &#123;&#125; // 等同于 add: function() &#123;&#125; &#125;, effects: &#123; *addRemote() &#123;&#125; // 等同于 addRemote: function*() &#123;&#125; &#125;,&#125;); Spread OperatorSpread Operator 即 3 个点 ...，有几种不同的使用方法。 可用于组装数组。 12const todos = ['Learn dva'];[...todos, 'Learn antd']; // ['Learn dva', 'Learn antd'] 也可用于获取数组的部分项。 1234567const arr = ['a', 'b', 'c'];const [first, ...rest] = arr;rest; // ['b', 'c']// With ignoreconst [first, , ...rest] = arr;rest; // ['c'] 还可收集函数参数为数组。 1234function directions(first, ...rest) &#123; console.log(rest);&#125;directions('a', 'b', 'c'); // ['b', 'c']; 代替 apply。 123456function foo(x, y, z) &#123;&#125;const args = [1,2,3];// 下面两句效果相同foo.apply(null, args);foo(...args); 对于 Object 而言，用于组合成新的 Object 。(ES2017 stage-2 proposal) 1234567891011const foo = &#123; a: 1, b: 2,&#125;;const bar = &#123; b: 3, c: 2,&#125;;const d = 4;const ret = &#123; ...foo, ...bar, d &#125;; // &#123; a:1, b:3, c:2, d:4 &#125; 此外，在 JSX 中 Spread Operator 还可用于扩展 props，详见 Spread Attributes。 PromisesPromise 用于更优雅地处理异步请求。比如发起异步请求： 1234fetch('/api/todos') .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;)); 定义 Promise 。 123456789const delay = (timeout) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, timeout); &#125;);&#125;;delay(1000).then(_ =&gt; &#123; console.log('executed');&#125;); Generatorsdva 的 effects 是通过 generator 组织的。Generator 返回的是迭代器，通过 yield 关键字实现暂停功能。 这是一个典型的 dva effect，通过 yield 把异步逻辑通过同步的方式组织起来。 123456789app.model(&#123; namespace: 'todos', effects: &#123; *addRemote(&#123; payload: todo &#125;, &#123; put, call &#125;) &#123; yield call(addTodo, todo); yield put(&#123; type: 'add', payload: todo &#125;); &#125;, &#125;,&#125;); React ComponentStateless Functional ComponentsReact Component 有 3 种定义方式，分别是 React.createClass, class 和 Stateless Functional Component。推荐尽量使用最后一种，保持简洁和无状态。这是函数，不是 Object，没有 this 作用域，是 pure function。 比如定义 App Component 。 123456function App(props) &#123; function handleClick() &#123; props.dispatch(&#123; type: 'app/create' &#125;); &#125; return &lt;div onClick=&#123;handleClick&#125;&gt;$&#123;props.name&#125;&lt;/div&gt;&#125; 等同于： 12345678class App extends React.Component &#123; handleClick() &#123; this.props.dispatch(&#123; type: 'app/create' &#125;); &#125; render() &#123; return &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;$&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125; JSXComponent 嵌套类似 HTML，JSX 里可以给组件添加子组件。 12345&lt;App&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;Footer /&gt;&lt;/App&gt; classNameclass 是保留词，所以添加样式时，需用 className 代替 class 。 1&lt;h1 className="fancy"&gt;Hello dva&lt;/h1&gt; JavaScript 表达式JavaScript 表达式需要用 {} 括起来，会执行并返回结果。 比如： 1&lt;h1&gt;&#123; this.props.title &#125;&lt;/h1&gt; Mapping Arrays to JSX可以把数组映射为 JSX 元素列表。 123&lt;ul&gt; &#123; this.props.todos.map((todo, i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;todo&#125;&lt;/li&gt;) &#125;&lt;/ul&gt; 注释尽量别用 // 做单行注释。 123456789101112&lt;h1&gt; &#123;/* multiline comment */&#125; &#123;/* multi line comment */&#125; &#123; // single line &#125; Hello&lt;/h1&gt; Spread Attributes这是 JSX 从 ECMAScript6 借鉴过来的很有用的特性，用于扩充组件 props 。 比如： 12345const attrs = &#123; href: 'http://example.org', target: '_blank',&#125;;&lt;a &#123;...attrs&#125;&gt;Hello&lt;/a&gt; 等同于 12345const attrs = &#123; href: 'http://example.org', target: '_blank',&#125;;&lt;a href=&#123;attrs.href&#125; target=&#123;attrs.target&#125;&gt;Hello&lt;/a&gt; Props数据处理在 React 中是非常重要的概念之一，分别可以通过 props, state 和 context 来处理数据。而在 dva 应用里，你只需关心 props 。 propTypesJavaScript 是弱类型语言，所以请尽量声明 propTypes 对 props 进行校验，以减少不必要的问题。 123456function App(props) &#123; return &lt;div&gt;&#123;props.name&#125;&lt;/div&gt;;&#125;App.propTypes = &#123; name: React.PropTypes.string.isRequired,&#125;; 内置的 prop type 有： PropTypes.array PropTypes.bool PropTypes.func PropTypes.number PropTypes.object PropTypes.string 往下传数据 往上传数据 CSS Modules 理解 CSS Modules一张图理解 CSS Modules 的工作原理： button class 在构建之后会被重命名为 ProductList_button_1FU0u 。button 是 local name，而 ProductList_button_1FU0u 是 global name 。你可以用简短的描述性名字，而不需要关心命名冲突问题。 然后你要做的全部事情就是在 css/less 文件里写 .button {...}，并在组件里通过 styles.button 来引用他。 定义全局 CSSCSS Modules 默认是局部作用域的，想要声明一个全局规则，可用 :global 语法。 比如： 123456.title &#123; color: red;&#125;:global(.title) &#123; color: green;&#125; 然后在引用的时候： 12&lt;App className=&#123;styles.title&#125; /&gt; // red&lt;App className="title" /&gt; // green classnames Package在一些复杂的场景中，一个元素可能对应多个 className，而每个 className 又基于一些条件来决定是否出现。这时，classnames 这个库就非常有用。 123456789import classnames from 'classnames';const App = (props) =&gt; &#123; const cls = classnames(&#123; btn: true, btnLarge: props.type === 'submit', btnSmall: props.type === 'edit', &#125;); return &lt;div className=&#123; cls &#125; /&gt;;&#125; 这样，传入不同的 type 给 App 组件，就会返回不同的 className 组合： 12&lt;App type="submit" /&gt; // btn btnLarge&lt;App type="edit" /&gt; // btn btnSmall Reducerreducer 是一个函数，接受 state 和 action，返回老的或新的 state 。即：(state, action) =&gt; state 增删改以 todos 为例。 123456789101112131415161718192021app.model(&#123; namespace: 'todos', state: [], reducers: &#123; add(state, &#123; payload: todo &#125;) &#123; return state.concat(todo); &#125;, remove(state, &#123; payload: id &#125;) &#123; return state.filter(todo =&gt; todo.id !== id); &#125;, update(state, &#123; payload: updatedTodo &#125;) &#123; return state.map(todo =&gt; &#123; if (todo.id === updatedTodo.id) &#123; return &#123; ...todo, ...updatedTodo &#125;; &#125; else &#123; return todo; &#125; &#125;); &#125;, &#125;,&#125;; 嵌套数据的增删改建议最多一层嵌套，以保持 state 的扁平化，深层嵌套会让 reducer 很难写和难以维护。 12345678910111213app.model(&#123; namespace: 'app', state: &#123; todos: [], loading: false, &#125;, reducers: &#123; add(state, &#123; payload: todo &#125;) &#123; const todos = state.todos.concat(todo); return &#123; ...state, todos &#125;; &#125;, &#125;,&#125;); 下面是深层嵌套的例子，应尽量避免。 12345678910111213141516171819app.model(&#123; namespace: 'app', state: &#123; a: &#123; b: &#123; todos: [], loading: false, &#125;, &#125;, &#125;, reducers: &#123; add(state, &#123; payload: todo &#125;) &#123; const todos = state.a.b.todos.concat(todo); const b = &#123; ...state.a.b, todos &#125;; const a = &#123; ...state.a, b &#125;; return &#123; ...state, a &#125;; &#125;, &#125;,&#125;); Effect示例： 123456789app.model(&#123; namespace: 'todos', effects: &#123; *addRemote(&#123; payload: todo &#125;, &#123; put, call &#125;) &#123; yield call(addTodo, todo); yield put(&#123; type: 'add', payload: todo &#125;); &#125;, &#125;,&#125;); Effectsput用于触发 action 。 1yield put(&#123; type: 'todos/add', payload: 'Learn Dva' &#125;); call用于调用异步逻辑，支持 promise 。 1const result = yield call(fetch, '/todos'); select用于从 state 里获取数据。 1const todos = yield select(state =&gt; state.todos); 错误处理全局错误处理dva 里，effects 和 subscriptions 的抛错全部会走 onError hook，所以可以在 onError 里统一处理错误。 12345const app = dva(&#123; onError(e, dispatch) &#123; console.log(e.message); &#125;,&#125;); 然后 effects 里的抛错和 reject 的 promise 就都会被捕获到了。 本地错误处理如果需要对某些 effects 的错误进行特殊处理，需要在 effect 内部加 try catch 。 1234567891011app.model(&#123; effects: &#123; *addRemote() &#123; try &#123; // Your Code Here &#125; catch(e) &#123; console.log(e.message); &#125; &#125;, &#125;,&#125;); 异步请求异步请求基于 whatwg-fetch，API 详见：https://github.com/github/fetch GET 和 POST12345678910import request from '../util/request';// GETrequest('/api/todos');// POSTrequest('/api/todos', &#123; method: 'POST', body: JSON.stringify(&#123; a: 1 &#125;),&#125;); 统一错误处理假如约定后台返回以下格式时，做统一的错误处理。 1234&#123; status: 'error', message: '',&#125; 编辑 utils/request.js，加入以下中间件： 1234567function parseErrorMessage(&#123; data &#125;) &#123; const &#123; status, message &#125; = data; if (status === 'error') &#123; throw new Error(message); &#125; return &#123; data &#125;;&#125; 然后，这类错误就会走到 onError hook 里。 Subscriptionsubscriptions 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。格式为 ({ dispatch, history }) =&gt; unsubscribe 。 异步数据初始化比如：当用户进入 /users 页面时，触发 action users/fetch 加载用户数据。 12345678910111213app.model(&#123; subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; history.listen((&#123; pathname &#125;) =&gt; &#123; if (pathname === '/users') &#123; dispatch(&#123; type: 'users/fetch', &#125;); &#125; &#125;); &#125;, &#125;,&#125;); path-to-regexp Package如果 url 规则比较复杂，比如 /users/:userId/search，那么匹配和 userId 的获取都会比较麻烦。这是推荐用 path-to-regexp 简化这部分逻辑。 12345678import pathToRegexp from 'path-to-regexp';// in subscriptionconst match = pathToRegexp('/users/:userId/search').exec(pathname);if (match) &#123; const userId = match[1]; // dispatch action with userId&#125; RouterConfig with JSX Element (router.js)1234&lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="accounts" component=&#123;Accounts&#125;/&gt; &lt;Route path="statements" component=&#123;Statements&#125;/&gt;&lt;/Route&gt; 详见：react-router Route ComponentsRoute Components 是指 ./src/routes/ 目录下的文件，他们是 ./src/router.js 里匹配的 Component。 通过 connect 绑定数据比如： 123456789import &#123; connect &#125; from 'dva';function App() &#123;&#125;function mapStateToProps(state, ownProps) &#123; return &#123; users: state.users, &#125;;&#125;export default connect(mapStateToProps)(App); 然后在 App 里就有了 dispatch 和 users 两个属性。 Injected Props (e.g. location)Route Component 会有额外的 props 用以获取路由信息。 location params children 更多详见：react-router 基于 action 进行页面跳转123456789101112131415import &#123; routerRedux &#125; from 'dva/router';// Inside Effectsyield put(routerRedux.push('/logout'));// Outside Effectsdispatch(routerRedux.push('/logout'));// With queryrouterRedux.push(&#123; pathname: '/logout', query: &#123; page: 2, &#125;,&#125;); 除 push(location) 外还有更多方法，详见 react-router-redux dva 配置Redux Middleware比如要添加 redux-logger 中间件： 1234import createLogger from 'redux-logger';const app = dva(&#123; onAction: createLogger(),&#125;); 注：onAction 支持数组，可同时传入多个中间件。 history切换 history 为 browserHistory1234import &#123; browserHistory &#125; from 'dva/router';const app = dva(&#123; history: browserHistory,&#125;); 去除 hashHistory 下的 _k 查询参数12345import &#123; useRouterHistory &#125; from 'dva/router';import &#123; createHashHistory &#125; from 'history';const app = dva(&#123; history: useRouterHistory(createHashHistory)(&#123; queryKey: false &#125;),&#125;); 工具通过 dva-cli 创建项目先安装 dva-cli 。 1$ npm install dva-cli -g 然后创建项目。 1$ dva new myapp 最后，进入目录并启动。 12$ cd myapp$ npm start]]></content>
      <categories>
        <category>dva</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>React</tag>
        <tag>ES6</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用prop-types进行属性确认]]></title>
    <url>%2Fblog%2F2019%2F03%2F29%2F%E4%BD%BF%E7%94%A8prop-types%E8%BF%9B%E8%A1%8C%E5%B1%9E%E6%80%A7%E7%A1%AE%E8%AE%A4%2F</url>
    <content type="text"><![CDATA[在开发 React Native 自定义组件时，可以通过属性确认来声明这个组件需要哪些属性。这样，如果在调用这个自定义组件时没有提供相应的属性，则会在手机与调试工具中弹出警告信息，告知开发者该组件需要哪些属性。 为了保证 React Native 代码高效运行，属性确认仅在开发环境中有效。 prop-types 库的安装和配置 进入项目根目录，执行如下代码安装 prop-types 库： 1npm install --save prop-types 在需要使用的 js 文件中使用如下代码引入： 1import PropTypes from 'prop-types'; 使用prop-types下面对 list.js 代码做个修改，增加属性确认代码 123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import &#123; Text, View, &#125; from 'react-native'; import PropTypes from 'prop-types'; export default class List extends Component &#123; //........ &#125; //添加属性确认 List.propTypes = &#123; news: PropTypes.array, &#125; const styles = StyleSheet.create(&#123; //........ &#125;); 属性确认的语法1、要求属性是指定的 JavaScript 基本类型 123456属性: PropTypes.array,属性: PropTypes.bool,属性: PropTypes.func,属性: PropTypes.number,属性: PropTypes.object,属性: PropTypes.string, 2、要求属性是可渲染节点 1属性: PropTypes.node, 3、要求属性是某个 React 元素 1属性: PropTypes.element, 4、要求属性是某个指定类的实例 1属性: PropTypes.instanceOf(NameOfAClass), 5、要求属性取值为特定的几个值 1属性: PropTypes.oneOf(['value1', 'value2']), 6、要求属性可以为指定类型中的任意一个 12345属性: PropTypes.oneOfType([ PropTypes.bool, PropTypes.number, PropTypes.instanceOf(NameOfAClass),]) 7、要求属性为指定类型的数组 1属性: PropTypes.arrayOf(PropTypes.number), 8、要求属性是一个有特定成员变量的对象 1属性: PropTypes.objectOf(PropTypes.number), 9、要求属性是一个指定构成方式的对象 1234属性: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number,&#125;), 10、属性可以是任意类型 1属性: PropTypes.any 属性声明为必需的上述的 10 种语法，都可以通过在后面加上 isRequired 声明它是必需的。 123属性: PropTypes.array.isRequired,属性: PropTypes.any.isRequired,属性: PropTypes.instanceOf(NameOfAClass).isRequired,]]></content>
      <categories>
        <category>编程,Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docsify神奇的文档网站生成工具]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2Fdocsify%E7%A5%9E%E5%A5%87%E7%9A%84%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。 特性 无需构建，写完文档直接发布 容易使用并且轻量 (~19kB gzipped) 智能的全文搜索 提供多套主题 丰富的 API 支持 Emoji 兼容 IE10+ 支持 SSR (example) 快速开始推荐安装 docsify-cli 工具，可以方便创建及本地预览文档网站。 1npm i docsify-cli -g 初始化项目如果想在项目的 ./docs 目录里写文档，直接通过 init 初始化项目。 1docsify init ./docs 开始写文档初始化成功后，可以看到 ./docs 目录下创建的几个文件 index.html 入口文件 README.md 会做为主页内容渲染 .nojekyll 用于阻止 GitHub Pages 会忽略掉下划线开头的文件直接编辑 docs/README.md 就能更新网站内容，当然也可以写多个页面。 本地预览网站运行一个本地服务器通过 docsify serve 可以方便的预览效果，而且提供 LiveReload 功能，可以让实时的预览。默认访问 http://localhost:3000 。 1docsify serve docs 更多命令行工具用法，参考 docsify-cli 文档。 手动初始化如果不喜欢 npm 或者觉得安装工具太麻烦，我们其实只需要直接创建一个 index.html 文件。 1234567891011121314151617181920// index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="//unpkg.com/docsify/themes/vue.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; window.$docsify = &#123; //... &#125; &lt;/script&gt; &lt;script src="//unpkg.com/docsify/lib/docsify.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果系统里安装 Python 的话，也可以很轻易的启动一个静态服务器。 1cd docs &amp;&amp; python -m SimpleHTTPServer 3000 Loading 提示初始化时会显示 Loading… 内容，你可以自定义提示信息。 123// index.html &lt;div id="app"&gt;加载中&lt;/div&gt; 如果更改了 el 的配置，需要将该元素加上 data-app 属性。 123456789// index.html &lt;div data-app id="main"&gt;加载中&lt;/div&gt; &lt;script&gt; window.$docsify = &#123; el: '#main' &#125; &lt;/script&gt; 示例这是一份docsify开发的文档欢迎点击查看 git地址 线上预览 更加详细的设置配置参考官方文档]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6--Set和Map数据结构]]></title>
    <url>%2Fblog%2F2019%2F01%2F29%2FES6-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[ES6提供了新的数据结构Set, 它类似数组，但是成员的值都是唯一的，没有重复的值，Set本身是一个构造函数，用来生成Set数据结构。 SetSet构造函数可以结构一个数据作为参数，用来初始化 12345678let s = new Set();let s = new Set( [1,2,3,4,4] );s//Set&#123;1,2,3,4&#125;s.size//4[...set]//[1,2,3,4] 因此也出现了l两种数组去重的方法 1234567[...new Set( [1,2,3,4,4] ) ]//[1,2,3,4]//或者Array.from( new Set( [1,2,3,4,5,5] ) )//[1,2,3,4,5] Set实例的属性和方法Set结构的实例有属性:Set.prototype.constructor：构造函数，默认就是Set函数；Set.prototype.size：返回Set实例的成员总数；Set实例的方法分为两类：操作方法和遍历方法；add(value)：添加某个值，返回Set结构本身delete(value)：删除某个值，返回一个布尔值，表示删除是否成功；has(value)：返回一个布尔值，表示该值是否为Set的成员；clear() ：清除所有成员，没有返回值； 12345678910let s = new Set( [1,2,3,4,5,5] );s.add(4);s.size//5s.has(2)//trues.delete(2)s.has(2)//fasles.clear() 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach() :使用回调函数遍历每个成员 ###（1）keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 1234567891011121314151617181920212223let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] （2）forEach()Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 123456let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 12345678const map = new Map([["name","张三"] , ["title","Author"] ]);map.size//2map.has("name")//truemap.get("name")//"张三" 实例的属性好操作方法（1）size属性：返回 Map 结构的成员总数。 1234567const map = new Map();map.set('foo', true);map.set('bar', false);map//Map &#123;"foo" =&gt; true, "bar" =&gt; false&#125;map.size // 2 （2）set(key, value)set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 123456const m = new Map();m.set('edition', 6) // 键是字符串m.set(262, 'standard') // 键是数值m.set(undefined, 'nah') // 键是 undefined （3）get(key)get方法读取key对应的键值，如果找不到key，返回undefined。 123456const m = new Map([["name","MGT360124"],["age",18]])m.get('name')//"MGT360124" （4）has(key),delete(key),clear()has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 12345678910111213const m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // truem.delete(undefined)m.has(undefined) // false Map遍历方法Map结构原生提供三个遍历器生成函数和一个遍历方法;keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回所有成员的遍历器forEach()：遍历Map的所有成员Map遍历的顺序就是插入的顺序 12345678910111213141516171819202122232425262728293031323334353637const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// "F"// "T"for (let value of map.values()) &#123; console.log(value);&#125;// "no"// "yes"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// "F" "no"// "T" "yes"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes" Map结构转为数组结构 123456789101112131415161718const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eslint 规则]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2FEslint-%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应 的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。 安装npm install -g eslint 初始化项目还没有配置文件（.eslintrc）的话，可以通过指定–init参数来生成一个新的配置文件： eslint --init 运行eslint –init后，会在当前目录下生成一个.eslintrc文件，你可以在这个文件中配置一些规则。 配置ESLint被设计为完全可配置的，主要有两种方式来配置ESLint： 内嵌配置：将配置信息以注释的形式写在要检验的文件内 文件配置：利用javascript、json、yml语言的语法，生成名为.eslintrc.*的配置文件，将配置信息写到文件内 文件配置方式env：你的脚本将要运行在什么环境中Environment可以预设好的其他环境的全局变量，如brower、node环境变量、es6环境变量、mocha环境变量等12345'env': &#123; 'browser': true, 'commonjs': true, 'es6': true &#125;, globals：额外的全局变量 12345示例：globals: &#123; vue: true, wx: true&#125; parserOptions: ** JavaScript 语言选项 1234567891011121314"parserOptions": &#123; // ECMAScript 版本 "ecmaVersion":6, "sourceType":"script",//module // 想使用的额外的语言特性: "ecmaFeatures": &#123; // 允许在全局作用域下使用 return 语句 "globalReturn":true, // impliedStric "impliedStrict":true, // 启用 JSX "jsx":true &#125; &#125;, rules：开启规则和发生错误时报告的等级规则的错误等级有三种： 0或’off’：关闭规则。 1或’warn’：打开规则，并且作为一个警告（并不会导致检查不通过）。 2或’error’：打开规则，并且作为一个错误 (退出码为1，检查不通过)。 eslint 规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177// 0-不验证；1-警告；2-错误"no-alert": 0,//禁止使用alert confirm prompt "no-array-constructor": 2,//禁止使用数组构造器 "no-bitwise": 0,//禁止使用按位运算符 "no-caller": 1,//禁止使用arguments.caller或arguments.callee "no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名 "no-class-assign": 2,//禁止给类赋值 "no-cond-assign": 2,//禁止在条件表达式中使用赋值语句 "no-console": 2,//禁止使用console "no-const-assign": 2,//禁止修改const声明的变量 "no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1) "no-continue": 0,//禁止使用continue "no-control-regex": 2,//禁止在正则表达式中使用控制字符 "no-debugger": 2,//禁止使用debugger "no-delete-var": 2,//不能对var声明的变量使用delete操作符 "no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/ "no-dupe-keys": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; "no-dupe-args": 2,//函数参数不能重复 "no-duplicate-case": 2,//switch中的case标签不能重复 "no-else-return": 2,//如果if语句里面有return,后面不能跟else语句 "no-empty": 2,//块语句中的内容不能为空 "no-empty-character-class": 2,//正则表达式中的[]内容不能为空 "no-empty-label": 2,//禁止使用空label "no-eq-null": 2,//禁止对null使用==或!=运算符 "no-eval": 1,//禁止使用eval "no-ex-assign": 2,//禁止给catch语句中的异常参数赋值 "no-extend-native": 2,//禁止扩展native对象 "no-extra-bind": 2,//禁止不必要的函数绑定 "no-extra-boolean-cast": 2,//禁止不必要的bool转换 "no-extra-parens": 2,//禁止非必要的括号 "no-extra-semi": 2,//禁止多余的冒号 "no-fallthrough": 1,//禁止switch穿透 "no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3. "no-func-assign": 2,//禁止重复的函数声明 "no-implicit-coercion": 1,//禁止隐式转换 "no-implied-eval": 2,//禁止使用隐式eval "no-inline-comments": 0,//禁止行内备注 "no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数） "no-invalid-regexp": 2,//禁止无效的正则表达式 "no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量 "no-irregular-whitespace": 2,//不能有不规则的空格 "no-iterator": 2,//禁止使用__iterator__ 属性 "no-label-var": 2,//label名不能与var声明的变量名相同 "no-labels": 2,//禁止标签声明 "no-lone-blocks": 2,//禁止不必要的嵌套块 "no-lonely-if": 2,//禁止else语句内只有if语句 "no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） "no-mixed-requires": [0, false],//声明时不能混用声明类型 "no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格 "linebreak-style": [0, "windows"],//换行风格 "no-multi-spaces": 1,//不能用多余的空格 "no-multi-str": 2,//字符串不能用\换行 "no-multiple-empty-lines": [1, &#123;"max": 2&#125;],//空行最多不能超过2行 "no-native-reassign": 2,//不能重写native对象 "no-negated-in-lhs": 2,//in 操作符的左边不能有! "no-nested-ternary": 0,//禁止使用嵌套的三目运算 "no-new": 1,//禁止在使用new构造一个实例后不赋值 "no-new-func": 1,//禁止使用new Function "no-new-object": 2,//禁止使用new Object() "no-new-require": 2,//禁止使用new require "no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number "no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON() "no-octal": 2,//禁止使用八进制数字 "no-octal-escape": 2,//禁止使用八进制转义序列 "no-param-reassign": 2,//禁止给参数重新赋值 "no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接 "no-plusplus": 0,//禁止使用++，-- "no-process-env": 0,//禁止使用process.env "no-process-exit": 0,//禁止使用process.exit() "no-proto": 2,//禁止使用__proto__属性 "no-redeclare": 2,//禁止重复声明变量 "no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ "no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错 "no-return-assign": 1,//return 语句中不能有赋值表达式 "no-script-url": 0,//禁止使用javascript:void(0) "no-self-compare": 2,//不能比较自身 "no-sequences": 0,//禁止使用逗号运算符 "no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 "no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 "no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格 "no-sparse-arrays": 2,//禁止稀疏数组， [1,,2] "no-sync": 0,//nodejs 禁止同步方法 "no-ternary": 0,//禁止使用三目运算符 "no-trailing-spaces": 1,//一行结束后面不要有空格 "no-this-before-super": 0,//在调用super()之前不能使用this或super "no-throw-literal": 2,//禁止抛出字面量错误 throw "error"; "no-undef": 1,//不能有未定义的变量 "no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined "no-undefined": 2,//不能使用undefined "no-unexpected-multiline": 2,//避免多行表达式 "no-underscore-dangle": 1,//标识符不能以_开头或结尾 "no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; "no-unreachable": 2,//不能有无法执行的代码 "no-unused-expressions": 2,//禁止无用的表达式 "no-unused-vars": [2, &#123;"vars": "all", "args": "after-used"&#125;],//不能有声明后未被使用的变量或参数 "no-use-before-define": 2,//未定义前不能使用 "no-useless-call": 2,//禁止不必要的call和apply "no-void": 2,//禁用void操作符 "no-var": 0,//禁用var，用let和const代替 "no-warning-comments": [1, &#123; "terms": ["todo", "fixme", "xxx"], "location": "start" &#125;],//不能有警告备注 "no-with": 2,//禁用with "array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格 "arrow-parens": 0,//箭头函数用小括号括起来 "arrow-spacing": 0,//=&gt;的前/后括号 "accessor-pairs": 0,//在对象中使用getter/setter "block-scoped-var": 0,//块语句中使用var "brace-style": [1, "1tbs"],//大括号风格 "callback-return": 1,//避免多次调用回调什么的 "camelcase": 2,//强制驼峰法命名 "comma-dangle": [2, "never"],//对象字面量项尾不能有逗号 "comma-spacing": 0,//逗号前后的空格 "comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾 "complexity": [0, 11],//循环复杂度 "computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的 "consistent-return": 0,//return 后面是否允许省略 "consistent-this": [2, "that"],//this别名 "constructor-super": 0,//非派生类不能调用super，派生类必须调用super "curly": [2, "all"],//必须使用 if()&#123;&#125; 中的&#123;&#125; "default-case": 2,//switch语句最后必须有default "dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾 "dot-notation": [0, &#123; "allowKeywords": true &#125;],//避免不必要的方括号 "eol-last": 0,//文件以单一的换行符结束 "eqeqeq": 2,//必须使用全等 "func-names": 0,//函数表达式必须有名字 "func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式 "generator-star-spacing": 0,//生成器函数*的前后空格 "guard-for-in": 0,//for in循环要用if语句过滤 "handle-callback-err": 0,//nodejs 处理错误 "id-length": 0,//变量名长度 "indent": [2, 4],//缩进风格 "init-declarations": 0,//声明时必须赋初值 "key-spacing": [0, &#123; "beforeColon": false, "afterColon": true &#125;],//对象字面量中冒号的前后空格 "lines-around-comment": 0,//行前/行后备注 "max-depth": [0, 4],//嵌套块深度 "max-len": [0, 80, 4],//字符串最大长度 "max-nested-callbacks": [0, 2],//回调嵌套深度 "max-params": [0, 3],//函数最多只能有3个参数 "max-statements": [0, 10],//函数内最多有几个声明 "new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 "new-parens": 2,//new时必须加小括号 "newline-after-var": 2,//变量声明后是否需要空一行 "object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格 "object-shorthand": 0,//强制对象字面量缩写语法 "one-var": 1,//连续声明 "operator-assignment": [0, "always"],//赋值运算符 += -=什么的 "operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首 "padded-blocks": 0,//块语句内行首行尾是否要空行 "prefer-const": 0,//首选const "prefer-spread": 0,//首选展开运算 "prefer-reflect": 0,//首选Reflect的方法 "quotes": [1, "single"],//引号类型 `` "" '' "quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号 "radix": 2,//parseInt必须指定第二个参数 "id-match": 0,//命名检测 "require-yield": 0,//生成器函数必须有yield "semi": [2, "always"],//语句强制分号结尾 "semi-spacing": [0, &#123;"before": false, "after": true&#125;],//分号前后空格 "sort-vars": 0,//变量声明时排序 "space-after-keywords": [0, "always"],//关键字后面是否要空一格 "space-before-blocks": [0, "always"],//不以新行开始的块&#123;前面要不要有空格 "space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格 "space-in-parens": [0, "never"],//小括号里面要不要有空格 "space-infix-ops": 0,//中缀操作符周围要不要有空格 "space-return-throw-case": 2,//return throw case后面要不要加空格 "space-unary-ops": [0, &#123; "words": true, "nonwords": false &#125;],//一元运算符的前/后要不要加空格 "spaced-comment": 0,//注释风格要不要有空格什么的 "strict": 2,//使用严格模式 "use-isnan": 2,//禁止比较时使用NaN，只能用isNaN() "valid-jsdoc": 0,//jsdoc规则 "valid-typeof": 2,//必须使用合法的typeof的值 "vars-on-top": 2,//var必须放在作用域顶部 "wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格 "wrap-regex": 0,//正则表达式字面量用小括号包起来 "yoda": [2, "never"]//禁止尤达条件 一些错误的正确修改Prevent definitions of unused state (react/no-unused-state)以下模式被认为是警告: 123456789101112131415class MyComponent extends React.Component &#123; state = &#123; foo: 0 &#125;; render() &#123; return &lt;SomeComponent /&gt;; &#125;&#125;var UnusedGetInitialStateTest = createReactClass(&#123; getInitialState: function() &#123; return &#123; foo: 0 &#125;; &#125;, render: function() &#123; return &lt;SomeComponent /&gt;; &#125;&#125;) 以下模式不被视为警告: 123456789101112131415class MyComponent extends React.Component &#123; state = &#123; foo: 0 &#125;; render() &#123; return &lt;SomeComponent foo=&#123;this.state.foo&#125; /&gt;; &#125;&#125;var UnusedGetInitialStateTest = createReactClass(&#123; getInitialState: function() &#123; return &#123; foo: 0 &#125;; &#125;, render: function() &#123; return &lt;SomeComponent foo=&#123;this.state.foo&#125; /&gt;; &#125;&#125;) react prop-typespropTypes能用来检测全部数据类型的变量，包括基本类型的的字符串，布尔值，数字，以及引用类型的对象，数组，函数，甚至还有ES6新增的符号类型 1234567891011Son.propTypes = &#123; optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型&#125; 使用parseInt()函数当使用parseInt()函数时，通常省略第二个参数 radix，并让函数尝试从第一个参数确定它是什么类型的数字。默认情况下，parseInt()将自动检测十进制和十六进制（通过0x前缀）。在 ECMAScript 5之前，parseInt()还会自动检测八进制文字，这会导致问题，因为许多开发人员认为领先的文字0会被忽略。 不要这样做： 1var num = parseInt("071"); // 57 做这个： 1var num = parseInt("071", 10); // 71 条件逻辑里一定要加内容处理123456789101112131415161718192021/*eslint no-empty: "error"*/if (foo) &#123; // empty&#125;while (foo) &#123; /* empty */&#125;try &#123; doSomething();&#125; catch (ex) &#123; // continue regardless of error&#125;try &#123; doSomething();&#125; finally &#123; /* continue regardless of error */&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[styled-components快速入门]]></title>
    <url>%2Fblog%2F2019%2F01%2F03%2Fstyled-components%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[styled-components利用标记的模板文字来设置组件的样式。 它删除了组件和样式之间的映射。这意味着当您定义样式时，实际上是在创建一个正常的React组件，它会将样式附加到它上面。 styled-componentsstyled-components 是一个常用的css in js 类库。和所有同类型的类库一样，通过 js 赋能解决了原生 css 所不具备的能力，比如变量、循环、函数等。 文档官方文档链接 优势className 的写法会让原本写css的写法十分难以接受,sass 、less 等预处理可以解决部分 css 的局限性，还是要学习新的语法，而且需要对其编译，如果通过导入css的方式 会导致变量泄露成为全局 需要配置webpack让其模块化,其复杂的 webpack 配置也总是让开发者抵触。 有过sass 、less开发经验，也能很快的切换到styled-components，因为大部分语法都类似，比如嵌套、&amp; 、 继承等， styled-componens 很好的解决了学习成本与开发环境问题，很适合 React 技术栈 、React Native的项目开发。 安装12npm install --save styled-components webstorm需要安装 styled-component 插件 ; vscode已支持智能提示 实战简单的组件创建了两个简单的组件，一个包装器和一个标题，并附加了一些样式： 123456789101112131415161718192021222324import styled from 'styled-components';//创建一个Title组件，它将使用某些样式const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;// 创建一个包装器组件，它将使用某些样式const Wrapper = styled.section` padding: 4em; background: papayawhip;`;//像任何其他React组件一样使用Title和Wrapper - 除了它们的样式！render( &lt;Wrapper&gt; &lt;Title&gt; Hello World! &lt;/Title&gt; &lt;/Wrapper&gt;); 可以看到控制台中输出了一个随机的className，这是styled-components帮我们完成的. 注意: 组件名要以大些开头 不然会被解析成普通标签 传递props123456789101112131415const Button = styled.button` background: $&#123;props =&gt; props.primary ? 'palevioletred' : 'white'&#125;; color: $&#123;props =&gt; props.primary ? 'white' : 'palevioletred'&#125;; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 在组件传递的props都可以在定义组件时获取到，这样就很容易实现定制某些风格组件 props高级用法设置默认值，在未设定必须传值的情况下我们会给一个默认值(defaultProps) 1234567891011121314151617181920212223242526272829303132export default class ALbum extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; // 接收传递的值 imgSrc: props.imgSrc &#125; &#125; render () &#123; const &#123;imgSrc&#125; = this.state return ( &lt;Container imgSrc=&#123;imgSrc&#125;&gt; &lt;/Container&gt; ) &#125;&#125;// 在这里是可以拿到props的 const Container = styled.div` background-size: cover; background-image: url($&#123;props =&gt; props.imgSrc&#125;); width: 100%; height: 300px;`// 当然没传值也没关系 我们设置默认值Container.defaultProps = &#123; imgSrc: Cover&#125; 塑造组件这个非常有用 你可能会遇到一些原本就已经是组件了 但是你要为他添加一些样式，这时候该怎么办呢 ? 12345678910111213141516// 传递className 在react-native 中要使用 styleconst Link = (&#123;className , children&#125;) =&gt; ( &lt;a className=&#123;className&#125;&gt; &#123;children&#125; &lt;/a&gt;)const StyledLink = styled(Link)` color: palevioletred;`render( &lt;div&gt; &lt;Link&gt;普通组件&lt;/Link&gt; &lt;StyledLink&gt;有颜色吗？&lt;/StyledLink&gt; &lt;/div&gt;); 组件样式继承12345678910111213const Button = styled.button` color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;const TomatoButton = Button.extend` color: tomato; border-color: tomato;`;// TomatoButton 部分样式继承自 Button 这种情况下不会生成两个class 改变组件标签在闲的蛋疼的情况下 我们想要改变组件的标签 比如把 button 变成 a 标签 12// 利用上面定义的 Button 组件 调用 withComponent 方法const Link = Button.withComponent('a') 维护其他属性在某种情况下，我们可能需要用到第三方库样式，我们可以使用这个方法轻松达到12345678910111213141516const Input = styled.input.attrs(&#123; // 定义静态 props type: 'password', // 没传默认使用 1em margin: props =&gt; props.size || '1em', padding: props =&gt; props.size || '1em'&#125;)` color: palevioletred; font-size: 1em; border: 2px solid palevioletred; border-radius: 3px; // 动态计算props margin: $&#123;props =&gt; props.margin&#125;; padding: $&#123;props =&gt; props.padding&#125;`render ( &lt;Input size='1em'&gt;&lt;/Input&gt; &lt;Input size='2em'&gt;&lt;/Input&gt; ) 动画动画会生成一个随机类名 而不会污染到全局1234567891011121314import &#123; keyframes &#125; from 'styled-components'// CSS 动画const rotate360 = keyframes` from &#123; transform: rotate(0); &#125; to &#123; transform: rotate(360deg); &#125;`const Rotate = Button.extend` animation: $&#123;rotate360&#125; 2s linear infinite;`render ( &lt;Rotate&gt; 💅 &lt;/Rotate&gt; ) 最后styled-components虽然解决了大部分问题，增加了可维护性，但是破坏了原生体验，时常我们需要写更多的代码来达到业务要求，希望未来有更好的方案.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>React</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLite 之 INSERT OR REPLACE使用]]></title>
    <url>%2Fblog%2F2018%2F12%2F28%2FSQLite-%E4%B9%8B-INSERT-OR-REPLACE%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SQLite是一个C语言库，它实现了一个 小型， 快速， 自包含， 高可靠性， 功能齐全的 SQL数据库引擎。SQLite是世界上使用最多的数据库引擎。它内置于所有移动电话和大多数计算机中，并且捆绑在人们每天使用的无数其他应用程序中。下面是介绍如何使用INSERT OR REPLACE命令。 业务需求具体业务中,遇到需要批量插入和修改数据库的情况。 当前数据不存在，进行数据插入操作 当前数据存在，进行数据更新操作 以上的业务情况，可以使用SQlite的 INSERT OR REPLACE命令进行操作，具体的语法：1INSERT OR REPLACE INTO table-name (column-name,...) VALUES (column-value,...) UNIQUE 约束 或 PRIMARY KEY约束 UNIQUE约束: 唯一约束,防止在一个特定的列存在两个记录具有相同的值 PRIMARY KEY约束: 约束唯一标识数据库表中的每条记录。 相同点PRIMARY KEY也是UNIQUE,即不可重复 不同点 1.PRIMARY KEY是非空的,但是UNIQUE可以为空 2.只能有一个主键,但是唯一索引可以有多个 3.如果没有指定聚合索引,那么主键默认为聚合索引,唯一索引不具备该特性 1INSERT OR REPLACE INTO table-name (column-name,...) VALUES (column-value,...) 在如上的colunm-name中,如果已插入的column-value均无已存在的值,则判断插入的该条数据不存在,反正存在. 创建表： 1CREATE TABLE TARD ( ID INT PRIMARY KEY, name TEXT NOT NULL UNIQUE, age INT NOT NULL , date CHAR(50),Dvalue REAL DEFAULT 300.00); 12345678910111213141516171819// 在xiaoming不存在的情况下进行INSERTINSERT OR REPLACE INTO TARD (ID, name, age, date) VALUES (1, 'xiaoming', 18, '打电话')// 结果ID name age date Dvalue1 xiaoming 18 打电话 300// 在xiaoming已经存在的情况下进行updateINSERT OR REPLACE INTO TARD (ID, name, age, date) VALUES (1, 'xiaoming', 118, '去打电话')// 结果ID name age date Dvalue1 xiaoming 118 去打电话 300 创建表的时候ID和name都是UNIQUE的,命令只有在两个值都不存在时,才会进行插入,否则更新当前数据 注意如果INSERT OR REPLACE INTO table-name (column-name,...) VALUES (column-value,...)该数据已存在,在更新时,某行数据没填写,则默认为空,覆盖之前的数据. 举例: 1INSERT OR REPLACE INTO TARD (ID, name, age, date) VALUES (1, 'xiaoming', 118) xiaoming已在数据库中,会进行更新操作,没有填写date数值,则date数值不会被保留,而且替换为NULL 12ID name age date Dvalue1 xiaoming 118 NULL 300]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnyProxy简介移动端抓包工具]]></title>
    <url>%2Fblog%2F2018%2F12%2F26%2FAnyProxy%E7%AE%80%E4%BB%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[移动端的开发，难免需要抓包查看情况，在实际工作里开发移动端业务需求，找到了AnyProxy抓包神器，它是阿里巴巴基于 Node.js 开发的一款开源代理服务器，使用场景很广，满足日常需求开发和测试。 1. 简介 AnyProxy 是阿里巴巴基于 Node.js 开发的一款开源代理服务器。AnyProxy链接 代理服务器站在客户端和服务端的中间，它可以收集双方通信的每个比特。一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务所使用的代理协议，请求对目标服务器创建连接或者获取目标服务器的指定资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应。 AnyProxy 是完全可以灵活配置的代理服务器。它支持 https明文代理 ，且提供了 Web 界面便于观测请求情况，同时支持二次开发，可以用 JavaScript 来控制代理的全部流程，搭建前端个性化调试环境。 2. 安装安装 Node.js123~ brew update~ brew install node~ node --version 安装 AnyProxy（需要node8）12345~ 安装稳定正式版$ npm install -g anyproxy~ 最新测试版，需要使用最新版本 node 进行安装$ npm install -g anyproxy@beta~ 有时需要添加 sudo 使用AnyProxy1、启动 anyproxy1~ anyproxy 启动结果123 ~ anyproxy[AnyProxy Log][2018-12-26 11:42:19]: Http proxy started on port 8001[AnyProxy Log][2018-12-26 11:42:19]: web interface started on port 8002 2、启动浏览器1http://192.168.0.195:8002/ 或 http://127.0.0.1:8002/ 3、客户端配置代理 ip 端口号8001 启动anyproxy 配置 Https1、 生成 rootCA1234// 稳定版本生成方法~ sudo anyproxy --root// 最新版本生成方法~ anyproxy-ca 以支持 Https 方式重新启动 AnyProxy123~ anyproxy --intercept// 简写~ anyproxy -i 启动结果12345678910~ anyproxy -i[AnyProxy WARN][2018-12-26 11:55:54]: ROOT CA NOT INSTALLED YET? The rootCA is not trusted yet, install it to the trust store now? Yes[AnyProxy Log][2018-12-26 11:56:03]: About to trust the root CA, this may requires your passwordPassword:[AnyProxy Log][2018-12-26 11:56:07]: Root CA install, you are ready to intercept the https now[AnyProxy Log][2018-12-26 11:56:07]: The root CA file path is: /Users/xmaczone/.anyproxy/certificates/rootCA.crt[AnyProxy Log][2018-12-26 11:56:08]: Http proxy started on port 8001[AnyProxy Log][2018-12-26 11:56:08]: web interface started on port 8002 手机安装证书 拓展windows下安装AnyProxy抓取移动App Http请求]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asyncwait的使用以及注意事项]]></title>
    <url>%2Fblog%2F2018%2F12%2F25%2Fasync-await%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[async / await, 搭配 promise, 可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性. 这里介绍 async / await的基本用法和一些注意事项. async使用 async function 可以定义一个异步函数,其语法为:1async function name([param[, param[, ... param]]]) &#123; statements &#125; async 函数的返回值很特殊: 不管在函数体内 return 了什么值, async 函数的实际返回值总是一个 Promise 对象. 详细讲就是:若在 async 函数中 return 了一个值 a, 不管 a 值是什么类型, async 函数的实际返回值总是 Promise.resolve(a). 那么 Promise.resolve(a) 最终返回一个什么样的promise呢? 看一下MDN的介绍: Promise.resolve(value)方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。 来看一段代码有这样一个场景: 需要先通过 请求a 拿到 数据a, 然后通过通过 请求b 并携带发送 数据a 获取到 数据b, 拿到 数据b 之后再展示到页面上. 方案一:1234567891011121314151617181920async function getData() &#123; // 假装请求数据a var data_a = await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('data_a'); &#125;, 1000); &#125;); // 假装请求数据b且此请求依赖数据a var data_b = await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('data_b'); &#125;, 1000); &#125;); // 展示数据2 console.log(data_b);&#125;getData(); 上面依次获取到 数据a 和 数据b, 然后再展示 数据b. 既然 async函数总是返回一个promise, 那么也可以在一个 async 函数返回获取 数据b 的promise, 调用函数后再使用 then 方法拿到数据, 代码如下: 1234567891011121314151617181920212223async function getData() &#123; // 假装请求数据a var data_a = await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('data_a_value'); &#125;, 1000); &#125;); // 假装请求数据b且此请求依赖数据a return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(data_a); // ===&gt;data_a_value resolve('data_b_value'); &#125;, 1000); &#125;);&#125;getData().then((value) =&gt; &#123; console.log(value); // ===&gt;data_b_value &#125;);// 结果返回顺序data_a_valuedata_b_value await引用MDN的介绍: await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用. await 的使用语法非常简单: 1[return_value] = await expression; 其中 expression 是一个 Promise 对象或者任何要等待的值; 而 await expression 的执行结果有以下几种情况: 若 expression 是一个 Promise 对象, 并且其以值 x 被 fulfilled, 则返回值为 x. 若 expression 是一个 Promise 对象, 并且其以异常 e 被 rejected, 则抛出异常 e. 若 expression 不是 Promise 对象, 则会将 expression 处理成一个以 expression 值被 fulfilled 的 Promise 对象, 然后返回这个 Promise 对象的最终值 (即 expression 值). 这种用法没太大意义, 因此实际使用时还是尽量在 await 后跟一个 Promise 对象. 另外需要注意的是, await 在等待 Promise 对象时会导致 async function 暂停执行, 一直到 Promise 对象决议之后才会 async function 继续执行. 通过一段代码来看一下: 1234567891011121314151617181920212223242526272829303132333435363738async function foo() &#123; var a = await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 2000); &#125;); console.log(a); // 第2秒时输出: 1 try &#123; var b = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(2); &#125;, 1000); &#125;) &#125; catch (e) &#123; console.log(e); // 第3秒时输出: 2 &#125; // 函数暂停2秒后再继续执行 var sleep = await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('sleep_value'); resolve('sleep'); &#125;, 2000); &#125;); var c = await 3; console.log(c); // 第5秒时输出: 3&#125;foo();// 结果返回顺序12sleep_value3]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好的东西收藏于此]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2F%E5%A5%BD%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%94%B6%E8%97%8F%E4%BA%8E%E6%AD%A4%2F</url>
    <content type="text"><![CDATA[这里会是一个知识的宝库，里面会有教程、文档、框架、方案、理论，大家慢慢去品味。 框架—React 1、dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。About DvaJS文档 链接 dva.js 知识导图 链接 AccountSystem 一个小型库存管理系统 链接 特性 易学易用，仅有 6 个 api，对 redux 用户尤其友好，配合 umi 使用后更是降低为 0 API elm 概念，通过 reducers, effects 和 subscriptions 组织 model 插件机制，比如 dva-loading 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading 支持 HMR，基于 babel-plugin-dva-hmr 实现 components、routes 和 models 的 HMR 他是怎么来的？ Why dva and what’s dva 支付宝前端应用架构的发展和选择 2、AntD Admin 一套优秀的中后台前端解决方案About 在线演示 - 链接 使用文档 - 链接 常见问题 - 链接 更新日志 - 链接 特性 国际化，源码中抽离翻译字段，按需加载语言包 动态权限，不同权限对应不同菜单 优雅美观，Ant Design 设计体系 Mock 数据，本地数据调试 3、12 步 30 分钟，完成用户管理的 CURD 应用 (react+dva+antd)About git链接 链接 实现日志 链接 Roadhog 是一个包含 dev、build 和 test 的命令行工具，他基于 react-dev-utils，和 create-react-app 的体验保持一致。你可以想象他为可配置版的 create-react-app。链接 框架—Vue 1、Ant Design of VueAbout Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 链接 特性 提炼自企业级中后台产品的交互语言和视觉风格。 开箱即用的高质量 Vue 组件。 共享Ant Design of React设计工具体系。 2、Vue-baidu-mapAbout Vue 2.x的百度地图组件\ 特性 git链接 文档地址 3、 Vue-element-adminAbout 一个神奇的vue后台管理系统 特性 git链接 4、 Vue-element-adminAbout 用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历 特性 git链接 5、 ElementAbout 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 特性 git链接 文档地址 实战实验 1、基于React 编写的基于Taro + Dva构建的适配不同端（微信/百度/支付宝小程序、H5、React-Native 等）的时装衣橱技术栈React + Taro + Dva + Sass + ES6/ES7 特性 git链接 taro文档地址 工具 1、docsifyAbout文档地址一个神奇的文档网站生成工具 docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 特性 无需构建，写完文档直接发布 容易使用并且轻量 (~19kB gzipped) 智能的全文搜索 提供多套主题 丰富的 API 支持 Emoji 兼容 IE10+ 支持 SSR (example)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象原则-高内聚、低耦合]]></title>
    <url>%2Fblog%2F2018%2F12%2F19%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99-%E9%AB%98%E5%86%85%E8%81%9A%E3%80%81%E4%BD%8E%E8%80%A6%E5%90%88%2F</url>
    <content type="text"><![CDATA[面向对象原则：高内聚、低耦合;多聚合、少继承；使得各个业务模块的“可重用性”、“移植性”明显提升。 高内聚、低耦合 内聚：就是每个模块尽可能可以独立完成自己的功能，不依赖于其他外部模块的代码。 耦合：就是模块与模块之间接口的复杂程度，模块之间的联系如果越复杂那么他们的耦合度就越高，会出现修改一处代码引发蝴蝶效应，牵一发而动全身。 结果：使得各个业务模块的“可重用性”、“移植性”明显提升；通常项目代码结构中各模块的内聚程度越高，那么模块间的耦合程度就越低 模块：函数 高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合） 低耦合：减少类内部，一个成员方法调用另一个成员方法 类 高内聚低耦合：减少类内部，对其他类的调用 功能块 高内聚低耦合：减少模块之间的交互复杂度（接口数量，参数数据） 多聚合、少继承 聚合：事物A由若干个事物B组成，体现在类与类之间的关系就是：“类B的实例”作为“类A”的“成员对象”出现。 继承：顾名思义，体现在类与类之间的关系就是：“类B”被类A所继承显然，当观察类B所具有的行为能力时，“聚合”方式更加清晰。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitment使用 GitHub Issues 搭建评论系统]]></title>
    <url>%2Fblog%2F2018%2F12%2F07%2FGitment%E4%BD%BF%E7%94%A8-GitHub-Issues-%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 基础使用1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。 2. 引入 Gitment将下面的代码添加到你的页面： 123456789101112131415&lt;div id="container"&gt;&lt;/div&gt;&lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt;&lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', repo: '存储评论的 repo', oauth: &#123; client_id: '你的 client ID', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。 如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。 $ npm install --save gitment关于构造函数中的更多可用参数请查看 Gitment Options 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。 之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能） 比如你可以通过自定义主题将评论框放在评论列表前面： 1234567891011121314151617const myTheme = &#123; render(state, instance) &#123; const container = document.createElement('div') container.lang = "en-US" container.className = 'gitment-container gitment-root-container' container.appendChild(instance.renderHeader(state, instance)) container.appendChild(instance.renderEditor(state, instance)) container.appendChild(instance.renderComments(state, instance)) container.appendChild(instance.renderFooter(state, instance)) return container &#125;,&#125;const gitment = new Gitment(&#123; // ... theme: myTheme,&#125;)gitment.render('container') 更多自定义内容请查看文档。 其他问题语言问题考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React16新特性来认识一波]]></title>
    <url>%2Fblog%2F2018%2F11%2F29%2FReact16%E6%96%B0%E7%89%B9%E6%80%A7%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[React的16版本，采用了MIT开源许可证,React16新特性来认识一波。 Fragments：render函数可以返回数组和字符串 error boundaries：错误处理 portals ：支持声明性地将子树渲染到另一个DOM节点 custom DOM attributes ：ReactDom允许传递非标准属性 improved server-side rendering:提升服务端渲染性能 支持自定义DOM属性 setState传入null时不会再触发更新 更好的服务器端渲染 新的打包策略 新特性1、render可以return数组 ，字符串 React16新增加了render的返回格式，你可以return返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，且不需要外层包含div标签。不过需要添加对应的key值。 12345678910111213141516171819202122232425262728//stringrender()&#123; return 'Hello,world'&#125;//numberrender()&#123; return 0123456789&#125;//booleanrender()&#123; return isTrue ? true : false&#125;//nullrender()&#123; return null&#125;//fragments，遇到控制台出现warning,是未加key标识符，render()&#123; return [ &lt;div&gt;Hello&lt;/div&gt;, &lt;span&gt;world&lt;/span&gt;, &lt;p&gt;DRL&lt;/p&gt; ]&#125; 2、error boundaries错误处理React16新增加了抛异常的生命周期函数componentDidCatch 123componentDidCatch(err,info)&#123; this.setState(&#123;isError:1&#125;); &#125; 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为try-catch 在容易出错的组件外使用ErrorBoundary将它包裹起来: 12345678910111213141516171819202122232425262728293031//使用方式import React, &#123; Component &#125; from 'react'export default class ErrorBoundary extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; hasError: false &#125; &#125; componentDidCatch(err, info) &#123; this.setState(&#123; hasError: true &#125;) &#125; render()&#123; if(this.state.hasError)&#123; return &lt;div&gt;Something wrong!&lt;/div&gt; &#125; return this.props.children &#125;&#125;render()&#123; return ( &lt;div&gt; &lt;ErrorBoundary&gt; &lt;Listview user=&#123;this.state.data&#125; /&gt; &lt;/ErrorBoundary&gt; &lt;button onClick=&#123;this.onClickChange&#125;&gt;toUpdate&lt;/button&gt; &lt;/div&gt; )&#125; 如果Listview组件发生错误，将会使用ErrorBoundary提供的&lt;div&gt;Something went wrong&lt;/div&gt;代替它，不会引起整个组件树的卸载。 3、portals支持声明性地将子树渲染到另一个DOM节点Portals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//实现一个简易蒙层效果，抽象出一个通用的Overlay组件import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';export default class Overlay extends Component &#123; constructor(props) &#123; super(props); this.container = document.createElement('div'); document.body.appendChild(this.container); &#125; componentWillUnmount() &#123; document.body.removeChild(this.container); &#125; render() &#123; return ReactDOM.createPortal( &lt;div className='overlay'&gt; &lt;span className='overlay-close' onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt; &#123;this.props.children&#125; &lt;/div&gt;, this.container ) &#125;&#125;//该组件对应的样式如下.overlay&#123; box-sizing:border-box; position: fixed; top:50%; left:50%; width:260px; height:200px; margin-left:-130px; margin-top:-100px; padding:10px; background-color: #fff; outline: rgba(0,0,0,.5) solid 9999px;&#125;.overlay-close&#123; position: absolute; top:10px; right:10px; color:red; cursor: pointer;&#125;使用方式如下：class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; overlayActive: false &#125; this.closeOverlay = this.closeOverlay.bind(this); this.showOverlay = this.showOverlay.bind(this); &#125; closeOverlay() &#123; this.setState(&#123; overlayActive: false &#125;) &#125; showOverlay() &#123; this.setState(&#123; overlayActive: true &#125;) &#125; render() &#123; return ( &lt;div className="App"&gt; &lt;div&gt;hello world!&lt;/div&gt; &#123;this.state.overlayActive &amp;&amp; &lt;Overlay onClose=&#123;this.closeOverlay&#125;&gt;overlay content&lt;/Overlay&gt;&#125; &lt;button onClick=&#123;this.showOverlay&#125;&gt;show&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 4、custom DOM attributes ：ReactDom允许传递非标准属性5、 improved server-side rendering:提升服务端渲染性能6、 支持自定义DOM属性7、 setState传入null时不会再触发更新8、 更好的服务器端渲染9、 新的打包策略]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript: 什么是纯函数以及为什么要用纯函数]]></title>
    <url>%2Fblog%2F2018%2F11%2F11%2FJavaScript-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？ 除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。 什么函数是纯纯函数的定义是： 1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。 这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。 在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。 什么是可观察的副作用一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。 注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。 副作用来自，但不限于： 进行一个 HTTP 请求 Mutating data 输出数据到屏幕或者控制台 DOM 查询/操作 Math.random() 获取的当前时间 副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。 不过首先，让我们来看一些纯的和不纯的函数对比的例子…… 纯函数以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：1function priceAfterTax(productPrice) &#123; return (productPrice * 0.20) + productPrice;&#125; 它符合我们所说的两条纯函数的定义。不依赖于任何外部输入，不改变任何外部数据、没有副作用。 即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。 非纯函数我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:1234var tax = 20;function calculateTax(productPrice) &#123; return (productPrice * (tax/100)) + productPrice;&#125; 暂停片刻，看看你是否能看出为什么这个函数不纯。 其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。 为什么说纯函数在 JavaScript 很重要纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。 不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。 并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。 可测试性和重构另一个使用纯函数的原因是测试以及重构。 使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。 同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。） 正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。 此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 Wiki。同时也推荐阅读 开发建议手册 以及 纯函数 vs. 非纯函数. 原文链接： medium.com]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP里很好的使用ImageMagick---convert篇]]></title>
    <url>%2Fblog%2F2018%2F09%2F18%2F%E5%9C%A8PHP%E9%87%8C%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BD%BF%E7%94%A8ImageMagick-convert%E7%AF%87%2F</url>
    <content type="text"><![CDATA[ImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是—-convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。 基本命令与格式1、基本命令 magick: 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。 convert: 等同于 magick 命令。 identify: 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。 mogrify: 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。 composite: 将一个图片或多个图片组合成新图片。 montage: 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。 compare: 从数学和视觉角度比较源图像与重建图像之间的差异。 display:在任何 X server 上显示一个图像或图像序列。 animate: 在任何 X server 上显示图像序列。 import: 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。 conjure:解释并执行 MSL ( Magick Scripting Language ) 写的脚本。 stream: 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。 2、命令格式基本命令的使用，遵循 Unix 风格的标准格式，例如 command [options] input_image output_image 将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用 1convert -resize 200x200 goods.png goods.jpg 开始绘制生成图片一些前期参数1、入参123456789101112131415$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';$item_title='测试字体';$shop_title='测试店铺';$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';$numid_share='0000000';$qr_title='长按识别二维码';// 对宝贝标题裁剪$drawtitone=mb_substr($item_title,0,13, 'utf-8');$drawtittow=mb_substr($item_title,13,13, 'utf-8');$drawtitthree=mb_substr($item_title,26,13, 'utf-8');$time_date = time(); // 时间戳$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径----&gt;指定一个文件夹保存生成图片过程里的图片 2、先下载素材文件我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。12345678910$item_img_down = $workDir.'/itemimage.jpg';$shop_img_down = $workDir.'/shopimage.jpg';$qr_img_down = $workDir.'/qrimage.jpg';// 下载宝贝主图\NetworkUtils::curlDownload($item_img, $item_img_down);// 下载店铺图片\NetworkUtils::curlDownload($shop_img, $shop_img_down);// 下载二维码\NetworkUtils::curlDownload($qr_img, $qr_img_down); \NetworkUtils::curlDownload($item_img, $item_img_down); 下载$item_img保存在目标路径文件夹下的$workDir.&#39;/itemimage.jpg&#39;路径。 3、指定字体和颜色1234$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';$fontColor = '#333333';$fontColor_shoptitle = '#999999';$fontColor_qrtitlt = '#666666'; 4、创建一个底图创建一个750x1046白色的底图，我们可以在上面绘制文字 123456// 创建一个底图(并且加上一些文字)$back_img=$workDir.'/bg.jpg'; //要生成的图片的路径----&gt;可以在服务器端看到$back_cmds="convert 'xc:[750x1046!]' -background white -font &#123;$fontFamily&#125; -draw 'text 580,994 \"&#123;$qr_title&#125;\"' -fill \"&#123;$fontColor_qrtitlt&#125;\" -pointsize 20 -draw 'text 114,990 \"&#123;$shop_title&#125;\"' -font &#123;$fontFamily&#125; -pointsize 22 -fill '#999999' &#123;$workDir&#125;/bg.jpg";$result_back_cmds = \SystemCommon::runningCmd($back_cmds); 这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。-font {$fontFamily} -draw &#39;text 580,994 \&quot;{$qr_title}\&quot;&#39; -fill \&quot;{$fontColor_qrtitlt}\&quot; -pointsize 20 解释一下： xc:[100x40!]: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 ! -fill &#39;rgba(0, 0, 0, 0)&#39;：设置了文本的填充颜色 text 114,990: 对文字进行定位 -font：指定字体 -pointsize：指定文本的字体大小 -draw：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline ) 继续添加文字： 12345$back_img_shoptitle=$workDir.'/btitle.jpg'; //要生成的图片的路径$back_cmds_shoptitle="convert -draw 'text 40,820 \"&#123;$drawtitone&#125;\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\" -draw 'text 40,866 \"&#123;$drawtittow&#125;\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\" -draw 'text 40,912 \"&#123;$drawtitthree&#125;\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\" &#123;$back_img&#125; &#123;$workDir&#125;/btitle.jpg";$result_back_cmds_shoptitle = \SystemCommon::runningCmd($back_cmds_shoptitle); 效果： 5、拼接图片现在就可以在之前得到的图片上拼接所需要的图片了 12345678 // 在底图上合并商品主图$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg'; //要生成的图片的路径$geometryX = "+" . 0; // 定位$geometryY = "+" . 0; // 定位$customPicPos = "northwest";$back_cmds_itemimg = "convert &#123;$back_img_shoptitle&#125; &#123;$workDir&#125;/item_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryX&#125;&#123;$geometryY&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result.jpg";$result_back_cmds_itemimg = \SystemCommon::runningCmd($back_cmds_itemimg); 解释一下： -geometry: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写 composite: 将一个图片或多个图片组合成新图片。 这里是把{$workDir}/item_img_mag.jpg路径的图片绘制到之前绘制文字的图片上$back_img_shoptitle，最终得到的图片保存路径是在{$workDir}/result.jpg 让我们继续操作图片 1234567891011// 合并二维码 $geometryXshop = "+" . 40;$geometryYshop = "+" . 950;$back_cmds_shopimg = "convert &#123;$workDir&#125;/result.jpg &#123;$workDir&#125;/shop_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXshop&#125;&#123;$geometryYshop&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result1.jpg";$result_back_cmds_shopimg = \SystemCommon::runningCmd($back_cmds_shopimg); // 合并店铺图标$geometryXqr = "+" . 520;$geometryYqr = "+" . 784;$back_cmds_qrimg = "convert &#123;$workDir&#125;/result1.jpg &#123;$workDir&#125;/qr_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXqr&#125;&#123;$geometryYqr&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result2.jpg";$result_back_cmds_qrimg = \SystemCommon::runningCmd($back_cmds_qrimg); 效果： 发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。 6、放大拼接图片尺寸需要对多拼接的图片都进行操作 123456789 // 看来需要先放大主图$item_img_m="convert -resize '750x766!' &#123;$item_img_down&#125; &#123;$workDir&#125;/item_img_mag.jpg";$item_img_mag = \SystemCommon::runningCmd($item_img_m); // 看来需要先放大二维码$shop_img_m="convert -resize 64x64 &#123;$shop_img_down&#125; &#123;$workDir&#125;/shop_img_mag.jpg";$shop_img_mag = \SystemCommon::runningCmd($shop_img_m); // 看来需要先放大店铺图标$qr_img_m="convert -resize 200x200 &#123;$qr_img_down&#125; &#123;$workDir&#125;/qr_img_mag.jpg";$qr_img_mag = \SystemCommon::runningCmd($qr_img_m); -resize 延伸解读 IamgeMagick 提供了几种符号来定义缩放 12345convert -resize '150x100!' goods.jpg thumbnail.jpgconvert -resize '150x100&gt;' goods.jpg thumbnail.jpgconvert -resize '150x100&lt;' goods.jpg thumbnail.jpg !：不管图片宽高如何，都缩放成 150x100 这样的尺寸。 &gt;：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。 &lt;：与 &gt; 功能相反 缩放对比 这样的结果也不是我们需要的 只有convert -resize &#39;750x766!&#39; {$item_img_down} {$workDir}/item_img_mag.jpg这样固定尺寸之后可以得到： 7、图片转换为 base64格式我们最后同样的以base64格式输出给前端 12345678910111213141516171819$stdout = trim($result_back_cmds_qrimg["stdout"]);$Return = array();if (empty($stdout) || strpos($result_back_cmds_qrimg["stderr"], "identify") != false) &#123; // runningCmd执行成功 $dest_img = $workDir.'/result2.jpg'; // /*图片转换为 base64格式编码*/ $base64_image = ''; $image_info = getimagesize($dest_img); $image_data = fread(fopen($dest_img, 'r'), filesize($dest_img)); $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data)); $Return['data']=$base64_image; $Return['dest_img']=$dest_img; $Return['type']='success'; $Return['msg']=1; return $Return;&#125;$Return['data']='';$Return['msg']=2;return $Return; $workDir.&#39;/result2.jpg是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。 （小姐姐拼接图） 这次convert命令的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。 欢迎光顾个人Blog]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP里使用ImageMagick生成base64图片]]></title>
    <url>%2Fblog%2F2018%2F09%2F05%2F%E5%9C%A8PHP%E9%87%8C%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BD%BF%E7%94%A8ImageMagick%2F</url>
    <content type="text"><![CDATA[最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。 一些需要的知识点 PHP将图片转base64编码以及base64图片转换为图片并保存代码图片转base64编码12345678910111213/*图片转换为 base64格式编码*/$img = 'uploads/about.png';$base64_img = base64EncodeImage($img);echo '&lt;img src="' . $base64_img . '" /&gt;'; function base64EncodeImage ($image_file) &#123; $base64_image = ''; $image_info = getimagesize($image_file); $image_data = fread(fopen($image_file, 'r'), filesize($image_file)); $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data)); return $base64_image;&#125; base64图片转换为图片并保存12345678910111213141516171819202122/* base64格式编码转换为图片并保存对应文件夹 */function base64_image_content($base64_image_content,$path)&#123; //匹配出图片的格式 if (preg_match('/^(data:\s*image\/(\w+);base64,)/', $base64_image_content, $result))&#123; $type = $result[2]; $new_file = $path."/".date('Ymd',time())."/"; if(!file_exists($new_file))&#123; //检查是否有该文件夹，如果没有就创建，并给予最高权限 mkdir($new_file, 0700); &#125; $new_file = $new_file.time().".&#123;$type&#125;"; if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content))))&#123; return '/'.$new_file; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; echo base64_image_content($base64_img,"uploads/"); base64Base64是一种用64个字符来表示任意二进制数据的方法。Base64的原理很简单，首先，准备一个包含64个字符的数组： [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit 如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 使用jpg图片体积要比png小使用PHP的Imagick类进行图像的操作 具体操作(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片123// 初始化一个画板 $img =new Imagick(); $img-&gt;newImage(750,1046,'white','jpg') ; (2).在底图上添加需求图片前提是我们已经知道了需要合并的图片链接地址12345678910111213141516171819202122232425262728293031323334353637383940414243$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'第一步：实例化图片$imgtwo = new Imagick($item_img);第二步：设置添加图片的大小$imgtwo-&gt;resizeImage(750,764,Imagick::FILTER_LANCZOS,1);关于resizeImage参数说明 bool Imagick::resizeImage ( int $columns , int $rows , int $filter , float $blur [, bool $bestfit = false ] )参数： ● columns 图片的宽度 ● rows 图片高度 ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定 ● blur blur=1 为虚化， blur =-1 为锐化第三步：与底图合并$img-&gt;compositeImage($imgtwo,$imgtwo-&gt;getImageCompose(),0,0);使用compositeImage(); bool Imagick::compositeImage ( Imagick $composite_object , int $composite , int $x , int $y [, int $channel = Imagick::CHANNEL_ALL ] )参数： ● composite_object ：用于合并的图片的Imagick对象 ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表 ● x：相对图像顶点左上位置（0,0）的横坐标 ● y：相对图像顶点左上位置（0,0）的纵坐标 ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。到这里就可以得到一个合并的图片了1、加一个header信息，可以直接在网页上查看图片 header("Content-Type: img/png"); echo $img;2、可以把图片在指定目录中生成，在指定目录下生成为img.png $file="./img.png"; $img-&gt;writeImage($file);我这里是这样处理： header ( 'Content-type: ' . strtolower ($img-&gt;getImageFormat ()) ); $type = strtolower($img-&gt;getImageFormat()); $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径，随机生成图片名称 (3).图片上拼接文字写入文字以添加店铺文字为例，逐步完成文字的写入。1234567891011$shop_title='测试店铺'；// 添加店铺文字$drawQr = new ImagickDraw(); // 实例化ImagickDraw$drawQr -&gt; setFillColor(new ImagickPixel('#999999')); // 颜色$drawQr -&gt; setFontSize('24'); // 大小$drawQr -&gt; setFont('../../conf/Microsoftyahei.ttf'); // 字体$drawQr -&gt; setTextAlignment(Imagick::ALIGN_LEFT); // 字体方向// ps： Imagick::ALIGN_RIGHT 朝右边 Imagick::ALIGN_LEFT 左边 Imagick::ALIGN_CENTER 中间$drawQr -&gt; setTextEncoding("utf-8"); // 字体编码$drawQr -&gt; annotation(114,990,$shop_title); // 画出文字$img -&gt; drawImage($drawQr); // 画在地板上 详细解读： 1、实例化ImagickDraw类： $drawQr = new ImagickDraw(); 2、设置字体颜色$drawQr -&gt; setFillColor(new ImagickPixel(&#39;#999999&#39;)); 3、设置字体大小$drawQr -&gt; setFontSize(&#39;24&#39;); 4、设置字体格式$drawQr -&gt; setFont(&#39;../../conf/Microsoftyahei.ttf&#39;); 5、设置字体方向$draw-&gt;setTextAlignment(Imagick::ALIGN_RIGHT); ps： Imagick::ALIGN_RIGHT 朝右边 Imagick::ALIGN_LEFT 左边 Imagick::ALIGN_CENTER 中间 6、设置字体编码$drawQr -&gt; setTextEncoding(&quot;utf-8&quot;); 7、画出文字$drawQr -&gt; annotation(114,990,$shop_title); 8、在底图上写入字体$img -&gt; drawImage($drawQr); 写入文字这个地方的一些坑： 没有设置字体格式时，中文字会解析错误（英文没有问题） （汉字解析失败） (设置字体格式正常显示) (4).图片base64导出最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。123456789$dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径$Return = array();// *图片转换为 base64格式编码*$base64_image = '';$image_info = getimagesize($dest_img);$image_data = fread(fopen($dest_img, 'r'), filesize($dest_img));$base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));$Return['data']=$base64_image;return $Return; $base64_image就是base64格式的图片。 需要注意的是前端得到的额base64数据里包含有&#39;\r\n&#39;回车字符，需要特殊处理才可以正确显示图片。 （最后得到的合并图片） (调整拼接图片大小得到不同的图片)]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(七)]]></title>
    <url>%2Fblog%2F2018%2F08%2F08%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。 这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考flex 阮一峰 Num1简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。 list.wxml 12345678910111213&lt;!--pages/list/list.wxml--&gt;&lt;view class="box"&gt; &lt;text class="list_header"&gt;每日一看&lt;/text&gt; &lt;view class="list" wx:for="&#123;&#123;list&#125;&#125;"&gt; &lt;view class='list_img'&gt; &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='list_main'&gt; &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; list.wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* pages/list/list.wxss *//*整个容器*/.box&#123;display: flex;flex-direction: column;/*竖直排列*/&#125;/*title文字*/.list_header&#123;font-size: 32rpx;font-weight: bold;color: #444;padding:20rpx;border-bottom: 2rpx solid #ccc;&#125;/*列表项容器*/.list&#123;display:flex;flex-direction: row;/*横向排列*/align-content: center;border-bottom:1rpx solid #ccc;&#125;/*图片容器*/.list_img&#123;display: flex;align-content: center;padding:20rpx 10rpx;&#125;/*图片*/.avatar&#123;width:130rpx;height:130rpx;border-radius: 4rpx;border: 1rpx solid #F2F2F2;&#125;/*文字容器，包含标题和内容*/.list_main&#123;display: flex;flex-direction: column;/*文字竖直排列*/align-content: center;padding:40rpx 20rpx;overflow: hidden;&#125;.list_title&#123;font-size: 28rpx;color: #717171;font-weight: bold;padding-bottom: 10rpx;&#125;.list_content&#123;font-size: 24rpx;color: #999;&#125; list.js里的数据先写成假数据。123456789101112131415161718192021222324// pages/list/list.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; list:[&#123; img: 'http://localhost:9999/image/a1.jpg', title: '美丽的大海啊！', content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！' &#125;, &#123; img: 'http://localhost:9999/image/a2.jpg', title: '回不去的那叫从前', content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。' &#125;, &#123; img: 'http://localhost:9999/image/a3.jpg', title: '森林生存恐怖游戏', content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。' &#125;, ] &#125;, （也可以使用本地node服务）12345678910111213141516171819202122232425262728var express = require('express');var fs = require('fs');var app = express();//处理静态资源app.use(express.static('./'));app.get('/list', function (req, res) &#123; res.send(&#123; code: 200, data: [&#123; img: 'http://localhost:9999/image/a1.jpg', title: '美丽的大海啊！', content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！' &#125;, &#123; img: 'http://localhost:9999/image/a2.jpg', title: '回不去的那叫从前', content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。' &#125;, &#123; img: 'http://localhost:9999/image/a3.jpg', title: '森林生存恐怖游戏', content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。' &#125;, ] &#125;);&#125;);app.listen(9999); //监听端口 Num2接下来是img在头部，下方是文字内容。 list.wxml 1234567891011121314&lt;!--pages/listview/listview.wxml--&gt;&lt;view class="box"&gt; &lt;text class="list_header"&gt;每日一看&lt;/text&gt; &lt;view class="list" wx:for="&#123;&#123;list&#125;&#125;"&gt; &lt;view class='list_img'&gt; &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='list_main'&gt; &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt; &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; list.wxss1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* pages/listview/listview.wxss *//*整个容器*/.box&#123;display: flex;background: #ccc;flex-direction: column;/*竖直排列*/align-content: center;&#125;/*列表项容器*/.list&#123;background: #FFF;display:flex;flex-direction: column;/*竖直排列*/align-content: center;width:90%;margin:20rpx auto;/*居中对齐*/&#125;/*图片容器*/.list_img&#123;display: flex;align-content: center;width:100%;padding:20rpx 0rpx;&#125;/*图片*/.avatar&#123;width:100%;height:400rpx;border-radius: 4rpx;border: 1rpx solid #F2F2F2;&#125;/*文字容器，包含标题和内容*/.list_main&#123;display: flex;flex-direction: column;/*文字竖直排列*/align-content: center;padding:20rpx;overflow: hidden;&#125;.list_title&#123;font-size: 28rpx;color: #717171;font-weight: bold;padding-bottom: 10rpx;&#125;.list_address&#123;font-size: 24rpx;color: #717171;font-weight: bold;padding-bottom: 10rpx;&#125;.list_content&#123;font-size: 24rpx;color: #999;&#125; list.js里的数据先写成假数据。123456789101112131415161718192021222324// pages/list/list.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; list:[&#123; img: 'http://localhost:9999/image/a1.jpg', title: '美丽的大海啊！', content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！' &#125;, &#123; img: 'http://localhost:9999/image/a2.jpg', title: '回不去的那叫从前', content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。' &#125;, &#123; img: 'http://localhost:9999/image/a3.jpg', title: '森林生存恐怖游戏', content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。' &#125;, ] &#125;, （也可以使用本地node服务）12345678910111213141516171819202122232425262728293031var express = require('express');var fs = require('fs');var app = express();//处理静态资源app.use(express.static('./'));app.get('/list', function (req, res) &#123; res.send(&#123; code: 200, data: [&#123; img: 'http://localhost:9999/image/a1.jpg', title: '美丽的大海啊！', address: '1美丽的大海啊！', content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！' &#125;, &#123; img: 'http://localhost:9999/image/a2.jpg', title: '回不去的那叫从前', address: '1回不去的那叫从前', content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。' &#125;, &#123; img: 'http://localhost:9999/image/a3.jpg', title: '森林生存恐怖游戏', address: '1森林生存恐怖游戏', content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。' &#125;, ] &#125;);&#125;);app.listen(9999); //监听端口 Num3上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。 主要点：123456789list.json配置:"enablePullDownRefresh": true需要捕获这两个事件：onReachBottom（滚动到底部事件）onPullDownRefresh（下拉刷新事件） 本地服务： 1234567891011121314151617181920212223var express = require('express');var fs = require('fs');var app = express();//处理静态资源app.use(express.static('./'));app.get('/list/:num',function(req,res)&#123;var num = req.params.num;//页码var arr = [];(function()&#123;for(var i=(num*5-5);i&lt;(num*5);i++)&#123;var obj = &#123;id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'&#125;;arr.push(obj);&#125;&#125;)();res.send(&#123;code: 200,page:num,data: arr&#125;);&#125;);app.listen(9999);//监听端口 12345678910111213141516171819202122&lt;!--pages/listview/listview.wxml--&gt;&lt;loading hidden="&#123;&#123;isLoading&#125;&#125;"&gt;加载中...&lt;/loading&gt;&lt;view class="box"&gt; &lt;view wx:if="&#123;&#123;isRefesh&#125;&#125;"&gt; &lt;icon type='waiting' size='45'&gt;&lt;/icon&gt; &lt;text&gt;刷新中...&lt;/text&gt; &lt;/view&gt; &lt;view class="list" wx:for="&#123;&#123;list&#125;&#125;" id="&#123;&#123;page&#125;&#125;"&gt; &lt;view class='list_img'&gt; &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='list_main'&gt; &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt; &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123&lt;!-- listview.json --&gt;&#123;"enablePullDownRefresh": true&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// pages/listview/listview.jsPage(&#123; data: &#123; list: [],//列表项数据 page: 1,//页码 isRefesh: false,//是否刷新 isLoading: true//正在加载 &#125;, //下拉刷新 onPullDownRefresh: function () &#123; var that = this; that.setData(&#123; isRefesh: true &#125;);//刷新条出现 wx.request(&#123; url: 'http://localhost:9999/list/1', method: 'GET', success: function (res) &#123; var listdata = res.data.data; setTimeout(function () &#123; wx.stopPullDownRefresh;//停止下拉刷新效果 that.setData(&#123; page: 1 &#125;);//重置页码 that.setData(&#123; list: listdata, isRefesh: false &#125;);//重新设置列表项和刷新条消失 &#125;, 1000); &#125; &#125;); &#125;, //滑到底部加载 onReachBottom: function () &#123; var that = this; var page = that.data.page + 1; var oldData = this.data.list;//老数据 that.setData(&#123; isLoading: false &#125;);//loading出现 wx.request(&#123; url: 'http://localhost:9999/list/' + page, method: 'GET', success: function (res) &#123; var allData = []; var listdata = res.data.data;//新数据 allData = oldData.concat(listdata);//老数据和新数据合并 that.setData(&#123; list: allData, page: page &#125;);//重新设置列表项和页码 setTimeout(function () &#123; that.setData(&#123; isLoading: true &#125;);//loading消失 &#125;, 1000); &#125; &#125;) &#125;, //页码初始化 onLoad: function (options) &#123; var that = this; that.setData(&#123; isLoading: false &#125;);//loading出现 wx.request(&#123; url: 'http://localhost:9999/list/1', method: 'GET', success: function (res) &#123; var listdata = res.data.data; that.setData(&#123; list: listdata &#125;); setTimeout(function () &#123; that.setData(&#123; isLoading: true &#125;);//loading消失 &#125;, 1000); &#125; &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小笔记本]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%AC%94%E8%AE%B0%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。 Node环境起一个服务准备工作需要安装NodeJS环境 1、安装Expressnpm install express -gnpm install express-generator -g 2、初始化项目新建项目express 项目名称 1234567891011121314151617181920212223242526272829303132➜ Weichat express serverDmo warning: the default view engine will not be jade in future releases warning: use `--view=jade' or `--help' for additional options create : serverDmo/ create : serverDmo/public/ create : serverDmo/public/javascripts/ create : serverDmo/public/images/ create : serverDmo/public/stylesheets/ create : serverDmo/public/stylesheets/style.css create : serverDmo/routes/ create : serverDmo/routes/index.js create : serverDmo/routes/users.js create : serverDmo/views/ create : serverDmo/views/error.jade create : serverDmo/views/index.jade create : serverDmo/views/layout.jade create : serverDmo/app.js create : serverDmo/package.json create : serverDmo/bin/ create : serverDmo/bin/www change directory: $ cd serverDmo install dependencies: $ npm install run the app: $ DEBUG=serverdmo:* npm start 目录介绍：/bin:用来启动应用（服务器）/public: 存放静态资源目录/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。/views: 模板文件所在目录 文件格式为.jade目录app.js程序main文件 这个是服务器启动的入口 首先启动服务器npm start //启动服务器 在浏览器中访问 http://localhost:3000/ 基本使用打开app.js 这里介绍下主要代码123456789101112131415161718192021222324252627282930313233343536373839 var express = require('express'); var path = require('path'); var favicon = require('serve-favicon'); var logger = require('morgan'); var cookieParser = require('cookie-parser'); var bodyParser = require('body-parser'); var app = express();///=======路由信息 （接口地址）开始 存放在./routes目录下===========// var routes = require('./routes/index');//home page接口 var users = require('./routes/users'); //用户接口 app.use('/', routes); //在app中注册routes该接口 app.use('/users', users);//在app中注册users接口///=======路由信息 （接口地址 介绍===========/////=======模板 开始===========//// view engine setup app.set('views', path.join(__dirname, 'views')); app.set('view engine', 'jade');///=======模板 结束===========//当我们在浏览器中 访问 http://localhost:3000/ 调用的就是index中的接口我们打开index.js就可以看到该接口的定义：var express = require('express');var router = express.Router();//定义一个get请求 path为根目录/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);module.exports = router; 定义一个路由的基本格式为：app.METHOD(PATH, HANDLER)其中：app 是 express 的实例。METHOD是 HTTP 请求方法。PATH 是服务器上的路径。HANDLER 是在路由匹配时执行的函数。以上的定义代表]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>React</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(六)]]></title>
    <url>%2Fblog%2F2018%2F07%2F31%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。 有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的wx.uploadFile(obj) 12npm install expressnpm install formidable Node-server文件 1234567891011121314151617181920212223242526272829var express = require('express');//处理post需要引入这个中间件,处理的是form-datavar formidable = require('formidable');var fs = require('fs');var app = express();// 处理静态资源app.use(express.static('./'));// 处理post的form-data 类型app.post('/postformdata',function (req,res) &#123; var form = new formidable.IncomingForm(); // 输入流 form.encoding = 'utf-8'; form.uploadDir = 'upload'; //这里设置上传目录 form.parse(req,function(err,fields,files)&#123; // 这里解析请求 if (err) &#123; res.send(err); return; &#125; var avatarName = Date.now() + '.jpg'; // 以时间作为名字 var newPath = form.uploadDir + avatarName; fs.renameSync(files.my_upload.path,newPath); // my_upload是前端设置的name，把图片储存下来并且重新命名 res.send(&#123; code:200, path:'http:localhost:9998/'+newPath &#125;) &#125;)&#125;)app.listen(9998); // 监听端口 Num 1 第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。 在upload文件目录下操作 1234567&lt;!--pages/upload/upload.wxml--&gt;&lt;view class='container'&gt; &lt;button type='primary' bindtap='uploadImg'&gt;上传图片&lt;/button&gt; &lt;view class="imginfo" wx:for="&#123;&#123;imglist&#125;&#125;" wx:for-index="id" wx:for-item="item"&gt; &lt;image src='&#123;&#123;item&#125;&#125;' bindtap='previewImg' data-imgid="&#123;&#123;id&#125;&#125;" class='myimg'&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112/* pages/upload/upload.wxss */.imginfo&#123; display: flex; flex-direction: column; align-items: center;&#125;.myimg&#123; width: 70px; height: 70px; border:1px solid #ccc;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// pages/upload/upload.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; imgList:[] // 图片列表 &#125;, // 上传图片 uploadImg:function()&#123; var that = this; wx.chooseImage(&#123; success: function(res) &#123; var tempFilePaths = res.tempFilePaths; wx.uploadFile(&#123; url: 'http://localhost:9998/postformdata', //nodeJS数据接口 filePath: tempFilePaths[0], name: 'my_upload',//这个前后台名称需要保持一致，别乱写。 formData: &#123; 'user': 'test' &#125;, success:function(res)&#123; var data = JSON.parse(res.data);//返回来的是字符串格式。 var arr = that.data.imgList; arr.push(data.path); that.setData(&#123; imgList: arr &#125;);//只有这种方式才能更新视图 console.log(that.data.imgList); wx.showToast(&#123; title: '文件上传成功', icon: 'success', duration: 2000 &#125;) &#125; &#125;) &#125; &#125;) &#125;, //预览图片 previewImg: function (e) &#123; var index = e.target.dataset.imgid;//获取图片的id var that = this; console.log(index); wx.previewImage(&#123; current: that.data.imgList[index],//当前的图片 urls: that.data.imgList // 需要预览的图片http链接列表 &#125;); &#125;, 以上就是不要的步骤。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发小锦囊]]></title>
    <url>%2Fblog%2F2018%2F07%2F30%2F%E5%BC%80%E5%8F%91%E5%B0%8F%E9%94%A6%E5%9B%8A%2F</url>
    <content type="text"><![CDATA[这里会收录一下遇到的，或者解决问题的方法。不断收集，不断壮大。 开发小锦囊 JavaScript1、js 判断字符串中是否包含某个字符串 String对象的方法 方法一: indexOf() (推荐) 123var str = "123";console.log(str.indexOf("3") != -1 ); // trueindexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。 方法二: search() 123var str = "123";console.log(str.search("3") != -1 ); // truesearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 方法三:match() 123456var str = "123";var reg = RegExp(/3/);if(str.match(reg))&#123; // 包含 &#125;match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 RegExp 对象方法 方法四:test() 1234var str = "123";var reg = RegExp(/3/);console.log(reg.test(str)); // truetest() 方法用于检索字符串中指定的值。返回 true 或 false。 方法五:exec() 123456var str = "123";var reg = RegExp(/3/);if(reg.exec(str))&#123; // 包含 &#125;exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 2、 JS中every()和some()的用法 every()与some()方法都是JS中数组的迭代方法。 every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。 some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。 1234567891011var arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some( function( item, index, array )&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); console.log( arr.every( function( item, index, array )&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); 3、 用Set为数组去重123456var arr = [1,2,2,3,4] // 需要去重的数组var set = new Set(arr) // &#123;1,2,3,4&#125;var newArr = Array.from(set) // 再把set转变成arrayconsole.log(newArr) // [1,2,3,4] 4、 删除数组尾部元素一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。12345678const arr = [11, 22, 33, 44, 55, 66];// truncantingarr.length = 3;console.log(arr); //=&gt; [11, 22, 33]// clearingarr.length = 0;console.log(arr); //=&gt; []console.log(arr[2]); //=&gt; undefined 5、 平铺多维数组使用Spread操作，可以很容易去平铺嵌套多维数组：12const arr = [11, [22, 33], [44, 55], 66];const flatArr = [].concat(...arr); //=&gt; [11, 22, 33, 44, 55, 66] 可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。123456789unction flattenArray(arr) &#123; const flattened = [].concat(...arr); return flattened.some(item =&gt; Array.isArray(item)) ? flattenArray(flattened) : flattened;&#125;const arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];const flatArr = flattenArray(arr); //=&gt; [11, 22, 33, 44, 55, 66, 77, 88, 99] 6、 格式化JSON代码JSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。1234567891011121314151617181920const obj = &#123; foo: &#123; bar: [11, 22, 33, 44], baz: &#123; bing: true, boom: 'Hello' &#125; &#125; &#125;;// The third parameter is the number of spaces used to // beautify the JSON output.JSON.stringify(obj, null, 4); // =&gt;"&#123;// =&gt; "foo": &#123;// =&gt; "bar": [// =&gt; 11,// =&gt; 22,// =&gt; 33,// =&gt; 44// =&gt; ],// =&gt; "baz": &#123;// =&gt; "bing": true,// =&gt; "boom": "Hello"// =&gt; &#125;// =&gt; &#125;// =&gt;&#125;" 7、 await多个async函数在使用async/await的时候，可以使用Promise.all来await多个async函数。1await Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 8、JSON对象和JSON数组添加删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354（1）纯JSON文本可以这样var json=&#123; id:"id1", name:"开心"&#125;; //添加json["gender"]="男"json["age"]=26;alert(json.age); //删除delete json["age"];alert(json.age);alert(json.gender);正常对象的删除：var o = new Object;o.name = "David";alert(o.name); //输出 "David"delete o.name;alert(o.name); //输出 "undefined"（2纯json对象的话就把以上的var json先json1 = JSON.parse(json)就可以了（3)如果用JSON数组文本的话可以这样var mainArray = [ &#123;"tag" :"任务","num":2&#125;, &#123;"tag" :"工作" ,"num":6&#125;]; mainArray .push(&#123; "tag":"开会","num":3&#125;); mainArray.shift();//删除数组头元素mainArray.pop();//删除数组尾元素 ----------------------由object创建json文本格式的方法----------------------&lt;p id="a"&gt;ssss&lt;/p&gt;&lt;script&gt;var data = new Object();data.name = "airuikun";data.sex = "man";var s = JSON.stringify(data);document.getElementById("a").innerHTML = s;&lt;/script&gt; 9、随机生成验证码123456789var str=Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1);// 结果如下=&gt; 8a51 React篇 1、 关于this.setState更新的问题this.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法: 1.回调函数callback12345this.setState(&#123; val: this.state.val+1&#125;, () =&gt; &#123; console.log(this.state.val)&#125;); 2.componentDidUpdate 123componentDidUpdate()&#123; console.log(this.state.val);&#125; 在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新 3.将this.setState放入setTimeout函数中1234567let self = this;setTimeout(function () &#123; self.setState(&#123; val:self.state.val+1 &#125;); console.log(self.state.val);&#125;) 在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。 PHP篇php 字符串中是否包含指定字符串的多种方法1. strstrstrstr() 函数搜索一个字符串在另一个字符串中的第一次出现。该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。 代码如下:1234567&lt;?php /*如手册上的举例*/ $email = 'user@example.com'; $domain = strstr($email, '@'); echo $domain; // prints @example.com?&gt; 2. stristrstristr() 函数查找字符串在另一个字符串中第一次出现的位置。如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。 它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写. 3. strposstrpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好. 实例112345if(strpos('www.jb51.net','jb51') !== false)&#123; echo '包含jb51'; &#125;else&#123; echo '不包含jb51'; &#125; 实例2123$str= 'abc';$needle= 'a';$pos = strpos($str, $needle); // 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False 4. explode用explode进行判断PHP判断字符串的包含代码如下:123456789function checkstr($str)&#123; $needle ='a';//判断是否包含a这个字符 $tmparray = explode($needle,$str); if(count($tmparray)&gt;1)&#123; return true; &#125; else&#123; return false; &#125;&#125; 5、substr例如我们需要判断最后一个字符是不是制定字符123456&lt;?php/*$str1="&lt;p&gt;这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll&lt;/p&gt;";if(substr($str1,-8)==".dll&lt;/p&gt;")&#123;echo substr($str1,0,-4);&#125; 6、substr_count统计“子字符串”在“原始字符串中出现的次数”substr_count()函数本是一个小字符串在一个大字符串中出现的次数：$number = substr_count(big_string, small_string);正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle； 查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：123456789101112function check_str($str, $substr)&#123; $nums=substr_count($str,$substr); if ($nums&gt;=1) &#123; return true; &#125; else &#123; return false; &#125;&#125; php中数组和字符串的相互转换数组转字符串：1implode('!', $arr);//将一维数组以！分隔组合成一个字符串，参数一可以为"" 字符串转数组：123explode('!', $str);//将字符串以!分割为一个一维数组,参数一不可以为""str_split($str, 3);//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。 php的strpos() 函数判断字符串中是否包含某字符串的方法判断某字符串中是否包含某字符串的方法12345if(strpos('www.idc-gz.com','idc-gz') !== false)&#123; echo '包含';&#125;else&#123; echo '不包含';&#125; PHP中实现中文字串截取无乱码的方法在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。 直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：123451、使用mbstring扩展库的mb_substr截取就不会出现乱码了。2、自己书写截取函数，但效率不如用mbstring扩展库来得高。3、如果仅是为了输出截取的串，可用如下方式实现：substr($str, 0, 30).chr(0)。 substr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。举个例子：123456789&lt;?phpecho mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');?&gt;输出：这样一来我的字&lt;?phpecho mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');?&gt;输出：这样一从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>React</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样在JS里尽量少写for循环]]></title>
    <url>%2Fblog%2F2018%2F07%2F29%2F%E6%80%8E%E6%A0%B7%E5%9C%A8JS%E9%87%8C%E5%B0%BD%E9%87%8F%E5%B0%91%E5%86%99for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[“很多场景，for来的更直接，更明了。” “最喜欢for循环了。想break就break。可能会多数据的还是for循环。” “for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响”,这是很多时候都会考虑的问题。 用好 filter，map，和其它 ES6 新增的高阶遍历函数问题一： 将数组中的空值去除123456const arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, ""];答案：const compact = arr =&gt; arr.filter(Boolean); 问题二： 将数组中的 VIP 用户余额加 1012345678910111213141516const users = [ &#123; username: "Kelly", isVIP: true, balance: 20 &#125;, &#123; username: "Tom", isVIP: false, balance: 19 &#125;, &#123; username: "Stephanie", isVIP: true, balance: 30 &#125;];答案：users.map( user =&gt; (user.isVIP ? &#123; ...user, balance: user.balance + 10 &#125; : user));补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。 问题三： 判断字符串中是否含有元音字母123456789const randomStr = "hdjrwqpi";答案：const isVowel = char =&gt; ["a", "e", "o", "i", "u"].includes(char);const containsVowel = str =&gt; [...str].some(isVowel);containsVowel(randomStr); 问题四： 判断用户是否全部是成年人123456789const users = [ &#123; name: "Jim", age: 23 &#125;, &#123; name: "Lily", age: 17 &#125;, &#123; name: "Will", age: 25 &#125;];答案：users.every(user =&gt; user.age &gt;= 18); 问题五： 找出上面用户中的未成年人1234567891011const users = [ &#123; name: "Jim", age: 23 &#125;, &#123; name: "Lily", age: 17 &#125;, &#123; name: "Will", age: 25 &#125;];答案：const findTeen = users =&gt; users.find(user =&gt; user.age &lt; 18);findTeen(users); 问题六： 将数组中重复项清除12345678const dupArr = [1, 2, 3, 3, 3, 3, 6, 7];答案：const uniq = arr =&gt; [...new Set(arr)];uniq(dupArr); 问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义12345答案：const genNumArr = (length, limit) =&gt; Array.from(&#123; length &#125;, _ =&gt; Math.floor(Math.random() * limit));genNumArr(10, 100); 理解和熟练使用 reduce问题一： 不借助原生高阶函数，定义 reduce123456答案：const reduce = (f, acc, arr) =&gt; &#123; if (arr.length === 0) return acc; const [head, ...tail] = arr; return reduce(f, f(head, acc), tail);&#125;; 问题二： 将多层数组转换成一层数组12345678910const nestedArr = [1, 2, [3, 4, [5, 6]]];答案：const flatten = arr =&gt; arr.reduce( (flat, next) =&gt; flat.concat(Array.isArray(next) ? flatten(next) : next), [] ); 问题三：将下面数组转成对象，key/value 对应里层数组的两个值123456789const objLikeArr = [["name", "Jim"], ["age", 18], ["single", true]];答案：const fromPairs = pairs =&gt; pairs.reduce((res, pair) =&gt; ((res[pair[0]] = pair[1]), res), &#123;&#125;);fromPairs(objLikeArr); 问题四： 取出对象中的深层属性123456789const deepAttr = &#123; a: &#123; b: &#123; c: 15 &#125; &#125; &#125;;答案：const pluckDeep = path =&gt; obj =&gt; path.split(".").reduce((val, attr) =&gt; val[attr], obj);pluckDeep("a.b.c")(deepAttr); 问题五：将用户中的男性和女性分别放到不同的数组里：1234567891011121314151617181920const users = [ &#123; name: "Adam", age: 30, sex: "male" &#125;, &#123; name: "Helen", age: 27, sex: "female" &#125;, &#123; name: "Amy", age: 25, sex: "female" &#125;, &#123; name: "Anthony", age: 23, sex: "male" &#125;,];答案：const partition = (arr, isValid) =&gt; arr.reduce( ([pass, fail], elem) =&gt; isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []], ); const isMale = person =&gt; person.sex === "male";const [maleUser, femaleUser] = partition(users, isMale); 问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold） 12345678910111213const unfold = (f, seed) =&gt; &#123; const go = (f, seed, acc) =&gt; &#123; const res = f(seed); return res ? go(f, res[1], acc.concat(res[0])) : acc; &#125;; return go(f, seed, []);&#125;;根据这个 unfold 函数，定义一个 Python 里面的 range 函数。答案：const range = (min, max, step = 1) =&gt; unfold(x =&gt; x &lt; max &amp;&amp; [x, x + step], min); 用递归代替循环（可以break！）问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。12345678910111213141516const num1 = [3, 4, 5, 6, 7];const num2 = [43, 23, 5, 67, 87, 3, 6];答案：const zipWith = f =&gt; xs =&gt; ys =&gt; &#123; if (xs.length === 0 || ys.length === 0) return []; const [xHead, ...xTail] = xs; const [yHead, ...yTail] = ys; return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];&#125;;const add = x =&gt; y =&gt; x + y;zipWith(add)(num1)(num2); 问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。123456789101112131415161718192021222324252627const houses = [ "Eddard Stark", "Catelyn Stark", "Rickard Stark", "Brandon Stark", "Rob Stark", "Sansa Stark", "Arya Stark", "Bran Stark", "Rickon Stark", "Lyanna Stark", "Tywin Lannister", "Cersei Lannister", "Jaime Lannister", "Tyrion Lannister", "Joffrey Baratheon"];答案：const takeWhile = f =&gt; ([head, ...tail]) =&gt; f(head) ? [head, ...takeWhile(f)(tail)] : [];const isStark = name =&gt; name.toLowerCase().includes("stark");takeWhile(isStark)(houses); 问题二： 找出数组中的奇数，然后取出前4个：12345678910111213141516const numList = [1, 3, 11, 4, 2, 5, 6, 7];答案：const takeFirst = (limit, f, arr) =&gt; &#123; if (limit === 0 || arr.length === 0) return []; const [head, ...tail] = arr; return f(head) ? [head, ...takeFirst(limit - 1, f, tail)] : takeFirst(limit, f, tail);&#125;;const isOdd = n =&gt; n % 2 === 1;takeFirst(4, isOdd, numList); 使用高阶函数遍历数组时可能遇到的陷阱问题一： 从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3123456789101112131415161718192021222324252627282930// 用我们刚刚定义的辅助函数来生成符合要求的数组const bigArr = genNumArr(1e6, 100);答案：const isEven = num =&gt; num % 2 === 0;const triple = num =&gt; num * 3;bigArr.filter(isEven).map(triple);// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：const results = [];for (let i = 0; i &lt; bigArr.length; i++) &#123; if (isEven(bigArr[i])) &#123; results.push(triple(bigArr[i])); &#125;&#125;// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！# Transduce先用 reduce 来定义 filter 和 map，至于为什么这样做等下再解释。```hconst filter = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (f(val) &amp;&amp; acc.push(val), acc), []);const map = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (acc.push(f(val)), acc), []); 重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：123456const filter = f =&gt; reducer =&gt; (acc, value) =&gt; &#123; if (f(value)) return reducer(acc, value); return acc;&#125;;const map = f =&gt; reducer =&gt; (acc, value) =&gt; reducer(acc, f(value)); 现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。123const pushReducer = (acc, value) =&gt; (acc.push(value), acc);bigNum.reduce(map(triple)(filter(isEven)(pushReducer)), []); 但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：1const pipe = (...fns) =&gt; (...args) =&gt; fns.reduce((fx, fy) =&gt; fy(fx), ...args); 然后我们就可以优雅地组合函数了：1234567bigNum.reduce( pipe( filter(isEven), map(triple) )(pushReducer), []); 经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 transducers-js。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。 for 循环和 for … of 循环的区别for … of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for … of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for … of 来遍历数组是会被禁止的。那么，for … of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个： 12345678910111213141516171819202122232425262728293031323334353637383940问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。```hconst starks = [ &quot;Eddard Stark&quot;, &quot;Catelyn Stark&quot;, &quot;Rickard Stark&quot;, &quot;Brandon Stark&quot;, &quot;Rob Stark&quot;, &quot;Sansa Stark&quot;, &quot;Arya Stark&quot;, &quot;Bran Stark&quot;, &quot;Rickon Stark&quot;, &quot;Lyanna Stark&quot;];答案：function* repeatedArr(arr) &#123; let i = 0; while (true) &#123; yield arr[i++ % arr.length]; &#125;&#125;const infiniteNameList = repeatedArr(starks);const wait = ms =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, ms); &#125;);(async () =&gt; &#123; for (const name of infiniteNameList) &#123; await wait(1000); console.log(name); &#125;&#125;)(); 前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(五)]]></title>
    <url>%2Fblog%2F2018%2F07%2F22%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。 前言数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！ 那么来看个需求： 做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。 准备工作 wx.chooseImage：选择图片 wx.saveFile(OBJ)：将临时图片保存在本地 wx.setStorage(OBJ)：保存图片的路径。 当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。好了，理顺了思路，我们看一下代码： 1234567891011121314151617// &lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" mode="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;button bindtap='keepImg'&gt;保存图片&lt;/button&gt; &lt;button bindtap='deleteImg'&gt;删除图片&lt;/button&gt; &lt;image src='&#123;&#123;imgPath&#125;&#125;'&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//index.js//获取应用实例const app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo'), imgPath:'' &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, keepImg:function()&#123; var that = this; // 浏览文件 wx.chooseImage(&#123; count:1, sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有 success: function(res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 var tempFilePaths = res.tempFilePaths; console.log(tempFilePaths) //将本地照片保存在小程序内 wx.saveFile(&#123; tempFilePath: tempFilePaths[0], success:function(res)&#123; var savedFilePath = res.savedFilePath; // 图片成功之后存储在本地的路径 console.log(savedFilePath) if (!wx.getStorageSync('storageImgPath')) &#123; //数据存储，保存图片的路径 wx.setStorageSync('storageImgPath', savedFilePath) &#125; that.setData(&#123; imgPath: wx.getStorageSync('storageImgPath')&#125;) &#125; &#125;) &#125;, &#125;) &#125;, deleteImg:function()&#123; wx.removeStorageSync('storageImgPath'); //从数据缓存中删除 var that = this; wx.getSavedFileList(&#123; //获取本地的文件列表 success:function(res)&#123; console.log(res.errMsg); var files = res.fileList; if(res.fileList.length&gt;0)&#123; // 删除第一张 wx.removeSavedFile(&#123; filePath:res.fileList[0].filePath, success:function(res)&#123; // 提示语 wx.showToast(&#123; title: '删除成功', icon:'success', duration:2000 &#125;) &#125; &#125;) &#125; &#125; &#125;) &#125;, onLoad: function () &#123; if (app.globalData.userInfo) &#123; this.setData(&#123; userInfo: app.globalData.userInfo, hasUserInfo: true &#125;) &#125; else if (this.data.canIUse)&#123; // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125; else &#123; // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo(&#123; success: res =&gt; &#123; app.globalData.userInfo = res.userInfo this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125; &#125;, getUserInfo: function(e) &#123; console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;&#125;) 效果]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2 + oh my zsh打造最强Mac终端]]></title>
    <url>%2Fblog%2F2018%2F07%2F22%2FiTerm2-oh-my-zsh-agnoster-%E6%89%93%E9%80%A0%E6%9C%80%E5%BC%BAMac%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[iTerm2 + oh my zsh 打造最强Mac终端 #安装iTerm2iTerm2官方下载地址 http://www.iterm2.com/downloads.html #安装 oh-my-zsh 1curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh #配置创建配置文件1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 设置zsh为默认的shellchsh -s /bin/zsh 此时，zsh已经安装成功 接来下，可以去https://github.com/robbyrussell/oh-my-zsh/wiki/themes 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async Functions (异步函数)]]></title>
    <url>%2Fblog%2F2018%2F07%2F15%2FAsync-Functions-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ECMAScript 2017 新特性 Async Functions(异步函数) 。 async(异步) 函数变体以下是已经存在的异步函数变体。请注意无处不在的 async 关键字。 异步函数声明： async function foo() {} 异步函数表达式： const foo = async function () {}; 异步函数定义：let obj = { async foo() {} } 异步箭头函数： const foo = async () =&gt; {}; async(异步) 函数总是返回 Promisesasync(异步) 函数的 Promise 完成状态： 1234567async function asyncFunc() &#123; return 123;&#125; asyncFunc().then(x =&gt; console.log(x)); // 123 async(异步) 函数的 Promise 拒绝状态： 1234567async function asyncFunc() &#123; throw new Error('Problem!');&#125; asyncFunc().catch(err =&gt; console.log(err)); // Error: Problem! 通过 await 处理 async(异步) 计算的结果和错误await（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回： 如果 Promise 是完成状态，await 的结果是完成态的值。 如果 Promise 是拒绝状态，await 会抛出拒绝值。 处理单个 async(异步) 返回值：123456789101112async function asyncFunc() &#123; const result = await otherAsyncFunc(); console.log(result);&#125; // 等价于:function asyncFunc() &#123; return otherAsyncFunc() .then(result =&gt; &#123; console.log(result); &#125;);&#125; 按顺序处理多个 async(异步) 返回值： 123456789101112131415161718async function asyncFunc() &#123; const result1 = await otherAsyncFunc1(); console.log(result1); const result2 = await otherAsyncFunc2(); console.log(result2);&#125; // 等价于:function asyncFunc() &#123; return otherAsyncFunc1() .then(result1 =&gt; &#123; console.log(result1); return otherAsyncFunc2(); &#125;) .then(result2 =&gt; &#123; console.log(result2); &#125;);&#125; 并行处理多个 async(异步) 返回值： 123456789101112131415161718async function asyncFunc() &#123; const [result1, result2] = await Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]); console.log(result1, result2);&#125; // 等价于:function asyncFunc() &#123; return Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]) .then([result1, result2] =&gt; &#123; console.log(result1, result2); &#125;);&#125; 错误处理： 123456789101112131415async function asyncFunc() &#123; try &#123; await otherAsyncFunc(); &#125; catch (err) &#123; console.error(err); &#125;&#125; // 等价于:function asyncFunc() &#123; return otherAsyncFunc() .catch(err =&gt; &#123; console.error(err); &#125;);&#125; 理解 async(异步) 函数解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。 对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下： 123456789101112function fetchJson(url) &#123; return fetch(url) .then(request =&gt; request.text()) .then(text =&gt; &#123; return JSON.parse(text); &#125;) .catch(error =&gt; &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;);&#125;fetchJson('http://example.com/some_file.json').then(obj =&gt; console.log(obj)); 通过 generator 来编写异步代码co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同： 12345678910const fetchJson = co.wrap(function* (url) &#123; try &#123; let request = yield fetch(url); let text = yield request.text(); return JSON.parse(text); &#125; catch (error) &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;&#125;); 每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于 then() 所做的工作）。 通过 async(异步) 函数来编写异步代码async(异步) 函数用的特定语法基本上和 co 类似：12345678910async function fetchJson(url) &#123; try &#123; let request = await fetch(url); let text = await request.text(); return JSON.parse(text); &#125; catch (error) &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;&#125; 在内部，异步函数写法更类似于 generators 。 以同步开始，异步处理的 async(异步) 函数以下是 async(异步)函数是如何工作的： 1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。 2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。 3、返回 Promise 对象 p。 当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和 catch() 的回调总是在当前代码完成后执行。 以下是代码示例： 12345678910111213async function asyncFunc() &#123; console.log('asyncFunc()'); // (A) return 'abc';&#125;asyncFunc().then(x =&gt; console.log(`Resolved: $&#123;x&#125;`)); // (B)console.log('main'); // (C) // Output:// asyncFunc()// main// Resolved: abc 您可以认为是以下的执行顺序： 1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。 2、行C：执行继续。 3、行B：Promise 完成状态通知是异步发生的。 返回不被包裹的 Promise 对象Promise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise p 的。这意味着： 1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。 2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：12345async function asyncFunc() &#123; return Promise.resolve(123);&#125;asyncFunc().then(x =&gt; console.log(x)) // 123 有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）： 123456JavaScript 代码:async function asyncFunc() &#123; return Promise.reject(new Error('Problem!'));&#125;asyncFunc().catch(err =&gt; console.error(err)); // Error: Problem! 这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：1234JavaScript 代码:async function asyncFunc() &#123; return anotherAsyncFunc();&#125; 上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹 anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：1234JavaScript 代码:async function asyncFunc() &#123; return await anotherAsyncFunc();&#125; 使用 await 小贴士不要忘记使用 await在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：12345JavaScript 代码:async function asyncFunc() &#123; const value = otherAsyncFunc(); // missing `await`! ···&#125; 在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。 await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：12345JavaScript 代码:async function foo() &#123; await step1(); // (A) ···&#125; 行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。 不需要使用 await 的情况有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：1234567JavaScript 代码:async function asyncFunc() &#123; const writer = openFile('someFile.txt'); writer.write('hello'); // don’t wait writer.write('world'); // don’t wait await writer.close(); // wait for file to close&#125; 在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。 asyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。 由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return 替换 await writer.close() ：1234567JavaScript 代码:async function asyncFunc() &#123; const writer = openFile('someFile.txt'); writer.write('hello'); writer.write('world'); return writer.close();&#125; 这两个版本各有利弊，await 版本可能稍微更容易理解。 await 是顺序执行的，Promise.all() 是并行的下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。12345JavaScript 代码:async function foo() &#123; const result1 = await asyncFunc1(); const result2 = await asyncFunc2();&#125; 这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ： 1234567JavaScript 代码:async function foo() &#123; const [result1, result2] = await Promise.all([ asyncFunc1(), asyncFunc2(), ]);&#125; 我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。 异步函数和回调async(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。 Array.prototype.map()我们从数组方法 map() 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。12345678JavaScript 代码:async function downloadContent(urls) &#123; return urls.map(url =&gt; &#123; // 错误的语法! const content = await httpGet(url); return content; &#125;);&#125; 这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？1234567JavaScript 代码:async function downloadContent(urls) &#123; return urls.map(async (url) =&gt; &#123; // 注意这一行中的 async ; const content = await httpGet(url); return content; &#125;);&#125; 这段代码有两个问题： 现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待 downloadContent() 执行结束。我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：12345678JavaScript 代码:async function downloadContent(urls) &#123; const promiseArray = urls.map(async (url) =&gt; &#123; const content = await httpGet(url); return content; &#125;); return await Promise.all(promiseArray);&#125; map() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。123456JavaScript 代码:async function downloadContent(urls) &#123; const promiseArray = urls.map( url =&gt; httpGet(url)); return await Promise.all(promiseArray);&#125; 我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开 Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：123456JavaScript 代码:async function downloadContent(urls) &#123; const promiseArray = urls.map( url =&gt; httpGet(url)); return Promise.all(promiseArray);&#125; Array.prototype.forEach()我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：12345678JavaScript 代码:async function logContent(urls) &#123; urls.forEach(url =&gt; &#123; // Wrong syntax const content = await httpGet(url); console.log(content); &#125;);&#125; 同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 await 。 我们换作异步箭头函数：12345678JavaScript 代码:async function logContent(urls) &#123; urls.forEach(async url =&gt; &#123; const content = await httpGet(url); console.log(content); &#125;); // Not finished here&#125; 这段代码起作用了，但是会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。 如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。1234567JavaScript 代码:async function logContent(urls) &#123; for (const url of urls) &#123; const content = await httpGet(url); console.log(content); &#125;&#125; 现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：12345678JavaScript 代码:async function logContent(urls) &#123; await Promise.all(urls.map( async url =&gt; &#123; const content = await httpGet(url); console.log(content); &#125;));&#125; map() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。 使用异步函数小贴士了解你的 Promisesasync(异步) 函数的基础就是 Promises 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。 举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：1234567891011121314151617181920212223JavaScript 代码:function httpGet(url, responseType="") &#123; return new Promise( function (resolve, reject) &#123; const request = new XMLHttpRequest(); request.onload = function () &#123; if (this.status === 200) &#123; // Success resolve(this.response); &#125; else &#123; // Something went wrong (404 etc.) reject(new Error(this.statusText)); &#125; &#125;; request.onerror = function () &#123; reject(new Error( 'XMLHttpRequest Error: '+this.statusText)); &#125;; request.open('GET', url); xhr.responseType = responseType; request.send(); &#125;);&#125; XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者 throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。 因此，异步函数的通用编码风格是： 直接使用 Promise 对象来构建异步原语。 用异步函数来使用这些原语。扩展阅读：“Exploring ES6” 中的 “异步编程中的 Promises 对象” 章节 立即调用异步函数表达式有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main()  并立即调用它：1234JavaScript 代码:async function main() &#123; console.log(await asyncFunction());&#125; main();或者您可以使用立即调用异步函数表达式：1234JavaScript 代码:(async function () &#123; console.log(await asyncFunction());&#125;)(); 另一个选择是立即调用异步箭头函数：1234JavaScript 代码:(async () =&gt; &#123; console.log(await asyncFunction());&#125;)(); 用异步函数进行单元测试以下代码使用 测试框架 mocha 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试： 12345678910111213import assert from 'assert'; // Bug: the following test always succeedstest('Testing async code', function () &#123; asyncFunc1() // (A) .then(result1 =&gt; &#123; assert.strictEqual(result1, 'a'); // (B) return asyncFunc2(); &#125;) .then(result2 =&gt; &#123; assert.strictEqual(result2, 'b'); // (C) &#125;);&#125;); 然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。 你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。12JavaScript 代码:return asyncFunc1() // (A) 异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：12345678JavaScript 代码:import assert from 'assert';test('Testing async code', async function () &#123; const result1 = await asyncFunc1(); assert.strictEqual(result1, 'a'); const result2 = await asyncFunc2(); assert.strictEqual(result2, 'b');&#125;); 在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。 不要担心没有处理的拒绝拒态当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告：12345JavaScript 代码:async function foo() &#123; throw new Error('Problem!');&#125;foo(); 阅读延伸 异步函数 （提出者Brian Terlson） 通过generators来简化异步计算（“Exporing ES6”中的部分章节）原文地址：http://exploringjs.com/es2016-es2017/ch_async-functions.html]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(四)]]></title>
    <url>%2Fblog%2F2018%2F06%2F28%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序websocket之旅。websocket是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。 一个小栗子以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用ajax轮询（setinterval函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。对于websocket技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。websocket很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。 快速生成标准文件 以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。 123456789101112131415&lt;!-- app.json文件 --&gt;&#123; "pages":[ "pages/index/index", "pages/logs/logs", "pages/charts/charts" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;&#125; 前期准备1、小栗子试图插件图表类的插件一般就是echarts和highcharts,而在小程序里，我们可以使用wxcharts,wxcharts的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，下载链接 2、数据接口支持这里的数据支持使用的是Nodejs，还要了解一下websocket,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。 Nodejs有个插件封装了socket，叫nodejs-websocket。使用npm安装一下:npm install nodejs-websocket 123➜ ~ npm i nodejs-websocket -g/usr/local/lib└── nodejs-websocket@1.7.1 server.js 12345678910111213141516171819var ws = require('nodejs-websocket');// 创建servervar server = ws.createServer(function(conn)&#123; conn.on("text",function(str)&#123; // 监听文本输入 if (str == "stock") &#123; setInterval(function()&#123; var arr=[]; for (let i = 0; i &lt; 6; i++) &#123; var count = (Math.ceil((Math.random()*100))/100).toFixed(2); arr.push(count) &#125; var obj = &#123;data:arr&#125; conn.send(JSON.stringify(obj)) &#125;,2000); &#125; &#125;)&#125;).listen(8000) websocket建立专用通道后，服务端只要监听到客户端发来的文本内容是”stock”,就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。 注意 利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。ws就相当于http，wss就相当于https，所以正确的写法应该是：ws://localhost:8000 微信客户端 使用websocket很容易，主要就是你这几个步骤： 建立连接 发送数据 接收数据 结束 charts.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// pages/charts/charts.jsvar wxCharts = require('wxcharts.js');Page(&#123; data: &#123;&#125;, onLoad: function (options) &#123; // var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8]; // var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94]; //建立连接 wx.connectSocket(&#123; url: 'ws://localhost:8000',//这里连接的就是服务端的socket &#125;); //连接成功监听 wx.onSocketOpen(function (res) &#123; //发送信息 wx.sendSocketMessage(&#123; data: "stock" &#125;); console.log('WebSocket连接已打开！') &#125;); //连接失败监听 wx.onSocketError(function (res) &#123; console.log('WebSocket连接打开失败，请检查！') &#125;); //接收数据 wx.onSocketMessage(function (res) &#123; //收到的信息 console.log('收到服务器内容：' + res.data); var obj = JSON.parse(res.data); console.log(obj); //绘制图表，利用canvas绘图技术。 new wxCharts(&#123; canvasId: 'lineCanvas',//指定canvas的id type: 'line',//类型是线形图 categories: ['2012', '2013', '2014', '2015', '2016', '2017'], series: [&#123; name: '成交量1', data: obj.data,//websocket接收到的数据 format: function (val) &#123; if (typeof val == "string") &#123; val = parseFloat(val); &#125; return val.toFixed(2) + '万'; &#125; &#125;, &#123; name: '成交量2', data: [0.30, 0.37, 0.65, 0.78, 0.69, 0.94], format: function (val) &#123; return val.toFixed(2) + '万'; &#125; &#125;], yAxis: &#123; title: '成交金额 (万元)', format: function (val) &#123; return val.toFixed(2); &#125;, min: 0 &#125;, width: 320, height: 200 &#125;); &#125;); &#125;&#125;) charts.wxml: 123&lt;!--pages/charts/charts.wxml--&gt;&lt;canvas style="width: 100%; height: 200px;border:1px solid #ccc;" canvas-id="lineCanvas"&gt;&lt;/canvas&gt; 看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。下面通过控制台，看下websocket请求的特征：]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6里 三种异步解决方案]]></title>
    <url>%2Fblog%2F2018%2F06%2F27%2FES6%E9%87%8C-%E4%B8%89%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[介绍一下ES6里的三种异步方案。 知识尝鲜 1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用next() 方法；2、next() 方法，可以给他传入一个参数。调用next()方法，会返回一个对象{value: res,done: false} ,这里的done 表示迭代器。 方法一： Generator + Promise1234567891011121314151617181920212223242526272829303132333435363738394041const fund = require('fund')// Promise 版的readFileconst readFile = function (fileName) &#123; return new Promise(function(resolve, reject) &#123; fund.readFile(fileName, function(err, data)&#123; if (err) return reject(error); resolve(data); &#125;) &#125;)&#125;const newgen = function * () &#123; let demo1 = yield readFile('a.txt'); let demo2 = yield readFile('b.txt'); console.log('demo1---&gt;', demo1.toString()); console.log('demo2---&gt;', demo2.toString());&#125;// 基于 Generator 和 Promise 的自动执行器function run(gen) &#123; let g = gen(); function next(data) &#123; let result = g.next(data); if (result.done) return result.value; result.value.then(function(data) &#123; next(data); &#125;); &#125; next();&#125;run(gen); 执行器 中的 result.value 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样 let f1 = yield readFile(&#39;a.txt&#39;);就可以拿到值. 方法二： Generator + Thunk函数123456789101112131415161718192021222324252627282930313233343536373839const fs = require('fs')// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数function thunkify(fn, obj = &#123;&#125;) &#123; return function () &#123; let args = Array.from(arguments); return function (m) &#123; args.push(m) return fn.apply(obj, args) &#125; &#125;&#125;const readFile = thunkify(fs.readFile, fs);const gen = function* () &#123; let f1 = yield readFile('a.txt'); let f2 = yield readFile('b.txt'); console.log('F1--&gt;', f1.toString()); console.log('F2--&gt;', f2.toString());&#125;// 基于 Generator 和 Thunk函数的自动执行器function run(fn) &#123; let gen = fn(); function next(err, data) &#123; let result = gen.next(data); if (result.done) return 1; result.value(next); &#125; next();&#125;run(gen); Thunk转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法 方法三：async 函数 + await 的异步处理方式123456789101112131415161718192021const fs = require('fs')// Promise 版的readFileconst readFile = function (fileName) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(fileName, function(err, data)&#123; if (err) return reject(err); resolve(data); &#125;) &#125;)&#125;const asyncReadFile = async function () &#123; const f1 = await readFile('a.txt'); const f2 = await readFile('b.txt'); console.log(f1.toString()); console.log(f2.toString());&#125;;asyncReadFile(); readFile函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(三)]]></title>
    <url>%2Fblog%2F2018%2F06%2F19%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。 修改导航栏信息先从修改导航栏信息开始，主要修改的文件是app.json文件，在里面可以定义一些样式 定义底部tab导航栏可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在app.json文件里操作。 app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。 简单说一下这个配置各个项的含义: 1、pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。2、window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。其他配置项细节可以参考文档 小程序的配置 app.json 。 以下是一个包含了所有配置选项的 app.json ：参考地址1234567891011121314151617181920212223&#123; "pages": [ "pages/index/index", "pages/logs/index" ], "window": &#123; "navigationBarTitleText": "Demo" &#125;, "tabBar": &#123; "list": [&#123; "pagePath": "pages/index/index", "text": "首页" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志" &#125;] &#125;, "networkTimeout": &#123; "request": 10000, "downloadFile": 10000 &#125;, "debug": true&#125; app.json 配置项列表 tabBar的配置参数可以在list里面配置，包括icon的设置，可以去iconfont去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。 iconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图： 抽离公共部分把头像和昵称抽离成公共部分共用，小程序提供了import和include两种方式，微信头像和昵称，显然是异步获取的。为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到app.wxss全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。 把index.wxss里的用户样式移动到app.wxss下：123456789101112131415161718192021/**index.wxss用户信息样式**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125; 接下来新建common目录，新建文件header.wxml 123456789&lt;!-- 在这个文件里把index页面的用户信息移动过来 --&gt;&lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt;&lt;/view&gt; 在 index.wxml合适位置引入文件： 1&lt;include src="../common/header.wxml"/&gt; 在 index.js合适位置缓存本地： 12// 缓存本地wx.setStorageSync('userData', this.data.userInfo) 在需要展示的页面就可以引入公共模块，和数据具体配置： 1&lt;include src="../common/header.wxml"/&gt; 同时小程序还提供了template模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。接下来可以试着加入一个footer.wxml公共组件文件吧。 footer.wxml： 需要引入的文件配置： 注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。 生命周期app.js文件,就是个App()函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有var app = getApp()这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。这个object，除了getUserInfo这个自定义函数，还有onLaunch是内置的函数，那么onLaunch是啥意思呢？先来说下生命周期的概念。生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：初始化，渲染前，渲染中，渲染后，销毁等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示： 1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。 正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。小程序生命周期，分为注册App和注册Page两段。其实也简单。App可以比作浏览器，Page可以比作网页。那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已. onShow和onHide，也就是前台和后台的定义。 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。而对于onError和其他选项，一般不经常使用。 Page（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。 这里也有onShow和onHide，那么这俩哥们又是啥时候触发呢？onShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？ 页面跳转分两种情况：1、wx.navigateTo保留当前页面，跳转2、wx.redirectTo关闭当前页面，跳转 这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。 12&lt;button open-type="getUserInfo" bindtap="keepJump"&gt;保留当前页面并跳转 &lt;/button&gt;&lt;button open-type="getUserInfo" bindtap="closeJump"&gt;关闭当前页面并跳转 &lt;/button&gt;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅(二)]]></title>
    <url>%2Fblog%2F2018%2F06%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于form组件、本地存储和页面的跳转和回退的小程序之旅。 介绍下 form组件、本地存储和页面的跳转和回退 表单组件和数据存储功能新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能 在pages下新增一个login文件夹。 操作步骤为：pages文件夹右键-&gt;新建-&gt;目录， 然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。 配置代码： login.wxml:1234567891011&lt;!--login.wxml--&gt;&lt;form bindsubmit="formSubmit"&gt; &lt;view class="container"&gt; &lt;input name="userName" type="text" class="myinput" placeholder="请输入用户名" value="&#123;&#123;userName&#125;&#125;"/&gt; &lt;input name="userPass" type="text" class="myinput" password placeholder="请输入密码" value="&#123;&#123;userPass&#125;&#125;"/&gt; &lt;button formType="submit"&gt;标记我&lt;/button&gt; &lt;/view&gt;&lt;/form&gt; login.js: 12345678910111213141516171819202122232425262728//login.jsPage(&#123; data: &#123; userName: '',//用户名 userPass: '',//密码 &#125;, //表单提交函数，每个input需要有name，否则获取不到值。 formSubmit: function (e) &#123; console.log(e.detail.value);//返回格式：Object &#123;userName: "hello", userPass: "123"&#125; var obj = e.detail.value; if (obj.userName &amp;&amp; obj.userPass) &#123; //本地存储用户名和密码 wx.setStorageSync('userName', obj.userName); wx.setStorageSync('userPass', obj.userPass); &#125; &#125;, //加载事件，如果判断有缓存信息，就读取并显示在input里。 onLoad: function () &#123; var name = wx.getStorageSync('userName'); var password = wx.getStorageSync('userPass'); if (name) &#123; this.setData(&#123; userName: name &#125;); &#125; if (password) &#123; this.setData(&#123; userPass: password &#125;); &#125; &#125;&#125;) login.wxsss: 12345.myinput&#123; border:1px solid cyan; border-radius: 40px; margin-bottom: 10px;&#125; 可以在首页创建一个按钮，然后利用wx.navigateTo组件跳转一下即可，直接看一下效果： 小程序的表单，默认是异步提交的。它在form上全局绑定一个事件，然后根据name去寻找表单元素的值。所以每个input输入框一定要跟上name，否则找不到。这里只是input，至于其他的表单元素可以再去看看。还有就是有关数据存储，要用小程序提供的api： wx.setStorage(OBJ)：异步存储内容。wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。wx.getStorage(OBJ)：异步获取内容。wx.getStorageSync(key)：同步获取内容。 一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。而异步存储的话，要注意其OBJ参数的书写格式，它包括： key，data，success回调函数，fail回调函数等参数的对象 小程序的本地数据存储也有大小限制：不能超过10MB 异步存储登录页的用户名和密码在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。 login.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//login.jsPage(&#123; data: &#123; userName: null, userPass: null &#125;, //表单提交函数，每个input需要有name，否则获取不到值。 formSubmit: function (e) &#123; console.log(e.detail.value);//返回格式：Object &#123;userName: "hello", userPass: "123"&#125; var obj = e.detail.value; if (obj.userName &amp;&amp; obj.userPass) &#123; //异步存储 wx.setStorage(&#123; key: 'userInfo', data: obj, success: function (res) &#123; // success wx.navigateBack(&#123; delta: 1, // 回退前 delta(默认为1) 页面 &#125;); &#125;, fail: function () &#123; // fail console.log('error'); &#125;, complete: function () &#123; // complete console.log('complete'); &#125; &#125;) &#125; &#125;, //加载事件，如果判断有缓存信息，就读取并显示在input里。 onLoad: function () &#123; var that = this; wx.getStorage(&#123; key: 'userInfo', success: function (res) &#123; // success that.setData(&#123; userName: res.data.userName &#125;); that.setData(&#123; userPass: res.data.userPass &#125;); &#125;, fail: function () &#123; // fail console.log('error'); &#125;, complete: function () &#123; // complete console.log('complete'); &#125; &#125;) &#125;&#125;) 还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api： wx.removeStorage(OBJ)：异步移除某条数据。wx.removeStorageSync(key)：同步移除某条数据。wx.clearStorage()：异步清除所有数据。wx.clearStorageSync()：同步清除所有数据。 在之前的页面里加入一个清除本地缓存数据的一个按钮 index.js:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//index.js//获取应用实例const app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, //事件处理函数 bindViewTap: function () &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, //页面跳转事件处理函数 bindViewLogin: function () &#123; wx.navigateTo(&#123; url: '../login/login' &#125;) &#125;, clearData: function () &#123; //清除所有数据 wx.clearStorageSync(); &#125;, onLoad: function () &#123; if (app.globalData.userInfo) &#123; this.setData(&#123; userInfo: app.globalData.userInfo, hasUserInfo: true &#125;) &#125; else if (this.data.canIUse)&#123; // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125; else &#123; // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo(&#123; success: res =&gt; &#123; app.globalData.userInfo = res.userInfo this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125; &#125;, getUserInfo: function(e) &#123; console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;&#125;) 总结以上就是表单和本地数据存储的一些练习。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-集成第三方库]]></title>
    <url>%2Fblog%2F2018%2F06%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。 集成第三方库接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。 示例这个示例挑选了 tag-it 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框： 1234&lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt;&lt;/ul&gt; 转换成: 要运行起来，需要引入 jQueyr、jQuery UI 和 tag-it插件。这是运行的代码1$('&lt;dom element selector&gt;').tagit(); 选择 DOM 元素，然后调用 tagit() 。 现在，来创建一个简单的 React 应用，它将使用 jQuery 插件: 1234567891011121314151617181920212223242526272829303132// Tags.jsxclass Tags extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123; this.props.tags.map( (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt; ) &#125; &lt;/ul&gt; ); &#125;&#125;;// App.jsxclass App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; tags: ['JavaScript', 'CSS' ] &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Tags tags=&#123; this.state.tags &#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.querySelector('#container')); App 类是入口。它使用了Tags组件，Tags 组件会根据传入的 tags 属性来展示无序列表。当 React 在页面上渲染列表时就有了&lt;ul&gt;标签，这样就可以和 jQuery 插件连接起来。 强制单通道渲染首先，要做的就是强制 Tags 组件进行单通道渲染。这是因为当 React 在实际 DOM中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 shouldComponentUpdate，像这样:123456class Tags extends React.Component &#123; shouldComponentUpdate() &#123; return false; &#125; ... 这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 shouldComponentUpdate 对于 React 组件来说，是让其知道是否触发 render 方法。这适用于的场景，因为想使用 React 来添加 HTML 标记，添加完后就不想再依靠 React 。 初始化插件React 提供了 API 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。 123456789101112131415161718class Tags extends React.Component &#123; ... componentDidMount() &#123; this.list = $(this.refs.list); this.list.tagit(); &#125; render() &#123; return ( &lt;ul ref='list'&gt; &#123; this.props.tags.map( (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt; ) &#125; &lt;/ul&gt; ); &#125; ... 上面的代码和 shouldComponentUpdate 一起使用就会使 React 渲染出有两项的 &lt;ul&gt;，然后 tag-it 会其转换成标签可编辑的插件。 使用 React 控制插件假如说我们想要通过代码来为已经运行的 tag-it 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 Tags 组件，但同时还要保持单通道渲染。 为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 Tags 组件。 12345678910111213141516171819202122232425262728class App extends React.Component &#123; constructor(props) &#123; super(props); this._addNewTag = this._addNewTag.bind(this); this.state = &#123; tags: ['JavaScript', 'CSS' ], newTag: null &#125;; &#125; _addNewTag() &#123; this.setState(&#123; newTag: this.refs.field.value &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;Add new tag:&lt;/p&gt; &lt;div&gt; &lt;input type='text' ref='field' /&gt; &lt;button onClick=&#123; this._addNewTag &#125;&gt;Add&lt;/button&gt; &lt;/div&gt; &lt;Tags tags=&#123; this.state.tags &#125; newTag=&#123; this.state.newTag &#125; /&gt; &lt;/div&gt; ); &#125;&#125; 我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 Tags 组件的重新渲染。但由于 shouldComponentUpdate的存在，页面上不会有任何的更新。唯一的变化就是得到 newTag属性的新值，另一个生命周期方法 componentWillReceiveProps 会捕获到属性的新值: 123456class Tags extends React.Component &#123; ... componentWillReceiveProps(newProps) &#123; this.list.tagit('createTag', newProps.newTag); &#125; ... .tagit(&#39;createTag&#39;, newProps.newTag)是纯粹的 jQuery 代码。如果想调用第三方库的方法，componentWillReceiveProps是个不错的选择。 下面是 Tags 组件的完整代码: 1234567891011121314151617181920212223class Tags extends React.Component &#123; componentDidMount() &#123; this.list = $(this.refs.list); this.list.tagit(); &#125; shouldComponentUpdate() &#123; return false; &#125; componentWillReceiveProps(newProps) &#123; this.list.tagit('createTag', newProps.newTag); &#125; render() &#123; return ( &lt;ul ref='list'&gt; &#123; this.props.tags.map( (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt; ) &#125; &lt;/ul&gt; ); &#125;&#125;; 结语尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。 总结React 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-组件样式]]></title>
    <url>%2Fblog%2F2018%2F06%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。 组件样式经典 CSS 类JSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 .css文件中的。唯一需要注意的是 React 中使用的是 className，而不是 class 。例如: 1&lt;h1 className='title'&gt;Styling&lt;/h1&gt; 内联样式内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。 12345678const inlineStyles = &#123; color: 'red', fontSize: '10px', marginTop: '2em', 'border-top': 'solid 1px #000'&#125;;&lt;h2 style=&#123; inlineStyles &#125;&gt;Inline styling&lt;/h2&gt; 因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承: 12345678const theme = &#123; fontFamily: 'Georgia', color: 'blue'&#125;;const paragraphText = &#123; ...theme, fontSize: '20px'&#125;; theme中有一些基础样式，然后在 paragraphText 中混入 theme 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。 CSS 模块CSS 模块 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。 下面的示例可以让你快速对其运行原理有个大致的了解:1234567891011/* style.css */.title &#123; color: green;&#125;// App.jsximport styles from "./style.css";function App() &#123; return &lt;h1 style=&#123; styles.title &#125;&gt;Hello world&lt;/h1&gt;;&#125; 默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。 当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:1234.title &#123; composes: mainColor from "./brand-colors.css";&#125; Styled-componentsStyled-components 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 Link组件，它具有特定的风格和用法，而再使用 &lt;a&gt;标签。 12345678const Link = styled.a` text-decoration: none; padding: 4px; border: solid 1px #999; color: black;`;&lt;Link href='http://google.com'&gt;Google&lt;/Link&gt; 还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:12345const AnotherLink = styled(Link)` color: blue;`;&lt;AnotherLink href='http://facebook.com'&gt;Facebook&lt;/AnotherLink&gt; 到目前为止 styled-components 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。 结语处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-依赖注入]]></title>
    <url>%2Fblog%2F2018%2F06%2F13%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 依赖注入 的技术 (大多数人认为它是一种模式) 用来解决这种问题。 在 React 中，对依赖注入的需要是显而易见的。 依赖注入来考虑下面的应用的组件树:12345678910111213141516171819202122232425262728// Title.jsxexport default function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;&#125;// Header.jsximport Title from './Title.jsx';export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; );&#125;// App.jsximport Header from './Header.jsx';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; title: 'React in patterns' &#125;; &#125; render() &#123; return &lt;Header /&gt;; &#125;&#125;; 字符串 “React in patterns” 应该以某种方式到达 Title 组件。最直接的方式就从 App 传到 Header，再从 Header 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。 已经了解过 高阶组件 ，它可以用来注入数据。来使用同样的技术来注入 title 变量: 1234567891011121314151617181920212223242526272829// inject.jsxconst title = 'React in patterns';export default function inject(Component) &#123; return class Injector extends React.Component &#123; render() &#123; return ( &lt;Component &#123;...this.props&#125; title=&#123; title &#125; /&gt; ) &#125; &#125;;&#125;// -----------------------------------// Header.jsximport inject from './inject.jsx';import Title from './Title.jsx';var EnhancedTitle = inject(Title);export default function Header() &#123; return ( &lt;header&gt; &lt;EnhancedTitle /&gt; &lt;/header&gt; );&#125; title隐藏在了中间层 (高阶组件) ，在中间层将title属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。 使用 React context (16.3 之前的版本) 在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。 React 有 context 的概念。每个 React 组件都可以访问 context。它有些类似于 事件总线 ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 store 。1234567891011121314151617181920212223// 定义 context 的地方var context = &#123; title: 'React in patterns' &#125;;class App extends React.Component &#123; getChildContext() &#123; return context; &#125; ...&#125;;App.childContextTypes = &#123; title: React.PropTypes.string&#125;;// 使用 context 的地方class Inject extends React.Component &#123; render() &#123; var title = this.context.title; ... &#125;&#125;Inject.contextTypes = &#123; title: React.PropTypes.string&#125;; 注意，需要使用childContextTypes和 contextTypes 来指定 context对象的具体签名。如果不指定的话，那么 context 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 context写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如: 12345678910// dependencies.jsexport default &#123; data: &#123;&#125;, get(key) &#123; return this.data[key]; &#125;, register(key, value) &#123; this.data[key] = value; &#125;&#125; 然后，回到示例中，App 组件应该是这样的:1234567891011121314151617import dependencies from './dependencies';dependencies.register('title', 'React in patterns');class App extends React.Component &#123; getChildContext() &#123; return dependencies; &#125; render() &#123; return &lt;Header /&gt;; &#125;&#125;;App.childContextTypes = &#123; data: React.PropTypes.object, get: React.PropTypes.func, register: React.PropTypes.func&#125;; Title 组件通过 context 来获取数据:123456789101112// Title.jsxexport default class Title extends React.Component &#123; render() &#123; return &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt; &#125;&#125;Title.contextTypes = &#123; data: React.PropTypes.object, get: React.PropTypes.func, register: React.PropTypes.func&#125;; 理想情况下，不想每次需要访问 context时都指定contextTypes。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用this.context.get(&#39;title&#39;) 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:1234567891011// Title.jsximport wire from './wire';function Title(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;&#125;export default wire(Title, ['title'], function resolve(title) &#123; return &#123; title &#125;;&#125;); wire函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 mapper的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。 wire 函数的代码如下所示:123456789101112131415161718export default function wire(Component, dependencies, mapper) &#123; class Inject extends React.Component &#123; render() &#123; var resolved = dependencies.map( this.context.get.bind(this.context) ); var props = mapper(...resolved); return React.createElement(Component, props); &#125; &#125; Inject.contextTypes = &#123; data: React.PropTypes.object, get: React.PropTypes.func, register: React.PropTypes.func &#125;; return Inject;&#125;; Inject 是高阶组件，它可以访问 context并获取 dependencies数组中的所有项。mapper 函数接收 context 数据并将其转换成我们组建所需要的属性。 使用 React context (16.3 及之后的版本)Fackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。 还是使用同一个示例，让字符串抵达&lt;Title&gt;组件。 先来定义包含 context初始化的文件:1234567// context.jsimport &#123; createContext &#125; from 'react';const Context = createContext(&#123;&#125;);export const Provider = Context.Provider;export const Consumer = Context.Consumer; createContext返回的对象具有 Provider 和 Consumer属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。 假设说 App 组件是根组件。在此需要传入 context。 12345678910111213import &#123; Provider &#125; from './context';const context = &#123; title: 'React In Patterns' &#125;;class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123; context &#125;&gt; &lt;Header /&gt; &lt;/Provider&gt; ); &#125;&#125;; 包装组件以及子组件现在共享同一个 context 。&lt;Title&gt;组件是需要 title 字符串的组件之一，所以要在组件中使用 &lt;Consumer&gt; 。123456789import &#123; Consumer &#125; from './context';function Title() &#123; return ( &lt;Consumer&gt;&#123; (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt; &#125;&lt;/Consumer&gt; );&#125; 注意，Consumer类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。 新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。 使用模块系统如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。 众所周知，JavaScript 中的典型模块系统具有缓存机制。在 Node 官方文档 中可以看到: 模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象。多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。 这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 单例，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。 来创建一个新文件di.jsx ，它的代码如下所示: 12345678910111213141516171819202122232425262728var dependencies = &#123;&#125;;export function register(key, dependency) &#123; dependencies[key] = dependency;&#125;export function fetch(key) &#123; if (dependencies[key]) return dependencies[key]; throw new Error(`"$&#123; key &#125; is not registered as dependency.`);&#125;export function wire(Component, deps, mapper) &#123; return class Injector extends React.Component &#123; constructor(props) &#123; super(props); this._resolvedDependencies = mapper(...deps.map(fetch)); &#125; render() &#123; return ( &lt;Component &#123;...this.state&#125; &#123;...this.props&#125; &#123;...this._resolvedDependencies&#125; /&gt; ); &#125; &#125;;&#125; 将依赖保存在了 dependencies这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 register 和 fetch这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 setter 和 getter。再然后是 wire函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 mapper 函数来提取所需属性。 有了di.jsx 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。 12345678910111213141516171819202122232425262728293031323334353637// app.jsximport Header from './Header.jsx';import &#123; register &#125; from './di.jsx';register('my-awesome-title', 'React in patterns');class App extends React.Component &#123; render() &#123; return &lt;Header /&gt;; &#125;&#125;;// -----------------------------------// Header.jsximport Title from './Title.jsx';export default function Header() &#123; return ( &lt;header&gt; &lt;Title /&gt; &lt;/header&gt; );&#125;// -----------------------------------// Title.jsximport &#123; wire &#125; from './di.jsx';var Title = function(props) &#123; return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;&#125;;export default wire( Title, ['my-awesome-title'], title =&gt; (&#123; title &#125;)); 如果查看 Title.jsx 文件的话，可以看到实际的组件和 wire 存在于不同的文件中。这种方式让组件和 mapper 函数的单元测试更简单。 结语依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-Redux]]></title>
    <url>%2Fblog%2F2018%2F06%2F11%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Redux%2F</url>
    <content type="text"><![CDATA[Redux 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (视频)。它类似于 Flux 架构 并有很多共同点。 ReduxRedux 架构及其主要特点 类似于 Flux 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 store中。注意，我们说的是 store，而不是 stores ，这是因为在 Redux 中只有一个 store ，这是 Redux 与 Flux 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 reducers 。一旦 store接收到动作，它会将当前状态和给定动作发送给reducer并要求其返回一个新的状态。然后，在数据不可变的方式下， reducer需要返回新的状态。再然后， store更新自身的内部状态。最后，与 store连接的 React组件会重新渲染。 概念相当清晰并再次遵循了 单向数据流 。我们来讨论每一个部分并引入一些支持 Redux 模式工作的新术语。 动作 ( Actions )Redux 中的动作和 Flux一样，也只是有 type属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如: 12345const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';const action = &#123; type: CHANGE_VISIBILITY, visible: false&#125; 使用像 CHANGE_VISIBILITY 这样的常量作为动作的类型是一种最佳实践。有很多支持 Redux的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。 visible 属性是我们所提到过的元数据。它与 Redux本身无关，它表示应用中某处需要使用的数据。 每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 action creators 诞生的原因。action creator 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:1234567const changeVisibility = visible =&gt; (&#123; type: CHANGE_VISIBILITY, visible&#125;);changeVisibility(false);// &#123; type: CHANGE_VISIBILITY, visible: false &#125; 注意，将 visible 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。 StoreRedux 提供辅助函数 createStore 来创建 store 。它的函数签名如下:123import &#123; createStore &#125; from 'redux';createStore([reducer], [initial state], [enhancer]); 正如之前所提到的，reducer 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 store 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数enhancer提供 API 来使用第三方的中间件来扩展Redux，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。 创建好的store 具有四个方法:getState、dispatch、subscribe和 replaceReducer 。其中最重要的或许就是dispatch:1store.dispatch(changeVisibility(false)); 这里我们使用的是 action creator。我们将其结果 (即 action 对象) 传给 dispatch方法。然后，它会传播给应用中的 reducers。 在典型的React应用中，我们通常不会直接使用getState 和 subscribe，因为有辅助函数 可以将组件和 store联系起来并有效地订阅 store 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用getState。replaceReducer是一个高级 API ，它用来交互 store所使用的当前 reducer 。 Reducerreducer函数大概是Redux中最精华的部分。reducer还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。 (1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 (2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 下面是个很简单的计数器 reducer : 12345678const counterReducer = function (state, action) &#123; if (action.type === ADD) &#123; return &#123; value: state.value + 1 &#125;; &#125; else if (action.type === SUBTRACT) &#123; return &#123; value: state.value - 1 &#125;; &#125; return &#123; value: 0 &#125;;&#125;; 它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。 连接 React 组件如果是在 React上下文中讨论Redux的话，那基本离不开 react-redux 模块。它提供两样东西来进行 Redux 到组件的连接。 (1) &lt;Provider&gt; 组件 - 它是一个组件，它接收 store并使得所有的子组件都可以通过 React 的 context API 来访问 store。 例如:123&lt;Provider store=&#123; myStore &#125;&gt; &lt;MyApp /&gt;&lt;/Provider&gt; 通常，我们只在应用中的单个地方使用它。 (2) connect 函数 - 它是一个函数，它负责订阅 store的更新和重新渲染组件。它是通过 高阶组件 实现的。 这是它的函数签名:123456connect( [mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) mapDispatchToProps也是类似的，只是它接收的是 dispatch函数，而不是state 。这里是我们将派发动作定义成属性的地方。123const mapDispatchToProps = dispatch =&gt; (&#123; changeVisibility: value =&gt; dispatch(changeVisibility(value))&#125;); mergeProps将 mapStateToProps、 mapDispatchToProps和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。options 接收一组如何控制连接的设置。 使用 Redux 的简单计数器应用使用上面所有的 API 来创建一个简单的计数器应用。 “Add” 和 “Subtract” 按钮只是改变 store 的值。”Visible” 和 “Hidden” 按钮用来控制计数器是否显示。 创建动作每个 Redux 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:增加、减少和管理可见性。所有动作代码如下所示:12345678910const ADD = 'ADD';const SUBTRACT = 'SUBTRACT';const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';const add = () =&gt; (&#123; type: ADD &#125;);const subtract = () =&gt; (&#123; type: SUBTRACT &#125;);const changeVisibility = visible =&gt; (&#123; type: CHANGE_VISIBILITY, visible&#125;); Store 及其 reducers在解释 store 和 reudcers时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。store 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:123456const initialState = &#123; counter: &#123; value: 0 &#125;, visible: true&#125;; 需要为这两部分分别定义 reducer。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 reducer 函数来进行维护，这样管理起来将会非常困难。 Redux提供辅助函数来让我们能够锁定state的某个特定部分并为其分配一个 reducer。它就是 combineReducers :1234567import &#123; createStore, combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; counter: function A() &#123; ... &#125;, visible: function B() &#123; ... &#125;&#125;);const store = createStore(rootReducer); 函数 A 只接收 counter 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。 counter 切片的reducer 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 counter 状态。12345678const counterReducer = function (state, action) &#123; if (action.type === ADD) &#123; return &#123; value: state.value + 1 &#125;; &#125; else if (action.type === SUBTRACT) &#123; return &#123; value: state.value - 1 &#125;; &#125; return state || &#123; value: 0 &#125;;&#125;; 当 store 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 { type: &quot;@@redux/INIT&quot;} 。在这个实例中，reducer 应该返回数据的初始值 { value: 0 } 。 visible 的 reducer 相当简单，它只处理动作 CHANGE_VISIBILITY :123456const visibilityReducer = function (state, action) &#123; if (action.type === CHANGE_VISIBILITY) &#123; return action.visible; &#125; return true;&#125;; 最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。 1234const rootReducer = combineReducers(&#123; counter: counterReducer, visible: visibilityReducer&#125;); 选择器 ( Selectors )我们知道状态通常都是细化成多个状态切片。我们有专门的 reducer来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:12const getCounterValue = state =&gt; state.counter.value;const getVisibility = state =&gt; state.visible; 这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。 React 组件先来处理管理计数器可见性的 UI 部分。12345678910111213141516171819function Visibility(&#123; changeVisibility &#125;) &#123; return ( &lt;div&gt; &lt;button onClick=&#123; () =&gt; changeVisibility(true) &#125;&gt; Visible &lt;/button&gt; &lt;button onClick=&#123; () =&gt; changeVisibility(false) &#125;&gt; Hidden &lt;/button&gt; &lt;/div&gt; );&#125;const VisibilityConnected = connect( null, dispatch =&gt; (&#123; changeVisibility: value =&gt; dispatch(changeVisibility(value)) &#125;))(Visibility); 第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。 12345678910111213141516171819function Counter(&#123; value, add, subtract &#125;) &#123; return ( &lt;div&gt; &lt;p&gt;Value: &#123; value &#125;&lt;/p&gt; &lt;button onClick=&#123; add &#125;&gt;Add&lt;/button&gt; &lt;button onClick=&#123; subtract &#125;&gt;Subtract&lt;/button&gt; &lt;/div&gt; );&#125;const CounterConnected = connect( state =&gt; (&#123; value: getCounterValue(state) &#125;), dispatch =&gt; (&#123; add: () =&gt; dispatch(add()), subtract: () =&gt; dispatch(subtract()) &#125;))(Counter); 这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: value、add 和 subtract。 最后要完成的就是 App 组件，我们在这里进行应用的组装。 12345678910111213function App(&#123; visible &#125;) &#123; return ( &lt;div&gt; &lt;VisibilityConnected /&gt; &#123; visible &amp;&amp; &lt;CounterConnected /&gt; &#125; &lt;/div&gt; );&#125;const AppConnected = connect( state =&gt; (&#123; visible: getVisibility(state) &#125;))(App); 再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。 结语Redux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的: 顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。 我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略(五)]]></title>
    <url>%2Fblog%2F2018%2F05%2F29%2FES6%E6%94%BB%E7%95%A5-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。 数组扩展forEach()方法这个方法其实是es5的，还是很好用的。12345var arr = ['a', 'b', 'c', 'd'];//遍历数组arr.forEach(function(val)&#123; console.log(val);&#125;); Array.from()方法它是将两类对象装换为真的数组：类数组对象arguments、可遍历对象（可数Object、Set、Map). 123456789101112131415161718192021222324252627282930let myObj = &#123;length:2,'0':'hello','1':'world'&#125;;console.log(Array.from(myObj));//[ 'hello', 'world' ]&lt;!-- Set --&gt;let mySet = new Set([1,1,2,3]);mySet.add('hello');mySet.add('hello');mySet.add(NaN);mySet.add(NaN);mySet.add(undefined);mySet.add(undefined);console.log(Array.from(mySet));//[ 1, 2, 3, 'hello', NaN, undefined ]&lt;!-- Map --&gt;let myMap = new Map();myMap.set(0,'hello');myMap.set(true,'world');myMap.set(1,'haha');console.log(Array.from(myMap));//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]&lt;!-- arguments --&gt;function foo()&#123;console.log(Array.from(arguments));&#125;foo(1,3,5);//[ 1, 3, 5 ] find()和findindex()find()查找数组里符合条件的第一个值findindex()是查找数组里符合条件的第一个索引的下标 123456789101112&lt;!-- find() --&gt;console.log([-1, 4, -5, 10].find((n) =&gt; n &lt; 2));// -1&lt;!-- findindex() --&gt;console.log([1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 4; //5这个值的索引下标是1&#125;));// 1 fill()填充方法将空数组填充固定的某一个值。 1234console.log(new Array(4));//[ , , , ]console.log(new Array(4).fill(2));//[2, 2, 2, 2] lterator 遍历器使用最多的遍历器是：for...in和for前者是循环遍历Object对象，后者是遍历数组在ES6里又新增加了2种数据结构：Set和Map。这里就用到了lterator，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用for....of循环。 1234567891011121314151617181920212223242526272829let myMap = new Map();myMap.set(0,'hello');myMap.set(1,'world');myMap.set('hi','jack');for(let v of myMap)&#123; console.log(v); console.log(v[0]+'--'+v[1]);&#125;/* [0, "hello"] 0--hello [1, "world"] 1--world ["hi", "jack"] hi--jack*/let mySet = new Set([1,3,5]);for(let v of mySet)&#123; console.log(v);&#125;/* 1 3 5*/ ModuleModule它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。 这里需要注意：Node环境下使用export和require前端JS环境下使用export和import(需要babel等工具来解析) 12345678910111213141516171819202122&lt;!-- foo.js --&gt;//导出方法module.exports.sayHi = function()&#123; console.log('hello,world');&#125;;//导出对象module.exports.obj = &#123;'a':1,'b':2&#125;;class Person &#123; constructor( name)&#123; this.name = name; &#125; eat() &#123; console.log(this.name+' eat'); &#125;&#125;//导出一个类module.exports.Person = Person; 12345678910&lt;!-- text.js --&gt;//引入模块var text = require('./foo.js');//使用模块text.sayHi();console.log(text.obj.a);var p = new text.Person('jack');p.eat(); 在se6的语法下，需要babel 的支持。1、安装 npm install babel-preset-es2015npminstall --global babel-cli 2、配置.babelrc文件 {&quot;presets&quot;:[&quot;es2015&quot;]} 3、测试一下 12345&lt;!-- export.js --&gt;var yourname = 'Jack';var age = 18;export &#123;yourname, age&#125;; 123456&lt;!-- import.js --&gt;import &#123;yourname, age&#125; from './export.js';function say() &#123; console.log(yourname,age);&#125; 4、运行 babel export.js --out-file export_out.jsbabel import.js --out-file import_out.js 运行结束之后，目录下增加了2个输出文件，export_out.js和import_out.js 123456789101112&lt;!-- export_out.js--&gt;'use strict';Object.defineProperty(exports, "__esModule", &#123;value: true&#125;);var yourname = 'Jack';var age = 18;exports.yourname = yourname;exports.age = age; 123456789&lt;!-- import_out.js --&gt;'use strict';var _export = require('./export.js');function say() &#123; console.log(_export.yourname, _export.age);&#125; 其实翻译过来后，仍旧是exports和require！ 5、在前端测试text.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试一下&lt;/title&gt;&lt;script src="./import_out.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; say();&lt;/script&gt; 这样是运行不了的，他们环境都不一样，怎么可能运行。babel只是一个编译工具，这里只是把es6编译为common.js规范的语法，require这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。 common、cmd、amd:cmd是seajs遵循的规范amd是requirejs遵循的规范commomJS是node遵循的规范 就需要加入webpack. webpack1、安装npm install webpack -g (全局安装)npm install webpack (本地安装) 2、运行编译webpack import_out.js bundle.js 因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。 3、 再一次测试test.html 会有错误抛出：say is not defined 这个其实是模块化的问题，say()方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有(function(modules) { ....... })(); 这就是一个自执行的封闭空间。如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。webpack有个expose-loader这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:123456789'use strict';var _export = require('./export.js');function say() &#123;console.log(_export.yourname, _export.age);&#125;&lt;!-- 把say()方法挂到window下面 --&gt;window.say = say; 然后再运行一下webpack命令：webpack import_out.js bundle.js好啦，你再运行下test.html，发现终于成功啦！ 总结其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。 参考原文：ES6攻略]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略(四)]]></title>
    <url>%2Fblog%2F2018%2F05%2F29%2FES6%E6%94%BB%E7%95%A5-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。 Set之前的JS只提供了两种容器：数组和对象。es6又添加了另一种非常有用的数据结构：Set。他就是集合的意思，本身也是一种容器。既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？拿他跟数组比较的话，Set的最大的特点就是每个值都是唯一的，不能有重复值。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。 12345678let container = new Set([1, 2, 2, 3, 4, 4]);//可以直接传入数组进行初始化container.add(5);//添加元素container.delete(5);//删除元素console.log(container.has(5));//false，5这个元素被删除了console.log(container);//Set &#123; 1, 2, 3, 4 &#125;console.log(container.size);//长度4let unique_arr = [...container];//省略号语法console.log(unique_arr);//唯一值数组：[ 1, 2, 3, 4 ] Set的构造方法可以直接传数组进行初始化，当然也可以这样声明：let mySet = new Set(); Set跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。 123//简单去重方案var arr = [1,1,2,3,3,3];console.log([...new Set(arr)]);//一句话搞定 这并不适用于含有重复对象的数组，因为对象是比较的是内存地址。123console.log(&#123;&#125;==&#123;&#125;);//false,内存地址不同let arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];console.log([...new Set(arr)]);//对象是无法去重的 对象数组到底如何去重呢？一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用Set的不重复特性，把对象先转成字符串存入Set，去掉重复值后，再转回来就好。 12345678910111213function unique(arr)&#123; var container = new Set();//遍历 arr.forEach(function(val)&#123;//将对象转换为字符串,存入set容器中，确保唯一性。 container.add(JSON.stringify(val)); &#125;); var newarr = [...container].map(function(item)&#123; return JSON.parse(item);//转换回去 &#125;); return newarr;&#125; 新数据结构：Map这个是Map容器，而不是前面的map()方法，千万别弄混了（注意大小写）！Map就是键值对容器，跟Object非常类似。它有什么特别之处呢？其实Object有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。如果让键不限于字符串，而是各种数据类型呢？比如num？ 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;map&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button id="btn1"&gt;提交&lt;/button&gt; &lt;button id="btn2"&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dom1 = document.getElementById('btn1'); var dom2 = document.getElementById('btn2'); var callback1 = function()&#123; alert('提交'); &#125;; var callback2 = function()&#123; alert('关闭'); &#125;; const m = new Map(); m.set(dom1,callback1); //键是dom m.set(dom2,callback2); console.log(m);&lt;/script&gt; 一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了 1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 因为对象比较的是内存地址，所以[&#39;a&#39;]作为新开辟的空间，无法在Map容器中找到。 再来看一下Map的增查改删，非常简单。 12345678910111213//利用二维数组，可以构建Mapconst myMap = new Map([ ['name', '张三'], ['content', 'hello,world']]);console.log(myMap);//Map &#123; 'name' =&gt; '张三', 'content' =&gt; 'hello,world' &#125;console.log(myMap.size); // 长度myMap.set('age',18);//增加属性console.log(myMap.get('name')); //获取属性myMap.delete('content');//删除属性console.log(myMap.has('content')); // 判断是否有这个属性console.log(myMap.keys());//获取所有的键 MapIterator &#123; 'name', 'age' &#125;console.log(myMap.values());//获取所有的值 MapIterator &#123; '张三', 18 &#125; 获取的keys集合是MapIterator类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构 Reflect是面镜子Reflect就是反射的意思，那究竟反射啥呢？大家知道镜子可以反射吧？Reflect就是一面镜子。那是谁照镜子呢？就是Object。也就是说，Object把自己的属于语言内部的方法（比如Object.defineProperty）照到了Reflect上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;利用反射实现数据和视图联动&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt;测试Object：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;&lt;div&gt;测试Reflect：&lt;input type="text" id='age'/&gt;&lt;/div&gt;&lt;div id="showName"&gt;&lt;/div&gt;&lt;div id="showAge"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;var userInfo = &#123;&#125;;//Object的方式Object.defineProperty(userInfo, "userName", &#123;get: function()&#123;return document.getElementById('showName').innerHTML;&#125;,set: function(name)&#123;document.getElementById('showName').innerHTML = name;&#125;&#125;);//Reflect是一面大镜子，Object你有的我就有！Reflect.defineProperty(userInfo, "age", &#123;get: function()&#123;return document.getElementById('showAge').innerHTML;&#125;,set: function(name)&#123;document.getElementById('showAge').innerHTML = name;&#125;&#125;);document.getElementById('userName').onkeyup = function(e)&#123;userInfo.userName = this.value;&#125;;document.getElementById('age').onkeyup = function(e)&#123;userInfo.age = this.value;&#125;;&lt;/script&gt; Reflect一共是13个静态方法，就是13种武器哈：1234567891011121314Reflect.apply(target,thisArg,args)Reflect.construct(target,args)Reflect.get(target,name,receiver)Reflect.set(target,name,value,receiver)Reflect.defineProperty(target,name,desc)Reflect.deleteProperty(target,name)Reflect.has(target,name)Reflect.ownKeys(target)Reflect.isExtensible(target)Reflect.preventExtensions(target)Reflect.getOwnPropertyDescriptor(target, name)Reflect.getPrototypeOf(target)Reflect.setPrototypeOf(target, prototype) 看下几个常用的方法。 12345678910111213141516171819202122232425262728let obj = &#123;name:'jack',age:18&#125;;//简单set方法Reflect.set(obj,'name','tom');console.log(obj.name);//tom//简单get方法let age = Reflect.get(obj,'age');console.log(age);//18//带有接收者对象的set方法let receiver = &#123;name:'lily'&#125;;//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。//所以，obj的name属性还是tom，但接收者receiver的name被改变了。//这种机制的作用是，可以在对象A中操作对象B。Reflect.set(obj,'name','bill',receiver);console.log(obj.name);//tomconsole.log(receiver.name);//bill//判断obj是否有name属性？//旧写法--inconsole.log('name' in obj);//true//新写法--hasconsole.log(Reflect.has(obj,'name'));//true 他与Proxy结合使用更合理。 ProxyProxy就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟Reflect是一一对应的。只要Proxy对象有的方法，Reflect对象上都有。当然咯，Proxy没有的，Reflect也有。 拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：var proxy = new Proxy(target, handler); 1.target就是目标对象，我们要给哪个对象加拦截？2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。 拿最简单的set方法为例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//形参说明：// target:待测试的Person实例// validator:验证规则personValidatorsfunction createValidator(target, validator) &#123;//拦截器，拦截赋值操作，触发set函数return new Proxy(target, &#123; set(target, key, value) &#123;//如果待测试的Person对象中含有这个属性，就启用验证规则，// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。 if (target.hasOwnProperty(key)) &#123; let rules = validator[key];//rules拿到的是name方法的引用//相当于调用方法name('hello') if (rules(value)) &#123;//如果验证无误，target的name属性可以修改成功 return Reflect.set(target, key, value); &#125; else &#123;//否则失败 return 'error'; &#125; &#125; else &#123; return 'error'; &#125; &#125;&#125;);&#125;//验证规则const personRules = &#123; name(val) &#123; return typeof val === 'string'; &#125;, age(val) &#123; return typeof val === 'number' &amp;&amp; val &gt; 18; &#125;&#125;;//测试类class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age;//开启验证，传入这个类的实例和验证规则personRules return createValidator(this, personRules); &#125;&#125;const bill = new Person('Bill', 25);bill.name = 'jack';//赋值成功bill.age = 10;//赋值失败console.log(bill.name);//jackconsole.log(bill.age);//25 createValidator这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。 再来看下Reflect.apply的用法。这个方法的使用频率还是蛮高的 1234567891011121314//假如这个foo函数是同事张三写的var obj = &#123;&#125;;function foo()&#123;console.log(this);&#125;//李四引入并使用了这个函数foo.apply(obj);//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。//可以在不依赖函数名的情况下改变函数的作用域么？Function.prototype.apply.call(foo,obj);//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。Reflect.apply(foo,obj,[]);//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错 结语Proxy是用于修改语言内部行为的机制，因为Object对象内部的方法大多属于这种情况，所以handler的配置，又跟Reflect紧密联系在一起（因为Reflect是Object的镜子嘛）。应该说，Reflect和Proxy之间的关系还是不太容易理顺的。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略(三)]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2FES6%E6%94%BB%E7%95%A5-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。 ES6es6的promise写法还是不够优雅，因为后面会跟很多then()。应该说，async/await是目前解决回调问题最好的方案了。 a:async函数是什么？b:一句话，它就是 Generator 函数的语法糖。a:而Generator又是神马？b:是es6的一个语法。a:这个语法干嘛的？b:不用管它，只需要把async搞明白。 要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是10.*，稳定版出到8.*，所以安装好就可以使用了。 使用async/await的目的就是去除掉Promise后面的then(),在并行下也没有then()的，主要是串行，就是互相依靠的请求方式。 假设有三个请求：请求1：拿到userid，传递给请求2。请求2：根据userid，查询ssoid，传递给请求3。请求3：根据ssoid，查到最终结果。 那么，如果可以这么写就好了： 12345var userid = getRequest1();var ssoid = getRequest2(userid);var res = getRequest3(userid,ssoid);//打印最终结果res.then(function(data)&#123;console.log(data);&#125;); 把之前es6的写法改一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var request = require('request');var urls = ['http://localhost:3000/hello1','http://localhost:3000/hello2','http://localhost:3000/hello3'];//创建任务函数不变function createPromise(url)&#123;//回调函数 var callback = function(resolve, reject)&#123; request(url , function(err , response , body)&#123; if(err)&#123; reject(err);//错误返回 &#125;else&#123; resolve(body);//成功返回 &#125; &#125;);&#125;;//布置任务var promise = new Promise(callback);//返回promise承诺 return promise;&#125;//声明async函数，返回的一定是promise对象async function doIt()&#123; var data_userid = await createPromise(urls[0]);//第一个请求任务 data_userid = JSON.parse(data_userid);//解析成对象 var userid = data_userid.userid;//获取userid var data_ssoid = await createPromise(urls[1]+"?userid="+userid);//第二个请求任务 data_ssoid = JSON.parse(data_ssoid);//解析成对象 var ssoid = data_ssoid.ssoid;//获取ssoid var result = await createPromise(urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid);//第三个请求任务 return result;//返回promise对象&#125;//最终执行doIt().then(function(data)&#123;//打印最终结果console.log(data);&#125;).catch(function(err)&#123;//捕获异常console.log(err);&#125;); 注意：1234561.async需要放在函数声明前，表示这个函数返回的一定是promise对象。2.await后面也必须是promise对象，表示这个任务是需要等待的。3.最后用then()获取所有接口的信息，catch()捕获所有异常。4.这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！这样，简单整洁，只留一个then和catch。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略(二)]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2FES6%E6%94%BB%E7%95%A5-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。 ES6回调使我们时常需要面对的问题，现在node已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于babel去编译。 关于es6的pormise他就是一个对象，看下面： 123456789101112131415161718192021&lt;!-- 对比一下他们的差异 --&gt;//布置一项任务var promise = new Promise(function(resolve, reject) &#123;// ... some code//resolve和reject是对象提供的两个回调函数 if(/* 异步操作成功 */)&#123; resolve(value); &#125; else&#123; reject(error); &#125;&#125;);//执行任务promise.then(function(data) &#123;// success console.log(data);&#125;).catch(function(err)&#123; console.log(err);&#125;); 从中可以看出，他和Q模块有点类似，比如：var deferred = Q.defer() 12345678910111213141516171819202122var request = require('request');//回调函数var callback = function(resolve, reject)&#123; var url = 'http://localhost:3000/hello1'; request(url , function(err , response , body)&#123; if(err)&#123; reject(err);//错误返回 &#125;else&#123; resolve(body);//成功返回 &#125; &#125;);&#125;;//布置一项任务var promise = new Promise(callback);//执行任务promise.then(function(data)&#123;//正确响应 console.log(data);&#125;).catch(function(err)&#123;//捕获错误信息 console.log('error info:',err);&#125;); 将url地址http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下： 再一次修改一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var request = require('request');var urls = ['http://localhost:3000/hello1','http://localhost:3000/hello2','http://localhost:3000/hello3'];//这里需要改写一下~~function createPromise(url)&#123;//回调函数 var callback = function(resolve, reject)&#123; request(url , function(err , response , body)&#123; if(err)&#123; reject(err);//错误返回 &#125;else&#123; resolve(body);//成功返回 &#125; &#125;); &#125;;//布置任务 var promise = new Promise(callback);//返回promise承诺 return promise;&#125;//第一个请求的回调var callback_Request1 = function(data)&#123;data = JSON.parse(data);console.log(data);var userid = data.userid;var url = urls[1]+'?userid='+userid;return createPromise(url);&#125;;//第二个请求的回调var callback_Request2 = function(data)&#123;data = JSON.parse(data);console.log(data);var userid = data.userid;var ssoid = data.ssoid;var url = urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid;return createPromise(url);&#125;;//业务逻辑被剥离出去咯~~createPromise(urls[0]).then(function(data)&#123;console.log('第一次请求');return callback_Request1(data);&#125;).then(function(data)&#123;console.log('第二次请求');return callback_Request2(data);&#125;).then(function(data)&#123;//打印最终结果console.log('第三次请求');console.log(data);&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略(一)]]></title>
    <url>%2Fblog%2F2018%2F05%2F27%2FES6%E6%94%BB%E7%95%A5-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。 ES6两个很有用的原生JS函数：map和reduce。 1、map() 方法： 它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。 123456789var data = [1,2,3];var callback = function(a)&#123; // 这里的a就是数组每一项的值 return a+1;&#125;var demo = data.map(callback);consloe.log(demo)//[2,3,4] 在这里需要注意的是map里面的回调函数，参数只有一个 2、reduce()方法 这个方法先从代码例子开始1234567891011var data = [1,2,3];var callback = function(a,b)&#123; console.log('初始值=',a); return a+b;&#125;;var demo = data.reduce(callback,100);console.log(demo);//初始值=100//初始值=101//初始值=103//106 reduce它有2个参数： 第一个是callback回调函数，主要是针对数组的操作； 第二个是传入的初始值 工作原理： 1、传入一个初始值； 2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果； 3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果； ….. 依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。这和ajax的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个并行，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者Q模块是用来解决回调问题，与之类似的有jQuery的延迟对象，ES6的promise对象，ES7的async和await.可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。 爬虫的工作原理： 先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。 先安装一个发送请求模块request和Q模块： npm install request --devnpm install q --dev 然后开始写个脚本，先用express搭建一个服务：12345678910111213141516171819202122232425262728var express = require('express')var router = express.Router();// GET home pagerouter.get('./',function(req,res,next)&#123;res.render('index',&#123;title:'Express'&#125;);&#125;)// 请求1router.get('/list1',function(req,res,next)&#123; setTimeout(() =&gt; &#123; res.send('请求1完成了！') &#125;, 1000);&#125;)// 请求2router.get('/list2',function(req,res,next)&#123; setTimeout(() =&gt; &#123; res.send('请求2完成了！') &#125;, 2000);&#125;)// 请求3router.get('/list3',function(req,res,next)&#123; setTimeout(() =&gt; &#123; res.send('请求3完成了！') &#125;, 3000);&#125;)module.exports = router; 以上为数据接口。 12345678910111213141516171819202122var Q = require('q');var request = require('request');function createPromise(url)&#123; var deferred = Q.defer(); // 创建任务 request(url, function(err,response,body)&#123; console.log('requested',url); if (err) &#123; deferred.reject(err); // 错误返回 &#125;else&#123; deferred.resolve(body) // 成功返回 &#125; &#125;) return deferred.promise; // 返回一个承诺&#125;createPromise('http://localhost:3000/list1').then(function(data)&#123; console.log(data);&#125;,function(err)&#123; console.error(err);&#125;) resolve就是继续执行，reject就是拒绝，defer就是布置任务。Q把每一个请求都会布置成一个任务，然后返回一个promise对象，promise就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从then()方法里面拿到需要的数据。 并行请求：1234567891011121314151617181920212223242526272829303132333435363738var Q = require('q');var request = require('request');var urls = [ 'http://localhost:3000/hello1', 'http://localhost:3000/hello2', 'http://localhost:3000/hello3', 'http//localhost:3000/hello_110' //这是个错误的地址];function createPromise(url) &#123; var deferred = Q.defer(); //创建任务 request(url, function (err, response, body) &#123; console.log("requested " + url); if (err) &#123; deferred.reject(err); //错误返回 &#125; else &#123; deferred.resolve(body); //成功返回 &#125; &#125;); return deferred.promise; //返回一个承诺&#125;var promises = urls.map(function (url) &#123; return createPromise(url);&#125;);Q.allSettled(promises).then(function (results) &#123; console.log(results); results.forEach(function (result) &#123; if (result.state === "fulfilled") &#123; console.log(result.value); &#125; else &#123; console.error(result.reason); &#125; &#125;);&#125;); 用map()方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回） 串行请求。先来个传统写法:1234567891011121314var Q = require('q');var request = require('request');request('http://localhost:3000/hello1' , function(err1 , response1 , body1)&#123; console.log(body1); request('http://localhost:3000/hello2',function(err2 , response2 , body2)&#123; console.log(body2); request('http://localhost:3000/hello3',function(err3 , response3 , body3)&#123; console.log(body3); &#125;); &#125;);&#125;); 这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。Q是如何解决回调地狱问题的呢？其实也简单，就是把发请求部分单独拆出去，做成子任务即可。前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码： 1234567891011121314151617181920212223242526272829303132333435var Q = require('q');var request = require('request');var urls = [ 'http://localhost:3000/hello1', 'http://localhost:3000/hello2', 'http://localhost:3000/hello3', 'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址];function createPromise(url) &#123; var deferred = Q.defer(); request(url, function (err, response, body) &#123; if (err) deferred.reject(err); else deferred.resolve(body); &#125;); return deferred.promise;&#125;//这里是亮点~~urls.reduce(function (promiseObj, url) &#123; //promiseObj第一次是Q(null)，也就是空的任务 return promiseObj.then(function (data) &#123; if (data) &#123; console.log(data); &#125; //返回promise，层级传递，直到最后一个拿到结果 return createPromise(url); &#125;, function (err) &#123; console.error(err); return createPromise(url); &#125;)&#125;, Q(null)); 比较难理解的还是reduce。我们这里再来分析一遍他：第1步：给定一个初始值Q(null)。第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。第3步：把第2步的结果Q(&#39;http://localhost:3000/hello1&#39;)作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。 现实中我们需求一般是这样的： 请求1：拿到userid，传递给请求2。请求2：根据userid，查询ssoid，传递给请求3。请求3：根据ssoid，查到最终结果。我们根据这种情况，再来一次：改造下接口：123456789101112131415161718192021222324252627282930313233343536373839404142434445var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function (req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);//请求1router.get('/hello1', function (req, res, next) &#123; setTimeout(function () &#123; res.json(&#123; code: 200, userid: 123 &#125;); &#125;, 1000);&#125;);//请求2router.get('/hello2', function (req, res, next) &#123; var param = req.query || req.params; var userid = param.userid; setTimeout(function () &#123; res.json(&#123; code: 200, userid: userid, ssoid: 456 &#125;); &#125;, 2000);&#125;);//请求3router.get('/hello3', function (req, res, next) &#123; var param = req.query || req.params; var userid = param.userid; var ssoid = param.ssoid; setTimeout(function () &#123; res.json(&#123; code: 200, userid: userid, ssoid: ssoid, msg: '完成啦！' &#125;); &#125;, 3000);&#125;);module.exports = router; 其次：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var Q = require('q');var request = require('request');var urls = [ 'http://localhost:3000/hello1', 'http://localhost:3000/hello2', 'http://localhost:3000/hello3'];function createPromise(url) &#123; var deferred = Q.defer(); request(url, function (err, response, body) &#123; if (err) deferred.reject(err); else deferred.resolve(body); &#125;); return deferred.promise;&#125;//第一个请求的回调var callback_Request1 = function (data) &#123; data = JSON.parse(data); console.log(data); var userid = data.userid; var url = urls[1] + '?userid=' + userid; return createPromise(url);&#125;;//第二个请求的回调var callback_Request2 = function (data) &#123; data = JSON.parse(data); console.log(data); var userid = data.userid; var ssoid = data.ssoid; var url = urls[2] + '?userid=' + userid + '&amp;ssoid=' + ssoid; return createPromise(url);&#125;;//业务逻辑被剥离出去咯~~createPromise(urls[0]).then(function (data) &#123; console.log('第一次请求'); return callback_Request1(data);&#125;).then(function (data) &#123; console.log('第二次请求'); return callback_Request2(data);&#125;).then(function (data) &#123; //打印最终结果 console.log('第三次请求'); console.log(data);&#125;); 就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6攻略]]></title>
    <url>%2Fblog%2F2018%2F05%2F25%2FES6%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。 搞定变量作用域问题：letES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。es6引入了let这个关键字，问题得到了解决：123456789101112131415161718let i=100;//循环语句1for(let i=0;i&lt;10;i++)&#123;&#125;console.log(i);//100//循环语句2while(true)&#123; let i=11; break;&#125;console.log(i);//100//分支语句if(true)&#123; let i=111;&#125;else&#123; let i=0;&#125;console.log(i);//100 let关键字让变量作用域变得清晰可控 利用const，保证全局变量不被更改有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。123456const username = "jack";//重新声明var username = 'hello';//直接修改username = 123;console.log(username); 类的声明与继承按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到高内聚低耦合的设计目的。其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。而es6引入了静态语言的class之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。1234567891011121314151617181920212223class Animal &#123;//构造函数，注意函数之间不用加; constructor()&#123; this.type = 'animal'; &#125; says(say)&#123; console.log(this.type + ' says ' + say); &#125;&#125;let animal = new Animal();animal.says('hello'); //animal says helloclass Cat extends Animal &#123; constructor()&#123; super();//继承了父类的属性和方法 this.type = 'cat'; &#125;&#125;let cat = new Cat();cat.says('hello'); //cat says hello 箭头函数，解决this指向问题JS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：1234567891011121314class Animal &#123; constructor()&#123; this.type = 'animal'; &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say); &#125;, 1000); &#125;&#125;var animal = new Animal();animal.says('hi'); //undefined says hi 这是一个比较经典的this被篡改的问题，因为这个该死的setTimeout函数，他的this指向的是window对象。我们可以利用一个变量保存住这个this指针，也或者使用bind(this)方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。123456789101112class Animal &#123; constructor()&#123; this.type = 'animal'; &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say); &#125;, 1000); &#125;&#125;var animal = new Animal();animal.says('hi'); //animal says hi 插入大段html文本这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟html拼接好，最后追加到某个div下。拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。如果能不改变html的结构就好了！于是es6引入了模板字串的概念。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var cont = document.getElementById('container');//一些变量var name = 'jack';var age = 18;cont.innerHTML = `&lt;div style="color:red;"&gt; &lt;span class="name"&gt;$&#123;name&#125;&lt;/span&gt; &lt;b class="age"&gt;$&#123;age&#125;&lt;/b&gt; &lt;/div&gt;`; 在反引号中随意使用各种引号，其中的变量都用${}来表示。这样代码就变得优雅了。 默认值default有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。123456function hello(name)&#123; name = name || 'jack'; console.log(name+' say hello!');&#125;hello(); 但这样写不够直观，es6提供了默认值的写法。1234function hello(name ='jack')&#123; console.log(name + ' say hello!');&#125;hello(); 省略号语法省略号是一种语法糖，在处理函数不定参时十分有用。像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。1234function hello(a,b,...others)&#123;console.log(others);//[ 'amily', 'mike', 'sam' ]&#125;hello('jack','tom','amily','mike','sam'); Object几个好用的扩展 Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。 1.assign()方法：用于对象的合并或拷贝。12345//对象合并var target = &#123;a:1&#125;;var source = &#123;b:2&#125;;Object.assign(target,source);console.log(target);//&#123;a: 1, b: 2&#125; 注意，拷贝是浅拷贝，而不是深拷贝。 1234567//对象拷贝，是浅拷贝。let target = &#123; a: &#123; b: 'hello'&#125; &#125;;let source = &#123; c: &#123; d: 'world' &#125; &#125;;Object.assign(target, source);console.log(target);//&#123; a: &#123; b: 'hello' &#125;, c: &#123; d: 'world' &#125; &#125;target.c.d = 'haha';console.log(source);//&#123; c: &#123; d: 'haha' &#125; &#125; 如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。究竟是用哪种拷贝，得看实际应用场景。 2.defineProperty()方法：双向绑定的秘密！ 在angular或vue等框架里，对双向绑定并不陌生。数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？我们可以通过这个es6新提供的方法轻松搞定它。先来看一下用法：1234567891011121314151617181920Object.defineProperty(obj, prop, descriptor) obj：待修改的对象。prop：待修改的属性名称。descriptor：待修改属性的相关描述，要求传入一个对象。&#123; configurable: false, enumerable: false, writable: false, value: '', set: function()&#123;&#125;, get: function()&#123;&#125;&#125;- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ delete ），是否可以修改属性的 writable 、 enumerable 属性。- enumerable：属性是否可遍历出来（可通过 for...in 遍历到）。- writable：属性是否可重写（是否可以对属性进行重新赋值？）- value：属性的默认值。- set：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。 看个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243var obj = &#123;&#125;;//给obj对象赋予了一个属性name，值为jackObject.defineProperty(obj, 'name', &#123; value: 'jack'&#125;);//给obj对象赋予了一个属性age，值为100Object.defineProperty(obj, 'age', &#123; value: 100, configurable: true,//可配置 enumerable: true,//可遍历出来 writable: true//可写&#125;);console.log(obj.age); // 100obj.age = 18;//重写console.log(obj.age); // 18. 因为age属性是可重写的//遍历objfor(let key in obj)&#123; console.log(key+":"+obj[key]);//age:18，默认是不可配置的，所以name读不到&#125;//给obj对象赋予了一个属性sex，值为maleObject.defineProperty(obj, 'sex', &#123; value: 'male', writable: false&#125;);obj.sex = 'female'; // 不可重写console.log(obj.sex); // 'male'delete obj.sex; // 属性删除无效，默认是不可配置的console.log(obj.sex);// 'male'，依然可以读出Object.defineProperty(obj, 'weight', &#123;//value: '75kg',//如果打开这个value就会报错 set: function(str) &#123;console.log('set weight',str);&#125;, get:function()&#123;console.log('get weight');&#125;&#125;); 需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。下面就来看一下如何实现一个数据和视图双向绑定效果。123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;数据和视图联动&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt;测试用户名：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;&lt;div id="show"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;var userInfo = &#123;&#125;;Object.defineProperty(userInfo, "userName", &#123; get: function()&#123; return document.getElementById('show').innerHTML; &#125;, set: function(name)&#123; document.getElementById('show').innerHTML = name; &#125;&#125;);document.getElementById('userName').onkeyup = function(e)&#123;//改变数据，触发set方法，从而改变了视图。 userInfo.userName = this.value;&#125;;&lt;/script&gt; 运行效果： 3.对象简写es6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：12345678var obj = &#123; name:'jack', age:18, method() &#123; return this.name+'--'+this.age; &#125;&#125;;console.log(obj.method());]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试集锦]]></title>
    <url>%2Fblog%2F2018%2F05%2F24%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。 前言 一些更新从最新的开始 RactReact生命周期?React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁 初始化 1、getDefaultProps() 设置默认的props，也可以使用dufaultProps设置组件的默认属性2、getInitialState()在es6的class语法里是没有这个函数的，可直接在construction里去定义this.state也就可以访问到this.props3、compontentWillMount()整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改state值4、render 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了5、compontentDidMount() 组件渲染完成之后调用，且只调用一次 更新 6、componentWillReceiverProps(nextProps) 在组件初始化的时候不会触发，组件接收到新的props时触发7、shouldCompontUpdate(nextProps, nextState) 这里是React性能优化非常重要的生命周期。在组件接收到新的props或者state时可以触发这个生命周期，可以对比前后props和state是否一样，如果相同一样则返回false去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行diff算法对比，极大地节省性能。8、componentWillUpdate(nextProps, nextState) 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改state9、render() 渲染组件10、 componentDidUpdate() 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取dom节点 卸载 11、componentWillUnmount() 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等 React 面试题 &amp; 回答 原文README.md 目录 序号. 问题 Core React 1 什么是 React? 2 React 的主要特点是什么? 3 什么是 JSX? 4 元素和组件有什么区别? 5 如何在 React 中创建组件? 6 何时使用类组件和函数组件? 7 什么是 Pure Components? 8 React 的状态是什么? 9 React 中的 props 是什么? 10 状态和属性有什么区别? 11 我们为什么不能直接更新状态? 12 回调函数作为 setState() 参数的目的是什么? 13 HTML 和 React 事件处理有什么区别? 14 如何在 JSX 回调中绑定方法或事件处理程序? 15 如何将参数传递给事件处理程序或回调函数? 16 React 中的合成事件是什么? 17 什么是内联条件表达式? 18 什么是 “key” 属性，在元素数组中使用它们有什么好处? 19 refs 有什么用? 20 如何创建 refs? 21 什么是 forward refs? 22 callback refs 和 findDOMNode() 哪一个是首选选项? 23 为什么 String Refs 被弃用? 24 什么是 Virtual DOM? 25 Virtual DOM 如何工作? 26 Shadow DOM 和 Virtual DOM 之间有什么区别? 27 什么是 React Fiber? 28 React Fiber 的主要目标是什么? 29 什么是受控组件? 30 什么是非受控组件? 31 createElement 和 cloneElement 有什么区别? 32 在 React 中的提升状态是什么? 33 组件生命周期的不同阶段是什么? 34 React 生命周期方法有哪些? 35 什么是高阶组件（HOC）? 36 如何为高阶组件创建属性代理? 37 什么是上下文（Context）? 38 children 属性是什么? 39 怎样在 React 中写注释? 40 构造函数使用带 props 参数的目的是什么? 41 什么是调解? 42 如何使用动态属性名设置 state ? 43 每次组件渲染时调用函数的常见错误是什么? 44 为什么有组件名称要首字母大写? 45 为什么 React 使用 className 而不是 class 属性? 46 什么是 Fragments ? 47 为什么使用 Fragments 比使用容器 div 更好? 48 在 React 中什么是 Portal ? 49 什么是无状态组件? 50 什么是有状态组件? 51 在 React 中如何校验 props 属性? 52 React 的优点是什么? 53 React 的局限性是什么? 54 在 React v16 中的错误边界是什么? 55 在 React v15 中如何处理错误边界? 56 静态类型检查推荐的方法是什么? 57 react-dom 包的用途是什么? 58 react-dom 中 render 方法的目的是什么? 59 ReactDOMServer 是什么? 60 在 React 中如何使用 innerHTML? 61 如何在 React 中使用样式? 62 在 React 中事件有何不同? 63 如果在构造函数中使用 setState() 会发生什么? 64 索引作为键的影响是什么? 65 在 componentWillMount() 方法中使用 setState() 好吗? 66 如果在初始状态中使用 props 属性会发生什么? 67 如何有条件地渲染组件? 68 为什么在 DOM 元素上展开 props 需要小心? 69 在 React 中如何使用装饰器? 70 如何 memoize（记忆）组件? 71 如何实现 Server Side Rendering 或 SSR? 72 如何在 React 中启用生产模式? 73 什么是 CRA 及其好处? 74 在 mounting 阶段生命周期方法的执行顺序是什么? 75 在 React v16 中，哪些生命周期方法将被弃用? 76 生命周期方法 getDerivedStateFromProps() 的目的是什么? 77 生命周期方法 getSnapshotBeforeUpdate() 的目的是什么? 78 createElement() 和 cloneElement() 方法有什么区别? 79 推荐的组件命名方法是什么? 80 在组件类中方法的推荐顺序是什么? 81 什么是 switching 组件? 82 为什么我们需要将函数传递给 setState() 方法? 83 在 React 中什么是严格模式? 84 React Mixins 是什么? 85 为什么 isMounted() 是一个反模式，而正确的解决方案是什么? 86 React 中支持哪些指针事件? 87 为什么组件名称应该以大写字母开头? 88 在 React v16 中是否支持自定义 DOM 属性? 89 constructor 和 getInitialState 有什么区别? 90 是否可以在不调用 setState 方法的情况下，强制组件重新渲染? 91 在使用 ES6 类的 React 中 super() 和 super(props) 有什么区别? 92 在 JSX 中如何进行循环? 93 如何在 attribute 引号中访问 props 属性? 94 什么是 React proptype 数组? 95 如何有条件地应用样式类? 96 React 和 ReactDOM 之间有什么区别? 97 为什么 ReactDOM 从 React 分离出来? 98 如何使用 React label 元素? 99 如何合并多个内联的样式对象? 100 如何在调整浏览器大小时重新渲染视图? 101 setState() 和 replaceState() 方法之间有什么区别? 102 如何监听状态变化? 103 在 React 状态中删除数组元素的推荐方法是什么? 104 在 React 中是否可以不在页面上渲染 HTML 内容? 105 如何用 React 漂亮地显示 JSON? 106 为什么你不能更新 React 中的 props? 107 如何在页面加载时聚焦一个输入元素? 108 更新状态中的对象有哪些可能的方法? 109 为什么函数比对象更适合于 setState()? 110 我们如何在浏览器中找到当前正在运行的 React 版本? 111 在 create-react-app 项目中导入 polyfills 的方法有哪些? 112 如何在 create-react-app 中使用 https 而不是 http? 113 如何避免在 create-react-app 中使用相对路径导入? 114 如何为 React Router 添加 Google Analytics? 115 如何每秒更新一个组件? 116 如何将 vendor prefixes 应用于 React 中的内联样式? 117 如何使用 React 和 ES6 导入和导出组件? 118 为什么 React 组件名称必须以大写字母开头? 119 为什么组件的构造函数只被调用一次? 120 在 React 中如何定义常量? 121 在 React 中如何以编程方式触发点击事件? 122 在 React 中是否可以使用 async/await? 123 React 项目常见的文件结构是什么? 124 最流行的动画软件包是什么? 125 模块化样式文件有什么好处? 126 什么是 React 流行的特定 linters? 127 如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用? 128 什么是渲染属性? React Router 129 什么是 React Router? 130 React Router 与 history 库的区别? 131 在 React Router v4 中的&lt;Router&gt;组件是什么? 132 history 中的 push() 和 replace() 方法的目的是什么? 133 如何使用在 React Router v4 中以编程的方式进行导航? 134 如何在 React Router v4 中获取查询字符串参数? 135 为什么你会得到 “Router may have only one child element” 警告? 136 如何在 React Router v4 中将 params 传递给 history.push 方法? 137 如何实现默认页面或 404 页面? 138 如何在 React Router v4 上获取历史对象? 139 登录后如何执行自动重定向? React Internationalization 140 什么是 React Intl? 141 React Intl 的主要特性是什么? 142 在 React Intl 中有哪两种格式化方式? 143 在 React Intl 中如何使用&lt;FormattedMessage&gt;作为占位符使用? 144 如何使用 React Intl 访问当前语言环境? 145 如何使用 React Intl 格式化日期? React Testing 146 在 React 测试中什么是浅层渲染（Shallow Renderer）? 147 在 React 中 TestRenderer 包是什么? 148 ReactTestUtils 包的目的是什么? 149 什么是 Jest? 150 Jest 对比 Jasmine 有什么优势? 151 举一个简单的 Jest 测试用例 React Redux 152 什么是 Flux? 153 什么是 Redux? 154 Redux 的核心原则是什么？? 155 与 Flux 相比，Redux 的缺点是什么? 156 mapStateToProps() 和 mapDispatchToProps() 之间有什么区别? 157 我可以在 reducer 中触发一个 Action 吗? 158 如何在组件外部访问 Redux 存储的对象? 159 MVW 模式的缺点是什么? 160 Redux 和 RxJS 之间是否有任何相似之处? 161 如何在加载时触发 Action? 162 在 React 中如何使用 Redux 的 connect() ? 163 如何在 Redux 中重置状态? 164 Redux 中连接装饰器的 at 符号的目的是什么? 165 React 上下文和 React Redux 之间有什么区别? 166 为什么 Redux 状态函数称为 reducers ? 167 如何在 Redux 中发起 AJAX 请求? 168 我应该在 Redux Store 中保留所有组件的状态吗? 169 访问 Redux Store 的正确方法是什么? 170 React Redux 中展示组件和容器组件之间的区别是什么? 171 Redux 中常量的用途是什么? 172 编写 mapDispatchToProps() 有哪些不同的方法? 173 在 mapStateToProps() 和 mapDispatchToProps() 中使用 ownProps 参数有什么用? 174 如何构建 Redux 项目目录? 175 什么是 redux-saga? 176 redux-saga 的模型概念是什么? 177 在 redux-saga 中 call() 和 put() 之间有什么区别? 178 什么是 Redux Thunk? 179 redux-saga 和 redux-thunk 之间有什么区别? 180 什么是 Redux DevTools? 181 Redux DevTools 的功能有哪些? 182 什么是 Redux 选择器以及使用它们的原因? 183 什么是 Redux Form? 184 Redux Form 的主要功能有哪些? 185 如何向 Redux 添加多个中间件? 186 如何在 Redux 中设置初始状态? 187 Relay 与 Redux 有何不同? React Native 188 React Native 和 React 有什么区别? 189 如何测试 React Native 应用程序? 190 如何在 React Native 查看日志? 191 怎么调试 React Native 应用? React supported libraries &amp; Integration 192 什么是 Reselect 以及它是如何工作的? 193 什么是 Flow? 194 Flow 和 PropTypes 有什么区别? 195 在 React 中如何使用 Font Awesome 图标? 196 什么 是 React 开发者工具? 197 在 Chrome 中为什么 DevTools 没有加载本地文件? 198 如何在 React 中使用 Polymer? 199 与 Vue.js 相比，React 有哪些优势? 200 React 和 Angular 有什么区别? 201 为什么 React 选项卡不会显示在 DevTools 中? 202 什么是 Styled Components? 203 举一个 Styled Components 的例子? 204 什么是 Relay? 205 如何在 create-react-app 中使用 TypeScript? Miscellaneous 206 Reselect 库的主要功能有哪些? 207 举一个 Reselect 用法的例子? 208 Redux 中的 Action 是什么? 209 在 React 中 statics 对象是否能与 ES6 类一起使用? 210 Redux 只能与 React 一起使用么? 211 您是否需要使用特定的构建工具来使用 Redux ? 212 Redux Form 的 initialValues 如何从状态更新? 213 React 是如何为一个属性声明不同的类型? 214 我可以导入一个 SVG 文件作为 React 组件么? 215 为什么不建议使用内联引用回调或函数? 216 在 React 中什么是渲染劫持? 217 什么是 HOC 工厂实现? 218 如何传递数字给 React 组件? 219 我需要将所有状态保存到 Redux 中吗？我应该使用 react 的内部状态吗? 220 在 React 中 registerServiceWorker 的用途是什么? 221 React memo 函数是什么? 222 React lazy 函数是什么? 223 如何使用 setState 防止不必要的更新? 224 如何在 React 16 版本中渲染数组、字符串和数值? 225 如何在 React 类中使用类字段声明语法? 226 什么是 hooks? 227 Hooks 需要遵循什么规则? 228 如何确保钩子遵循正确的使用规则? 229 Flux 和 Redux 之间有什么区别? 230 React Router V4 有什么好处? 231 您能描述一下 componentDidCatch 生命周期方法签名吗? 232 在哪些情况下，错误边界不会捕获错误? 233 为什么事件处理器不需要错误边界? 234 try catch 与错误边界有什么区别? 235 React 16 中未捕获的错误的行为是什么? 236 放置错误边界的正确位置是什么? 237 从错误边界跟踪组件堆栈有什么好处? 238 在定义类组件时，什么是必须的方法? 239 render 方法可能返回的类型是什么? 240 构造函数的主要目的是什么? 241 是否必须为 React 组件定义构造函数? 242 什么是默认属性? 243 为什么不能在 componentWillUnmount 中调用 setState() 方法? 244 getDerivedStateFromError 的目的是什么? 245 当组件重新渲染时顺序执行的方法有哪些? 246 错误处理期间调用哪些方法? 247 displayName 类属性的用途是什么? 248 支持 React 应用程序的浏览器有哪一些? 249 unmountComponentAtNode 方法的目的是什么? 250 什么是代码拆分? 251 严格模式有什么好处? 252 什么是 Keyed Fragments ? 253 React 支持所有的 HTML 属性么? 254 HOC 有哪些限制? 255 如何在 DevTools 中调试 forwardRefs? 256 什么时候组件的 props 属性默认为 true? 257 什么是 NextJS 及其主要特征? 258 如何将事件处理程序传递给组件? 259 在渲染方法中使用箭头函数好么? 260 如何防止函数被多次调用? 261 JSX 如何防止注入攻击? 262 如何更新已渲染的元素? 263 你怎么说 props 是只读的? 264 你认为状态更新是如何合并的? 265 如何将参数传递给事件处理程序? 266 如何防止组件渲染? 267 安全地使用索引作为键的条件是什么? 268 keys 是否需要全局唯一? 269 用于表单处理的流行选择是什么? 270 formik 相对于其他 redux 表单库有什么优势? 271 为什么不需要使用继承? 272 我可以在 React 应用程序中可以使用 web components 么? 273 什么是动态导入? 274 什么是 loadable 组件? 275 什么是 suspense 组件? 276 什么是基于路由的代码拆分? 277 举例说明如何使用 context? 278 在 context 中默认值的目的是什么? 279 你是怎么使用 contextType? 280 什么是 consumer? 281 在使用 context 时，如何解决性能方面的问题? 282 在 HOCs 中 forward ref 的目的是什么? 283 ref 参数对于所有函数或类组件是否可用? 284 在组件库中当使用 forward refs 时，你需要额外的注意? 285 如何在没有 ES6 的情况下创建 React 类组件 286 是否可以在没有 JSX 的情况下使用 React? 287 什么是差异算法? 288 差异算法涵盖了哪些规则? 289 你什么时候需要使用 refs? 290 对于渲染属性来说是否必须将 prop 属性命名为 render? 291 在 Pure Component 中使用渲染属性会有什么问题? 292 如何使用渲染属性创建 HOC? 293 什么是 windowing 技术? 294 你如何在 JSX 中打印 falsy 值? 295 portals 的典型使用场景是什么? 296 如何设置非受控组件的默认值? 297 你最喜欢的 React 技术栈是什么? 298 Real DOM 和 Virtual DOM 有什么区别? 299 如何为 React 应用程序添加 bootstrap? 300 你能否列出使用 React 作为前端框架的顶级网站或应用程序? 301 是否建议在 React 中使用 CSS In JS 技术? Core React 什么是 React? React 是一个开源前端 JavaScript 库，用于构建用户界面，尤其是单页应用程序。它用于处理网页和移动应用程序的视图层。React 是由 Facebook 的软件工程师 Jordan Walke 创建的。在 2011 年 React 应用首次被部署到 Facebook 的信息流中，之后于 2012 年被应用到 Instagram 上。 阅读资源： React 中文文档 掘金 - 图解 React 掘金 - 200行代码实现简版react *⬆ 返回目录 React 的主要特点是什么? React 的主要特性有： 考虑到真实的 DOM 操作成本很高，它使用 VirtualDOM 而不是真实的 DOM。 支持服务端渲染。 遵循单向数据流或数据绑定。 使用可复用/可组合的 UI 组件开发视图。 ⬆ 返回顶部 什么是 JSX? JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 React.createElement() 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。 在下面的示例中，&lt;h1&gt; 内的文本标签会作为 JavaScript 函数返回给渲染函数。 123456789class App extends React.Component &#123; render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;'Welcome to React world!'&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 以上示例 render 方法中的 JSX 将会被转换为以下内容： 12React.createElement("div", null, React.createElement( "h1", null, 'Welcome to React world!')); 这里你可以访问 Babeljs 在线体验一下。 阅读资源： 从零开始实现一个React（一）：JSX和虚拟DOM ⬆ 返回顶部 元素和组件有什么区别? 一个 Element 是一个简单的对象，它描述了你希望在屏幕上以 DOM 节点或其他组件的形式呈现的内容。Elements 在它们的属性中可以包含其他 Elements。创建一个 React 元素是很轻量的。一旦元素被创建后，它将不会被修改。 React Element 的对象表示如下： 12345const element = React.createElement( 'div', &#123;id: 'login-btn'&#125;, 'Login') 上面的 React.createElement() 函数会返回一个对象。 1234567&#123; type: &apos;div&apos;, props: &#123; children: &apos;Login&apos;, id: &apos;login-btn&apos; &#125;&#125; 最后使用 ReactDOM.render() 方法渲染到 DOM： 1&lt;div id='login-btn'&gt;Login&lt;/div&gt; 而一个组件可以用多种不同方式声明。它可以是一个含有 render() 方法的类。或者，在简单的情况中，它可以定义为函数。无论哪种情况，它都将 props 作为输入，并返回一个 JSX 树作为输出： 12const Button = (&#123; onLogin &#125;) =&gt; &lt;div id=&#123;'login-btn'&#125; onClick=&#123;onLogin&#125; /&gt; 然后 JSX 被转换成 React.createElement() 函数： 12345const Button = (&#123; onLogin &#125;) =&gt; React.createElement( 'div', &#123; id: 'login-btn', onClick: onLogin &#125;, 'Login') ⬆ 返回顶部 如何在 React 中创建组件? 有两种可行的方法来创建一个组件： Function Components: 这是创建组件最简单的方式。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素： 123function Greeting(&#123; message &#125;) &#123; return &lt;h1&gt;&#123;`Hello, $&#123;message&#125;`&#125;&lt;/h1&gt;&#125; Class Components: 你还可以使用 ES6 类来定义组件。上面的函数组件若使用 ES6 的类可改写为： 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;&#123;`Hello, $&#123;this.props.message&#125;`&#125;&lt;/h1&gt; &#125;&#125; ⬆ 返回顶部 何时使用类组件和函数组件? 如果组件需要使用状态或生命周期方法，那么使用类组件，否则使用函数组件。 ⬆ 返回顶部 什么是 Pure Components? React.PureComponent 与 React.Component 完全相同，只是它为你处理了 shouldComponentUpdate() 方法。当属性或状态发生变化时，PureComponent 将对属性和状态进行浅比较。另一方面，一般的组件不会将当前的属性和状态与新的属性和状态进行比较。因此，在默认情况下，每当调用 shouldComponentUpdate 时，默认返回 true，所以组件都将重新渲染。 ⬆ 返回顶部 React 的状态是什么? 组件的状态是一个对象，它包含某些信息，这些信息可能在组件的生命周期中发生更改。我们应该尽量使状态尽可能简单，并尽量减少有状态组件的数量。让我们创建一个包含消息状态的 User 组件： 1234567891011121314151617class User extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; message: 'Welcome to React world' &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.message&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 状态（State）与属性（Props）类似，但它是私有的，完全由组件控制。也就是说，除了它所属的组件外，任何组件都无法访问它。 ⬆ 返回顶部 React 中的 props 是什么? Props 是组件的输入。它们是单个值或包含一组值的对象，这些值在创建时使用类似于 HTML 标记属性的命名约定传递给组件。它们是从父组件传递到子组件的数据。 Props 的主要目的是提供以下组件功能： 将自定义数据传递到组件。 触发状态更改。 在组件的 render() 方法中通过 this.props.reactProp 使用。 例如，让我们使用 reactProp 属性创建一个元素： 1&lt;Element reactProp=&#123;'1'&#125; /&gt; 然后，reactProp 将成为附加到 React props 对象的属性，该对象最初已存在于使用 React 库创建的所有组件上。 1props.reactProp ⬆ 返回顶部 状态和属性有什么区别?state 和 props 都是普通的 JavaScript 对象。虽然它们都保存着影响渲染输出的信息，但它们在组件方面的功能不同。Props 以类似于函数参数的方式传递给组件，而状态则类似于在函数内声明变量并对它进行管理。 States vs Props | Conditions | States | Props || ——————– | —— | —– || 可从父组件接收初始值 | 是 | 是 || 可在父组件中改变其值 | 否 | 是 || 在组件内设置默认值 | 是 | 是 || 在组件内可改变 | 是 | 否 || 可作为子组件的初始值 | 是 | 是 | ⬆ 返回顶部 我们为什么不能直接更新状态?如果你尝试直接改变状态，那么组件将不会重新渲染。 12//Wrongthis.state.message = 'Hello world' 正确方法应该是使用 setState() 方法。它调度组件状态对象的更新。当状态更改时，组件通将会重新渲染。 12//Correctthis.setState(&#123; message: 'Hello World' &#125;) 注意： 你可以在 constructor 中或使用最新的 JavaScript 类属性声明语法直接设置状态对象。 ⬆ 返回顶部 回调函数作为 setState() 参数的目的是什么?当 setState 完成和组件渲染后，回调函数将会被调用。由于 setState() 是异步的，回调函数用于任何后续的操作。 注意： 建议使用生命周期方法而不是此回调函数。 1setState(&#123; name: 'John' &#125;, () =&gt; console.log('The name has updated and component re-rendered')) 阅读资源： 掘金 - 揭密React setState ⬆ 返回顶部 HTML 和 React 事件处理有什么区别? 在 HTML 中事件名必须小写: 1&lt;button onclick='activateLasers()'&gt; 而在 React 中它遵循 camelCase (驼峰) 惯例： 1&lt;button onClick=&#123;activateLasers&#125;&gt; 在 HTML 中你可以返回 false 以阻止默认的行为： 1&lt;a href='#' onclick='console.log("The link was clicked."); return false;' /&gt; 而在 React 中你必须地明确地调用 preventDefault() ： 1234function handleClick(event) &#123; event.preventDefault() console.log('The link was clicked.')&#125; ⬆ 返回顶部 如何在 JSX 回调中绑定方法或事件处理程序?实现这一点有三种可能的方法： Binding in Constructor: 在 JavaScript 类中，方法默认不被绑定。这也适用于定义为类方法的 React 事件处理程序。通常我们在构造函数中绑定它们。 12345678910class Component extends React.Componenet &#123; constructor(props) &#123; super(props) this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; // ... &#125;&#125; Public class fields syntax: 如果你不喜欢 bind 方案，则可以使用 public class fields syntax 正确绑定回调。 123handleClick = () =&gt; &#123; console.log('this is:', this)&#125; 123&lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;'Click me'&#125;&lt;/button&gt; Arrow functions in callbacks: 你可以在回调函数中直接使用 arrow functions。 123&lt;button onClick=&#123;(event) =&gt; this.handleClick(event)&#125;&gt; &#123;'Click me'&#125;&lt;/button&gt; 注意： 如果回调函数作为属性传给子组件，那么这些组件可能触发一个额外的重新渲染。在这些情况下，考虑到性能，最好使用 .bind() 或 public class fields syntax 方案。 ⬆ 返回顶部 如何将参数传递给事件处理程序或回调函数?你可以使用箭头函数来包装事件处理器并传递参数： 1&lt;button onClick=&#123;() =&gt; this.handleClick(id)&#125; /&gt; 这相当于调用 .bind: 1&lt;button onClick=&#123;this.handleClick.bind(this, id)&#125; /&gt; ⬆ 返回顶部 React 中的合成事件是什么?SyntheticEvent 是对浏览器原生事件的跨浏览器包装。它的 API 与浏览器的原生事件相同，包括 stopPropagation() 和 preventDefault()，除了事件在所有浏览器中的工作方式相同。 ⬆ 返回顶部 什么是内联条件表达式?在 JS 中你可以使用 if 语句或三元表达式，来实现条件判断。除了这些方法之外，你还可以在 JSX 中嵌入任何表达式，方法是将它们用大括号括起来，然后再加上 JS 逻辑运算符 &amp;&amp;。 1234567891011&lt;h1&gt;Hello!&lt;/h1&gt;&#123; messages.length &gt; 0 &amp;&amp; !isLogin ? &lt;h2&gt; You have &#123;messages.length&#125; unread messages. &lt;/h2&gt; : &lt;h2&gt; You don't have unread messages. &lt;/h2&gt;&#125; 当然如果只是想判断 if，可以如下直接判断： 123&#123; isLogin &amp;&amp; &lt;span&gt;Your have been login!&lt;/span&gt;&#125; 在上面的代码中，不需要使用`isLogin ? &lt;span&gt;Your have been login!&lt;/span&gt; : null`这样的形式。 **[⬆ 返回顶部](#目录)** 什么是 “key” 属性，在元素数组中使用它们有什么好处?key 是一个特殊的字符串属性，你在创建元素数组时需要包含它。Keys 帮助 React 识别哪些项已更改、添加或删除。 我们通常使用数据中的 IDs 作为 keys: 12345const todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;) 在渲染列表项时，如果你没有稳定的 IDs，你可能会使用 index 作为 key： 12345const todoItems = todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;) 注意： 由于列表项的顺序可能发生改变，因此并不推荐使用 indexes 作为 keys。这可能会对性能产生负面影响，并可能导致组件状态出现问题。 如果将列表项提取为单独的组件，则在列表组件上应用 keys 而不是 li 标签。 如果在列表项中没有设置 key 属性，在控制台会显示警告消息。 ⬆ 返回顶部 refs 有什么用?ref 用于返回对元素的引用。但在大多数情况下，应该避免使用它们。当你需要直接访问 DOM 元素或组件的实例时，它们可能非常有用。 如何创建 refs?这里有两种方案 这是最近增加的一种方案。Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用refs，只需将 ref 分配给构造函数中的实例属性。 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.myRef = React.createRef() &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt; &#125;&#125; 你也可以使用 ref 回调函数的方案，而不用考虑 React 版本。例如，访问搜索栏组件中的 input 元素如下： 1234567891011121314151617181920212223class SearchBar extends Component &#123; constructor(props) &#123; super(props); this.txtSearch = null; this.state = &#123; term: '' &#125;; this.setInputSearchRef = e =&gt; &#123; this.txtSearch = e; &#125; &#125; onInputChange(event) &#123; this.setState(&#123; term: this.txtSearch.value &#125;); &#125; render() &#123; return ( &lt;input value=&#123;this.state.term&#125; onChange=&#123;this.onInputChange.bind(this)&#125; ref=&#123;this.setInputSearchRef&#125; /&gt; ); &#125;&#125; 你也可以在使用 closures 的函数组件中使用 refs。 注意： 你也可以使用内联引用回调，尽管这不是推荐的方法。 ⬆ 返回顶部 什么是 forward refs?Ref forwarding 是一个特性，它允许一些组件获取接收到 ref 对象并将它进一步传递给子组件。 123456789const ButtonElement = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className="CustomButton"&gt; &#123;props.children&#125; &lt;/button&gt;));// Create ref to the DOM button:const ref = React.createRef();&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;'Forward Ref'&#125;&lt;/ButtonElement&gt; ⬆ 返回顶部 callback refs 和 findDOMNode() 哪一个是首选选项?最好是使用 callback refs 而不是 findDOMNode() API。因为 findDOMNode() 阻碍了将来对 React 的某些改进。 使用 findDOMNode 已弃用的方案： 123456789class MyComponent extends Component &#123; componentDidMount() &#123; findDOMNode(this).scrollIntoView() &#125; render() &#123; return &lt;div /&gt; &#125;&#125; 推荐的方案是： 123456789class MyComponent extends Component &#123; componentDidMount() &#123; this.node.scrollIntoView() &#125; render() &#123; return &lt;div ref=&#123;node =&gt; this.node = node&#125; /&gt; &#125;&#125; ⬆ 返回顶部 为什么 String Refs 被弃用?如果你以前使用过 React，你可能会熟悉旧的 API，其中的 ref 属性是字符串，如 ref={&#39;textInput&#39;}，并且 DOM 节点的访问方式为this.refs.textInput。我们建议不要这样做，因为字符串引用有以下问题，并且被认为是遗留问题。字符串 refs 在 React v16 版本中被移除。 它们强制 React 跟踪当前执行的组件。这是有问题的，因为它使 React 模块有状态，这会导致在 bundle 中复制 React 模块时会导致奇怪的错误。 它们是不可组合的 - 如果一个库把一个 ref 传给子元素，则用户无法对其设置另一个引用。 它们不能与静态分析工具一起使用，如 Flow。Flow 无法猜测出 this.refs 上的字符串引用的作用及其类型。Callback refs 对静态分析更友好。 使用 “render callback” 模式（比如： ），它无法像大多数人预期的那样工作。 12345678910111213class MyComponent extends Component &#123; renderRow = (index) =&gt; &#123; // This won't work. Ref will get attached to DataTable rather than MyComponent: return &lt;input ref=&#123;'input-' + index&#125; /&gt;; // This would work though! Callback refs are awesome. return &lt;input ref=&#123;input =&gt; this['input-' + index] = input&#125; /&gt;; &#125; render() &#123; return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt; &#125;&#125; ⬆ 返回顶部 什么是 Virtual DOM?Virtual DOM (VDOM) 是 Real DOM 的内存表示形式。UI 的展示形式被保存在内存中并与真实的 DOM 同步。这是在调用的渲染函数和在屏幕上显示元素之间发生的一个步骤。整个过程被称为 reconciliation。 Real DOM vs Virtual DOM | Real DOM | Virtual DOM || :————————–: | :———————-: || 更新较慢 | 更新较快 || 可以直接更新 HTML | 无法直接更新 HTML || 如果元素更新，则创建新的 DOM | 如果元素更新，则更新 JSX || DOM 操作非常昂贵 | DOM 操作非常简单 || 较多的内存浪费 | 没有内存浪费 | 阅读资源： 知乎 - 如何理解虚拟DOM? edureka - react-interview-questions ⬆ 返回顶部 Virtual DOM 如何工作?Virtual DOM 分为三个简单的步骤。 每当任何底层数据发生更改时，整个 UI 都将以 Virtual DOM 的形式重新渲染。 然后计算先前 Virtual DOM 对象和新的 Virtual DOM 对象之间的差异。 一旦计算完成，真实的 DOM 将只更新实际更改的内容。 ⬆ 返回顶部 Shadow DOM 和 Virtual DOM 之间有什么区别?Shadow DOM 是一种浏览器技术，它解决了构建网络应用的脆弱性问题。Shadow DOM 修复了 CSS 和 DOM。它在网络平台中引入作用域样式。 无需工具或命名约定，你即可使用原生 JavaScript 捆绑 CSS 和标记、隐藏实现详情以及编写独立的组件。Virtual DOM 是一个由 JavaScript 库在浏览器 API 之上实现的概念。 ⬆ 返回顶部 什么是 React Fiber?Fiber 是 React v16 中新的 reconciliation 引擎，或核心算法的重新实现。React Fiber 的目标是提高对动画，布局，手势，暂停，中止或者重用任务的能力及为不同类型的更新分配优先级，及新的并发原语等领域的适用性。 ⬆ 返回顶部 React Fiber 的主要目标是什么?React Fiber 的目标是提高其在动画、布局和手势等领域的适用性。它的主要特性是 incremental rendering: 将渲染任务拆分为小的任务块并将任务分配到多个帧上的能力。 ⬆ 返回顶部 什么是受控组件?在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，即每个状态更改都有一个相关联的处理程序。 例如，我们使用下面的 handleChange 函数将输入框的值转换成大写： 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;)&#125; ⬆ 返回顶部 什么是非受控组件?非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。 在下面的 UserProfile 组件中，我们通过 ref 引用 name 输入框： 123456789101112131415161718192021222324class UserProfile extends React.Component &#123; constructor(props) &#123; super(props) this.handleSubmit = this.handleSubmit.bind(this) this.input = React.createRef() &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.input.current.value) event.preventDefault() &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; &#123;'Name:'&#125; &lt;input type="text" ref=&#123;this.input&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt; ); &#125;&#125; 在大多数情况下，建议使用受控组件来实现表单。 ⬆ 返回顶部 createElement 和 cloneElement 有什么区别?JSX 元素将被转换为 React.createElement() 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 cloneElement 用于克隆元素并传递新的属性。 ⬆ 返回顶部 在 React 中的提升状态是什么?当多个组件需要共享相同的更改数据时，建议将共享状态提升到最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移动到父组件，而不是在两个子组件中维护局部状态。 ⬆ 返回顶部 组件生命周期的不同阶段是什么?组件生命周期有三个不同的生命周期阶段： Mounting: 组件已准备好挂载到浏览器的 DOM 中. 此阶段包含来自 constructor(), getDerivedStateFromProps(), render(), 和 componentDidMount() 生命周期方法中的初始化过程。 Updating: 在此阶段，组件以两种方式更新，发送新的属性并使用 setState() 或 forceUpdate() 方法更新状态. 此阶段包含 getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() 和 componentDidUpdate() 生命周期方法。 Unmounting: 在这个最后阶段，不需要组件，它将从浏览器 DOM 中卸载。这个阶段包含 componentWillUnmount() 生命周期方法。 值得一提的是，在将更改应用到 DOM 时，React 内部也有阶段概念。它们按如下方式分隔开： Render 组件将会进行无副作用渲染。这适用于纯组件（Pure Component），在此阶段，React 可以暂停，中止或重新渲染。 Pre-commit 在组件实际将更改应用于 DOM 之前，有一个时刻允许 React 通过getSnapshotBeforeUpdate()捕获一些 DOM 信息（例如滚动位置）。 Commit React 操作 DOM 并分别执行最后的生命周期： componentDidMount() 在 DOM 渲染完成后调用, componentDidUpdate() 在组件更新时调用, componentWillUnmount() 在组件卸载时调用。React 16.3+ 阶段 (也可以看交互式版本) React 16.3 之前 ⬆ 返回顶部 React 生命周期方法有哪些?React 16.3+ getDerivedStateFromProps: 在调用render()之前调用，并在 每次 渲染时调用。 需要使用派生状态的情况是很罕见得。值得阅读 如果你需要派生状态. componentDidMount: 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。 shouldComponentUpdate: 确定组件是否应该更新。 默认情况下，它返回true。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回false值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。 getSnapshotBeforeUpdate: 在最新的渲染输出提交给 DOM 前将会立即调用，这对于从 DOM 捕获信息（比如：滚动位置）很有用。 componentDidUpdate: 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果shouldComponentUpdate()返回false，则不会触发。 componentWillUnmount 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。 Before 16.3 componentWillMount: 在组件render()前执行，用于根组件中的应用程序级别配置。应该避免在该方法中引入任何的副作用或订阅。 componentDidMount: 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。 componentWillReceiveProps: 在组件接收到新属性前调用，若你需要更新状态响应属性改变（例如，重置它），你可能需对比this.props和nextProps并在该方法中使用this.setState()处理状态改变。 shouldComponentUpdate: 确定组件是否应该更新。 默认情况下，它返回true。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回false值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。 componentWillUpdate: 当shouldComponentUpdate返回true后重新渲染组件之前执行，注意你不能在这调用this.setState() componentDidUpdate: 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果shouldComponentUpdate()返回false，则不会触发。 componentWillUnmount: 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。 ⬆ 返回顶部 什么是高阶组件（HOC）?高阶组件(HOC) 就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种模式，这种模式是由react自身的组合性质必然产生的。 我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。 1const EnhancedComponent = higherOrderComponent(WrappedComponent) HOC 有很多用例： 代码复用，逻辑抽象化 渲染劫持 抽象化和操作状态（state） 操作属性（props） 译注：更详细用法请参考高阶组件的使用 ⬆ 返回顶部 如何为高阶组件创建属性代理?你可以使用属性代理模式向输入组件增加或编辑属性（props）： 1234567891011121314function HOC(WrappedComponent) &#123; return class Test extends Component &#123; render() &#123; const newProps = &#123; title: 'New Header', footer: false, showFeatureX: false, showFeatureY: true &#125;; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt; &#125; &#125;&#125; ⬆ 返回顶部 什么是上下文（Context）?Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递props。比如，需要在应用中许多组件需要访问登录用户信息、地区偏好、UI主题等。 123456789101112131415161718192021222324252627282930// 创建一个 theme Context, 默认 theme 的值为 lightconst ThemeContext = React.createContext('light');function ThemedButton(props) &#123; // ThemedButton 组件从 context 接收 theme return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125;// 中间组件function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value="dark"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; ⬆ 返回顶部 children 属性是什么?Children 是一个属性（this.props.chldren），它允许你将组件作为数据传递给其他组件，就像你使用的任何其他组件一样。在组件的开始和结束标记之间放置的组件树将作为children属性传递给该组件。 React API 中有许多方法中提供了这个不透明数据结构的方法，包括：React.Children.map、React.Children.forEach、React.Children.count、React.Children.only、React.Children.toArray。 12345678910111213const MyDiv = React.createClass(&#123; render: function() &#123; return &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &#125;&#125;)ReactDOM.render( &lt;MyDiv&gt; &lt;span&gt;&#123;'Hello'&#125;&lt;/span&gt; &lt;span&gt;&#123;'World'&#125;&lt;/span&gt; &lt;/MyDiv&gt;, node) ⬆ 返回顶部 怎样在 React 中写注释?React/JSX 中的注释类似于 JavaScript 的多行注释，但是是用大括号括起来。 单行注释： 1234&lt;div&gt; &#123;/* 单行注释（在原生 JavaScript 中，单行注释用双斜杠（//）表示） */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;&lt;/div&gt; 多行注释： 12345&lt;div&gt; &#123;/* 多行注释超过 一行 */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;&lt;/div&gt; ⬆ 返回顶部 构造函数使用带 props 参数的目的是什么?在调用super()方法之前，子类构造函数不能使用this引用。这同样适用于ES6子类。将props参数传递给super()的主要原因是为了在子构造函数中访问this.props。 带 props 参数: 1234567class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) console.log(this.props) // prints &#123; name: 'John', age: 42 &#125; &#125;&#125; 不带 props 参数: 123456789101112131415class MyComponent extends React.Component &#123; constructor(props) &#123; super() console.log(this.props) // prints undefined // but props parameter is still available console.log(props) // prints &#123; name: 'John', age: 42 &#125; &#125; render() &#123; // no difference outside constructor console.log(this.props) // prints &#123; name: 'John', age: 42 &#125; &#125;&#125; 上面的代码片段显示this.props仅在构造函数中有所不同。 它在构造函数之外是相同的。 ⬆ 返回顶部 什么是调解?当组件的props或state发生更改时，React 通过将新返回的元素与先前呈现的元素进行比较来确定是否需要实际的 DOM 更新。当它们不相等时，React 将更新 DOM 。此过程称为reconciliation。 ⬆ 返回顶部 如何使用动态属性名设置 state ?如果你使用 ES6 或 Babel 转换器来转换你的 JSX 代码，那么你可以使用计算属性名称来完成此操作。 123handleInputChange(event) &#123; this.setState(&#123; [event.target.id]: event.target.value &#125;)&#125; ⬆ 返回顶部 每次组件渲染时调用函数的常见错误是什么?你需要确保在将函数作为参数传递时未调用该函数。 1234render() &#123; // Wrong: handleClick is called instead of passed as a reference! return &lt;button onClick=&#123;this.handleClick()&#125;&gt;&#123;'Click Me'&#125;&lt;/button&gt;&#125; 相反地，传递函数本身应该没有括号： 1234render() &#123; // Correct: handleClick is passed as a reference! return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;'Click Me'&#125;&lt;/button&gt;&#125; ⬆ 返回顶部 为什么有组件名称要首字母大写?这是必要的，因为组件不是 DOM 元素，它们是构造函数。 此外，在 JSX 中，小写标记名称是指 HTML 元素，而不是组件。 ⬆ 返回顶部 为什么 React 使用 className 而不是 class 属性?class 是 JavaScript 中的关键字，而 JSX 是 JavaScript 的扩展。这就是为什么 React 使用 className 而不是 class 的主要原因。传递一个字符串作为 className 属性。 123render() &#123; return &lt;span className=&#123;'menu navigation-menu'&#125;&gt;&#123;'Menu'&#125;&lt;/span&gt;&#125; 在实际项目中，我们经常使用classnames来方便我们操作className。 ⬆ 返回顶部 什么是 Fragments ?它是 React 中的常见模式，用于组件返回多个元素。Fragments 可以让你聚合一个子元素列表，而无需向 DOM 添加额外节点。 123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; )&#125; 以下是简洁语法，但是在一些工具中还不支持： 123456789render() &#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; )&#125; 译注：React 16 以前，render 函数的返回必须有一个根节点，否则报错。 ⬆ 返回顶部 为什么使用 Fragments 比使用容器 div 更好? 通过不创建额外的 DOM 节点，Fragments 更快并且使用更少的内存。这在非常大而深的节点树时很有好处。 一些 CSS 机制如Flexbox和CSS Grid具有特殊的父子关系，如果在中间添加 div 将使得很难保持所需的结构。 在 DOM 审查器中不会那么的杂乱。 ⬆ 返回顶部 在 React 中什么是 Portal ?Portal 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。 1ReactDOM.createPortal(child, container) 第一个参数是任何可渲染的 React 子节点，例如元素，字符串或片段。第二个参数是 DOM 元素。 ⬆ 返回顶部 什么是无状态组件?如果行为独立于其状态，则它可以是无状态组件。你可以使用函数或类来创建无状态组件。但除非你需要在组件中使用生命周期钩子，否则你应该选择函数组件。无状态组件有很多好处： 它们易于编写，理解和测试，速度更快，而且你可以完全避免使用this关键字。 ⬆ 返回顶部 什么是有状态组件?如果组件的行为依赖于组件的state，那么它可以被称为有状态组件。这些有状态组件总是类组件，并且具有在constructor中初始化的状态。 12345678910class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; render() &#123; // ... &#125;&#125; ⬆ 返回顶部 在 React 中如何校验 props 属性?当应用程序以开发模式运行的时，React 将会自动检查我们在组件上设置的所有属性，以确保它们具有正确的类型。如果类型不正确，React 将在控制台中生成警告信息。由于性能影响，它在生产模式下被禁用。使用 isRequired 定义必填属性。 预定义的 prop 类型： PropTypes.number PropTypes.string PropTypes.array PropTypes.object PropTypes.func PropTypes.node PropTypes.element PropTypes.bool PropTypes.symbol PropTypes.any 我们可以为 User 组件定义 propTypes，如下所示： 123456789101112131415161718import React from 'react'import PropTypes from 'prop-types'class User extends React.Component &#123; static propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired &#125; render() &#123; return ( &lt;&gt; &lt;h1&gt;&#123;`Welcome, $&#123;this.props.name&#125;`&#125;&lt;/h1&gt; &lt;h2&gt;&#123;`Age, $&#123;this.props.age&#125;`&#125;&lt;/h2&gt; &lt;/&gt; ) &#125;&#125; 注意: 在 React v15.5 中，PropTypes 从 React.PropTypes 被移动到 prop-types 库中。 ⬆ 返回顶部 React 的优点是什么? 使用 Virtual DOM 提高应用程序的性能。 JSX 使代码易于读写。 它支持在客户端和服务端渲染。 易于与框架（Angular，Backbone）集成，因为它只是一个视图库。 使用 Jest 等工具轻松编写单元与集成测试。 ⬆ 返回顶部 React 的局限性是什么? React 只是一个视图库，而不是一个完整的框架。 对于 Web 开发初学者来说，有一个学习曲线。 将 React 集成到传统的 MVC 框架中需要一些额外的配置。 代码复杂性随着内联模板和 JSX 的增加而增加。 太多较小的组件导致过度工程化或样板文件。 ⬆ 返回顶部 在 React v16 中的错误边界是什么?错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。 如果一个类组件定义了一个名为 componentDidCatch(error, info) 或 static getDerivedStateFromError() 新的生命周期方法，则该类组件将成为错误边界： 123456789101112131415161718192021222324class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; hasError: false &#125; &#125; componentDidCatch(error, info) &#123; // You can also log the error to an error reporting service logErrorToMyService(error, info) &#125; static getDerivedStateFromError(error) &#123; // Update state so the next render will show the fallback UI. return &#123; hasError: true &#125;; &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;&#123;'Something went wrong.'&#125;&lt;/h1&gt; &#125; return this.props.children &#125;&#125; 之后，将其作为常规组件使用： 123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; ⬆ 返回顶部 在 React v15 中如何处理错误边界?React v15 使用 unstable_handleError 方法为错误边界提供了非常基础的支持。已在 React v16 中，将其重命名为componentDidCatch。 ⬆ 返回顶部 静态类型检查推荐的方法是什么?通常，我们使用 PropTypes 库（在 React v15.5 之后 React.PropTypes 被移动到了 prop-types 包中），在 React 应用程序中执行类型检查。对于大型项目，建议使用静态类型检查器，比如 Flow 或 TypeScript，它们在编译时执行类型检查并提供 auto-completion 功能。 ⬆ 返回顶部 react-dom 包的用途是什么?react-dom 包提供了特定的 DOM 方法，可以在应用程序的顶层使用。大多数的组件不需要使用此模块。该模块中提供的一些方法如下： render() hydrate() unmountComponentAtNode() findDOMNode() createPortal() ⬆ 返回顶部 react-dom 中 render 方法的目的是什么?此方法用于将 React 元素渲染到所提供容器中的 DOM 结构中，并返回对组件的引用。如果 React 元素之前已被渲染到容器中，它将对其执行更新，并且只在需要时改变 DOM 以反映最新的更改。 1ReactDOM.render(element, container[, callback]) 如果提供了可选的回调函数，该函数将在组件被渲染或更新后执行。 ⬆ 返回顶部 ReactDOMServer 是什么?ReactDOMServer 对象使你能够将组件渲染为静态标记（通常用于 Node 服务器中），此对象主要用于服务端渲染（SSR）。以下方法可用于服务器和浏览器环境： renderToString() renderToStaticMarkup() 例如，你通常运行基于 Node 的 Web 服务器，如 Express，Hapi 或 Koa，然后你调用 renderToString 将根组件渲染为字符串，然后作为响应进行发送。 1234567891011// using Expressimport &#123; renderToString &#125; from 'react-dom/server'import MyPage from './MyPage'app.get('/', (req, res) =&gt; &#123; res.write('&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;') res.write('&lt;div id="content"&gt;') res.write(renderToString(&lt;MyPage/&gt;)) res.write('&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;') res.end()&#125;) ⬆ 返回顶部 在 React 中如何使用 innerHTML?dangerouslySetInnerHTML 属性是 React 用来替代在浏览器 DOM 中使用 innerHTML。与 innerHTML 一样，考虑到跨站脚本攻击（XSS），使用此属性也是有风险的。使用时，你只需传递以 __html 作为键，而 HTML 文本作为对应值的对象。 在本示例中 MyComponent 组件使用 dangerouslySetInnerHTML 属性来设置 HTML 标记： 1234567function createMarkup() &#123; return &#123; __html: 'First &amp;middot; Second' &#125;&#125;function MyComponent() &#123; return &lt;div dangerouslySetInnerHTML=&#123;createMarkup()&#125; /&gt;&#125; ⬆ 返回顶部 如何在 React 中使用样式?style 属性接受含有 camelCased（驼峰）属性的 JavaScript 对象，而不是 CSS 字符串。这与 DOM 样式中的 JavaScript 属性一致，效率更高，并且可以防止 XSS 安全漏洞。 12345678const divStyle = &#123; color: 'blue', backgroundImage: 'url(' + imgUrl + ')'&#125;;function HelloWorldComponent() &#123; return &lt;div style=&#123;divStyle&#125;&gt;Hello World!&lt;/div&gt;&#125; 为了与在 JavaScript 中访问 DOM 节点上的属性保持一致，样式键采用了 camelcased（例如node.style.backgroundImage）。 ⬆ 返回顶部 在 React 中事件有何不同?处理 React 元素中的事件有一些语法差异： React 事件处理程序是采用驼峰而不是小写来命名的。 使用 JSX，你将传递一个函数作为事件处理程序，而不是字符串。 ⬆ 返回顶部 如果在构造函数中使用 setState() 会发生什么?当你使用 setState() 时，除了设置状态对象之外，React 还会重新渲染组件及其所有的子组件。你会得到这样的错误：Can only update a mounted or mounting component.。因此我们需要在构造函数中使用 this.state 初始化状态。 ⬆ 返回顶部 索引作为键的影响是什么?Keys 应该是稳定的，可预测的和唯一的，这样 React 就能够跟踪元素。 在下面的代码片段中，每个元素的键将基于列表项的顺序，而不是绑定到即将展示的数据上。这将限制 React 能够实现的优化。 123456&#123;todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;)&#125; 假设 todo.id 对此列表是唯一且稳定的，如果将此数据作为唯一键，那么 React 将能够对元素进行重新排序，而无需重新创建它们。 1234&#123;todos.map((todo) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;)&#125; ⬆ 返回顶部 在 componentWillMount() 方法中使用 setState() 好吗?建议避免在 componentWillMount() 生命周期方法中执行异步初始化。在 mounting 发生之前会立即调用 componentWillMount()，且它在 render() 之前被调用，因此在此方法中更新状态将不会触发重新渲染。应避免在此方法中引入任何副作用或订阅操作。我们需要确保对组件初始化的异步调用发生在 componentDidMount() 中，而不是在 componentWillMount() 中。 12345678componentDidMount() &#123; axios.get(`api/todos`) .then((result) =&gt; &#123; this.setState(&#123; messages: [...result.data] &#125;) &#125;)&#125; **[⬆ 返回顶部](#目录)** 如果在初始状态中使用 props 属性会发生什么?如果在不刷新组件的情况下更改组件上的属性，则不会显示新的属性值，因为构造函数函数永远不会更新组件的当前状态。只有在首次创建组件时才会用 props 属性初始化状态。 以下组件将不显示更新的输入值： 1234567891011121314class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; records: [], inputValue: this.props.inputValue &#125;; &#125; render() &#123; return &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt; &#125;&#125; 在 render 方法使用使用 props 将会显示更新的值： 12345678910111213class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; record: [] &#125; &#125; render() &#123; return &lt;div&gt;&#123;this.props.inputValue&#125;&lt;/div&gt; &#125;&#125; **[⬆ 返回顶部](#目录)** 如何有条件地渲染组件?在某些情况下，你希望根据某些状态渲染不同的组件。 JSX 不会渲染 false 或 undefined，因此你可以使用 &amp;&amp; 运算符，在某个条件为 true 时，渲染组件中指定的内容。 12345678const MyComponent = (&#123; name, address &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;&#123;name&#125;&lt;/h2&gt; &#123;address &amp;&amp; &lt;p&gt;&#123;address&#125;&lt;/p&gt; &#125; &lt;/div&gt;) 如果你需要一个 if-else 条件，那么使用三元运算符： 123456789const MyComponent = (&#123; name, address &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;&#123;name&#125;&lt;/h2&gt; &#123;address ? &lt;p&gt;&#123;address&#125;&lt;/p&gt; : &lt;p&gt;&#123;'Address is not available'&#125;&lt;/p&gt; &#125; &lt;/div&gt;) 阅读资源： 掘金 - 精读《React 八种条件渲染》 ⬆ 返回顶部 为什么在 DOM 元素上展开 props 需要小心?当我们展开属性时，我们会遇到添加未知 HTML 属性的风险，这是一种不好的做法。相反，我们可以使用属性解构和...rest 运算符，因此它只添加所需的 props 属性。例如， 12345const ComponentA = () =&gt; &lt;ComponentB isDisplay=&#123;true&#125; className=&#123;'componentStyle'&#125; /&gt;const ComponentB = (&#123; isDisplay, ...domProps &#125;) =&gt; &lt;div &#123;...domProps&#125;&gt;&#123;'ComponentB'&#125;&lt;/div&gt; ⬆ 返回顶部 在 React 中如何使用装饰器?你可以装饰你的类组件，这与将组件传递到函数中是一样的。 装饰器是修改组件功能灵活且易读的方式。 123456789101112131415161718192021@setTitle('Profile')class Profile extends React.Component &#123; //....&#125;/* title is a string that will be set as a document title WrappedComponent is what our decorator will receive when put directly above a component class as seen in the example above*/const setTitle = (title) =&gt; (WrappedComponent) =&gt; &#123; return class extends React.Component &#123; componentDidMount() &#123; document.title = title &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; ⬆ 返回顶部 如何 memoize（记忆）组件?有可用于函数组件的 memoize 库。例如 moize 库可以将组件存储在另一个组件中。 1234567891011import moize from 'moize'import Component from './components/Component' // this module exports a non-memoized componentconst MemoizedFoo = moize.react(Component)const Consumer = () =&gt; &#123; &lt;div&gt; &#123;'I will memoize the following entry:'&#125; &lt;MemoizedFoo/&gt; &lt;/div&gt;&#125; ⬆ 返回顶部 如何实现 Server Side Rendering 或 SSR?React 已经配备了用于处理 Node 服务器上页面渲染的功能。你可以使用特殊版本的 DOM 渲染器，它遵循与客户端相同的模式。 1234import ReactDOMServer from 'react-dom/server'import App from './App'ReactDOMServer.renderToString(&lt;App /&gt;) 此方法将以字符串形式输出常规 HTML，然后将其作为服务器响应的一部分放在页面正文中。在客户端，React 检测预渲染的内容并无缝地衔接。 ⬆ 返回顶部 如何在 React 中启用生产模式?你应该使用 Webpack 的 DefinePlugin 方法将 NODE_ENV 设置为 production，通过它你可以去除 propType 验证和额外警告等内容。除此之外，如果你压缩代码，如使用 Uglify 的死代码消除，以去掉用于开发的代码和注释，它将大大减少包的大小。 ⬆ 返回顶部 什么是 CRA 及其好处?create-react-app CLI 工具允许你无需配置步骤，快速创建和运行 React 应用。 让我们使用 CRA 来创建 Todo 应用： 1234567891011# Installation$ npm install -g create-react-app# Create new project$ create-react-app todo-app$ cd todo-app# Build, test and run$ npm run build$ npm run test$ npm start 它包含了构建 React 应用程序所需的一切： React, JSX, ES6, 和 Flow 语法支持。 ES6 之外的语言附加功能，比如对象扩展运算符。 Autoprefixed CSS，因此你不在需要 -webkit- 或其他前缀。 一个快速的交互式单元测试运行程序，内置了对覆盖率报告的支持。 一个实时开发服务器，用于警告常见错误。 一个构建脚本，用于打包用于生产中包含 hashes 和 sourcemaps 的 JS、CSS 和 Images 文件。 ⬆ 返回顶部 在 mounting 阶段生命周期方法的执行顺序是什么?在创建组件的实例并将其插入到 DOM 中时，将按以下顺序调用生命周期方法。 constructor() static getDerivedStateFromProps() render() componentDidMount() ⬆ 返回顶部 在 React v16 中，哪些生命周期方法将被弃用?以下生命周期方法将成为不安全的编码实践，并且在异步渲染方面会更有问题。 componentWillMount() componentWillReceiveProps() componentWillUpdate() 从 React v16.3 开始，这些方法使用 UNSAFE_ 前缀作为别名，未加前缀的版本将在 React v17 中被移除。 ⬆ 返回顶部 生命周期方法 getDerivedStateFromProps() 的目的是什么?新的静态 getDerivedStateFromProps() 生命周期方法在实例化组件之后以及重新渲染组件之前调用。它可以返回一个对象用于更新状态，或者返回 null 指示新的属性不需要任何状态更新。 12345class MyComponent extends React.Component &#123; static getDerivedStateFromProps(props, state) &#123; // ... &#125;&#125; 此生命周期方法与 componentDidUpdate() 一起涵盖了 componentWillReceiveProps() 的所有用例。 ⬆ 返回顶部 生命周期方法 getSnapshotBeforeUpdate() 的目的是什么?新的 getSnapshotBeforeUpdate() 生命周期方法在 DOM 更新之前被调用。此方法的返回值将作为第三个参数传递给componentDidUpdate()。 12345class MyComponent extends React.Component &#123; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // ... &#125;&#125; 此生命周期方法与 componentDidUpdate() 一起涵盖了 componentWillUpdate() 的所有用例。 ⬆ 返回顶部 createElement() 和 cloneElement() 方法有什么区别?JSX 元素将被转换为 React.createElement() 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 cloneElement 用于克隆元素并传递新的属性。 ⬆ 返回顶部 推荐的组件命名方法是什么?建议通过引用命名组件，而不是使用 displayName。 使用 displayName 命名组件: 1234export default React.createClass(&#123; displayName: 'TodoApp', // ...&#125;) 推荐的方式： 123export default class TodoApp extends React.Component &#123; // ...&#125; ⬆ 返回顶部 在组件类中方法的推荐顺序是什么?从 mounting 到 render stage 阶段推荐的方法顺序： static 方法 constructor() getChildContext() componentWillMount() componentDidMount() componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() componentDidUpdate() componentWillUnmount() 点击处理程序或事件处理程序，如 onClickSubmit() 或 onChangeDescription() 用于渲染的getter方法，如 getSelectReason() 或 getFooterContent() 可选的渲染方法，如 renderNavigation() 或 renderProfilePicture() render() ⬆ 返回顶部 什么是 switching 组件?switching 组件是渲染多个组件之一的组件。我们需要使用对象将 prop 映射到组件中。 例如，以下的 switching 组件将基于 page 属性显示不同的页面： 12345678910111213141516171819202122import HomePage from './HomePage'import AboutPage from './AboutPage'import ServicesPage from './ServicesPage'import ContactPage from './ContactPage'const PAGES = &#123; home: HomePage, about: AboutPage, services: ServicesPage, contact: ContactPage&#125;const Page = (props) =&gt; &#123; const Handler = PAGES[props.page] || ContactPage return &lt;Handler &#123;...props&#125; /&gt;&#125;// The keys of the PAGES object can be used in the prop types to catch dev-time errors.Page.propTypes = &#123; page: PropTypes.oneOf(Object.keys(PAGES)).isRequired&#125; ⬆ 返回顶部 为什么我们需要将函数传递给 setState() 方法?这背后的原因是 setState() 是一个异步操作。出于性能原因，React 会对状态更改进行批处理，因此在调用 setState() 方法之后，状态可能不会立即更改。这意味着当你调用 setState() 方法时，你不应该依赖当前状态，因为你不能确定当前状态应该是什么。这个问题的解决方案是将一个函数传递给 setState()，该函数会以上一个状态作为参数。通过这样做，你可以避免由于 setState() 的异步性质而导致用户在访问时获取旧状态值的问题。 假设初始计数值为零。在连续三次增加操作之后，该值将只增加一个。 12345// assuming this.state.count === 0this.setState(&#123; count: this.state.count + 1 &#125;)this.setState(&#123; count: this.state.count + 1 &#125;)this.setState(&#123; count: this.state.count + 1 &#125;)// this.state.count === 1, not 3 如果将函数传递给 setState()，则 count 将正确递增。 1234this.setState((prevState, props) =&gt; (&#123; count: prevState.count + props.increment&#125;))// this.state.count === 3 as expected ⬆ 返回顶部 在 React 中什么是严格模式?React.StrictMode 是一个有用的组件，用于突出显示应用程序中的潜在问题。就像 &lt;Fragment&gt;，&lt;StrictMode&gt; 一样，它们不会渲染任何额外的 DOM 元素。它为其后代激活额外的检查和警告。这些检查仅适用于开发模式。 12345678910111213141516import React from 'react'function ExampleApplication() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;React.StrictMode&gt; &lt;div&gt; &lt;ComponentOne /&gt; &lt;ComponentTwo /&gt; &lt;/div&gt; &lt;/React.StrictMode&gt; &lt;Footer /&gt; &lt;/div&gt; )&#125; 在上面的示例中，strict mode 检查仅应用于 &lt;ComponentOne&gt; 和 &lt;ComponentTwo&gt; 组件。 ⬆ 返回顶部 React Mixins 是什么?Mixins 是一种完全分离组件通用功能的方法。 Mixins 不应该被继续使用，可以用高阶组件或装饰器来替换。 最常用的 mixins 是 PureRenderMixin。当 props 和状态与之前的 props 和状态相等时，你可能在某些组件中使用它来防止不必要的重新渲染： 1234567const PureRenderMixin = require('react-addons-pure-render-mixin')const Button = React.createClass(&#123; mixins: [PureRenderMixin], // ...&#125;)` ⬆ 返回顶部 为什么 isMounted() 是一个反模式，而正确的解决方案是什么?isMounted() 的主要场景是避免在组件卸载后调用 setState()，因为它会发出警告。 123if (this.isMounted()) &#123; this.setState(&#123;...&#125;)&#125; 在调用 setState() 之前检查 isMounted() 会消除警告，但也会破坏警告的目的。使用 isMounted() 有一种代码味道，因为你要检查的唯一原因是你认为在卸载组件后可能持有引用。 最佳解决方案是找到在组件卸载后调用 setState() 的位置，并修复它们。这种情况最常发生在回调中，即组件正在等待某些数据并在数据到达之前卸载。理想情况下，在卸载之前，应在 componentWillUnmount() 中取消任何回调。 ⬆ 返回顶部 React 中支持哪些指针事件?Pointer Events 提供了处理所有输入事件的统一方法。在过去，我们有一个鼠标和相应的事件监听器来处理它们，但现在我们有许多与鼠标无关的设备，比如带触摸屏的手机或笔。我们需要记住，这些事件只能在支持 Pointer Events 规范的浏览器中工作。 目前以下事件类型在 React DOM 中是可用的： onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture onLostPointerCaptur onPointerEnter onPointerLeave onPointerOver onPointerOut ⬆ 返回顶部 为什么组件名称应该以大写字母开头?如果使用 JSX 渲染组件，则该组件的名称必须以大写字母开头，否则 React 将会抛出无法识别标签的错误。这种约定是因为只有 HTML 元素和 SVG 标签可以以小写字母开头。 定义组件类的时候，你可以以小写字母开头，但在导入时应该使用大写字母。 1234567class myComponent extends Component &#123; render() &#123; return &lt;div /&gt; &#125;&#125;export default myComponent 当在另一个文件导入时，应该以大写字母开头： 1import MyComponent from './MyComponent' ⬆ 返回顶部 在 React v16 中是否支持自定义 DOM 属性?是的，在过去 React 会忽略未知的 DOM 属性。如果你编写的 JSX 属性 React 无法识别，那么 React 将跳过它。例如： 1&lt;div mycustomattribute=&#123;'something'&#125; /&gt; 在 React 15 中将在 DOM 中渲染一个空的 div： 1&lt;div /&gt; 在 React 16 中，任何未知的属性都将会在 DOM 显示： 1&lt;div mycustomattribute='something' /&gt; 这对于应用特定于浏览器的非标准属性，尝试新的 DOM APIs 与集成第三方库来说非常有用。 ⬆ 返回顶部 constructor 和 getInitialState 有什么区别?当使用 ES6 类时，你应该在构造函数中初始化状态，而当你使用 React.createClass() 时，就需要使用 getInitialState() 方法。 使用 ES6 类: 123456class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; /* initial state */ &#125; &#125;&#125; 使用 React.createClass(): 12345const MyComponent = React.createClass(&#123; getInitialState() &#123; return &#123; /* initial state */ &#125; &#125;&#125;) 注意： 在 React v16 中 React.createClass() 已被弃用和删除，请改用普通的 JavaScript 类。 ⬆ 返回顶部 是否可以在不调用 setState 方法的情况下，强制组件重新渲染?默认情况下，当组件的状态或属性改变时，组件将重新渲染。如果你的 render() 方法依赖于其他数据，你可以通过调用 forceUpdate() 来告诉 React，当前组件需要重新渲染。 1component.forceUpdate(callback) 建议避免使用 forceUpdate()，并且只在 render() 方法中读取 this.props 和 this.state。 ⬆ 返回顶部 在使用 ES6 类的 React 中 super() 和 super(props) 有什么区别?当你想要在 constructor() 函数中访问 this.props，你需要将 props 传递给 super() 方法。 使用 super(props): 123456class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) console.log(this.props) // &#123; name: 'John', ... &#125; &#125;&#125; 使用 super(): 123456class MyComponent extends React.Component &#123; constructor(props) &#123; super() console.log(this.props) // undefined &#125;&#125; 在 constructor() 函数之外，访问 this.props 属性会显示相同的值。 ⬆ 返回顶部 在 JSX 中如何进行循环?你只需使用带有 ES6 箭头函数语法的 Array.prototype.map 即可。例如，items 对象数组将会被映射成一个组件数组： 123&lt;tbody&gt; &#123;items.map(item =&gt; &lt;SomeComponent key=&#123;item.id&#125; name=&#123;item.name&#125; /&gt;)&#125;&lt;/tbody&gt; 你不能使用 for 循环进行迭代： 12345&lt;tbody&gt; for (let i = 0; i &lt; items.length; i++) &#123; &lt;SomeComponent key=&#123;items[i].id&#125; name=&#123;items[i].name&#125; /&gt; &#125;&lt;/tbody&gt; 这是因为 JSX 标签会被转换成函数调用，并且你不能在表达式中使用语句。但这可能会由于 do 表达式而改变，它们是第一阶段提案。 ⬆ 返回顶部 如何在 attribute 引号中访问 props 属性?React (或 JSX) 不支持属性值内的变量插值。下面的形式将不起作用： 1&lt;img className='image' src='images/&#123;this.props.image&#125;' /&gt; 但你可以将 JS 表达式作为属性值放在大括号内。所以下面的表达式是有效的： 1&lt;img className='image' src=&#123;'images/' + this.props.image&#125; /&gt; 使用模板字符串也是可以的： 1&lt;img className='image' src=&#123;`images/$&#123;this.props.image&#125;`&#125; /&gt; ⬆ 返回顶部 什么是 React proptype 数组?如果你要规范具有特定对象格式的数组的属性，请使用 React.PropTypes.shape() 作为 React.PropTypes.arrayOf() 的参数。 123456ReactComponent.propTypes = &#123; arrayWithShape: React.PropTypes.arrayOf(React.PropTypes.shape(&#123; color: React.PropTypes.string.isRequired, fontSize: React.PropTypes.number.isRequired &#125;)).isRequired&#125; ⬆ 返回顶部 如何有条件地应用样式类?你不应该在引号内使用大括号，因为它将被计算为字符串。 1&lt;div className="btn-panel &#123;this.props.visible ? 'show' : 'hidden'&#125;"&gt; 相反，你需要将大括号移到外部（不要忘记在类名之间添加空格）： 1&lt;div className=&#123;'btn-panel ' + (this.props.visible ? 'show' : 'hidden')&#125;&gt; 模板字符串也可以工作： 1&lt;div className=&#123;`btn-panel $&#123;this.props.visible ? 'show' : 'hidden'&#125;`&#125;&gt; ⬆ 返回顶部 React 和 ReactDOM 之间有什么区别?react 包中包含 React.createElement(), React.Component, React.Children，以及与元素和组件类相关的其他帮助程序。你可以将这些视为构建组件所需的同构或通用帮助程序。react-dom 包中包含了 ReactDOM.render()，在 react-dom/server 包中有支持服务端渲染的 ReactDOMServer.renderToString() 和 ReactDOMServer.renderToStaticMarkup() 方法。 ⬆ 返回顶部 为什么 ReactDOM 从 React 分离出来?React 团队致力于将所有的与 DOM 相关的特性抽取到一个名为 ReactDOM 的独立库中。React v0.14 是第一个拆分后的版本。通过查看一些软件包，react-native，react-art，react-canvas，和 react-three，很明显，React 的优雅和本质与浏览器或 DOM 无关。为了构建更多 React 能应用的环境，React 团队计划将主要的 React 包拆分成两个：react 和 react-dom。这为编写可以在 React 和 React Native 的 Web 版本之间共享的组件铺平了道路。 ⬆ 返回顶部 如何使用 React label 元素?如果你尝试使用标准的 for 属性将 &lt;label&gt; 元素绑定到文本输入框，那么在控制台将会打印缺少 HTML 属性的警告消息。 12&lt;label for=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt; 因为 for 是 JavaScript 的保留字，请使用 htmlFor 来替代。 12&lt;label htmlFor=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt; ⬆ 返回顶部 如何合并多个内联的样式对象?在 React 中，你可以使用扩展运算符: 1&lt;button style=&#123;&#123;...styles.panel.button, ...styles.panel.submitButton&#125;&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt; 如果你使用的是 React Native，则可以使用数组表示法： 1&lt;button style=&#123;[styles.panel.button, styles.panel.submitButton]&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt; ⬆ 返回顶部 如何在调整浏览器大小时重新渲染视图?你可以在 componentDidMount() 中监听 resize 事件，然后更新尺寸（width 和 height）。你应该在 componentWillUnmount() 方法中移除监听。 123456789101112131415161718192021class WindowDimensions extends React.Component &#123; componentWillMount() &#123; this.updateDimensions() &#125; componentDidMount() &#123; window.addEventListener('resize', this.updateDimensions) &#125; componentWillUnmount() &#123; window.removeEventListener('resize', this.updateDimensions) &#125; updateDimensions() &#123; this.setState(&#123;width: $(window).width(), height: $(window).height()&#125;) &#125; render() &#123; return &lt;span&gt;&#123;this.state.width&#125; x &#123;this.state.height&#125;&lt;/span&gt; &#125;&#125; ⬆ 返回顶部 setState() 和 replaceState() 方法之间有什么区别?当你使用 setState() 时，当前和先前的状态将被合并。replaceState() 会抛出当前状态，并仅用你提供的内容替换它。通常使用 setState()，除非你出于某种原因确实需要删除所有以前的键。你还可以在 setState() 中将状态设置为 false/null，而不是使用 replaceState()。 ⬆ 返回顶部 如何监听状态变化?当状态更改时将调用以下生命周期方法。你可以将提供的状态和属性值与当前状态和属性值进行比较，以确定是否发生了有意义的改变。 12componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState) ⬆ 返回顶部 在 React 状态中删除数组元素的推荐方法是什么?更好的方法是使用 Array.prototype.filter() 方法。 例如，让我们创建用于更新状态的 removeItem() 方法。 12345removeItem(index) &#123; this.setState(&#123; data: this.state.data.filter((item, i) =&gt; i !== index) &#125;)&#125; ⬆ 返回顶部 在 React 中是否可以不在页面上渲染 HTML 内容?可以使用最新的版本 (&gt;=16.2)，以下是可能的选项： 123render() &#123; return false&#125; 123render() &#123; return null&#125; 123render() &#123; return []&#125; 123render() &#123; return &lt;React.Fragment&gt;&lt;/React.Fragment&gt;&#125; 123render() &#123; return &lt;&gt;&lt;/&gt;&#125; 返回 undefined 是无效的。 ⬆ 返回顶部 如何用 React 漂亮地显示 JSON?我们可以使用 &lt;pre&gt; 标签，以便保留 JSON.stringify() 的格式： 12345678910111213const data = &#123; name: 'John', age: 42 &#125; class User extends React.Component &#123; render() &#123; return ( &lt;pre&gt; &#123;JSON.stringify(data, null, 2)&#125; &lt;/pre&gt; ) &#125;&#125; React.render(&lt;User /&gt;, document.getElementById('container')) **[⬆ 返回顶部](#目录)** 为什么你不能更新 React 中的 props?React 的哲学是 props 应该是 immutable 和 top-down。这意味着父级可以向子级发送任何属性值，但子级不能修改接收到的属性。 ⬆ 返回顶部 如何在页面加载时聚焦一个输入元素?你可以为 input 元素创建一个 ref，然后在 componentDidMount() 方法中使用它： 123456789101112131415161718192021class App extends React.Component&#123; componentDidMount() &#123; this.nameInput.focus() &#125; render() &#123; return ( &lt;div&gt; &lt;input defaultValue=&#123;'Won\'t focus'&#125; /&gt; &lt;input ref=&#123;(input) =&gt; this.nameInput = input&#125; defaultValue=&#123;'Will focus'&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('app')) ⬆ 返回顶部 更新状态中的对象有哪些可能的方法? 用一个对象调用 setState() 来与状态合并： 使用 Object.assign() 创建对象的副本： 12const user = Object.assign(&#123;&#125;, this.state.user, &#123; age: 42 &#125;)this.setState(&#123; user &#125;) 使用扩展运算符： 12const user = &#123; ...this.state.user, age: 42 &#125;this.setState(&#123; user &#125;) 使用一个函数调用 setState()： 123456this.setState(prevState =&gt; (&#123; user: &#123; ...prevState.user, age: 42 &#125;&#125;)) ⬆ 返回顶部 为什么函数比对象更适合于 setState()?出于性能考虑，React 可能将多个 setState() 调用合并成单个更新。这是因为我们可以异步更新 this.props 和 this.state，所以不应该依赖它们的值来计算下一个状态。 以下的 counter 示例将无法按预期更新： 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;) 首选方法是使用函数而不是对象调用 setState()。该函数将前一个状态作为第一个参数，当前时刻的 props 作为第二个参数。 1234// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)) ⬆ 返回顶部 我们如何在浏览器中找到当前正在运行的 React 版本?你可以使用 React.version 来获取版本： 123456const REACT_VERSION = React.versionReactDOM.render( &lt;div&gt;&#123;`React version: $&#123;REACT_VERSION&#125;`&#125;&lt;/div&gt;, document.getElementById('app')) ⬆ 返回顶部 在 create-react-app 项目中导入 polyfills 的方法有哪些? 从 core-js 中手动导入: 创建一个名为 polyfills.js 文件，并在根目录下的 index.js 文件中导入它。运行 npm install core-js 或 yarn add core-js 并导入你所需的功能特性： 123import 'core-js/fn/array/find'import 'core-js/fn/array/includes'import 'core-js/fn/number/is-nan' 使用 Polyfill 服务: 通过将以下内容添加到 index.html 中来获取自定义的特定于浏览器的 polyfill： 1&lt;script src='https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'&gt;&lt;/script&gt; 在上面的脚本中，我们必须显式地请求 Array.prototype.includes 特性，因为它没有被包含在默认的特性集中。 ⬆ 返回顶部 如何在 create-react-app 中使用 https 而不是 http?你只需要使用 HTTPS=true 配置。你可以编辑 package.json 中的 scripts 部分： 123"scripts": &#123; "start": "set HTTPS=true &amp;&amp; react-scripts start"&#125; 或直接运行 set HTTPS=true &amp;&amp; npm start ⬆ 返回顶部 如何避免在 create-react-app 中使用相对路径导入?在项目的根目录中创建一个名为 .env 的文件，并写入导入路径： 1NODE_PATH=src/app 然后重新启动开发服务器。现在，你应该能够在没有相对路径的情况下导入 src/app 内的任何内容。 ⬆ 返回顶部 如何为 React Router 添加 Google Analytics?在 history 对象上添加一个监听器以记录每个页面的访问： 1234history.listen(function (location) &#123; window.ga('set', 'page', location.pathname + location.search) window.ga('send', 'pageview', location.pathname + location.search)&#125;) ⬆ 返回顶部 如何每秒更新一个组件?你需要使用 setInterval() 来触发更改，但也需要在组件卸载时清除计时器，以防止错误和内存泄漏。 1234567componentDidMount() &#123; this.interval = setInterval(() =&gt; this.setState(&#123; time: Date.now() &#125;), 1000)&#125;componentWillUnmount() &#123; clearInterval(this.interval)&#125; ⬆ 返回顶部 如何将 vendor prefixes 应用于 React 中的内联样式?React不会自动应用 vendor prefixes，你需要手动添加 vendor prefixes。 12345&lt;div style=&#123;&#123; transform: 'rotate(90deg)', WebkitTransform: 'rotate(90deg)', // note the capital 'W' here msTransform: 'rotate(90deg)' // 'ms' is the only lowercase vendor prefix&#125;&#125; /&gt; ⬆ 返回顶部 如何使用 React 和 ES6 导入和导出组件?导出组件时，你应该使用默认导出： 123456789101112import React from 'react'import User from 'user'export default class MyProfile extends React.Component &#123; render()&#123; return ( &lt;User type="customer"&gt; //... &lt;/User&gt; ) &#125;&#125; 使用 export 说明符，MyProfile 将成为成员并导出到此模块，此外在其他组件中你无需指定名称就可以导入相同的内容。 ⬆ 返回顶部 为什么 React 组件名称必须以大写字母开头?在 JSX 中，小写标签被认为是 HTML 标签。但是，含有 . 的大写和小写标签名却不是。 &lt;component /&gt; 将被转换为 React.createElement(&#39;component&#39;) (i.e, HTML 标签) &lt;obj.component /&gt; 将被转换为 React.createElement(obj.component) &lt;Component /&gt; 将被转换为 React.createElement(Component) ⬆ 返回顶部 为什么组件的构造函数只被调用一次?React 协调算法假设如果自定义组件出现在后续渲染的相同位置，则它与之前的组件相同，因此重用前一个实例而不是创建新实例。 ⬆ 返回顶部 在 React 中如何定义常量?你可以使用 ES7 的 static 来定义常量。 123class MyComponent extends React.Component &#123; static DEFAULT_PAGINATION = 10&#125; ⬆ 返回顶部 在 React 中如何以编程方式触发点击事件?你可以使用 ref 属性通过回调函数获取对底层的 HTMLinputeElement 对象的引用，并将该引用存储为类属性，之后你就可以利用该引用在事件回调函数中， 使用 HTMLElement.click 方法触发一个点击事件。这可以分为两个步骤： 在 render 方法创建一个 ref： 1&lt;input ref=&#123;input =&gt; this.inputElement = input&#125; /&gt; 在事件处理器中触发点击事件 1this.inputElement.click() ⬆ 返回顶部 在 React 中是否可以使用 async/await?如果要在 React 中使用 async/await，则需要 Babel 和 transform-async-to-generator 插件。 ⬆ 返回顶部 React 项目常见的文件结构是什么?React 项目文件结构有两种常见的实践。 按功能或路由分组: 构建项目的一种常见方法是将 CSS，JS 和测试用例放在一起，按功能或路由分组。 123456789101112131415161718common/├─ Avatar.js├─ Avatar.css├─ APIUtils.js└─ APIUtils.test.jsfeed/├─ index.js├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js└─ FeedAPI.jsprofile/├─ index.js├─ Profile.js├─ ProfileHeader.js├─ ProfileHeader.css└─ ProfileAPI.js 按文件类型分组: 另一种流行的项目结构组织方法是将类似的文件组合在一起。 123456789101112131415api/├─ APIUtils.js├─ APIUtils.test.js├─ ProfileAPI.js└─ UserAPI.jscomponents/├─ Avatar.js├─ Avatar.css├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js├─ Profile.js├─ ProfileHeader.js└─ ProfileHeader.css ⬆ 返回顶部 最流行的动画软件包是什么?React Transition Group 和 React Motion 是React生态系统中流行的动画包。 ⬆ 返回顶部 模块化样式文件有什么好处?建议避免在组件中对样式值进行硬编码。任何可能在不同的 UI 组件之间使用的值都应该提取到它们自己的模块中。 例如，可以将这些样式提取到单独的组件中： 12345678910111213export const colors = &#123; white, black, blue&#125;export const space = [ 0, 8, 16, 32, 64] 然后在其他组件中单独导入： 1import &#123; space, colors &#125; from './styles' ⬆ 返回顶部 什么是 React 流行的特定 linters?ESLint 是一个流行的 JavaScript linter。有一些插件可以分析特定的代码样式。在 React 中最常见的一个是名为 eslint-plugin-react npm 包。默认情况下，它将使用规则检查许多最佳实践，检查内容从迭代器中的键到一组完整的 prop 类型。另一个流行的插件是 eslint-plugin-jsx-a11y，它将帮助修复可访问性的常见问题。由于 JSX 提供的语法与常规 HTML 略有不同，因此常规插件无法获取 alt 文本和 tabindex 的问题。 ⬆ 返回顶部 如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用?你可以使用 AJAX 库，如 Axios，jQuery AJAX 和浏览器内置的 fetch API。你应该在 componentDidMount() 生命周期方法中获取数据。这样当获取到数据的时候，你就可以使用 setState() 方法来更新你的组件。 例如，从 API 中获取员工列表并设置本地状态： 1234567891011121314151617181920212223242526272829303132333435363738394041class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; employees: [], error: null &#125; &#125; componentDidMount() &#123; fetch('https://api.example.com/items') .then(res =&gt; res.json()) .then( (result) =&gt; &#123; this.setState(&#123; employees: result.employees &#125;) &#125;, (error) =&gt; &#123; this.setState(&#123; error &#125;) &#125; ) &#125; render() &#123; const &#123; error, employees &#125; = this.state if (error) &#123; return &lt;div&gt;Error: &#123;error.message&#125;&lt;/div&gt;; &#125; else &#123; return ( &lt;ul&gt; &#123;employees.map(item =&gt; ( &lt;li key=&#123;employee.name&#125;&gt; &#123;employee.name&#125;-&#123;employees.experience&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; ) &#125; &#125;&#125; ⬆ 返回顶部 什么是渲染属性?Render Props 是一种简单的技术，用于使用值为函数的 prop 属性在组件之间共享代码。下面的组件使用返回 React 元素的 render 属性： 123&lt;DataProvider render=&#123;data =&gt; ( &lt;h1&gt;&#123;`Hello $&#123;data.target&#125;`&#125;&lt;/h1&gt;)&#125;/&gt; 像 React Router 和 DownShift 这样的库使用了这种模式。 ⬆ 返回顶部 React Router 什么是 React Router?React Router 是一个基于 React 之上的强大路由库，可以帮助您快速地向应用添加视图和数据流，同时保持 UI 与 URL 同步。 ⬆ 返回顶部 React Router 与 history 库的区别?React Router 是history库的包装器，它处理浏览器的window.history与浏览器和哈希历史的交互。它还提供了内存历史记录，这对于没有全局历史记录的环境非常有用，例如移动应用程序开发（React Native）和使用 Node 进行单元测试。 ⬆ 返回顶部 在 React Router v4 中的&lt;Router&gt;组件是什么?React Router v4 提供了以下三种类型的 &lt;Router&gt; 组件: &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; 以上组件将创建browser，hash和memory的 history 实例。React Router v4 通过router对象中的上下文使与您的路由器关联的history实例的属性和方法可用。 ⬆ 返回顶部 history 中的 push() 和 replace() 方法的目的是什么?一个 history 实例有两种导航方法： push() replace() 如果您将 history 视为一个访问位置的数组，则push()将向数组添加一个新位置，replace()将用新的位置替换数组中的当前位置。 ⬆ 返回顶部 如何使用在 React Router v4 中以编程的方式进行导航?在组件中实现操作路由/导航有三种不同的方法。 使用withRouter()高阶函数： withRouter()高阶函数将注入 history 对象作为组件的 prop。该对象提供了push()和replace()方法，以避免使用上下文。 12345678910import &#123; withRouter &#125; from 'react-router-dom' // this also works with 'react-router-native'const Button = withRouter((&#123; history &#125;) =&gt; ( &lt;button type='button' onClick=&#123;() =&gt; &#123; history.push('/new-location') &#125;&#125; &gt; &#123;'Click Me!'&#125; &lt;/button&gt;)) 使用&lt;Route&gt;组件和渲染属性模式： &lt;Route&gt;组件传递与withRouter()相同的属性，因此您将能够通过 history 属性访问到操作历史记录的方法。 123456789101112import &#123; Route &#125; from 'react-router-dom'const Button = () =&gt; ( &lt;Route render=&#123;(&#123; history &#125;) =&gt; ( &lt;button type='button' onClick=&#123;() =&gt; &#123; history.push('/new-location') &#125;&#125; &gt; &#123;'Click Me!'&#125; &lt;/button&gt; )&#125; /&gt;) 使用上下文: 建议不要使用此选项，并将其视为不稳定的API。 12345678910111213141516const Button = (props, context) =&gt; ( &lt;button type='button' onClick=&#123;() =&gt; &#123; context.history.push('/new-location') &#125;&#125; &gt; &#123;'Click Me!'&#125; &lt;/button&gt;)Button.contextTypes = &#123; history: React.PropTypes.shape(&#123; push: React.PropTypes.func.isRequired &#125;)&#125; ⬆ 返回顶部 如何在 React Router v4 中获取查询字符串参数?在 React Router v4 中并没有内置解析查询字符串的能力，因为多年来一直有用户希望支持不同的实现。因此，使用者可以选择他们喜欢的实现方式。建议的方法是使用 query-string 库。 12const queryString = require('query-string');const parsed = queryString.parse(props.location.search); 如果你想要使用原生 API 的话，你也可以使用 URLSearchParams ： 12const params = new URLSearchParams(props.location.search)const foo = params.get('name') 如果使用 URLSearchParams 的话您应该为 IE11 使用polyfill。 ⬆ 返回顶部 为什么你会得到 “Router may have only one child element” 警告?此警告的意思是Router组件下仅能包含一个子节点。 你必须将你的 Route 包装在&lt;Switch&gt;块中，因为&lt;Switch&gt;是唯一的，它只提供一个路由。 首先，您需要在导入中添加Switch： 1import &#123; Switch, Router, Route &#125; from 'react-router' 然后在&lt;Switch&gt;块中定义路由： 123456&lt;Router&gt; &lt;Switch&gt; &lt;Route &#123;/* ... */&#125; /&gt; &lt;Route &#123;/* ... */&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; ⬆ 返回顶部 如何在 React Router v4 中将 params 传递给 history.push 方法?在导航时，您可以将 props 传递给history对象： 12345this.props.history.push(&#123; pathname: '/template', search: '?name=sudheer', state: &#123; detail: response.data &#125;&#125;) search属性用于在push()方法中传递查询参数。 ⬆ 返回顶部 如何实现默认页面或 404 页面?&lt;Switch&gt;呈现匹配的第一个孩子&lt;Route&gt;。 没有路径的&lt;Route&gt;总是匹配。所以你只需要简单地删除 path 属性，如下所示： 12345&lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route path="/user" component=&#123;User&#125;/&gt; &lt;Route component=&#123;NotFound&#125; /&gt;&lt;/Switch&gt; ⬆ 返回顶部 如何在 React Router v4 上获取历史对象? 创建一个导出history对象的模块，并在整个项目中导入该模块。 例如， 创建history.js文件: 12345import &#123; createBrowserHistory &#125; from 'history'export default createBrowserHistory(&#123; /* pass a configuration object here if needed */&#125;) 您应该使用&lt;Router&gt;组件而不是内置路由器。在index.js文件中导入上面的history.js： 123456789import &#123; Router &#125; from 'react-router-dom'import history from './history'import App from './App'ReactDOM.render(( &lt;Router history=&#123;history&#125;&gt; &lt;App /&gt; &lt;/Router&gt;), holder) 您还可以使用类似于内置历史对象的history对象的push方法： 1234// some-other-file.jsimport history from './history'history.push('/go-here') ⬆ 返回顶部 登录后如何执行自动重定向?react-router包在 React Router 中提供了&lt;Redirect&gt;组件。渲染&lt;Redirect&gt;将导航到新位置。与服务器端重定向一样，新位置将覆盖历史堆栈中的当前位置。 123456789101112import React, &#123; Component &#125; from 'react'import &#123; Redirect &#125; from 'react-router'export default class LoginComponent extends Component &#123; render() &#123; if (this.state.isLoggedIn === true) &#123; return &lt;Redirect to="/your/redirect/page" /&gt; &#125; else &#123; return &lt;div&gt;&#123;'Login Please'&#125;&lt;/div&gt; &#125; &#125;&#125; ⬆ 返回顶部 React Internationalization 什么是 React Intl?React Intl库使 React 中的内部化变得简单，使用现成的组件和 API ，可以处理从格式化字符串，日期和数字到复数的所有功能。React Intl 是FormatJS的一部分，它通过其组件和 API 提供与 React 的绑定。 ⬆ 返回顶部 React Intl 的主要特性是什么? 用分隔符显示数字 正确显示日期和时间 显示相对于“现在”的日期 将标签转换为字符串 支持 150 多种语言 支持在浏览器和 Node 中运行 建立在标准之上 ⬆ 返回顶部 在 React Intl 中有哪两种格式化方式?该库提供了两种格式化字符串，数字和日期的方法：React 组件或 API。 1234&lt;FormattedMessage id=&#123;'account'&#125; defaultMessage=&#123;'The amount is less than minimum balance.'&#125;/&gt; 12345678const messages = defineMessages(&#123; accountMessage: &#123; id: 'account', defaultMessage: 'The amount is less than minimum balance.', &#125;&#125;)formatMessage(messages.accountMessage) ⬆ 返回顶部 在 React Intl 中如何使用&lt;FormattedMessage&gt;作为占位符使用?react-intl的&lt;Formatted ... /&gt;组件返回元素，而不是纯文本，因此它们不能用于占位符，替代文本等。在这种情况下，您应该使用较低级别的 API formatMessage()。您可以使用injectIntl()高阶函数将intl对象注入到组件中，然后使用该对象上使用formatMessage()格式化消息。 12345678910111213import React from 'react'import &#123; injectIntl, intlShape &#125; from 'react-intl'const MyComponent = (&#123; intl &#125;) =&gt; &#123; const placeholder = intl.formatMessage(&#123;id: 'messageId'&#125;) return &lt;input placeholder=&#123;placeholder&#125; /&gt;&#125;MyComponent.propTypes = &#123; intl: intlShape.isRequired&#125;export default injectIntl(MyComponent) ⬆ 返回顶部 如何使用 React Intl 访问当前语言环境?您可以在应用的任何组件中使用injectIntl()获取的当前语言环境： 1234567891011import &#123; injectIntl, intlShape &#125; from 'react-intl'const MyComponent = (&#123; intl &#125;) =&gt; ( &lt;div&gt;&#123;`The current locale is $&#123;intl.locale&#125;`&#125;&lt;/div&gt;)MyComponent.propTypes = &#123; intl: intlShape.isRequired&#125;export default injectIntl(MyComponent) ⬆ 返回顶部 如何使用 React Intl 格式化日期?injectIntl()高阶组件将允许您通过组件中的 props 访问formatDate()方法。 该方法由FormattedDate实例在内部使用，它返回格式化日期的字符串表示。 1234567891011121314151617import &#123; injectIntl, intlShape &#125; from 'react-intl'const stringDate = this.props.intl.formatDate(date, &#123; year: 'numeric', month: 'numeric', day: 'numeric'&#125;)const MyComponent = (&#123;intl&#125;) =&gt; ( &lt;div&gt;&#123;`The formatted date is $&#123;stringDate&#125;`&#125;&lt;/div&gt;)MyComponent.propTypes = &#123; intl: intlShape.isRequired&#125;export default injectIntl(MyComponent) ⬆ 返回顶部 React Testing 在 React 测试中什么是浅层渲染（Shallow Renderer）?浅层渲染对于在 React 中编写单元测试用例很有用。它允许您渲染一个一级深的组件并断言其渲染方法返回的内容，而不必担心子组件未实例化或渲染。 例如，如果您有以下组件： 12345678function MyComponent() &#123; return ( &lt;div&gt; &lt;span className=&#123;'heading'&#125;&gt;&#123;'Title'&#125;&lt;/span&gt; &lt;span className=&#123;'description'&#125;&gt;&#123;'Description'&#125;&lt;/span&gt; &lt;/div&gt; )&#125; 然后你可以如下断言： 12345678910111213import ShallowRenderer from 'react-test-renderer/shallow'// in your testconst renderer = new ShallowRenderer()renderer.render(&lt;MyComponent /&gt;)const result = renderer.getRenderOutput()expect(result.type).toBe('div')expect(result.props.children).toEqual([ &lt;span className=&#123;'heading'&#125;&gt;&#123;'Title'&#125;&lt;/span&gt;, &lt;span className=&#123;'description'&#125;&gt;&#123;'Description'&#125;&lt;/span&gt;]) ⬆ 返回顶部 在 React 中 TestRenderer 包是什么?此包提供了一个渲染器，可用于将组件渲染为纯 JavaScript 对象，而不依赖于 DOM 或原生移动环境。该包可以轻松获取由 ReactDOM 或 React Native 平台所渲染的视图层次结构（类似于DOM树）的快照，而无需使用浏览器或jsdom。 1234567891011121314import TestRenderer from 'react-test-renderer'const Link = (&#123;page, children&#125;) =&gt; &lt;a href=&#123;page&#125;&gt;&#123;children&#125;&lt;/a&gt;const testRenderer = TestRenderer.create( &lt;Link page=&#123;'https://www.facebook.com/'&#125;&gt;&#123;'Facebook'&#125;&lt;/Link&gt;)console.log(testRenderer.toJSON())// &#123;// type: 'a',// props: &#123; href: 'https://www.facebook.com/' &#125;,// children: [ 'Facebook' ]// &#125; ⬆ 返回顶部 ReactTestUtils 包的目的是什么?ReactTestUtils由with-addons包提供，允许您对模拟 DOM 执行操作以进行单元测试。 ⬆ 返回顶部 什么是 Jest?Jest是一个由 Facebook 基于 Jasmine 创建的 JavaScript 单元测试框架，提供自动模拟创建和jsdom环境。它通常用于测试组件。 ⬆ 返回顶部 Jest 对比 Jasmine 有什么优势?与 Jasmine 相比，有几个优点： 自动查找在源代码中要执行测试。 在运行测试时自动模拟依赖项。 允许您同步测试异步代码。 使用假的 DOM 实现（通过jsdom）运行测试，以便可以在命令行上运行测试。 在并行流程中运行测试，以便更快完成。 ⬆ 返回顶部 举一个简单的 Jest 测试用例让我们为sum.js文件中添加两个数字的函数编写一个测试： 123const sum = (a, b) =&gt; a + bexport default sum 创建一个名为sum.test.js的文件，其中包含实际测试： 12345import sum from './sum'test('adds 1 + 2 to equal 3', () =&gt; &#123; expect(sum(1, 2)).toBe(3)&#125;) 然后将以下部分添加到package.json： 12345&#123; "scripts": &#123; "test": "jest" &#125;&#125; 最后，运行yarn test或npm test，Jest 将打印结果： 123$ yarn testPASS ./sum.test.js✓ adds 1 + 2 to equal 3 (2ms) ⬆ 返回顶部 React Redux 什么是 Flux?Flux 是应用程序设计范例，用于替代更传统的 MVC 模式。它不是一个框架或库，而是一种新的体系结构，它补充了 React 和单向数据流的概念。在使用 React 时，Facebook 会在内部使用此模式。 在 dispatcher，stores 和视图组件具有如下不同的输入和输出： ⬆ 返回顶部 什么是 Redux?Redux 是基于 Flux设计模式 的 JavaScript 应用程序的可预测状态容器。Redux 可以与 React 一起使用，也可以与任何其他视图库一起使用。它很小（约2kB）并且没有依赖性。 ⬆ 返回顶部 Redux 的核心原则是什么？?Redux 遵循三个基本原则： 单一数据来源： 整个应用程序的状态存储在单个对象树中。单状态树可以更容易地跟踪随时间的变化并调试或检查应用程序。 状态是只读的： 改变状态的唯一方法是发出一个动作，一个描述发生的事情的对象。这可以确保视图和网络请求都不会直接写入状态。 使用纯函数进行更改： 要指定状态树如何通过操作进行转换，您可以编写reducers。Reducers 只是纯函数，它将先前的状态和操作作为参数，并返回下一个状态。 ⬆ 返回顶部 与 Flux 相比，Redux 的缺点是什么?我们应该说使用 Redux 而不是 Flux 几乎没有任何缺点。这些如下： 您将需要学会避免突变： Flux 对变异数据毫不吝啬，但 Redux 不喜欢突变，许多与 Redux 互补的包假设您从不改变状态。您可以使用 dev-only 软件包强制执行此操作，例如redux-immutable-state-invariant，Immutable.js，或指示您的团队编写非变异代码。 您将不得不仔细选择您的软件包： 虽然 Flux 明确没有尝试解决诸如撤消/重做，持久性或表单之类的问题，但 Redux 有扩展点，例如中间件和存储增强器，以及它催生了丰富的生态系统。 还没有很好的 Flow 集成： Flux 目前可以让你做一些非常令人印象深刻的静态类型检查，Redux 还不支持。 ⬆ 返回顶部 mapStateToProps() 和 mapDispatchToProps() 之间有什么区别?mapStateToProps()是一个实用方法，它可以帮助您的组件获得最新的状态（由其他一些组件更新）： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; mapDispatchToProps()是一个实用方法，它可以帮助你的组件触发一个动作事件（可能导致应用程序状态改变的调度动作）： 1234567const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125; ⬆ 返回顶部 我可以在 reducer 中触发一个 Action 吗?在 reducer 中触发 Action 是反模式。您的 reducer 应该没有副作用，只是接收 Action 并返回一个新的状态对象。在 reducer 中添加侦听器和调度操作可能会导致链接的 Action 和其他副作用。 ⬆ 返回顶部 如何在组件外部访问 Redux 存储的对象?是的，您只需要使用createStore()从它创建的模块中导出存储。此外，它不应污染全局窗口对象。 123store = createStore(myReducer)export default store ⬆ 返回顶部 MVW 模式的缺点是什么? DOM 操作非常昂贵，导致应用程序行为缓慢且效率低下。 由于循环依赖性，围绕模型和视图创建了复杂的模型。 协作型应用程序（如Google Docs）会发生大量数据更改。 无需添加太多额外代码就无法轻松撤消（及时回退）。 ⬆ 返回顶部 Redux 和 RxJS 之间是否有任何相似之处?这些库的目的是不同的，但是存在一些模糊的相似之处。 Redux 是一个在整个应用程序中管理状态的工具。它通常用作 UI 的体系结构。可以将其视为（一半）Angular 的替代品。 RxJS 是一个反应式编程库。它通常用作在 JavaScript 中完成异步任务的工具。把它想象成 Promise 的替代品。 Redux 使用 Reactive 范例，因为Store是被动的。Store 检测到 Action，并自行改变。RxJS也使用 Reactive 范例，但它不是一个体系结构，它为您提供了基本构建块 Observables 来完成这种模式。 ⬆ 返回顶部 如何在加载时触发 Action?您可以在componentDidMount()方法中触发 Action，然后在render()方法中可以验证数据。 12345678910111213141516171819class App extends Component &#123; componentDidMount() &#123; this.props.fetchData() &#125; render() &#123; return this.props.isLoaded ? &lt;div&gt;&#123;'Loaded'&#125;&lt;/div&gt; : &lt;div&gt;&#123;'Not Loaded'&#125;&lt;/div&gt; &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; isLoaded: state.isLoaded&#125;)const mapDispatchToProps = &#123; fetchData &#125;export default connect(mapStateToProps, mapDispatchToProps)(App) ⬆ 返回顶部 在 React 中如何使用 Redux 的 connect() ?您需要按照两个步骤在容器中使用您的 Store： 使用mapStateToProps()： 它将 Store 中的状态变量映射到您指定的属性。 将上述属性连接到容器： mapStateToProps函数返回的对象连接到容器。你可以从react-redux导入connect()。 1234567891011121314import React from 'react'import &#123; connect &#125; from 'react-redux'class App extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.containerData&#125;&lt;/div&gt; &#125;&#125;function mapStateToProps(state) &#123; return &#123; containerData: state.data &#125;&#125;export default connect(mapStateToProps)(App) ⬆ 返回顶部 如何在 Redux 中重置状态?你需要在你的应用程序中编写一个root reducer，它将处理动作委托给combineReducers()生成的 reducer。 例如，让我们在USER_LOGOUT动作之后让rootReducer()返回初始状态。我们知道，无论 Action 怎么样，当使用undefined作为第一个参数调用它们时，reducers 应该返回初始状态。 1234567891011const appReducer = combineReducers(&#123; /* your app's top-level reducers */&#125;)const rootReducer = (state, action) =&gt; &#123; if (action.type === 'USER_LOGOUT') &#123; state = undefined &#125; return appReducer(state, action)&#125; 如果使用redux-persist，您可能还需要清理存储空间。redux-persist在 storage 引擎中保存您的状态副本。首先，您需要导入适当的 storage 引擎，然后在将其设置为undefined之前解析状态并清理每个存储状态键。 123456789101112131415const appReducer = combineReducers(&#123; /* your app's top-level reducers */&#125;)const rootReducer = (state, action) =&gt; &#123; if (action.type === 'USER_LOGOUT') &#123; Object.keys(state).forEach(key =&gt; &#123; storage.removeItem(`persist:$&#123;key&#125;`) &#125;) state = undefined &#125; return appReducer(state, action)&#125; ⬆ 返回顶部 Redux 中连接装饰器的 at 符号的目的是什么?@符号实际上是用于表示装饰器的 JavaScript 表达式。装饰器可以在设计时注释和修改类和属性。 让我们举个例子，在没有装饰器的情况下设置 Redux 。 未使用装饰器: 123456789101112131415161718import React from 'react'import * as actionCreators from './actionCreators'import &#123; bindActionCreators &#125; from 'redux'import &#123; connect &#125; from 'react-redux'function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;&#125;class MyApp extends React.Component &#123; // ...define your main app here&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyApp) 使用装饰器: 1234567891011121314151617import React from 'react'import * as actionCreators from './actionCreators'import &#123; bindActionCreators &#125; from 'redux'import &#123; connect &#125; from 'react-redux'function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;&#125;@connect(mapStateToProps, mapDispatchToProps)export default class MyApp extends React.Component &#123; // ...define your main app here&#125; 除了装饰器的使用外，上面的例子几乎相似。装饰器语法尚未构建到任何 JavaScript 运行时中，并且仍然是实验性的并且可能会发生变化。您可以使用babel来获得装饰器支持。 ⬆ 返回顶部 React 上下文和 React Redux 之间有什么区别?您可以直接在应用程序中使用Context，这对于将数据传递给深度嵌套的组件非常有用。而Redux功能更强大，它还提供了 Context API 无法提供的大量功能。此外，React Redux 在内部使用上下文，但它不会在公共 API 中有所体现。 ⬆ 返回顶部 为什么 Redux 状态函数称为 reducers ?Reducers 总是返回状态的累积（基于所有先前状态和当前 Action）。因此，它们充当了状态的 Reducer。每次调用 Redux reducer 时，状态和 Action 都将作为参数传递。然后基于该 Action 减少（或累积）该状态，然后返回下一状态。您可以reduce一组操作和一个初始状态（Store），在该状态下执行这些操作以获得最终的最终状态。 ⬆ 返回顶部 如何在 Redux 中发起 AJAX 请求?您可以使用redux-thunk中间件，它允许您定义异步操作。 让我们举个例子，使用fetch API将特定帐户作为 AJAX 调用获取： 1234567891011121314151617export function fetchAccount(id) &#123; return dispatch =&gt; &#123; dispatch(setLoadingAccountState()) // Show a loading spinner fetch(`/account/$&#123;id&#125;`, (response) =&gt; &#123; dispatch(doneFetchingAccount()) // Hide loading spinner if (response.status === 200) &#123; dispatch(setAccount(response.json)) // Use a normal function to set the received state &#125; else &#123; dispatch(someError) &#125; &#125;) &#125;&#125;function setAccount(data) &#123; return &#123; type: 'SET_Account', data: data &#125;&#125; ⬆ 返回顶部 我应该在 Redux Store 中保留所有组件的状态吗? 将数据保存在 Redux 存储中，并在组件内部保持 UI 相关状态。 ⬆ 返回顶部 访问 Redux Store 的正确方法是什么?在组件中访问 Store 的最佳方法是使用connect()函数，该函数创建一个包裹现有组件的新组件。此模式称为高阶组件，通常是在 React 中扩展组件功能的首选方式。这允许您将状态和 Action 创建者映射到组件，并在 Store 更新时自动传递它们。 我们来看一个使用 connect 的&lt;FilterLink&gt;组件的例子： 123456789101112131415161718import &#123; connect &#125; from 'react-redux'import &#123; setVisibilityFilter &#125; from '../actions'import Link from '../components/Link'const mapStateToProps = (state, ownProps) =&gt; (&#123; active: ownProps.filter === state.visibilityFilter&#125;)const mapDispatchToProps = (dispatch, ownProps) =&gt; (&#123; onClick: () =&gt; dispatch(setVisibilityFilter(ownProps.filter))&#125;)const FilterLink = connect( mapStateToProps, mapDispatchToProps)(Link)export default FilterLink 由于它具有相当多的性能优化并且通常不太可能导致错误，因此 Redux 开发人员几乎总是建议使用connect()直接访问 Store（使用上下文API）。 12345class MyComponent &#123; someMethod() &#123; doSomethingWith(this.context.store) &#125;&#125; ⬆ 返回顶部 React Redux 中展示组件和容器组件之间的区别是什么?展示组件是一个类或功能组件，用于描述应用程序的展示部分。 容器组件是连接到 Redux Store的组件的非正式术语。容器组件订阅 Redux 状态更新和dispatch操作，它们通常不呈现 DOM 元素; 他们将渲染委托给展示性的子组件。 ⬆ 返回顶部 Redux 中常量的用途是什么?常量允许您在使用 IDE 时轻松查找项目中该特定功能的所有用法。它还可以防止你拼写错误，在这种情况下，你会立即得到一个ReferenceError。 通常我们会将它们保存在一个文件中（constants.js或actionTypes.js）。 123456export const ADD_TODO = 'ADD_TODO'export const DELETE_TODO = 'DELETE_TODO'export const EDIT_TODO = 'EDIT_TODO'export const COMPLETE_TODO = 'COMPLETE_TODO'export const COMPLETE_ALL = 'COMPLETE_ALL'export const CLEAR_COMPLETED = 'CLEAR_COMPLETED' 在 Redux 中，您可以在两个地方使用它们： 在 Action 创建时: 让我们看看 actions.js: 12345import &#123; ADD_TODO &#125; from './actionTypes';export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; 在 reducers 里: 让我们创建 reducer.js 文件: 12345678910111213141516import &#123; ADD_TODO &#125; from './actionTypes'export default (state = [], action) =&gt; &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, &#123; text: action.text, completed: false &#125; ]; default: return state &#125;&#125; ⬆ 返回顶部 编写 mapDispatchToProps() 有哪些不同的方法?有一些方法可以将action creators绑定到mapDispatchToProps()中的dispatch()。以下是可能的写法： 123const mapDispatchToProps = (dispatch) =&gt; (&#123; action: () =&gt; dispatch(action())&#125;) 123const mapDispatchToProps = (dispatch) =&gt; (&#123; action: bindActionCreators(action, dispatch)&#125;) 1const mapDispatchToProps = &#123; action &#125; 第三种写法只是第一种写法的简写。 ⬆ 返回顶部 在 mapStateToProps() 和 mapDispatchToProps() 中使用 ownProps 参数有什么用?如果指定了ownProps参数，React Redux 会将传递给该组件的 props 传递给你的connect函数。因此，如果您使用连接组件： 123import ConnectedComponent from './containers/ConnectedComponent';&lt;ConnectedComponent user=&#123;'john'&#125; /&gt; 你的mapStateToProps()和mapDispatchToProps()函数里面的ownProps将是一个对象： 1&#123; user: 'john' &#125; 您可以使用此对象来决定从这些函数返回的内容。 ⬆ 返回顶部 如何构建 Redux 项目目录?大多数项目都有几个顶级目录，如下所示： Components: 用于dumb组件，Redux 不必关心的组件。 Containers: 用于连接到 Redux 的smart组件。 Actions: 用于所有 Action 创建器，其中文件名对应于应用程序的一部分。 Reducers: 用于所有 reducer，其中文件名对应于state key。 Store: 用于 Store 初始化。 这种结构适用于中小型项目。 ⬆ 返回顶部 什么是 redux-saga?redux-saga是一个库，旨在使 React/Redux 项目中的副作用（数据获取等异步操作和访问浏览器缓存等可能产生副作用的动作）更容易，更好。 这个包在 NPM 上有发布: 1$ npm install --save redux-saga ⬆ 返回顶部 redux-saga 的模型概念是什么?Saga就像你的项目中的一个单独的线程，它独自负责副作用。redux-saga 是一个 redux 中间件，这意味着它可以在项目启动中使用正常的 Redux 操作，暂停和取消该线程，它可以访问完整的 Redux 应用程序状态，并且它也可以调度 Redux 操作。 ⬆ 返回顶部 在 redux-saga 中 call() 和 put() 之间有什么区别?call()和put()都是 Effect 创建函数。 call()函数用于创建 Effect 描述，指示中间件调用 promise。put()函数创建一个 Effect，指示中间件将一个 Action 分派给 Store。 让我们举例说明这些 Effect 如何用于获取特定用户数据。 1234567891011function* fetchUserSaga(action) &#123; // `call` function accepts rest arguments, which will be passed to `api.fetchUser` function. // Instructing middleware to call promise, it resolved value will be assigned to `userData` variable const userData = yield call(api.fetchUser, action.userId) // Instructing middleware to dispatch corresponding action. yield put(&#123; type: 'FETCH_USER_SUCCESS', userData &#125;)&#125; ⬆ 返回顶部 什么是 Redux Thunk?Redux Thunk中间件允许您编写返回函数而不是 Action 的创建者。 thunk 可用于延迟 Action 的发送，或仅在满足某个条件时发送。内部函数接收 Store 的方法dispatch()和getState()作为参数。 ⬆ 返回顶部 redux-saga 和 redux-thunk 之间有什么区别?Redux Thunk和Redux Saga都负责处理副作用。在大多数场景中，Thunk 使用Promises来处理它们，而 Saga 使用Generators。Thunk 易于使用，因为许多开发人员都熟悉 Promise，Sagas/Generators 功能更强大，但您需要学习它们。但是这两个中间件可以共存，所以你可以从 Thunks 开始，并在需要时引入 Sagas。 ⬆ 返回顶部 什么是 Redux DevTools?Redux DevTools是 Redux 的实时编辑的时间旅行环境，具有热重新加载，Action 重放和可自定义的 UI。如果您不想安装 Redux DevTools 并将其集成到项目中，请考虑使用 Chrome 和 Firefox 的扩展插件。 ⬆ 返回顶部 Redux DevTools 的功能有哪些? 允许您检查每个状态和 action 负载。 让你可以通过撤销回到过去。 如果更改 reducer 代码，将重新评估每个已暂存的 Action。 如果 Reducers 抛出错误，你会看到这发生了什么 Action，以及错误是什么。 使用persistState()存储增强器，您可以在页面重新加载期间保持调试会话。 ⬆ 返回顶部 什么是 Redux 选择器以及使用它们的原因?选择器是将 Redux 状态作为参数并返回一些数据以传递给组件的函数。 例如，要从 state 中获取用户详细信息： 1const getUserData = state =&gt; state.user.data ⬆ 返回顶部 什么是 Redux Form?Redux Form与 React 和 Redux 一起使用，以使 React 中的表单能够使用 Redux 来存储其所有状态。Redux Form 可以与原始 HTML5 输入一起使用，但它也适用于常见的 UI 框架，如 Material UI，React Widgets和React Bootstrap。 ⬆ 返回顶部 Redux Form 的主要功能有哪些? 字段值通过 Redux 存储持久化。 验证（同步/异步）和提交。 字段值的格式化，解析和规范化。 ⬆ 返回顶部 如何向 Redux 添加多个中间件?你可以使用applyMiddleware()。 例如，你可以添加redux-thunk和logger作为参数传递给applyMiddleware()： 12import &#123; createStore, applyMiddleware &#125; from 'redux'const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore) ⬆ 返回顶部 如何在 Redux 中设置初始状态?您需要将初始状态作为第二个参数传递给 createStore ： 12345678910111213const rootReducer = combineReducers(&#123; todos: todos, visibilityFilter: visibilityFilter&#125;)const initialState = &#123; todos: [&#123; id: 123, name: 'example', completed: false &#125;]&#125;const store = createStore( rootReducer, initialState) ⬆ 返回顶部 Relay 与 Redux 有何不同?Relay 与 Redux 类似，因为它们都使用单个 Store。主要区别在于 relay 仅管理源自服务器的状态，并且通过GraphQL查询（用于读取数据）和突变（用于更改数据）来使用对状态的所有访问。Relay 通过仅提取已更改的数据而为您缓存数据并优化数据提取。 ⬆ 返回顶部 React Native React Native 和 React 有什么区别?React是一个 JavaScript 库，支持前端 Web 和在服务器上运行，用于构建用户界面和 Web 应用程序。 React Native是一个移动端框架，可编译为本机应用程序组件，允许您使用 JavaScript 构建本机移动应用程序（iOS，Android和Windows），允许您使用 React 构建组件。 ⬆ 返回顶部 如何测试 React Native 应用程序?React Native 只能在 iOS 和 Android 等移动模拟器中进行测试。您可以使用 expo app（https://expo.io）在移动设备上运行该应用程序。如果使用 QR 代码进行同步，则您的移动设备和计算机应位于同一个无线网络中。 ⬆ 返回顶部 如何在 React Native 查看日志?您可以使用console.log，console.warn等。从 React Native v0.29 开始，您只需运行以下命令即可在控制台中查看日志： 12$ react-native log-ios$ react-native log-android ⬆ 返回顶部 怎么调试 React Native 应用?按照以下步骤调试 React Native 应用程序： 在 iOS 模拟器中运行您的应用程序。 按Command + D，然后在网页中打开http://localhost:8081/debugger-ui。 启用Pause On Caught Exceptions以获得更好的调试体验。 按Command + Option + I打开 Chrome Developer 工具，或通过View -&gt;Developer -&gt;Developer Tools打开它。 您现在应该能够像平常那样进行调试。 ⬆ 返回顶部 React supported libraries &amp; Integration 什么是 Reselect 以及它是如何工作的?Reselect是一个选择器库（用于 Redux ），它使用memoization概念。它最初编写用于计算类似 Redux 的应用程序状态的派生数据，但它不能绑定到任何体系结构或库。 Reselect 保留最后一次调用的最后输入/输出的副本，并仅在其中一个输入发生更改时重新计算结果。如果连续两次提供相同的输入，则 Reselect 将返回缓存的输出。它的 memoization 和缓存是完全可定制的。 ⬆ 返回顶部 什么是 Flow?Flow 是一个静态类型检查器，旨在查找 JavaScript 中的类型错误。与传统类型系统相比，Flow 类型可以表达更细粒度的区别。例如，与大多数类型系统不同，Flow 能帮助你捕获涉及 null 的错误。 ⬆ 返回顶部 Flow 和 PropTypes 有什么区别?Flow 是一个静态分析工具（静态检查器），它使用该语言的超集，允许你在所有代码中添加类型注释，并在编译时捕获整个类的错误。PropTypes 是一个基本类型检查器（运行时检查器），已经被添加到 React 中。除了检查传递给给定组件的属性类型外，它不能检查其他任何内容。如果你希望对整个项目进行更灵活的类型检查，那么 Flow/TypeScript 是更合适的选择。 ⬆ 返回顶部 在 React 中如何使用 Font Awesome 图标?接下来的步骤将在 React 中引入 Font Awesome： 安装 font-awesome: 1$ npm install --save font-awesome 在 index.js 文件中导入 font-awesome: 1import 'font-awesome/css/font-awesome.min.css' 在 className 中添加 Font Awesome 类: 123render() &#123; return &lt;div&gt;&lt;i className=&#123;'fa fa-spinner'&#125; /&gt;&lt;/div&gt;&#125; ⬆ 返回顶部 什么 是 React 开发者工具?React Developer Tools 允许您检查组件层次结构，包括组件属性和状态。它既可以作为浏览器扩展（用于 Chrome 和 Firefox ），也可以作为独立的应用程序（用于其他环境，包括 Safari、IE 和 React Native）。 可用于不同浏览器或环境的官方扩展。 Chrome插件 Firefox插件 独立应用 (Safari, React Native, 等) ⬆ 返回顶部 在 Chrome 中为什么 DevTools 没有加载本地文件?如果您在浏览器中打开了本地 HTML 文件（file://...），则必须先打开Chrome Extensions并选中“允许访问文件URL”。 ⬆ 返回顶部 如何在 React 中使用 Polymer? 创建 Polymer 元素： 1234567&lt;link rel='import' href='../../bower_components/polymer/polymer.html' /&gt;Polymer(&#123; is: 'calender-element', ready: function() &#123; this.textContent = 'I am a calender' &#125;&#125;) 通过在 HTML 文档中导入 Polymer 组件，来创建该组件对应的标签。例如，在 React 应用程序的 index.html 文件中导入。 1&lt;link rel='import' href='./src/polymer-components/calender-element.html'&gt; 在 JSX 文件中使用该元素： 1234567891011import React from 'react'class MyComponent extends React.Component &#123; render() &#123; return ( &lt;calender-element /&gt; ) &#125;&#125;export default MyComponent ⬆ 返回顶部 与 Vue.js 相比，React 有哪些优势?与 Vue.js 相比，React 具有以下优势： 在大型应用程序开发中提供更大的灵活性。 更容易测试。 更适合创建移动端应用程序。 提供更多的信息和解决方案。 ⬆ 返回顶部 React 和 Angular 有什么区别?| React | Angular || —– | ——- || React 是一个库，只有View层 | Angular是一个框架，具有完整的 MVC 功能 || React 可以处理服务器端的渲染 | AngularJS 仅在客户端呈现，但 Angular 2 及更高版本可以在服务器端渲染 || React 在 JS 中使用看起来像 HTML 的 JSX，这可能令人困惑 | Angular 遵循 HTML 的模板方法，这使得代码更短且易于理解 || React Native 是一种 React 类型，它用于构建移动应用程序，它更快，更稳定 | Ionic，Angular 的移动 app 相对原生 app 来说不太稳定和慢 || 在 Reac t中，数据只以单一方向传递，因此调试很容易 | 在 Angular 中，数据以两种方式传递，即它在子节点和父节点之间具有双向数据绑定，因此调试通常很困难 | ⬆ 返回顶部 为什么 React 选项卡不会显示在 DevTools 中?当页面加载时，React DevTools设置一个名为__REACT_DEVTOOLS_GLOBAL_HOOK__的全局变量，然后 React 在初始化期间与该钩子通信。如果网站没有使用 React，或者如果 React 无法与 DevTools 通信，那么它将不会显示该选项卡。 ⬆ 返回顶部 什么是 Styled Components?styled-components 是一个用于样式化 React 应用程序的 JavaScript 库。 它删除了样式和组件之间的映射，并允许您在 js 中编写 CSS。 ⬆ 返回顶部 举一个 Styled Components 的例子?让我们创建具有特定样式的&lt;Title&gt;和&lt;Wrapper&gt;组件。 123456789101112131415import React from 'react'import styled from 'styled-components'// Create a &lt;Title&gt; component that renders an &lt;h1&gt; which is centered, red and sized at 1.5emconst Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`// Create a &lt;Wrapper&gt; component that renders a &lt;section&gt; with some padding and a papayawhip backgroundconst Wrapper = styled.section` padding: 4em; background: papayawhip;` Title和Wrapper变量现在是可以像任何其他 react 组件一样渲染。 123&lt;Wrapper&gt; &lt;Title&gt;&#123;'Lets start first styled component!'&#125;&lt;/Title&gt;&lt;/Wrapper&gt; ⬆ 返回顶部 什么是 Relay?Relay 是一个 JavaScript 框架，用于使用 React 视图层为 Web 应用程序提供数据层和客户端与服务器之间的通信。 ⬆ 返回顶部 如何在 create-react-app 中使用 TypeScript?当您创建一个新项目带有--scripts-version选项值为react-scripts-ts时便可将 TypeScript 引入。 生成的项目结构如下所示： 123456789101112my-app/├─ .gitignore├─ images.d.ts├─ node_modules/├─ public/├─ src/│ └─ ...├─ package.json├─ tsconfig.json├─ tsconfig.prod.json├─ tsconfig.test.json└─ tslint.json ⬆ 返回顶部 Miscellaneous Reselect 库的主要功能有哪些? 选择器可以计算派生数据，允许 Redux 存储最小可能状态。 选择器是有效的。除非其参数之一发生更改，否则不会重新计算选择器。 选择器是可组合的。它们可以用作其他选择器的输入。 ⬆ 返回顶部 举一个 Reselect 用法的例子?让我们通过使用 Reselect 来简化计算不同数量的装运订单： 1234567891011121314151617181920212223242526272829303132333435import &#123; createSelector &#125; from 'reselect'const shopItemsSelector = state =&gt; state.shop.itemsconst taxPercentSelector = state =&gt; state.shop.taxPercentconst subtotalSelector = createSelector( shopItemsSelector, items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0))const taxSelector = createSelector( subtotalSelector, taxPercentSelector, (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100))export const totalSelector = createSelector( subtotalSelector, taxSelector, (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;))let exampleState = &#123; shop: &#123; taxPercent: 8, items: [ &#123; name: 'apple', value: 1.20 &#125;, &#123; name: 'orange', value: 0.95 &#125;, ] &#125;&#125;console.log(subtotalSelector(exampleState)) // 2.15console.log(taxSelector(exampleState)) // 0.172console.log(totalSelector(exampleState)) // &#123; total: 2.322 &#125; ⬆ 返回顶部 Redux 中的 Action 是什么?Actions是纯 JavaScript 对象或信息的有效负载，可将数据从您的应用程序发送到您的 Store。 它们是 Store 唯一的数据来源。 Action 必须具有指示正在执行的操作类型的 type 属性。 例如，表示添加新待办事项的示例操作： 1234&#123; type: ADD_TODO, text: &apos;Add todo item&apos;&#125; ⬆ 返回顶部 在 React 中 statics 对象是否能与 ES6 类一起使用?不行，statics 仅适用于 React.createClass()： 1234567someComponent= React.createClass(&#123; statics: &#123; someMethod: function() &#123; // .. &#125; &#125;&#125;) 但是你可以在 ES6+ 的类中编写静态代码，如下所示： 123456789class Component extends React.Component &#123; static propTypes = &#123; // ... &#125; static someMethod() &#123; // ... &#125;&#125; ⬆ 返回顶部 Redux 只能与 React 一起使用么?Redux 可以用做任何 UI 层的数据存储。最常见的应用场景是 React 和 React Native，但也有一些 bindings 可用于 AngularJS，Angular 2,Vue，Mithril 等项目。Redux 只提供了一种订阅机制，任何其他代码都可以使用它。 ⬆ 返回顶部 您是否需要使用特定的构建工具来使用 Redux ?Redux 最初是用 ES6 编写的，用 Webpack 和 Babel 编译成 ES5。 无论您的 JavaScript 构建过程如何，您都应该能够使用它。Redux 还提供了一个 UMD 版本，可以直接使用而无需任何构建过程。 ⬆ 返回顶部 Redux Form 的 initialValues 如何从状态更新?你需要添加enableReinitialize：true设置。 1234const InitializeFromStateForm = reduxForm(&#123; form: 'initializeFromState', enableReinitialize : true&#125;)(UserEdit) 如果你的initialValues属性得到更新，你的表单也会更新。 ⬆ 返回顶部 React 是如何为一个属性声明不同的类型?你可以使用 PropTypes 中的 oneOfType() 方法。 例如，如下所示 size 的属性值可以是 string 或 number 类型。 123456Component.PropTypes = &#123; size: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ])&#125; ⬆ 返回顶部 我可以导入一个 SVG 文件作为 React 组件么?你可以直接将 SVG 作为组件导入，而不是将其作为文件加载。此功能仅在 `react-scripts@2.0.0` 及更高版本中可用。 12345678import &#123; ReactComponent as Logo &#125; from './logo.svg' const App = () =&gt; ( &lt;div&gt; &#123;/* Logo is an actual react component */&#125; &lt;Logo /&gt; &lt;/div&gt;) **[⬆ 返回顶部](#目录)** 为什么不建议使用内联引用回调或函数?如果将 ref 回调定义为内联函数，则在更新期间它将会被调用两次。首先使用 null 值，然后再使用 DOM 元素。这是因为每次渲染的时候都会创建一个新的函数实例，因此 React 必须清除旧的 ref 并设置新的 ref。 12345678910111213141516class UserForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log("Input Value is: ", this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type='text' ref=&#123;(input) =&gt; this.input = input&#125; /&gt; // Access DOM input in handle submit &lt;button type='submit'&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 但我们期望的是当组件挂载时，ref 回调只会被调用一次。一个快速修复的方法是使用 ES7 类属性语法定义函数。 1234567891011121314151617181920class UserForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log("Input Value is: ", this.input.value) &#125; setSearchInput = (input) =&gt; &#123; this.input = input &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type='text' ref=&#123;this.setSearchInput&#125; /&gt; // Access DOM input in handle submit &lt;button type='submit'&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; **[⬆ 返回顶部](#目录)** 在 React 中什么是渲染劫持?渲染劫持的概念是控制一个组件将从另一个组件输出什么的能力。实际上，这意味着你可以通过将组件包装成高阶组件来装饰组件。通过包装，你可以注入额外的属性或产生其他变化，这可能会导致渲染逻辑的更改。实际上它不支持劫持，但通过使用 HOC，你可以使组件以不同的方式工作。 ⬆ 返回顶部 什么是 HOC 工厂实现?在 React 中实现 HOC 有两种主要方式。 1.属性代理（PP）和 2.继承倒置（II）。他们遵循不同的方法来操纵WrappedComponent。属性代理 在这种方法中，HOC 的 render 方法返回 WrappedComponent 类型的 React 元素。我们通过 HOC 收到 props，因此定义为属性代理。 12345678function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; 继承倒置在这种方法中，返回的 HOC 类（Enhancer）扩展了 WrappedComponent 。它被称为继承反转，因为它不是扩展一些 Enhancer 类的 WrappedComponent，而是由 Enhancer 被动扩展。 通过这种方式，它们之间的关系似乎是逆的。 1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; ⬆ 返回顶部 如何传递数字给 React 组件?传递数字时你应该使用 {}，而传递字符串时还需要使用引号： 1React.render(&lt;User age=&#123;30&#125; department=&#123;"IT"&#125; /&gt;, document.getElementById('container')); ⬆ 返回顶部 我需要将所有状态保存到 Redux 中吗？我应该使用 react 的内部状态吗?这取决于开发者的决定。即开发人员的工作是确定应用程序的哪种状态，以及每个状态应该存在的位置，有些用户喜欢将每一个数据保存在 Redux 中，以维护其应用程序的完全可序列化和受控。其他人更喜欢在组件的内部状态内保持非关键或UI状态，例如“此下拉列表当前是否打开”。 以下是确定应将哪种数据放入Redux的主要规则： 应用程序的其他部分是否关心此数据？ 您是否需要能够基于此原始数据创建更多派生数据？ 是否使用相同的数据来驱动多个组件？ 能够将此状态恢复到给定时间点（即时间旅行调试）是否对您有价值？ 您是否要缓存数据（即，如果已经存在，则使用处于状态的状态而不是重新请求它）？ 在 React 中 registerServiceWorker 的用途是什么?默认情况下，React 会为你创建一个没有任何配置的 service worker。Service worker 是一个 Web API，它帮助你缓存资源和其他文件，以便当用户离线或在弱网络时，他/她仍然可以在屏幕上看到结果，因此，它可以帮助你建立更好的用户体验，这是你目前应该了解的关于 Service worker 的内容。 1234567import React from 'react';import ReactDOM from 'react-dom';import App from './App';import registerServiceWorker from './registerServiceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); ⬆ 返回顶部 React memo 函数是什么?当类组件的输入属性相同时，可以使用 pureComponent 或 shouldComponentUpdate 来避免组件的渲染。现在，你可以通过把函数组件包装在 React.memo 中来实现相同的功能。 123const MyComponent = React.memo(function MyComponent(props) &#123; /* only rerenders if props change */&#125;); ⬆ 返回顶部 React lazy 函数是什么?使用 React.lazy 函数允许你将动态导入的组件作为常规组件进行渲染。当组件开始渲染时，它会自动加载包含 OtherComponent 的包。它必须返回一个 Promise，该 Promise 解析后为一个带有默认导出 React 组件的模块。 123456789const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; );&#125; 注意： React.lazy 和 Suspense 还不能用于服务端渲染。如果要在服务端渲染的应用程序中进行代码拆分，我们仍然建议使用 React Loadable。 ⬆ 返回顶部 如何使用 setState 防止不必要的更新?你可以把状态的当前值与已有的值进行比较，并决定是否重新渲染页面。如果没有更改，你需要返回 null 以阻止渲染，否则返回最新的状态值。例如，用户配置信息组件将按以下方式实现条件渲染： 12345678910getUserProfile = user =&gt; &#123; const latestAddress = user.address; this.setState(state =&gt; &#123; if (state.address === latestAddress) &#123; return null; &#125; else &#123; return &#123; title: latestAddress &#125;; &#125; &#125;);&#125;; ⬆ 返回顶部 如何在 React 16 版本中渲染数组、字符串和数值?Arrays: 与旧版本不同的是，在 React 16 中你不需要确保 render 方法必须返回单个元素。通过返回数组，你可以返回多个没有包装元素的同级元素。例如，让我们看看下面的开发人员列表： 1234567const ReactJSDevs = () =&gt; &#123; return [ &lt;li key="1"&gt;John&lt;/li&gt;, &lt;li key="2"&gt;Jackie&lt;/li&gt;, &lt;li key="3"&gt;Jordan&lt;/li&gt; ];&#125; 你还可以将此数组项合并到另一个数组组件中： 12345678910const JSDevs = () =&gt; &#123; return ( &lt;ul&gt; &lt;li&gt;Brad&lt;/li&gt; &lt;li&gt;Brodge&lt;/li&gt; &lt;ReactJSDevs/&gt; &lt;li&gt;Brandon&lt;/li&gt; &lt;/ul&gt; );&#125; Strings and Numbers: 在 render 方法中，你也可以返回字符串和数值类型： 12345678// Stringrender() &#123; return 'Welcome to ReactJS questions';&#125;// Numberrender() &#123; return 2018;&#125; ⬆ 返回顶部 如何在 React 类中使用类字段声明语法?使用类字段声明可以使 React 类组件更加简洁。你可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定。让我们以一个 counter 示例来演示类字段声明，即不使用构造函数初始化状态且不进行方法绑定： 1234567891011121314151617181920212223242526class Counter extends Component &#123; state = &#123; value: 0 &#125;; handleIncrement = () =&gt; &#123; this.setState(prevState =&gt; (&#123; value: prevState.value + 1 &#125;)); &#125;; handleDecrement = () =&gt; &#123; this.setState(prevState =&gt; (&#123; value: prevState.value - 1 &#125;)); &#125;; render() &#123; return ( &lt;div&gt; &#123;this.state.value&#125; &lt;button onClick=&#123;this.handleIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;this.handleDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; ⬆ 返回顶部 什么是 hooks?Hooks 是一个新的草案，它允许你在不编写类的情况下使用状态和其他 React 特性。让我们来看一个 useState 钩子示例： 123456789101112131415import &#123; useState &#125; from 'react';function Example() &#123; // Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 阅读资源： 掘金 - 30分钟精通React Hooks ⬆ 返回顶部 Hooks 需要遵循什么规则?为了使用 hooks，你需要遵守两个规则： 仅在顶层的 React 函数调用 hooks。也就是说，你不能在循环、条件或内嵌函数中调用 hooks。这将确保每次组件渲染时都以相同的顺序调用 hooks，并且它会在多个 useState 和 useEffect 调用之间保留 hooks 的状态。 仅在 React 函数中调用 hooks。例如，你不能在常规的 JavaScript 函数中调用 hooks。 ⬆ 返回顶部 如何确保钩子遵循正确的使用规则?React 团队发布了一个名为eslint-plugin-react-hooks的 ESLint 插件，它实施了这两个规则。您可以使用以下命令将此插件添加到项目中， 1npm install eslint-plugin-react-hooks@next 并在您的 ESLint 配置文件中应用以下配置： 1234567891011// Your ESLint configuration&#123; "plugins": [ // ... "react-hooks" ], "rules": &#123; // ... "react-hooks/rules-of-hooks": "error" &#125;&#125; 注意： 此插件在 Create React App 已经默认配置。 ⬆ 返回顶部 Flux 和 Redux 之间有什么区别?以下是 Flux 和 Redux 之间的主要区别 | Flux | Redux || —– | ——- || 状态是可变的 | 状态是不可变的 || Store 包含状态和更改逻辑 | 存储和更改逻辑是分开的 || 存在多个 Store | 仅存在一个 Store || 所有的 Store 都是断开连接的 | 带有分层 reducers 的 Store || 它有一个单独的 dispatcher | 没有 dispatcher 的概念 || React 组件监测 Store | 容器组件使用连接函数 | ⬆ 返回顶部 React Router V4 有什么好处?以下是 React Router V4 模块的主要优点： 在React Router v4（版本4）中，API完全与组件有关。路由器可以显示为单个组件（），它包装特定的子路由器组件（）。 您无需手动设置历史记录。路由器模块将通过使用组件包装路由来处理历史记录。 通过仅添加特定路由器模块（Web，core 或 native）来减少应用大小。 ⬆ 返回顶部 您能描述一下 componentDidCatch 生命周期方法签名吗?在后代层级的组件抛出错误后，将调用componentDidCatch生命周期方法。该方法接收两个参数： error: - 抛出的错误对象 info: - 具有 componentStack 键的对象，包含有关哪个组件引发错误的信息。 方法结构如下： 1componentDidCatch(error, info) ⬆ 返回顶部 在哪些情况下，错误边界不会捕获错误?以下是错误边界不起作用的情况： 在事件处理器内。 setTimeout 或 requestAnimationFrame 回调中的异步代码。 在服务端渲染期间。 错误边界代码本身中引发错误时。 ⬆ 返回顶部 为什么事件处理器不需要错误边界?错误边界不会捕获事件处理程序中的错误。与 render 方法或生命周期方法不同，在渲染期间事件处理器不会被执行或调用。 如果仍然需要在事件处理程序中捕获错误，请使用下面的常规 JavaScript try/catch 语句： 123456789101112131415161718192021class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null &#125;; &#125; handleClick = () =&gt; &#123; try &#123; // Do something that could throw &#125; catch (error) &#123; this.setState(&#123; error &#125;); &#125; &#125; render() &#123; if (this.state.error) &#123; return &lt;h1&gt;Caught an error.&lt;/h1&gt; &#125; return &lt;div onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/div&gt; &#125;&#125; 上面的代码使用普通的 JavaScript try/catch 块而不是错误边界来捕获错误。 ⬆ 返回顶部 try catch 与错误边界有什么区别?Try catch 块使用命令式代码，而错误边界则是使用在屏幕上呈现声明性代码。 例如，以下是使用声明式代码的 try/catch 块： 12345try &#123; showButton();&#125; catch (error) &#123; // ...&#125; 而错误边界包装的声明式代码如下： 123&lt;ErrorBoundary&gt; &lt;MyComponent /&gt;&lt;/ErrorBoundary&gt; 因此，如果在组件树深处某个位置组件的 componentDidUpdate 方法中，发生了由 setState 引发的错误，它仍然会正确地冒泡到最近的错误边界。 ⬆ 返回顶部 React 16 中未捕获的错误的行为是什么?在 React 16 中，未被任何错误边界捕获的错误将导致整个 React 组件树的卸载。这一决定背后的原因是，与其显示已损坏的界面，不如完全移除它。例如，对于支付应用程序来说，显示错误的金额比什么都不提供更糟糕。 ⬆ 返回顶部 放置错误边界的正确位置是什么?错误边界使用的粒度由开发人员根据项目需要决定。你可以遵循这些方法中的任何一种： 可以包装顶层路由组件以显示整个应用程序中常见的错误消息。 你还可以将单个组件包装在错误边界中，以防止它们奔溃时影响到应用程序的其余部分。 ⬆ 返回顶部 从错误边界跟踪组件堆栈有什么好处?除了错误消息和 JavaScript 堆栈，React 16 将使用错误边界的概念显示带有文件名和行号的组件堆栈。例如，BuggyCounter 组件显示组件堆栈信息： ⬆ 返回顶部 在定义类组件时，什么是必须的方法?在类组件中 render() 方法是唯一需要的方法。也就是说，对于类组件，除了 render() 方法之外的所有方法都是可选的。 ⬆ 返回顶部 render 方法可能返回的类型是什么?以下列表是 render 方法返回的类型： React elements: 用于告诉 React 如何渲染 DOM 节点。它包括 HTML 元素，如 &lt;div /&gt; 和用户定义的元素。 Arrays and fragments: 以数组的形式返回多个元素和包装多个元素的片段。 Portals: 将子元素渲染到不同的 DOM 子树中。 String and numbers: 在 DOM 中将字符串和数字都作为文本节点进行呈现。 Booleans or null: 不会渲染任何内容，但这些类型用于有条件地渲染内容。 ⬆ 返回顶部 构造函数的主要目的是什么?使用构造函数主要有两个目的： 通过将对象分配给 this.state 来初始化本地状态。 用于为组件实例绑定事件处理方法。 例如，下面的代码涵盖了上述两种情况： 123456constructor(props) &#123; super(props); // Don't call this.setState() here! this.state = &#123; counter: 0 &#125;; this.handleClick = this.handleClick.bind(this);&#125; ⬆ 返回顶部 是否必须为 React 组件定义构造函数?不，这不是强制的。也就是说，如果你不需要初始化状态且不需要绑定方法，则你不需要为 React 组件实现一个构造函数。 ⬆ 返回顶部 什么是默认属性?defaultProps 被定义为组件类上的属性，用于设置组件类默认的属性值。它只适用于 undefined 的属性，而不适用于 null 属性。例如，让我们为按钮组件创建默认的 color 属性： 1234567class MyButton extends React.Component &#123; // ...&#125;MyButton.defaultProps = &#123; color: 'red'&#125;; 如果未设置 props.color，则会使用默认值 red。 也就是说，每当你试图访问 color 属性时，它都使用默认值。 123render() &#123; return &lt;MyButton /&gt; ; // props.color will be set to red &#125; 注意： 如果你提供的是 null 值，它会仍然保留 null 值。 ⬆ 返回顶部 为什么不能在 componentWillUnmount 中调用 setState() 方法?不应在 componentWillUnmount() 中调用 setState()，因为一旦卸载了组件实例，就永远不会再次装载它。 ⬆ 返回顶部 getDerivedStateFromError 的目的是什么?在子代组件抛出异常后会调用此生命周期方法。它以抛出的异常对象作为参数，并返回一个值用于更新状态。该生命周期方法的签名如下： 1static getDerivedStateFromError(error) 让我们举一个包含上述生命周期方法的错误边界示例，来说明 getDerivedStateFromError 的目的： 1234567891011121314151617181920class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; static getDerivedStateFromError(error) &#123; // Update state so the next render will show the fallback UI. return &#123; hasError: true &#125;; &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; ⬆ 返回顶部 当组件重新渲染时顺序执行的方法有哪些?更新可能由属性或状态的更改引起。在重新渲染组件时，会按以下顺序调用下列方法。 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() ⬆ 返回顶部 错误处理期间调用哪些方法?在渲染期间，生命周期方法内或任何子组件的构造函数中出现错误时，将会调用以下方法： static getDerivedStateFromError() componentDidCatch() ⬆ 返回顶部 displayName 类属性的用途是什么?displayName 被用于调试信息。通常，你不需要显式设置它，因为它是从定义组件的函数或类的名称推断出来的。如果出于调试目的或在创建高阶组件时显示不同的名称，可能需要显式设置它。 例如，若要简化调试，请选择一个显示名称，以表明它是 withSubscription HOC 的结果。 123456789function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123;/* ... */&#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || 'Component';&#125; ⬆ 返回顶部 支持 React 应用程序的浏览器有哪一些?React 支持所有流行的浏览器，包括 Internet Explorer 9 和更高版本，但旧版本的浏览器（如IE 9 和 IE 10）需要一些 polyfill。如果你使用 es5-shim and es5-sham polyfill，那么它甚至支持不支持 ES5 方法的旧浏览器。 ⬆ 返回顶部 unmountComponentAtNode 方法的目的是什么?此方法可从 react-dom 包中获得，它从 DOM 中移除已装载的 React 组件，并清除其事件处理程序和状态。如果容器中没有装载任何组件，则调用此函数将不起任何作用。如果组件已卸载，则返回 true；如果没有要卸载的组件，则返回 false。该方法的签名如下： 1ReactDOM.unmountComponentAtNode(container) ⬆ 返回顶部 什么是代码拆分?Code-Splitting 是 Webpack 和 Browserify 等打包工具所支持的一项功能，它可以创建多个 bundles，并可以在运行时动态加载。React 项目支持通过 dynamic import() 特性进行代码拆分。例如，在下面的代码片段中，它将使 moduleA.js 及其所有唯一依赖项作为单独的块，仅当用户点击 ‘Load’ 按钮后才加载。 moduleA.js 123const moduleA = 'Hello';export &#123; moduleA &#125;; App.js 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';class App extends Component &#123; handleClick = () =&gt; &#123; import('./moduleA') .then((&#123; moduleA &#125;) =&gt; &#123; // Use moduleA &#125;) .catch(err =&gt; &#123; // Handle failure &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Load&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; ⬆ 返回顶部 严格模式有什么好处?在下面的情况下， 将有所帮助： 使用 unsafe lifecycle methods 标识组件。 有关 legacy string ref API 用法发出警告。 检测无法预测的 side effects。 检测 legacy context API。 有关已弃用的 findDOMNode 用法的警告。 ⬆ 返回顶部 什么是 Keyed Fragments ?使用显式 &lt;React.Fragment&gt; 语法声明的片段可能具有 key 。一般用例是将集合映射到片段数组，如下所示， 12345678910111213function Glossary(props) &#123; return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // Without the `key`, React will fire a key warning &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; );&#125; 注意： 键是唯一可以传递给 Fragment 的属性。将来，可能会支持其他属性，例如事件处理程序。 ⬆ 返回顶部 React 支持所有的 HTML 属性么?从 React 16 开始，完全支持标准或自定义 DOM 属性。由于 React 组件通常同时使用自定义和与 DOM 相关的属性，因此 React 与 DOM API 一样都使用 camelCase 约定。让我们对标准 HTML 属性采取一些措施： 123&lt;div tabIndex="-1" /&gt; // Just like node.tabIndex DOM API&lt;div className="Button" /&gt; // Just like node.className DOM API&lt;input readOnly=&#123;true&#125; /&gt; // Just like node.readOnly DOM API 除了特殊情况外，这些属性的工作方式与相应的 HTML 属性类似。它还支持所有 SVG 属性。 ⬆ 返回顶部 HOC 有哪些限制?除了它的好处之外，高阶组件还有一些注意事项。 以下列出的几个注意事项: 不要在渲染方法中使用HOC：建议不要将 HOC 应用于组件的 render 方法中的组件。 1234567render() &#123; // A new version of EnhancedComponent is created on every render // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // That causes the entire subtree to unmount/remount each time! return &lt;EnhancedComponent /&gt;;&#125; 上述代码通过重新装载，将导致该组件及其所有子组件状态丢失，会影响到性能。正确的做法应该是在组件定义之外应用 HOC ，以便仅生成一次生成的组件 静态方法必须复制：将 HOC 应用于组件时，新组件不具有原始组件的任何静态方法 1234567// Define a static methodWrappedComponent.staticMethod = function() &#123;/*...*/&#125;// Now apply a HOCconst EnhancedComponent = enhance(WrappedComponent);// The enhanced component has no static methodtypeof EnhancedComponent.staticMethod === 'undefined' // true 您可以通过在返回之前将方法复制到输入组件上来解决此问题 123456function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; Refs 不会被往下传递对于HOC，您需要将所有属性传递给包装组件，但这对于 refs 不起作用。这是因为 ref 并不是一个类似于 key 的属性。在这种情况下，您需要使用 React.forwardRef API。 ⬆ 返回顶部 如何在 DevTools 中调试 forwardRefs?React.forwardRef接受渲染函数作为参数，DevTools 使用此函数来确定为 ref 转发组件显示的内容。例如，如果您没有使用 displayName 属性命名 render 函数，那么它将在 DevTools 中显示为“ForwardRef”， 123const WrappedComponent = React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;&#125;); 但如果你命名 render 函数，那么它将显示为 “ForwardRef(myFunction)” 12345const WrappedComponent = React.forwardRef( function myFunction(props, ref) &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;); 作为替代方案，您还可以为 forwardRef 函数设置 displayName 属性， 12345678910111213141516function logProps(Component) &#123; class LogProps extends React.Component &#123; // ... &#125; function forwardRef(props, ref) &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125; // Give this component a more helpful display name in DevTools. // e.g. "ForwardRef(logProps(MyComponent))" const name = Component.displayName || Component.name; forwardRef.displayName = `logProps($&#123;name&#125;)`; return React.forwardRef(forwardRef);&#125; ⬆ 返回顶部 什么时候组件的 props 属性默认为 true?如果没有传递属性值，则默认为 true。此行为可用，以便与 HTML 的行为匹配。例如，下面的表达式是等价的： 123&lt;MyInput autocomplete /&gt;&lt;MyInput autocomplete=&#123;true&#125; /&gt; 注意： 不建议使用此方法，因为它可能与 ES6 对象 shorthand 混淆（例如，{name}，它是{ name:name } 的缩写） ⬆ 返回顶部 什么是 NextJS 及其主要特征?Next.js 是一个流行的轻量级框架，用于使用 React 构建静态和服务端渲染应用程序。它还提供样式和路由解决方案。以下是 NextJS 提供的主要功能： 默认服务端渲染 自动代码拆分以加快页面加载速度 简单的客户端路由 (基于页面) 基于 Webpack 的开发环境支持 (HMR) 能够使用 Express 或任何其他 Node.js HTTP 服务器 可自定义你自己的 Babel 和 Webpack 配置 ⬆ 返回顶部 如何将事件处理程序传递给组件?可以将事件处理程序和其他函数作为属性传递给子组件。它可以在子组件中使用，如下所示： 1&lt;button onClick=&#123;this.handleClick&#125;&gt; ⬆ 返回顶部 在渲染方法中使用箭头函数好么?是的，你可以用。它通常是向回调函数传递参数的最简单方法。但在使用时需要优化性能。 12345678class Foo extends Component &#123; handleClick() &#123; console.log('Click happened'); &#125; render() &#123; return &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;Click Me&lt;/button&gt;; &#125;&#125; 注意： 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。 ⬆ 返回顶部 如何防止函数被多次调用?如果你使用一个事件处理程序，如 onClick or onScroll 并希望防止回调被过快地触发，那么你可以限制回调的执行速度。 这可以通过以下可能的方式实现： Throttling: 基于时间的频率进行更改。例如，它可以使用 lodash 的 _.throttle 函数。 Debouncing: 在一段时间不活动后发布更改。例如，可以使用 lodash 的 _.debounce 函数。 RequestAnimationFrame throttling: 基于 requestAnimationFrame 的更改。例如，可以使用 raf-schd。 注意：_.debounce , _.throttle 和 raf-schd 都提供了一个 cancel 方法来取消延迟回调。所以需要调用 componentWillUnmount，或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载。 ⬆ 返回顶部 JSX 如何防止注入攻击?React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。 12const name = response.potentiallyMaliciousInput;const element = &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;; 这样可以防止应用程序中的XSS（跨站点脚本）攻击。 ⬆ 返回顶部 如何更新已渲染的元素?通过将新创建的元素传递给 ReactDOM 的 render 方法，可以实现 UI 更新。例如，让我们举一个滴答时钟的例子，它通过多次调用 render 方法来更新时间： 1234567891011function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));&#125;setInterval(tick, 1000); ⬆ 返回顶部 你怎么说 props 是只读的?当你将组件声明为函数或类时，它决不能修改自己的属性。让我们来实现一个 capital 的函数： 123function capital(amount, interest) &#123; return amount + interest;&#125; 上面的函数称为 “pure” 函数，因为它不会尝试更改输入，并总是为相同的输入返回相同的结果。因此，React 有一条规则，即”所有 React 组件的行为都必须像纯函数一样。” ⬆ 返回顶部 你认为状态更新是如何合并的?When you call setState() in the component, React merges the object you provide into the current state. For example, let us take a facebook user with posts and comments details as state variables,当你在组件中调用 setState() 方法时，React 会将提供的对象合并到当前状态。例如，让我们以一个使用帖子和评论详细信息的作为状态变量的 Facebook 用户为例： 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 现在，你可以独立调用 setState() 方法，单独更新状态变量： 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; 如上面的代码段所示，this.setState({comments}) 只会更新 comments 变量，而不会修改或替换 posts 变量。 ⬆ 返回顶部 如何将参数传递给事件处理程序?在迭代或循环期间，向事件处理程序传递额外的参数是很常见的。这可以通过箭头函数或绑定方法实现。让我们以网格中更新的用户详细信息为例： 12&lt;button onClick=&#123;(e) =&gt; this.updateUser(userId, e)&#125;&gt;Update User details&lt;/button&gt;&lt;button onClick=&#123;this.updateUser.bind(this, userId)&#125;&gt;Update User details&lt;/button&gt; 在这两种方法中，合成参数 e 作为第二个参数传递。你需要在箭头函数中显式传递它，并使用 bind 方法自动转发它。 ⬆ 返回顶部 如何防止组件渲染?你可以基于特定的条件通过返回 null 值来阻止组件的渲染。这样它就可以有条件地渲染组件。 1234567891011function Greeting(props) &#123; if (!props.loggedIn) &#123; return null; &#125; return ( &lt;div className="greeting"&gt; welcome, &#123;props.name&#125; &lt;/div&gt; );&#125; 123456789101112131415class User extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;loggedIn: false, name: 'John'&#125;; &#125; render() &#123; return ( &lt;div&gt; //Prevent component render if it is not loggedIn &lt;Greeting loggedIn=&#123;this.state.loggedIn&#125; /&gt; &lt;UserDetails name=&#123;this.state.name&#125;&gt; &lt;/div&gt; ); &#125; 在上面的示例中，greeting 组件通过应用条件并返回空值跳过其渲染部分。 ⬆ 返回顶部 安全地使用索引作为键的条件是什么?有三个条件可以确保，使用索引作为键是安全的： 列表项是静态的，它们不会被计算，也不会更改。 列表中的列表项没有 ids 属性。 列表不会被重新排序或筛选。 ⬆ 返回顶部 keys 是否需要全局唯一?数组中使用的键在其同级中应该是唯一的，但它们不需要是全局唯一的。也就是说，你可以在两个不同的数组中使用相同的键。例如，下面的 book 组件在不同的组件中使用相同的数组： 12345678910111213141516171819202122232425function Book(props) &#123; const index = ( &lt;ul&gt; &#123;props.pages.map((page) =&gt; &lt;li key=&#123;page.id&#125;&gt; &#123;page.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); const content = props.pages.map((page) =&gt; &lt;div key=&#123;page.id&#125;&gt; &lt;h3&gt;&#123;page.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;page.content&#125;&lt;/p&gt; &lt;p&gt;&#123;page.pageNumber&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;index&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125; ⬆ 返回顶部 用于表单处理的流行选择是什么?Formik 是一个用于 React 的表单库，它提供验证、跟踪访问字段和处理表单提交等解决方案。具体来说，你可以按以下方式对它们进行分类： 获取表单状态输入和输出的值。 表单验证和错误消息。 处理表单提交。 它用于创建一个具有最小 API 的可伸缩、性能良好的表单助手，以解决令人讨厌的问题。 ⬆ 返回顶部 formik 相对于其他 redux 表单库有什么优势?下面是建议使用 formik 而不是 redux 表单库的主要原因： 表单状态本质上是短期的和局部的，因此不需要在 redux（或任何类型的flux库）中跟踪它。 每次按一个键，Redux-Form 都会多次调用整个顶级 Redux Reducer。这样就增加了大型应用程序的输入延迟。 经过 gzip 压缩过的 Redux-Form 为 22.5 kB，而 Formik 只有 12.7 kB。 ⬆ 返回顶部 为什么不需要使用继承?在 React 中，建议使用组合而不是继承来重用组件之间的代码。Props 和 composition 都为你提供了以一种明确和安全的方式自定义组件外观和行为所需的灵活性。但是，如果你希望在组件之间复用非 UI 功能，建议将其提取到单独的 JavaScript 模块中。之后的组件导入它并使用该函数、对象或类，而不需扩展它。 ⬆ 返回顶部 我可以在 React 应用程序中可以使用 web components 么?是的，你可以在 React 应用程序中使用 Web Components。尽管许多开发人员不会使用这种组合方式，但如果你使用的是使用 Web Components 编写的第三方 UI 组件，则可能需要这种组合。例如，让我们使用 Vaadin 提供的 Web Components 日期选择器组件： 123456789101112131415import React, &#123; Component &#125; from 'react';import './App.css';import '@vaadin/vaadin-date-picker';class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;vaadin-date-picker label="When were you born?"&gt;&lt;/vaadin-date-picker&gt; &lt;/div&gt; ); &#125;&#125;export default App; ⬆ 返回顶部 什么是动态导入?动态导入语法是 ECMAScript 提案，目前不属于语言标准的一部分。它有望在不久的将来被采纳。在你的应用程序中，你可以使用动态导入来实现代码拆分。让我们举一个加法的例子： Normal Import 12import &#123; add &#125; from './math';console.log(add(10, 20)); Dynamic Import 123import("./math").then(math =&gt; &#123; console.log(math.add(10, 20));&#125;); ⬆ 返回顶部 什么是 loadable 组件?如果你想要在服务端渲染的应用程序中实现代码拆分，建议使用 Loadable 组件，因为 React.lazy 和 Suspense 还不可用于服务器端渲染。Loadable 允许你将动态导入的组件作为常规的组件进行渲染。让我们举一个例子： 1234567891011import loadable from '@loadable/component'const OtherComponent = loadable(() =&gt; import('./OtherComponent'))function MyComponent() &#123; return ( &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; )&#125; 现在，其他组件将以单独的包进行加载。 ⬆ 返回顶部 什么是 suspense 组件?如果父组件在渲染时包含 dynamic import 的模块尚未加载完成，在此加载过程中，你必须使用一个 loading 指示器显示后备内容。这可以使用 Suspense 组件来实现。例如，下面的代码使用 Suspense 组件： 1234567891011const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 正如上面的代码中所展示的，懒加载的组件被包装在 Suspense 组件中。 ⬆ 返回顶部 什么是基于路由的代码拆分?进行代码拆分的最佳位置之一是路由。整个页面将立即重新渲染，因此用户不太可能同时与页面中的其他元素进行交互。因此，用户体验不会受到干扰。让我们以基于路由的网站为例，使用像 React Router 和 React.lazy 这样的库： 12345678910111213141516import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom';import React, &#123; Suspense, lazy &#125; from 'react';const Home = lazy(() =&gt; import('./routes/Home'));const About = lazy(() =&gt; import('./routes/About'));const App = () =&gt; ( &lt;Router&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt;); 在上面的代码中，代码拆分将发生在每个路由层级。 ⬆ 返回顶部 举例说明如何使用 context?Context 旨在共享可被视为全局的数据，用于 React 组件树。例如，在下面的代码中，允许手动通过一个 theme 属性来设置按钮组件的样式。 123456789101112131415161718192021222324252627//Lets create a context with a default theme value "luna"const ThemeContext = React.createContext('luna');// Create App component where it uses provider to pass theme value in the treeclass App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value="nova"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// A middle component where you don't need to pass theme prop anymorefunction Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;// Lets read theme value in the button component to useclass ThemedButton extends React.Component &#123; static contextType = ThemeContext; render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;; &#125;&#125; ⬆ 返回顶部 在 context 中默认值的目的是什么?当在组件树中的组件没有匹配到在其上方的 Provider 时，才会使用 defaultValue 参数。这有助于在不包装组件的情况下单独测试组件。下面的代码段提供了默认的主题值 Luna。 12const defaultTheme = "Luna"；const MyContext = React.createContext(defaultTheme); ⬆ 返回顶部 你是怎么使用 contextType?ContextType 用于消费 context 对象。ContextType 属性可以通过两种方式使用： contextType as property of class:可以为类的 contextType 属性分配通过 React.createContext() 创建的 context 对象。之后，你可以在任何生命周期方法和 render 函数中使用 this.context 引用该上下文类型最近的当前值。 让我们在 MyClass 上按如下方式设置 contextType 属性： 12345678910111213141516171819class MyClass extends React.Component &#123; componentDidMount() &#123; let value = this.context; /* perform a side-effect at mount using the value of MyContext */ &#125; componentDidUpdate() &#123; let value = this.context; /* ... */ &#125; componentWillUnmount() &#123; let value = this.context; /* ... */ &#125; render() &#123; let value = this.context; /* render something based on the value of MyContext */ &#125;&#125;MyClass.contextType = MyContext; Static field你可以使用静态类属性来初始化 contextType 属性： 1234567class MyClass extends React.Component &#123; static contextType = MyContext; render() &#123; let value = this.context; /* render something based on the value */ &#125;&#125; ⬆ 返回顶部 什么是 consumer?Consumer 是一个订阅上下文更改的 React 组件。它需要一个函数作为子元素，该函数接收当前上下文的值作为参数，并返回一个 React 元素。传递给函数 value 参数的参数值将等于在组件树中当前组件最近的 Provider 元素的 value 属性值。举个简单的例子： 123&lt;MyContext.Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/MyContext.Consumer&gt; ⬆ 返回顶部 在使用 context 时，如何解决性能方面的问题?Context 使用引用标识来确定何时重新渲染，当 Provider 的父元素重新渲染时，会有一些问题即可能会在 Consumers 中触发无任何意图的渲染。 例如，下面的代码将在每次 Provider 重新渲染时，重新渲染所有的 Consumers，这是因为渲染 Provider 时，始终会为 value 属性创建一个新的对象： 123456789class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 可以通过把 value 的值提升到父状态中来解决这个问题： 12345678910111213141516class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; **[⬆ 返回顶部](#目录)** 在 HOCs 中 forward ref 的目的是什么?因为 ref 不是一个属性，所以 Refs 不会被传递。就像 key 一样，React 会以不同的方式处理它。如果你将 ref 添加到 HOC，则该 ref 将引用最外层的容器组件，而不是包装的组件。在这种情况下，你可以使用 Forward Ref API。例如，你可以使用 React.forwardRef API 显式地将 refs 转发的内部的 FancyButton 组件。 以下的 HOC 会记录所有的 props 变化： 12345678910111213141516171819function logProps(Component) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; // Assign the custom prop "forwardedRef" as a ref return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;);&#125; 让我们使用这个 HOC 来记录所有传递到我们 “fancy button” 组件的属性： 12345678class FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;export default logProps(FancyButton); 现在让我们创建一个 ref 并将其传递给 FancyButton 组件。在这种情况下，你可以聚焦到 button 元素上。 123456789import FancyButton from './FancyButton';const ref = React.createRef();ref.current.focus();&lt;FancyButton label="Click Me" handleClick=&#123;handleClick&#125; ref=&#123;ref&#125;/&gt;; ⬆ 返回顶部 ref 参数对于所有函数或类组件是否可用?常规函数或类组件不会接收到 ref 参数，并且 ref 在 props 中也不可用。只有在使用 React.forwardRef 定义组件时，才存在第二个 ref 参数。 ⬆ 返回顶部 在组件库中当使用 forward refs 时，你需要额外的注意?当你开始在组件库中使用 forwardRef 时，你应该将其视为一个破坏性的更改，并为库发布一个新的主要版本。这是因为你的库可能具有不同的行为，如已分配了哪些引用，以及导出哪些类型。这些更改可能会破坏依赖于旧行为的应用程序和其他库。 ⬆ 返回顶部 如何在没有 ES6 的情况下创建 React 类组件如果你不使用 ES6，那么你可能需要使用 create-react-class 模块。对于默认属性，你需要在传递对象上定义 getDefaultProps() 函数。而对于初始状态，必须提供返回初始状态的单独 getInitialState 方法。 12345678910111213141516var Greeting = createReactClass(&#123; getDefaultProps: function() &#123; return &#123; name: 'Jhohn' &#125;; &#125;, getInitialState: function() &#123; return &#123;message: this.props.message&#125;; &#125;, handleClick: function() &#123; console.log(this.state.message); &#125;, render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;); 注意： 如果使用 createReactClass，则所有方法都会自动绑定。也就是说，你不需要在事件处理程序的构造函数中使用 .bind(this)。 ⬆ 返回顶部 是否可以在没有 JSX 的情况下使用 React?是的，使用 React 不强制使用 JSX。实际上，当你不想在构建环境中配置编译环境时，这是很方便的。每个 JSX 元素只是调用 React.createElement(component, props, …children) 的语法糖。例如，让我们来看一下使用 JSX 的 greeting 示例： 12345678910class Greeting extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.message&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Greeting message="World" /&gt;, document.getElementById('root')); 你可以在没有 JSX 的情况下编写相同的功能，如下所示： 12345678910class Greeting extends React.Component &#123; render() &#123; return React.createElement('div', null, `Hello $&#123;this.props.message&#125;`); &#125;&#125;ReactDOM.render( React.createElement(Greeting, &#123;message: 'World'&#125;, null), document.getElementById('root')); ⬆ 返回顶部 什么是差异算法?React 需要使用算法来了解如何有效地更新 UI 以匹配最新的树。差异算法将生成将一棵树转换为另一棵树的最小操作次数。然而，算法具有 O(n3) 的复杂度，其中 n 是树中元素的数量。在这种情况下，对于显示 1000 个元素将需要大约 10 亿个比较。这太昂贵了。相反，React 基于两个假设实现了一个复杂度为 O(n) 的算法： 两种不同类型的元素会产生不同的树结构。 开发者可以通过一个 key 属性，标识哪些子元素可以在不同渲染中保持稳定。 ⬆ 返回顶部 差异算法涵盖了哪些规则?在区分两棵树时，React 首先比较两个根元素。根据根元素的类型，行为会有所不同。它在重构算法中涵盖了以下规则： 不同类型的元素：每当根元素具有不同的类型时，React 将移除旧树并从头开始构建新树。例如，元素 到 ，或从 到 的不同类型的元素引导完全重建。 相同类型的DOM元素：当比较两个相同类型的 React DOM 元素时，React 查看两者的属性，保持相同的底层 DOM 节点，并仅更新已更改的属性。让我们以相同的 DOM 元素为例，除了 className 属性， 123&lt;div className="show" title="ReactJS" /&gt;&lt;div className="hide" title="ReactJS" /&gt; 相同类型的组件元素： 当组件更新时，实例保持不变，以便在渲染之间保持状态。React 更新底层组件实例的 props 以匹配新元素，并在底层实例上调用 componentWillReceiveProps() 和 componentWillUpdate()。之后，调用 render() 方法，diff 算法对前一个结果和新结果进行递归。 递归子节点：当对 DOM 节点的子节点进行递归时，React 会同时迭代两个子节点列表，并在出现差异时生成变异。例如，在子节点末尾添加元素时，在这两个树之间进行转换效果很好。 12345678910&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt; 处理 Key： React支持 key 属性。当子节点有 key 时，React 使用 key 将原始树中的子节点与后续树中的子节点相匹配。例如，添加 key 可以使树有效地转换， 12345678910&lt;ul&gt; &lt;li key="2015"&gt;Duke&lt;/li&gt; &lt;li key="2016"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li key="2014"&gt;Connecticut&lt;/li&gt; &lt;li key="2015"&gt;Duke&lt;/li&gt; &lt;li key="2016"&gt;Villanova&lt;/li&gt;&lt;/ul&gt; ⬆ 返回顶部 你什么时候需要使用 refs?这里是 refs 的一些使用场景： 管理聚焦、文本选择或媒体播放。 触发命令式动画。 与第三方 DOM 库集成。 ⬆ 返回顶部 对于渲染属性来说是否必须将 prop 属性命名为 render?即使模式名为 render props，你也不必使用名为 render 的属性名来使用此模式。也就是说，组件用于知道即将渲染内容的任何函数属性，在技术上都是一个 render props。让我们举一个名为 children 渲染属性的示例： 123&lt;Mouse children=&#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;)&#125;/&gt; 实际上，以上的 children 属性不一定需要在 JSX 元素的 `attributes` 列表中命名。反之，你可以将它直接放在元素内部： 12345&lt;Mouse&gt; &#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; )&#125;&lt;/Mouse&gt; 当使用上述的技术，需要在 propTypes 中明确声明 children 必须为函数类型： 123Mouse.propTypes = &#123; children: PropTypes.func.isRequired&#125;; **[⬆ 返回顶部](#目录)** 在 Pure Component 中使用渲染属性会有什么问题?如果在渲染方法中创建函数，则会否定纯组件的用途。因为浅属性比较对于新属性总是返回 false，在这种情况下，每次渲染都将为渲染属性生成一个新值。你可以通过将渲染函数定义为实例方法来解决这个问题。 ⬆ 返回顶部 如何使用渲染属性创建 HOC?可以使用带有渲染属性的常规组件实现大多数高阶组件（HOC）。例如，如果希望使用 withMouse HOC 而不是 组件，则你可以使用带有渲染属性的常规 组件轻松创建一个 HOC 组件。 1234567891011function withMouse(Component) &#123; return class extends React.Component &#123; render() &#123; return ( &lt;Mouse render=&#123;mouse =&gt; ( &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; ); &#125; &#125;&#125; ⬆ 返回顶部 什么是 windowing 技术?Windowing 是一种技术，它在任何给定时间只呈现一小部分行，并且可以显著减少重新呈现组件所需的时间以及创建的 DOM 节点的数量。如果应用程序呈现长的数据列表，则建议使用此技术。react-window 和 react-virtualized 都是常用的 windowing 库，它提供了几个可重用的组件，用于显示列表、网格和表格数据。 ⬆ 返回顶部 你如何在 JSX 中打印 falsy 值?Falsy 值比如 false，null，undefined 是有效的子元素，但它们不会呈现任何内容。如果仍要显示它们，则需要将其转换为字符串。我们来举一个如何转换为字符串的例子： 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt; ⬆ 返回顶部 portals 的典型使用场景是什么?当父组件拥有 overflow: hidden 或含有影响堆叠上下文的属性（z-index、position、opacity 等样式），且需要脱离它的容器进行展示时，React portal 就非常有用。例如，对话框、全局消息通知、悬停卡和工具提示。 ⬆ 返回顶部 如何设置非受控组件的默认值?在 React 中，表单元素的属性值将覆盖其 DOM 中的值。对于非受控组件，你可能希望能够指定其初始值，但不会控制后续的更新。要处理这种情形，你可以指定一个 defaultValue 属性来取代 value 属性。 1234567891011121314render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; User Name: &lt;input defaultValue="John" type="text" ref=&#123;this.input&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt; );&#125; 这同样适用于 select 和 textArea 输入框。但对于 checkbox 和 radio 控件，需要使用 defaultChecked。 ⬆ 返回顶部 你最喜欢的 React 技术栈是什么?尽管技术栈因开发人员而异，但最流行的技术栈用于 React boilerplate 项目代码中。它主要使用 redux 和 redux saga 进行状态管理和具有副作用的异步操作，使用 react-router 进行路由管理，使用 styled-components 库开发 React 组件，使用 axios 调用 REST api，以及其他支持的技术栈，如 webpack、reseselect、esnext、babel 等。 你可以克隆 https://github.com/react-boilerplate/react-boilerplate 并开始开发任何新的 React 项目。 ⬆ 返回顶部 Real DOM 和 Virtual DOM 有什么区别?以下是Real DOM和Virtual DOM之间的主要区别： | Real DOM | Virtual DOM || —– | ——- || 更新速度慢 | 更新速度快 || DOM 操作非常昂贵 | DOM 操作非常简单 || 可以直接更新 HTML | 你不能直接更新 HTML || 造成太多内存浪费 | 更少的内存消耗 || 如果元素更新了，创建新的 DOM 节点 | 如果元素更新，则更新 JSX 元素 | ⬆ 返回顶部 如何为 React 应用程序添加 bootstrap?Bootstrap 可以通过三种可能的方式添加到 React 应用程序中： 使用 Bootstrap CDN:这是添加 bootstrap 最简单的方式。在 head 标签中添加 bootstrap 相应的 CSS 和 JS 资源。 把 Bootstrap 作为依赖项：如果你使用的是构建工具或模块绑定器（如Webpack），那么这是向 React 应用程序添加 bootstrap 的首选选项。 1npm install bootstrap 使用 React Bootstrap 包:在这种情况下，你可以将 Bootstrap 添加到我们的 React 应用程序中，方法是使用一个以 React 组件形式对 Bootstrap 组件进行包装后包。下面的包在此类别中很流行： react-bootstrap reactstrap ⬆ 返回顶部 你能否列出使用 React 作为前端框架的顶级网站或应用程序?以下是使用 React 作为前端框架的前 10 个网站： Facebook Uber Instagram WhatsApp Khan Academy Airbnb Dropbox Flipboard Netflix PayPal ⬆ 返回顶部 是否建议在 React 中使用 CSS In JS 技术?React 对如何定义样式没有任何意见，但如果你是初学者，那么好的起点是像往常一样在单独的 *.css 文件中定义样式，并使用类名引用它们。此功能不是 React 的一部分，而是来自第三方库。但是如果你想尝试不同的方法（JS中的CSS），那么 styled-components 库是一个不错的选择。 ⬆ 返回顶部 前端的一些知识模块 HTML 对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储 CSS flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性 JavaScript 数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE 其他 移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作 作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。 HTMLDoctype作用？标准模式与兼容模式各有什么区别?1、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 2、标准模式的排版 和 JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于SGML,所以不需要对DTD进行引用，但是他也需要DOCTYPE来规范浏览器的行为。 常见的浏览器有哪些，及其浏览器的内核是啥？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。 [又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 浏览器内核的理解？主要分为两部分：渲染引擎（Layout engineer或Rendering Engine）和JS引擎 渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。 JS引擎：解析和执行JavaScript实现网页动态效果。 页面样式引入，link与@import`的区别？1、link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；2、@import是CSS提供的，只能用于加载CSS;3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;4、import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 行内元素有哪些，块级元素有哪些，空元素有哪些？ CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 行内元素: a b span img input select strong(强调的语气)块级元素：div p ul ol li dl dt dd h1 h2 h3 h4 ...常见的空元素: &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;和&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？123456789101112131415161718192021222324HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 - 绘画 canvas; - 用于媒介回放的 video 和 audio 元素; - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; - sessionStorage 的数据在浏览器关闭后自动删除; - 语意化更好的内容元素，比如 article、footer、header、nav、section; - 表单控件，calendar、date、time、email、url、search; - 新的技术webworker, websocket, Geolocation; - 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； - 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; &lt;!--[if lt IE 9]&gt; &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; &lt;![endif]--&gt;如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html3、在离线状态时，操作window.applicationCache进行需求实现。 详细的使用请参考：HTML5 离线缓存-manifest简介,有趣的HTML5：离线存储 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。详细请参考：有趣的HTML5：离线存储 描述一下 Cookies，SessionStorage 和 LocalStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 Iframe有那些缺点？iframe会阻塞主页面的Onload事件；搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 1234&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt; CSS介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？（1）有两种， IE 盒子模型、W3C 盒子模型；（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；（3）区 别： IE的content部分把 border 和 padding计算了进去; 算法题快速排序思路: 随机选择数组中的一个数 A，以这个数为基准 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的 这时候将左边和右边的数再递归上面的过程123456789101112131415161718192021const Arr = [85, 24, 63, 45, 17, 31, 96, 50];function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 递归 return quickSort(left).concat([pivot], quickSort(right));&#125;console.log(quickSort(Arr)); ps:这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。 这里是不同的声音： 面试官：阮一峰版的快速排序完全是错的 二分排序法二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。二分查找是一种「分治」思想的算法，大概流程如下： 数组中排在中间的数字 A，与要找的数字比较大小 因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找 这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。1234567891011121314151617181920212223function Find(target, array) &#123; let i = 0; let j = array[i].length - 1; while (i &lt; array.length &amp;&amp; j &gt;= 0) &#123; if (array[i][j] &lt; target) &#123; i++; &#125; else if (array[i][j] &gt; target) &#123; j--; &#125; else &#123; return true; &#125; &#125; return false;&#125;//测试用例console.log(Find(10, [ [1, 2, 3, 4], [5, 9, 10, 11], [13, 20, 21, 23] ])); 解析url后的参数123456789101112131415161718192021222324252627282930313233343536373839function parseParam(url) &#123; let obj = &#123;&#125;; let arr = url.split("?"); if (arr.length == 1) &#123; //判断没有问号 return "无参数" &#125; let total = arr[1].split("&amp;"); for (let i = 0; i &lt; total.length; i++) &#123; let single = total[i].split("="); if (single[0] == '') &#123; //判断有？但是没有参数 return '无参数' &#125; if (!single[1]) &#123; obj[single[0]] = true; &#125; else &#123; if (obj[single[0]]) &#123; let concat if (!Array.isArray(obj[single[0]])) &#123; //判断是否数组 concat = [obj[single[0]]] &#125; else &#123; concat = obj[single[0]]; &#125; concat.push(single[1]); concat = new Set(concat); concat = Array.from(concat) //数组去重 obj[single[0]] = concat &#125; else &#123; obj[single[0]] = decodeURI(single[1]) //进行转码 &#125; &#125; &#125; return obj&#125;var url = 'http://www.baidu.com/?user=huixin&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled';var params = parseParam(url)console.log(params) 实现一个简单的模版引擎：例如：我叫a,年龄b，性别c； let data = { name: ‘小明’, age: 18, } 没有定义的返回undefined 12345678910111213141516171819202122232425262728let template = '我是&#123;name&#125;，年龄&#123;age&#125;，性别&#123;sex&#125;';let data = &#123; name: '小明', age: 18,&#125;const reg= /(&#123;([a-zA-Z]+)&#125;)/g;var r= '',regrounp=&#123;&#125;;while( r = reg.exec(template) )&#123; Object.defineProperty(regrounp,r[2],&#123; enumerable:true, value:r[2] &#125;)&#125;var render = (template,regrounp)=&gt;&#123; var result=''; for( key in regrounp)&#123; if(data[key] == undefined)&#123; result = (result || template).replace(new RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,"g"),undefined); &#125;else&#123; result = (result || template).replace(new RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,"g"),data[key]); &#125; &#125; return result&#125;let newtemple = render(template, regrounp);console.log(newtemple) // 结果： 我是小明，年龄18，性别undefined 对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。 这里有一片很好的文章 推荐 编写一个简单的JavaScript模板引擎 如何快速让字符串变成已千为精度的数字1234567891011121314function exchange(num) &#123; num += ''; //转成字符串 if (num.length &lt;= 3) &#123; return num; &#125; num = num.replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g, (v) =&gt; &#123; console.log(v) return v + ','; &#125;); return num;&#125;console.log(exchange(1234567)); 实现 JS 对象的深拷贝深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。分析下怎么做 深拷贝 ： 首先假设深拷贝这个方法已经完成，为 deepClo 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复 1234567891011121314151617181920function deepClo(o1, o2) &#123; for (let k in o2) &#123; if (typeof o2[k] === 'object') &#123; o1[k] = &#123;&#125;; deepClo(o1[k], o2[k]); &#125; else &#123; o1[k] = o2[k]; &#125; &#125;&#125;// 测试用例let obj = &#123; a: 1, b: [1, 2, 3], c: &#123;&#125;&#125;;let emptyObj = Object.create(null);deepClo(emptyObj, obj);console.log(emptyObj.a == obj.a);console.log(emptyObj.b == obj.b); 递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。 求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项1234567891011121314151617181920212223242526272829303132下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值： let count = 0; function fn(n) &#123; let cache = &#123;&#125;; function _fn(n) &#123; if (cache[n]) &#123; return cache[n]; &#125; count++; if (n == 1 || n == 2) &#123; return 1; &#125; let prev = _fn(n - 1); cache[n - 1] = prev; let next = _fn(n - 2); cache[n - 2] = next; return prev + next; &#125; return _fn(n);&#125;let count2 = 0;function fn2(n) &#123; count2++; if (n == 1 || n == 2) &#123; return 1; &#125; return fn2(n - 1) + fn2(n - 2);&#125;console.log(fn(20), count); // 6765 20console.log(fn2(20), count2); // 6765 13529 算法的效率算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。常见的时间复杂度有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n^2) 立方阶 O(n^3) !k次方阶 O(n^k) 指数阶 O(2^n) 随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。一般做算法复杂度分析的时候，遵循下面的技巧： 看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推 如果有二分，则为O(logN) 保留最高项，去除常数项 题目：分析下面代码的算法复杂度 123456let i =0; // 语句执行一次 while (i &lt; n) &#123; // 语句执行 n 次 console.log(`Current i is $&#123;i&#125;`); //语句执行 n 次 i++; // 语句执行 n 次&#125;根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。 更多阅读：在 JavaScript 中学习数据结构与算法我接触过的前端数据结构与算法]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>ES6</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅—认识一下]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 目录结构 page — 项目所有的页面模板 utils — 公共js工具 app.js — 启动入口文件 app.wxss — 项目的全局样式文件 app.json — 项目的配置文件 在app.json里我们可以看到page下面就是我们可以配置的页面路径，pages/index/index这个路径就可以访问index.wxml下的东西，每一个页面都有“三大件”—js、wxml、wxss组成。 下面开始我们小栗子： 新增一个view，wxml与wxss就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。 12345678910111213141516&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class="demo"&gt;这是一个测试小栗子&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125;/*新增加的 */.demo&#123; color:blueviolet&#125; 保存好就可以看到效果了。接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//index.js//获取应用实例const app = getApp()Page(&#123; data: &#123; // 当前页面的所有数据 motto: '我们的第一个小程序。', userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; // 页面跳转函数 url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; // 加载页面时触发函数集合 if (app.globalData.userInfo) &#123; this.setData(&#123; userInfo: app.globalData.userInfo, hasUserInfo: true &#125;) &#125; else if (this.data.canIUse)&#123; // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125; else &#123; // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo(&#123; success: res =&gt; &#123; app.globalData.userInfo = res.userInfo this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125; &#125;, getUserInfo: function(e) &#123; //获取用户信息 console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;&#125;) 具体函数对应含义也可以参考微信公众平台开发。 先去wxml文件下增加一个按&lt;button class=&#39;primary&#39; bindtap=&#39;changeDemo&#39;&gt;点击改变状态&lt;/button&gt;,接着去js文件下添加初始数据，和点击的事件函数。123456789101112131415161718&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//index.js//获取应用实例const app = getApp()Page(&#123; data: &#123; // 当前页面的所有数据 motto: '我们的第一个小程序。', demotext:'当前我的状态', // 新增初始值 userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; // 页面跳转函数 url: '../logs/logs' &#125;) &#125;, //新增加的事件 changeDemo:function()&#123; this.setDate(&#123; demotext: '点击之后就改变了我的状态', &#125;) &#125;, onLoad: function () &#123; // 加载页面时触发函数集合 if (app.globalData.userInfo) &#123; this.setData(&#123; userInfo: app.globalData.userInfo, hasUserInfo: true &#125;) &#125; else if (this.data.canIUse)&#123; // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125; else &#123; // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo(&#123; success: res =&gt; &#123; app.globalData.userInfo = res.userInfo this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125; &#125;, getUserInfo: function(e) &#123; //获取用户信息 console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData(&#123; userInfo: e.detail.userInfo, hasUserInfo: true &#125;) &#125;&#125;) 在wxml文件里加入if-else的判断：12345678910111213141516171819&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text wx:if="&#123;&#123;demotext=='当前我的状态'&#125;&#125;" class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt; &lt;text wx:else class="demo"&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;&lt;/view&gt; 123456789101112// index.jsPage(&#123; data: &#123; // 当前页面的所有数据 motto: '我们的第一个小程序。', demotext:'当前我的状态', // 新增初始值 demovalue:'if判断的数据', userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, &#125;) 接下来是for循环遍历数据：123456789101112131415161718192021&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text wx:if="&#123;&#123;demotext=='当前我的状态'&#125;&#125;" class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt; &lt;text wx:else class="demo"&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt; &lt;view wx:for="&#123;&#123;fordata&#125;&#125;" wx:for-index="id" wx:for-item="itemvalue"&gt; ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125; &lt;/view&gt;&lt;/view&gt; 12345678910111213// index.jsPage(&#123; data: &#123; // 当前页面的所有数据 motto: '我们的第一个小程序。', demotext:'当前我的状态', // 新增初始值 demovalue:'if判断的数据', fordata: [&#123; name: '测试1', num: 12 &#125;, &#123; name: '测试2', num: 22 &#125;, &#123; name: '测试3', num: 32 &#125;], userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, &#125;) 本地数据都没有问题了，那么接下来就是Ajax 跨域请求,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求wx.request(OBJECT) 示例代码：12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册wx.chooseImage(OBJECT),在js文件里新增一个方法。12345678910111213141516onLoad: function () &#123; // 加载页面时触发函数集合 var that = this; wx.chooseImage(&#123; // 获取本地图片 count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 var tempFilePaths = res.tempFilePaths console.log(tempFilePaths) that.setData(&#123; demoImg: tempFilePaths &#125;); &#125; &#125;)&#125; wxml文件：12345678910111213141516171819202122&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo"&gt; &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image wx:if="&#123;&#123;demoImg!=null&#125;&#125;" src='&#123;&#123;demoImg&#125;&#125;'&gt;&lt;/image&gt; &lt;image wx:else bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt; &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="usermotto"&gt; &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text wx:if="&#123;&#123;demotext=='当前我的状态'&#125;&#125;" class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt; &lt;text wx:else class="demo"&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt; &lt;view wx:key="id" wx:for="&#123;&#123;fordata&#125;&#125;" wx:for-index="id" wx:for-item="itemvalue"&gt; ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125; &lt;/view&gt;&lt;/view&gt; 总结这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb数据库的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F21%2Fmongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。 一、mongodb的开启和关闭1. 查找mongod是否可用which mongod 2. 启动mongodb指定path 和log日志mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log 3. 关闭数据库mongod --shutdown 二、mongodb的操作1. 连接服务器mongod 115.29.137.34:27017 2. 使用数据库(不存在的数据库也可以使用,插入数据之后会自动保存)use mydb 3. 权限登陆db.auth(&#39;username&#39;,&#39;password&#39;) 4. 展示数据库列表show dbs 5. 插入数据(类似于mysql的表)db.users.insert({&#39;name&#39;:&#39;xiaomo&#39;})db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:25})db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:24,&#39;sex&#39;:&#39;女&#39;}) 6. 查询集合(前提是use了一个数据库)有一个System.indexes 是索引show collections 7. 不带条件查询db.users.find() 8. 带条件查询(参数是一个对象)db.users.find({&#39;name&#39;:&#39;xiaomo&#39;}) 9. 更新数据(有三个参数,1:查询条件,2:更新的内容 3：更新的配置)db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}})修改满足条件的第一条数据db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}},{multi:true})修改所有满足条件的数据 10. 保存数据(只有一个参数，必须要传id，后面是要修改的数据)db.users.save({&#39;id&#39;:&#39;objectId(574710a97a3afd63cde56a49)&#39;,&#39;age&#39;:30}) 11. 删除数据(1:条件 2 是否删除所有符合条件的)db.users.remove({&#39;name&#39;:&#39;xiaomoing&#39;},true) 12. 删除集合db.users.drop() 三、使用mongoose操作数据库1. 模块的介绍连接mongdodb的驱动 2. 配置和链接npm install --save mongoose1234var mongoose = require('mongoose');&lt;!-- var uri = 'mongodb://username:password@hostname:port/databasename'; --&gt;var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';mongoose.connect(uri); 3. Model 和Shema12345678910111213141516171819202122232425262728293031 // model.jsvar Schema = mongoose.Schema, ObjectId = Schema.ObjectId;var BlogPost = new Schema(&#123; author : ObjectId, title : String, body : String, date : Date&#125;);//Modelmongoose.model('blog',Schema);var Comment = new Schema(&#123; name: &#123; type: String, default: 'hahaha' &#125;, age: &#123; type: Number, min: 18, index: true &#125;, bio: &#123; type: String, match: /[a-z]/ &#125;, date: &#123; type: Date, default: Date.now &#125;&#125;);// a setterComment.path('name').set(function (v) &#123; return capitalize(v);&#125;);// middlewareComment.pre('save', function (next) &#123; notify(this.get('email')); next();&#125;); 4. 创建文档1234567891011121314//insert.jsvar mongoose ＝ require('mongoose');require('./model.js'); //执行var Blog = mongoose.model('blog');var blog = new Blog(&#123; name:'xiaomo', age:25, bio:'don't know', date:new Date &#125;);book.save(function(err)&#123; console.log('save status:'+err); &#125;); 5. 删除文档123456789101112var mongoose = require('mongoose');require('./model.js');var Blog = mongoose.model('blog');Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123; if(err)&#123; console.log(err) return; &#125; if(doc)&#123; doc.reomove();&#125; &#125;) 6. 简单查询12345678910var mongoose = require('mongoose');require('./model.js');var Blog = mongoose.model('blog');Blog.find(&#123;&#125;,function(err,doc)&#123; if(err)&#123; console.log(err) return; &#125; console.log('result',doc) &#125;) 第一个满足条件的结果12345678910var mongoose = require('mongoose');require('./model.js');var Blog = mongoose.model('blog');Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123; if(err)&#123; console.log(err) return; &#125; console.log('result',doc) &#125;) 7. 条件语句123456789101112131415161718// condation.js var mongoose = require('mongoose'); require('./model.js'); var Blog = mongoose.model('blog'); //名字是xiaomo或者xiaoming 可以用$or和$and var condation = &#123; $or $and:[ &#123;'name':'xiaomo'&#125;, &#123;'name':'xiaoming'&#125; ] &#125; Blog.find(condation,function(err,doc)&#123; if(err)&#123; console.log(err) return; &#125; console.log('result',doc) &#125;) 三、在项目中使用mongoose1. 生成项目koa koatest -e koatest 2. 安装依赖cd koatest &amp;&amp; npm install 3. 安装mongoosenpm install --save mongoose 4. 创建模型123456789// models/users.server.model.jsvar mongoose = require('mongoose');var UserSchema = new mongoose.Schema(&#123; uid:Number, username:String, createTime:Date, lastLogin:Date &#125;)module.exports = mongoose.model('User',UserSchema); 5. 创建配置文件12345678910111213// config/config.jsmodule.exports=&#123; mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'&#125;//config/mongoose.jsvar mongoose = require('mongoose');var config = require('./config.js');module.exports=function()&#123; var db = mongoose.connect(config.mongodb); require('./../models/users.server.model.js'); return db;&#125; 6. 操作mongdodb 代码123456789101112//routers/users.jsvar router = require('koa-router')();var mongoose = require('mongoose');var User = mongoose.model('User');router.get('/', function *(next) &#123; //add var user = new User(&#123; uid: &#125;) this.body = yield User.find(&#123;&#125;);&#125;);module.exports = router; 嗯嗯,就这样吧，完！]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>mongoDB</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-Flux]]></title>
    <url>%2Fblog%2F2018%2F05%2F18%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flux%2F</url>
    <content type="text"><![CDATA[Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。 Flux我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。 Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。 Flux 架构及其主要特点 这种模式的主角是dispatcher 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 actions (动作) 的通知并将其传给所有的 stores 。store 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 views(视图，这里指 React 组件) 的重新渲染。如果非要将 Flux和大名鼎鼎的MVC 相比较的话，Flux 中的store 类似于MVC中的 model 。它负责保存和修改数据。 传给 dispatcher 的动作可以来自于视图，也可以来自于系统的其他部分，比如 services 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。 实现 Flux 架构如其他流行的概念一样，Flux 也有一些 变种 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。 Dispatcher大多数场景下，我们只需要一个单个的dispatcher 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。dispatcher 需要知道两样东西: 动作和 stores 。动作只是简单地转发给 stores，所以没必要保存它们。然而，stores 应该在 dispatcher 中进行追踪，这样才可以遍历它们: 可以这样写：123456789101112131415var Dispatcher = function () &#123; return &#123; _stores: [], register: function (store) &#123; this._stores.push(&#123; store: store &#125;); &#125;, dispatch: function (action) &#123; if (this._stores.length &gt; 0) &#123; this._stores.forEach(function (entry) &#123; entry.store.update(action); &#125;); &#125; &#125; &#125;&#125;; 首先需要注意的是我们期望传入的 stores 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:1234567register: function (store) &#123; if (!store || !store.update) &#123; throw new Error('You should provide a store that has an `update` method.'); &#125; else &#123; this._stores.push(&#123; store: store &#125;); &#125;&#125; 将视图和 stores 进行绑定下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。 使用辅助函数一些 flux 的实现会自带辅助函数来完成此工作。例如:1Framework.attachToStore(view, store); 要让 attachToStore正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。 使用 mixin那么如果使用 React 的 mixins 呢？1234var View = React.createClass(&#123; mixins: [Framework.attachToStore(store)] ...&#125;); 为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建mixin 来完成绑定工作。但说实话，并认为这是个好主意。看起来 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。 使用 context解决此问题的另一项技术便是 React 的 context 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 context。 偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 “context” 功能可以让你做到这一点。 看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。 高阶组件概念高阶组件模式是由 Sebastian Markbåge 所提出的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如: 12345678910111213141516171819202122function attachToStore(Component, store, consumer) &#123; const Wrapper = React.createClass(&#123; getInitialState() &#123; return consumer(this.props, store); &#125;, componentDidMount() &#123; store.onChangeEvent(this._handleStoreChange); &#125;, componentWillUnmount() &#123; store.offChangeEvent(this._handleStoreChange); &#125;, _handleStoreChange() &#123; if (this.isMounted()) &#123; this.setState(consumer(this.props, store)); &#125; &#125;, render() &#123; return &lt;Component &#123;...this.props&#125; &#123;...this.state&#125; /&gt;; &#125; &#125;); return Wrapper;&#125;; Component 是我们想要附加到 store 中的视图。consumer 函数说明应该提取store 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:1234567class MyView extends React.Component &#123; ...&#125;ProfilePage = connectToStores(MyView, store, (props, store) =&gt; (&#123; data: store.get('key')&#125;)); 这是个有趣的模式，因为它转移了职责。它是视图从 store 中拉取数据，而不是 store 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 store 变得简单。现在 store 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。 最终的选择 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。 目前为止，我们的实现中只有 register 方法与 store 进行交互。1234567register: function (store) &#123; if (!store || !store.update) &#123; throw new Error('You should provide a store that has an `update` method.'); &#125; else &#123; this._stores.push(&#123; store: store &#125;); &#125;&#125; 将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。 下面是更改后的 register 方法:12345678910111213141516register: function (store) &#123; if (!store || !store.update) &#123; throw new Error( 'You should provide a store that has an `update` method.' ); &#125; else &#123; var consumers = []; var subscribe = function (consumer) &#123; consumers.push(consumer); &#125;; this._stores.push(&#123; store: store &#125;); return subscribe; &#125; return false;&#125; 最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 consumer 函数，但现在还没有任何代码来执行它们。 根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 action，但我们还应该发出 change 函数。调用此函数来触发 consumers :12345678910111213141516171819202122232425262728register: function (store) &#123; if (!store || !store.update) &#123; throw new Error( 'You should provide a store that has an `update` method.' ); &#125; else &#123; var consumers = []; var change = function () &#123; consumers.forEach(function (consumer) &#123; consumer(store); &#125;); &#125;; var subscribe = function (consumer) &#123; consumers.push(consumer); &#125;; this._stores.push(&#123; store: store, change: change &#125;); return subscribe; &#125; return false;&#125;,dispatch: function (action) &#123; if (this._stores.length &gt; 0) &#123; this._stores.forEach(function (entry) &#123; entry.store.update(action, entry.change); &#125;); &#125;&#125; 注意如何在_stores数组中将 change 和store 一起推送出去。稍后，在dispatch方法中通过传入action 和 change 函数来调用update 常见用法是使用store 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 consumer 函数一次。这可以在subscribe 方法中轻松完成:1234var subscribe = function (consumer, noInit) &#123; consumers.push(consumer); !noInit ? consumer(store) : null;&#125;; 当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:12345678910111213141516171819202122232425262728293031323334var Dispatcher = function () &#123; return &#123; _stores: [], register: function (store) &#123; if (!store || !store.update) &#123; throw new Error( 'You should provide a store that has an `update` method' ); &#125; else &#123; var consumers = []; var change = function () &#123; consumers.forEach(function (consumer) &#123; consumer(store); &#125;); &#125;; var subscribe = function (consumer, noInit) &#123; consumers.push(consumer); !noInit ? consumer(store) : null; &#125;; this._stores.push(&#123; store: store, change: change &#125;); return subscribe; &#125; return false; &#125;, dispatch: function (action) &#123; if (this._stores.length &gt; 0) &#123; this._stores.forEach(function (entry) &#123; entry.store.update(action, entry.change); &#125;); &#125; &#125; &#125;&#125;; 动作 ( Actions )或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: type和payload ：1234567&#123; type: 'USER_LOGIN_REQUEST', payload: &#123; username: '...', password: '...' &#125;&#125; type 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。 有趣的是type从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 stores 对哪些动作感兴趣。因此，我们可以应用 partial application 并避免传入动作对象。例如:123456789101112var createAction = function (type) &#123; if (!type) &#123; throw new Error('Please, provide action\'s type.'); &#125; else &#123; return function (payload) &#123; return dispatcher.dispatch(&#123; type: type, payload: payload &#125;); &#125; &#125;&#125; createAction 具有以下优点: 我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。 我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。 最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。 这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。 最终代码在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:123var createSubscriber = function (store) &#123; return dispatcher.register(store);&#125; 我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var Dispatcher = function () &#123; return &#123; _stores: [], register: function (store) &#123; if (!store || !store.update) &#123; throw new Error( 'You should provide a store that has an `update` method' ); &#125; else &#123; var consumers = []; var change = function () &#123; consumers.forEach(function (consumer) &#123; consumer(store); &#125;); &#125;; var subscribe = function (consumer, noInit) &#123; consumers.push(consumer); !noInit ? consumer(store) : null; &#125;; this._stores.push(&#123; store: store, change: change &#125;); return subscribe; &#125; return false; &#125;, dispatch: function (action) &#123; if (this._stores.length &gt; 0) &#123; this._stores.forEach(function (entry) &#123; entry.store.update(action, entry.change); &#125;); &#125; &#125; &#125;&#125;;module.exports = &#123; create: function () &#123; var dispatcher = Dispatcher(); return &#123; createAction: function (type) &#123; if (!type) &#123; throw new Error('Please, provide action\'s type.'); &#125; else &#123; return function (payload) &#123; return dispatcher.dispatch(&#123; type: type, payload: payload &#125;); &#125; &#125; &#125;, createSubscriber: function (store) &#123; return dispatcher.register(store); &#125; &#125; &#125;&#125;; 如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。 整合我们写好的模块提供两个辅助函数来构建 Flux 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。 HTML我们需要一些 UI 元素来进行互动:12345&lt;div id="counter"&gt; &lt;span&gt;&lt;/span&gt; &lt;button&gt;increase&lt;/button&gt; &lt;button&gt;decrease&lt;/button&gt;&lt;/div&gt; span 用来显示计数器的当前值。点击按钮会改变计数器的值。 视图123456789101112131415const View = function (subscribeToStore, increase, decrease) &#123; var value = null; var el = document.querySelector('#counter'); var display = el.querySelector('span'); var [ increaseBtn, decreaseBtn ] = Array.from(el.querySelectorAll('button')); var render = () =&gt; display.innerHTML = value; var updateState = (store) =&gt; value = store.getValue(); subscribeToStore([updateState, render]); increaseBtn.addEventListener('click', increase); decreaseBtn.addEventListener('click', decrease);&#125;; View 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。 之后我们定义了render函数，它负责将值渲染到 span 标签中。当 store 发生变化时会调用updateState 方法。我们将这两个函数传给subscribeToStore 是因为我们想要视图更新以及进行初首次渲染。还记得consumers 函数默认至少要调用一次吧？ 最后要做的是为按钮绑定点击事件。 Store每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。12const INCREASE = 'INCREASE';const DECREASE = 'DECREASE'; 通常每个 store只有一个实例。为了简单起见，我们将直接创建一个单例对象。 1234567891011121314const CounterStore = &#123; _data: &#123; value: 0 &#125;, getValue: function () &#123; return this._data.value; &#125;, update: function (action, change) &#123; if (action.type === INCREASE) &#123; this._data.value += 1; &#125; else if (action.type === DECREASE) &#123; this._data.value -= 1; &#125; change(); &#125;&#125;; _data 是 store 的内部状态。update 是dispatcher 所调用的方法，我们在 update 中处理动作，并在完成时调用change()方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。) 整合各个部分这样，store 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 store 的订阅者、动作并让这一切运转起来。 12345678const &#123; createAction, createSubscriber &#125; = Fluxiny.create();const counterStoreSubscriber = createSubscriber(CounterStore);const actions = &#123; increase: createAction(INCREASE), decrease: createAction(DECREASE)&#125;;View(counterStoreSubscriber, actions.increase, actions.decrease); 这样就完成了。视图订阅store并进行渲染，因为我们的consumers实际上就是 render 方法。 在线示例 这里有 JSBin 的 在线示例。如果你觉得这个示例过于简单的话，请查阅 Fluxiny 仓库中的示例。它使用 React 作为视图层。 在本章中所讨论的 Flux 实现可以在 这里 找到。可以 直接在浏览器中 使用，也可以通过 npm 依赖 进行安装。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-单向数据流]]></title>
    <url>%2Fblog%2F2018%2F05%2F16%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%2F</url>
    <content type="text"><![CDATA[单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。 单向数据流假设说有一个简单的 Switcher 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。123456789101112131415161718192021class Switcher extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; flag: false &#125;; this._onButtonClick = e =&gt; this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123; return ( &lt;button onClick=&#123; this._onButtonClick &#125;&gt; &#123; this.state.flag ? 'lights on' : 'lights off' &#125; &lt;/button&gt; ); &#125;&#125;;// ... 渲染组件function App() &#123; return &lt;Switcher /&gt;;&#125;; 此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 Switcher 组件。我们来将flag 提取到 store 中:1234567891011121314151617181920212223242526272829303132var Store = &#123; _flag: false, set: function(value) &#123; this._flag = value; &#125;, get: function() &#123; return this._flag; &#125;&#125;;class Switcher extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; flag: false &#125;; this._onButtonClick = e =&gt; &#123; this.setState(&#123; flag: !this.state.flag &#125;, () =&gt; &#123; this.props.onChange(this.state.flag); &#125;); &#125; &#125; render() &#123; return ( &lt;button onClick=&#123; this._onButtonClick &#125;&gt; &#123; this.state.flag ? 'lights on' : 'lights off' &#125; &lt;/button&gt; ); &#125;&#125;;function App() &#123; return &lt;Switcher onChange=&#123; Store.set.bind(Store) &#125; /&gt;;&#125;; Store 对象是一个 单例，它提供辅助函数 ( getter 和 setter ) 来读取/设置 _flag 属性。通过将 setter 传给Switcher 组件，我们能够更新外部数据。目前应用的工作流程大致如下: 假设我们可以通过 Store 将 flag 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 flag 为 true ，那么我们应该显示 “lights on”，而不是默认值 “lights off” 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 Store 中都有自身的状态。我们需要进行双向通讯，Store到组件和组件到Store 。12345678910// ... 在 App 组件中&lt;Switcher value=&#123; Store.get() &#125; onChange=&#123; Store.set.bind(Store) &#125; /&gt;// ... 在 Switcher 组件中constructor(props) &#123; super(props); this.state = &#123; flag: this.props.value &#125;; ... 工作流程改变后如下所示: 以上这些导致了需要在两处管理状态。如果 Store 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给Switcher 组件，这样就会增加应用的复杂度。 单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 store) 进行状态管理。要实现单向数据流的话，我们需要改造一下 Store 对象。我们需要允许我们订阅数据变化的逻辑：1234567891011121314var Store = &#123; _handlers: [], _flag: '', subscribe: function(handler) &#123; this._handlers.push(handler); &#125;, set: function(value) &#123; this._flag = value; this._handlers.forEach(handler =&gt; handler(value)) &#125;, get: function() &#123; return this._flag; &#125;&#125;; 然后我们将其与 App 组件联系起来，每次 Store 中的值产生变化时，都将重新渲染组件:1234567891011121314151617class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: Store.get() &#125;; Store.subscribe(value =&gt; this.setState(&#123; value &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;Switcher value=&#123; this.state.value &#125; onChange=&#123; Store.set.bind(Store) &#125; /&gt; &lt;/div&gt; ); &#125;&#125;; 做出改变后，Switcher 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。1234567891011function Switcher(&#123; value, onChange &#125;) &#123; return ( &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt; &#123; value ? 'lights on' : 'lights off' &#125; &lt;/button&gt; );&#125;;&lt;Switcher value=&#123; Store.get() &#125; onChange=&#123; Store.set.bind(Store) &#125; /&gt; 结语这种模式的好处是组件只负责展示 store 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-展示型组件和容器型组件]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。 展示型组件和容器型组件万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。 我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 Clock 组件，它接收 Date 对象作为属性并显示实时时间。12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: this.props.time &#125;; this._update = this._updateTime.bind(this); &#125; render() &#123; const time = this._formatTime(this.state.time); return ( &lt;h1&gt; &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125; &lt;/h1&gt; ); &#125; componentDidMount() &#123; this._interval = setInterval(this._update, 1000); &#125; componentWillUnmount() &#123; clearInterval(this._interval); &#125; _formatTime(time) &#123; var [ hours, minutes, seconds ] = [ time.getHours(), time.getMinutes(), time.getSeconds() ].map(num =&gt; num &lt; 10 ? '0' + num : num); return &#123; hours, minutes, seconds &#125;; &#125; _updateTime() &#123; this.setState(&#123; time: new Date(this.state.time.getTime() + 1000) &#125;); &#125;&#125;;ReactDOM.render(&lt;Clock time=&#123; new Date() &#125;/&gt;, ...); 在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 setInterval ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: _formatTime 和_updateTime 。_formatTime 用来提取时分秒并确保它们是两位数的形式。_updateTime 用来将time 对象设置为当前时间加一秒。 问题这个组件中它做了好几件事，似乎承担了太多的职责。 它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。 _formatTime 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。 提取出容器型组件容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 高阶组件 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。 下面是 ClockContainer 的代码:12345678910111213141516171819202122232425262728293031// Clock/index.jsimport Clock from './Clock.jsx'; // &lt;-- 展示型组件export default class ClockContainer extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: props.time &#125;; this._update = this._updateTime.bind(this); &#125; render() &#123; return &lt;Clock &#123; ...this._extract(this.state.time) &#125;/&gt;; &#125; componentDidMount() &#123; this._interval = setInterval(this._update, 1000); &#125; componentWillUnmount() &#123; clearInterval(this._interval); &#125; _extract(time) &#123; return &#123; hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() &#125;; &#125; _updateTime() &#123; this.setState(&#123; time: new Date(this.state.time.getTime() + 1000) &#125;); &#125;&#125;; 它接收 time (date 对象) 属性，使用setInterval 循环并了解数据 (getHours、getMinutes 和 getSeconds) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。 展示型组件展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 无状态组件，它们没有内部状态。 在本示例中，展示型组件只包含两位数的检查并返回 &lt;h1&gt; 标签:12345678910// Clock/Clock.jsxexport default function Clock(props) &#123; var [ hours, minutes, seconds ] = [ props.hours, props.minutes, props.seconds ].map(num =&gt; num &lt; 10 ? '0' + num : num); return &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;&#125;; 优点将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。 容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 render 方法中的 ·· 组件。 测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。 结语容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之旅——个人申请]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！ 小程序开发注册传送门，按照步骤完成注册认证就可以开始开发咯。 注册完之后就登录进入开发 填写个人资料 填写个人资料 注意事项： 1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。 2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。 3.每次登录都需要扫码认证，确认成功后就可以正常登录了。 个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具： 我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目 新建一个项目文件，输入自己的APPID，确定 进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！ 注意事项： 1.每次登录都需要扫码登录 2.需要输入自己的APPID 3.每次修改完代码都要编译 总结是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-受控输入和非受控输入]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。 受控输入和非受控输入在 React 表单管理中有两个经常使用的术语: 受控输入和非受控输入。 受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个&lt;input&gt; 字段，它就是受控的:123456789 class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; &#125; render() &#123; return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;; &#125;&#125;; 上面代码的结果是我们可以操作input 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让input正常工作的话，需要为其添加onChange 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 input中输入的文字。123456789101112131415161718class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; this._change = this._handleInputChange.bind(this); &#125; render() &#123; return ( &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; onChange=&#123; this._change &#125; /&gt; ); &#125; _handleInputChange(e) &#123; this.setState(&#123; value: e.target.value &#125;); &#125;&#125;; 与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 defaultValue 属性来提供初始值，此后浏览器将负责保存输入的状态。123456789class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; &#125; render() &#123; return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt; &#125;&#125;; 上面的 &lt;input&gt;元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用 Refs 来获取 DOM 元素的实际引用。12345678910111213141516171819class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;hello&apos; &#125;; this._change = this._handleInputChange.bind(this); &#125; render() &#123; return ( &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; onChange=&#123; this._change &#125; ref=&#123; input =&gt; this.input = input &#125;/&gt; ); &#125; _handleInputChange() &#123; this.setState(&#123; value: this.input.value &#125;); &#125;&#125;; ref属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量input中。之后当 onChange事件触发时，我们将 input 中的最新值保存到 App 组件的状态里。 大量使用refs 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。 结语使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-组合 (composition)]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88-composition%2F</url>
    <content type="text"><![CDATA[对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。 组合 ( composition )React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。 我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 React 组件 —App、Header 和 Navigation 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:1&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt; 组合这些组件的简单方法是在需要它们的时候引用即可。123456789101112131415161718// app.jsximport Header from './Header.jsx';export default function App() &#123; return &lt;Header /&gt;;&#125;// Header.jsximport Navigation from './Navigation.jsx';export default function Header() &#123; return &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;&#125;// Navigation.jsxexport default function Navigation() &#123; return (&lt;nav&gt; ... &lt;/nav&gt;);&#125; 但是，这种方式会引入一些问题: 我们可以把 App 看作是主要的组合场所。Header 可能还有其他元素，比如 logo、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 Navigation 的 Header 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。 代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 Navigation 组件出了问题，那么 Header 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: 浅层渲染 ( shallow rendering ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。) 使用 React children APIReact 提供了便利的 children 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 Header 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:12345678910export default function App() &#123; return ( &lt;Header&gt; &lt;Navigation /&gt; &lt;/Header&gt; );&#125;export default function Header(&#123; children &#125;) &#123; return &lt;header&gt;&#123; children &#125;&lt;/header&gt;;&#125;; 注意，如果不在 Header 中使用 { children }的话，那么 Navigation 组件永远不会渲染。 现在 Header 组件的测试变得更简单了，因为完全可以使用空 &lt;div&gt; 来渲染 Header 组件。这会使用组件更独立，并让我们专注于应用的一小部分。 将 child 作为 prop 传入每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。123456789101112131415161718const Title = function () &#123; return &lt;h1&gt;Hello there!&lt;/h1&gt;;&#125;const Header = function (&#123; title, children &#125;) &#123; return ( &lt;header&gt; &#123; title &#125; &#123; children &#125; &lt;/header&gt; );&#125;function App() &#123; return ( &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt; &lt;Navigation /&gt; &lt;/Header&gt; );&#125;; 运行结果： 当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。 高阶组件很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 装饰器模式 十分相似，因为它是对组件的包装与增强。 从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:1234567891011121314151617var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; render() &#123; return ( &lt;Component &#123;...this.props&#125; /&gt; ) &#125; &#125;;var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle);class App extends React.Component &#123; render() &#123; return &lt;EnhancedTitle /&gt;; &#125;&#125;; 高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有OriginalTitle所需要的配置:12345678910111213141516var config = require('path/to/configuration');var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; render() &#123; return ( &lt;Component &#123;...this.props&#125; title=&#123; config.appTitle &#125; /&gt; ) &#125; &#125;;var OriginalTitle = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle); appTitle 是封装在高阶组件内部的。OriginalTitle 只知道它所接收的 title 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建mocks 。 这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 OriginalTitle 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 OriginalTitle 。1234567891011121314151617181920212223242526var enhanceComponent = (Component) =&gt; class Enhance extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; remoteTitle: null &#125;; &#125; componentDidMount() &#123; fetchRemoteData('path/to/endpoint').then(data =&gt; &#123; this.setState(&#123; remoteTitle: data.title &#125;); &#125;); &#125; render() &#123; return ( &lt;Component &#123;...this.props&#125; title=&#123; config.appTitle &#125; remoteTitle=&#123; this.state.remoteTitle &#125; /&gt; ) &#125; &#125;;var OriginalTitle = (&#123; title, remoteTitle &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;var EnhancedTitle = enhanceComponent(OriginalTitle); 这次，OriginalTitle 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。 关于高阶组件的创建问题，Dan Abramov 提出了一个 非常棒的观点，像调用 enhanceComponent 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 将函数作为 children 传入和 render propReact 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 children 属性都是 React 组件。然而，有一种新的模式越来越受欢迎，children 属性是一个 JSX 表达式。我们先从传入一个简单对象开始。123456789101112131415161718function UserName(&#123; children &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;, &#123; children.firstName &#125; &lt;/div&gt; );&#125;function App() &#123; const user = &#123; firstName: 'Krasimir', lastName: 'Tsonev' &#125;; return ( &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt; );&#125; 运行结果： 这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。TodoList 组件只是简单地封装了所需的 HTML 标记。1234567891011121314151617181920212223242526272829function TodoList(&#123; todos, children &#125;) &#123; return ( &lt;section className='main-section'&gt; &lt;ul className='todo-list'&gt;&#123; todos.map((todo, i) =&gt; ( &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt; )) &#125;&lt;/ul&gt; &lt;/section&gt; );&#125;function App() &#123; const todos = [ &#123; label: 'Write tests', status: 'done' &#125;, &#123; label: 'Sent report', status: 'progress' &#125;, &#123; label: 'Answer emails', status: 'done' &#125; ]; const isCompleted = todo =&gt; todo.status === 'done'; return ( &lt;TodoList todos=&#123; todos &#125;&gt; &#123; todo =&gt; isCompleted(todo) ? &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label &#125; &lt;/TodoList&gt; );&#125; 运行结果： 注意观察 App 组件是如何不暴露数据结构的。TodoList 完全不知道 label 和 `status 属性。 名为 render prop 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 render 属性，而不是 children 。1234567891011121314151617181920function TodoList(&#123; todos, render &#125;) &#123; return ( &lt;section className='main-section'&gt; &lt;ul className='todo-list'&gt;&#123; todos.map((todo, i) =&gt; ( &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt; )) &#125;&lt;/ul&gt; &lt;/section&gt; );&#125;return ( &lt;TodoList todos=&#123; todos &#125; render=&#123; todo =&gt; isCompleted(todo) ? &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label &#125; /&gt;); 运行结果： 这两种模式 将函数作为 children 传入 和 render prop 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。1234567891011121314class DataProvider extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: null &#125;; setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000); &#125; render() &#123; if (this.state.data === null) return null; return ( &lt;section&gt;&#123; this.props.render(this.state.data) &#125;&lt;/section&gt; ); &#125;&#125; DataProvider 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个&lt;section&gt;，&lt;section&gt; 的内容是由 render 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。1&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt; 我们描述了我们想要做的事，而不是如何去做。细节都封装在了 DataProvider 中。最近，使用这种模式，某些界面限制只对具有 read:products 权限的用户开放。我们使用的是render prop 模式。123&lt;Authorize permissionsInclude=&#123;[ 'read:products' ]&#125; render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt; 这种声明式的方式相当不错，不言自明。Authorize 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 ProductList。 结语 你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-事件处理]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。 事件处理123456const theLogoIsClicked = () =&gt; alert('Clicked');&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;&lt;input type='text' onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt; 通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法: 123456789101112 class Switcher extends React.Component &#123; render() &#123; return ( &lt;button onClick=&#123; this._handleButtonClick &#125;&gt; click me &lt;/button&gt; ); &#125; _handleButtonClick() &#123; console.log(&apos;Button is clicked&apos;); &#125;&#125;; 这样使用完全可以，因为 _handleButtonClick 是一个函数，而我们也确实将这个函数传给了 onClick 属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 _handleButtonClick 函数中使用 this 来获取 Switcher 组件的引用时将会报错。通常，我们使用 bind 来解决:123&lt;button onClick=&#123; this._handleButtonClick.bind(this) &#125;&gt; click me&lt;/button&gt; 但是，这样做的话 bind 函数会一次又一次地被调用，这是因为 button 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:1234567891011121314151617class Switcher extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: 'React in patterns' &#125;; this._buttonClick = this._handleButtonClick.bind(this); &#125; render() &#123; return ( &lt;button onClick=&#123; this._buttonClick &#125;&gt; click me &lt;/button&gt; ); &#125; _handleButtonClick() &#123; console.log(`Button is clicked inside $&#123; this.state.name &#125;`); &#125;&#125;; 运行结果： 附带一提，在处理函数需要和组件的上下文保持统一时，Facebook 推荐 的也是此技巧。 构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。12345678910111213141516171819class Form extends React.Component &#123; constructor(props) &#123; super(props); this._onNameChanged = this._onFieldChange.bind(this, 'name'); this._onPasswordChanged = this._onFieldChange.bind(this, 'password'); &#125; render() &#123; return ( &lt;form&gt; &lt;input onChange=&#123; this._onNameChanged &#125; /&gt; &lt;input onChange=&#123; this._onPasswordChanged &#125; /&gt; &lt;/form&gt; ); &#125; _onFieldChange(field, event) &#123; console.log(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`); &#125;&#125;; 运行结果： 结语对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发常用设计模式-组件通讯]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。 组件通讯每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。 输入React 组件的输入是它的 props 。传递数据的方式如下:123456789101112131415// Demo.jsxfunction Demo(props) &#123; return &lt;h1&gt;&#123; props.text &#125;&lt;/h1&gt;;&#125;Demo.propTypes = &#123; text: PropTypes.string&#125;;Demo.defaultProps = &#123; text: 'Hello world'&#125;;// App.jsxfunction App() &#123; return &lt;Demo text='Hello React' /&gt;;&#125; Demo 组件只有一个输入属性 text 。父组件 (App) 在使用 &lt;Demo&gt; 标签时提供此属性。在定义组件的同时我们还定义了 propTypes 。在 propTypes 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。 React 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:12345678function SomethingElse(&#123; answer &#125;) &#123; return &lt;div&gt;The answer is &#123; answer &#125;&lt;/div&gt;;&#125;function Answer() &#123; return &lt;span&gt;42&lt;/span&gt;;&#125;&lt;SomethingElse answer=&#123; &lt;Answer /&gt; &#125; /&gt; 还有一个 props.children 属性，它可以让我们访问父组件标签内的子元素。例如:123456789101112131415function Title(&#123; text, children &#125;) &#123; return ( &lt;h1&gt; &#123; text &#125; &#123; children &#125; &lt;/h1&gt; );&#125;function App() &#123; return ( &lt;Title text='Hello React'&gt; &lt;span&gt;community&lt;/span&gt; &lt;/Title&gt; );&#125; 运行结果： 在这个示例中，App 组件中的 &lt;span&gt;community&lt;/span&gt; 就是 Title 组件中的 children 属性。注意，如果我们将 { children } 从 Title 组件中移除，那么 &lt;span&gt; 标签将不会渲染。 16.3 版本之前，组件还有一种间接输入，叫做context 。整个 React 组件树可能有一个 context 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 依赖注入 章节。 输出React 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。 在下面的示例中，有一个组件&lt;NameField /&gt;，它接受用户的输入并能将结果发送出去。12345678910111213141516171819202122function NameField(&#123; valueUpdated &#125;) &#123; return ( &lt;input onChange=&#123; event =&gt; valueUpdated(event.target.value) &#125; /&gt; );&#125;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: '' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;NameField valueUpdated=&#123; name =&gt; this.setState(&#123; name &#125;) &#125; /&gt; Name: &#123; this.state.name &#125; &lt;/div&gt; ); &#125;&#125;; 运行结果： 通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。123456789101112class ResultsPage extends React.Component &#123; componentDidMount() &#123; this.props.getResults(); &#125; render() &#123; if (this.props.results) &#123; return &lt;List results=&#123; this.props.results &#125; /&gt;; &#125; else &#123; return &lt;LoadingScreen /&gt; &#125; &#125;&#125; 假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 /results 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在componentDidMount 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 &lt;List&gt; 组件。 结语我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 开发常用设计模式-前言]]></title>
    <url>%2Fblog%2F2018%2F05%2F14%2FReact-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[React 模式介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。 Web https://sangka.github.io/react-in-patterns-cn/]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则速查表]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2FJavascript%E6%AD%A3%E5%88%99%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。 replace:1234// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.function getLen(str) &#123; return str.replace(/[^\x00-\xff]/g, &apos;xx&apos;).length;&#125; test:123456789// 匹配是否符合邮件规则var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// test返回一个布尔值, 表示是否匹配到制定字符串var mail = reg.test(&apos;anran758@gmail.com&apos;)if (mail) &#123; // 如果邮件格式正确的话, 就可以做点啥了(雾&#125; 表单验证1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/; 网络相关1234567891011//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;// 匹配JSON格式var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ 联系方式1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/; 字符串相关123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\w+$/;// 匹配空白行的正则表达式var reg = /\n\s*\r/;// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/;var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/g; 匹配特定数字1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/;// 匹配负整数var reg = /^-[1-9]\d*$/;// 匹配整数var reg = /^-?[1-9]\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;// 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Rax，以及 Rax 的特点]]></title>
    <url>%2Fblog%2F2018%2F05%2F11%2F%E4%BB%80%E4%B9%88%E6%98%AF-Rax%EF%BC%8C%E4%BB%A5%E5%8F%8A-Rax-%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Rax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax. Rax经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。 Rax 与 ReactReact 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。 Rax 的特点1、设计上支持不同容器Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。 2、体积足够小如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。 3、支持返回多个同级节点任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：123456789import &#123;createElement, Component, render&#125; from &apos;rax&apos;;class Test extends Component &#123; render() &#123; return [1, 2, 3].map((item) =&gt; &#123; return &lt;p&gt;&#123;item&#125;&lt;/p&gt;; &#125;); &#125;&#125; 这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。 4、标准化在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。 未来Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?了解更多 Rax 相关内容，欢迎访问 alibaba.github.io/rax来自Rax 团队敬上。原文链接https://alibaba.github.io/rax/blog/whats-rax]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React一些路由]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2FReact%E4%B8%80%E4%BA%9B%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[React路由Prompt、Redirect、match、Switch。 1、Prompt组件 除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。 它有一个必须的属性message，用于给用户提示信息。基本使用：1&lt;Prompt message=&quot;给用户提示信息&quot;/&gt; 有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。基本使用方式：1&lt;Prompt when=&#123;true&#125; message=&quot;给用户提示信息&quot;/&gt; 2、Redirect组件 在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。 Redirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。基本使用：12&lt;Redirect to=&apos;/new-path&apos; /&gt;&lt;Route path=&apos;/new-path&apos; component=&#123;NewPage&#125;/&gt; 1&lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt; Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它基本使用方式：1234567891011121314151617181920212223242526272829303132333435363738394041424344import React,&#123; Component &#125; from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;class Index extends Component&#123; render()&#123; return ( &lt;div&gt;this a Index page&lt;/div&gt; ) &#125;&#125;class Other extends Component&#123; render()&#123; return ( &lt;div&gt;this a Other page&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; toast: false, &#125; &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/index&quot;&gt;这是首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;这是其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt; &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;//因为重定向，所以每个路由展示界面都是other界面render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;)); 3、Switch组件 它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。 基本使用方式：123456import &#123; Switch &#125; from &quot;react-router-dom&quot;;&lt;Switch&gt; &lt;Route path=&quot;/&quot; component=&#123;Test1&#125; /&gt; &lt;Route path=&quot;/Test&quot; component=&#123;Test2&#125; /&gt;&lt;/Switch&gt; 以下实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React,&#123; Component &#125; from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &quot;react-router-dom&quot;;class Home extends Component&#123; render()&#123; return ( &lt;div&gt;Home&lt;/div&gt; ) &#125;&#125;class Other extends Component&#123; render()&#123; return ( &lt;div&gt;Other&lt;/div&gt; ) &#125;&#125;class Switchs extends Component&#123; render()&#123; return ( &lt;div&gt;Switchs test&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&quot;/:id&quot; component=&#123;Switchs&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;)); 4、Match对象 match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。 在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。 Match的获取方式：在Route component中，组件通过this.props.match获取。在Route render 和Route children中，通过传递一个参数的方式获取。12345678910111213141516171819202122232425262728293031323334以下实例：```hashimport &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;class Match extends Component&#123; render()&#123; return ( &lt;div&gt;id:&#123;this.props.match.params.id&#125;&lt;/div&gt; ) &#125;&#125;class Main extends Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/:id&quot; component=&#123;Match&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;//id是路径匹配参数。render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客问题收集器]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E6%96%87%E7%AB%A0%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！ First1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 3 等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 Second4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg) 也可以直接使用如下方式：1&#123;% asset_img long.png 记一次Hexo文章里的图片不显示问题 %&#125; 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 Hexo Next 解决 Busuanzi 统计浏览失效由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题时统计浏览数失效. 不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/ 解决方法: 到hexo的themes文件夹下, 进入 \themes\next\layout_third-party\analytics 打开: busuanzi-counter.swig 将src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js” 修改为src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”`]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题模板一些配置]]></title>
    <url>%2Fblog%2F2018%2F05%2F05%2Fnext%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。 1.修改文章底部的那个带#号的标签实现效果图 具体实现方法 123456/themes/next/layout/_macro/post.swig找到 rel="tag"&gt;#修改为&lt;i class="fa fa-tag"&gt;&lt;/i&gt;完整的应该是这样的： &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 2.在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 12345678910111213141516在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：&lt;div&gt;&#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125;&#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 3.修改“代码块自定义样式具体实现方法打开 \themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 4.侧边栏社交小图标设置具体实现方法打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可123456789101112131415161718192021222324252627# 社交链接# Social Linkssocial:GitHub: https://github.com/DuanruilongCSDN: https://github.com/Duanruilong微博: https://github.com/DuanruilongQQ: https://github.com/Duanruilong知乎: https://github.com/Duanruilong# Social Links Icons/设定链接的图标social_icons:enable: trueicons_only: falsetransition: true# Icon Mappings.# KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesomeGitHub: githubE-Mail: envelopeGoogle: googleTwitter: twitterInstagram: instagramStackOverflow: stack-overflow微博: weibo知乎: envelopeQQ: qq微信: weixinCSDN: crosshairslinks_title: discord 5.在网站底部加上访问量具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上这句话：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： 1.pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 6.添加热度具体实现方法next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃：12345&#123;% if theme.post_meta.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;&#123;% endif %&#125;&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;&lt;span&gt;℃&lt;/span&gt; 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了12345678910111213post: created: 创建于 modified: 更新于 sticky: 置顶 posted: 发表于 in: 分类于 read_more: 阅读全文 untitled: 未命名 toc_empty: 此文章未包含目录 visitors: 热度 wordcount: 字数统计 min2read: 阅读时长 copyright: 7.网站底部字数统计具体方法实现切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 8.添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为:1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 9.设置网站的图标Favicon在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 11.实现统计功能在根目录下安装 hexo-wordcount,运行：1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 12.添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，添加如下代码12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条. 13.在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:description: copyright: categories:--- 这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/2018/05/05/next主题模板一些配置/,那么在根目录下_config.yml中写成类似这样：）123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://duanruilong.github.io/root: /blogpermalink: :year/:month/:day/:title/permalink_defaults: 14.修改网页底部的桃心打开themes/next/layout/_partials/footer.swig，找到：123&lt;span class=&quot;with-love&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.authoricon &#125;&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/i&gt;&lt;/span&gt; 然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 15.文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; alert(&apos;密码错误！&apos;); if (history.length === 1) &#123; location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:description: copyright: categories:password: password--- 16.添加jiathis分享在主题配置文件中，jiathis为true，就行了1234# Share 分享jiathis: true# Warning: JiaThis does not support https.#add_this_id: 如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改就可以了1234567891011121314&lt;!-- JiaThis Button BEGIN --&gt;&lt;div class=&quot;jiathis_style&quot;&gt; &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_kaixin001&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://www.jiathis.com/share&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;&lt;/div&gt; 17.博文置顶或者排序修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如12345678---title: 第一篇blogdate: 2018-05-04 23:38:11tags: 生活description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面copyright: truetop: 12--- 18.修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base =16px 19.修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 20.点击爆炸效果跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下：1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：12345&#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下：12# Fireworksfireworks: true 21.DaoVoice 在线联系首先在 daovoice 注册账号,邀请码是0f81ff2f，注册完成后会得到一个 app_id : 1234daovoice(&apos;init&apos;, &#123; app_id: &quot;0000000&quot;&#125;);daovoice(&apos;update&apos;); 记下这个 app_id的值，然后打开/themes/next/layout/_partials/head.swig,写下如下代码：123456789101112&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125;``````````````````````````````````````````` 12345接着打开主题配置文件，在最后写下如下代码：```hash# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 重新 hexo g &amp;&amp; hexo s 就能看到效果了。安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式 22.添加跟帖(来必力)有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key 23.给文章设置阅读量Hexo 目录下的 \themes\next\ _config.yml 文件 12345678910111213141516# 增加不算子访问数量统计busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 访问总量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 24、在文章中嵌入 CodePen或 jsFiddle链接]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Github搭建个人博客详细配置]]></title>
    <url>%2Fblog%2F2018%2F05%2F05%2F%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。 新建文章hexo new &#39;文章标题&#39; 生成静态网页&amp;部署hexo clean 清除缓存hexo g 生成静态网页hexo d 开始部署 连接写法：hexo c &amp;&amp; hexo g &amp;&amp; hexo d 开启评论1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\landscape\layout_partial\article.ejs把1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id="comments"&gt;&lt;div id="disqus_thread"&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href="//disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id="comments"&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;" data-title="&lt;%= post.title %&gt;" data-url="&lt;%= page.permalink %&gt;"&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type="text/javascript"&gt; var duoshuoQuery = &#123;short_name:'&lt;%= config.disqus_shortname %&gt;'&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt; hexo相处里的错误部署没有权限123456789101112131415161718192021[master 74ddc79] Site updated: 2018-07-22 23:14:27 1 file changed, 1 insertion(+), 1 deletion(-)Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. at ChildProcess.&lt;anonymous&gt; (/Users/duanruilong/Github/hexo/node_modules/hexo-util/lib/spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at maybeClose (internal/child_process.js:877:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5) 查看权限 12345➜ ~ ssh -T git@github.comgit@github.com: Permission denied (publickey).&lt;!--就是没有权限 --&gt; 接下来这样来1、检查是否有SSH key 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接进行第三步。 2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：ssh-keygen -t rsa -C &quot;邮箱名&quot; 然后会出现：123456789101112131415161718192021222324252627282930Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa):直接回车就可以。然后会出现：Enter passphrase (empty for no passphrase):Enter same passphrase again:要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，直接输入就好。然后会出现：Your identification has been saved in /c/Users/dell/.ssh/id_rsa.Your public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.The key fingerprint is:65:69:······02:4b emailname@email.comThe key's randomart image is:+--[ RSA 2048]----+| || . o . || . o o = o || . o * = o || E o + o . || . o. . . || .. |+-----------------+至此，密钥已经成功生成。 3、接下来在github上添加SSH key： ① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是/Users/duanruilong/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。 ② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。 ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。 4、测试设置是否成功ssh -T git@github.com 有可能会出现： 1234567891011121314151617The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?或者是The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)?这种情况下，直接 yes 回车然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）：Hi username! You've successfully authenticated, but GitHub does not provide shell access. 5、设置用户信息~ git config --global user.name~ git config --global user.email 6、然后就可以部署你的博客hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们第一次相遇]]></title>
    <url>%2Fblog%2F2018%2F05%2F04%2F%E7%AC%AC%E4%B8%80%E7%AF%87blog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的blog，这里是我记录生活和一些事情的地方，这里会收录一些好的文章，值得学习的东西；也是一个随记的地方。我们的遇到就是缘分的开始，互相学习，互相认识。 我来自七彩云南 读书于古都西安 现在坐标上海 耕织于前端开发，菜鸟到大神的过程是漫长的，不断学习，不断进步，说不定哪一天…… 路要一步一步走，知识也要慢慢啃 喜欢运动打篮球，欢迎各大球友结识，还喜欢搞搞摄影视频剪辑，喜欢看到的色彩，等等还要就是美食烹饪 好吧就这样吧！]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F05%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
