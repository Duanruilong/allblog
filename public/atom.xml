<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>About-龙大</title>
  
  <subtitle>不忘初心，继续前进。</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://duanruilong.github.io/"/>
  <updated>2018-05-15T15:41:10.259Z</updated>
  <id>https://duanruilong.github.io/</id>
  
  <author>
    <name>DRLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React开发常用设计模式-展示型组件和容器型组件</title>
    <link href="https://duanruilong.github.io/2018/05/15/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6/"/>
    <id>https://duanruilong.github.io/2018/05/15/React开发常用设计模式-展示型组件和容器型组件/</id>
    <published>2018-05-15T15:34:58.000Z</published>
    <updated>2018-05-15T15:41:10.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="展示型组件和容器型组件"><a href="#展示型组件和容器型组件" class="headerlink" title="展示型组件和容器型组件"></a>展示型组件和容器型组件</h1><p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为<code>展示型组件</code>和<code>容器型组件</code>。</p><p>我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 <code>Clock</code> 组件，它接收 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date</a> 对象作为属性并显示实时时间。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; time: <span class="keyword">this</span>.props.time &#125;;</span><br><span class="line">    <span class="keyword">this</span>._update = <span class="keyword">this</span>._updateTime.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="keyword">this</span>._formatTime(<span class="keyword">this</span>.state.time);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._interval = setInterval(<span class="keyword">this</span>._update, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>._interval);</span><br><span class="line">  &#125;</span><br><span class="line">  _formatTime(time) &#123;</span><br><span class="line">    var [ hours, minutes, seconds ] = [</span><br><span class="line">      time.getHours(),</span><br><span class="line">      time.getMinutes(),</span><br><span class="line">      time.getSeconds()</span><br><span class="line">    ].<span class="built_in">map</span>(num =&gt; num &lt; <span class="number">10</span> ? <span class="string">'0'</span> + num : num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; hours, minutes, seconds &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      time: <span class="keyword">new</span> Date(<span class="keyword">this</span>.state.time.getTime() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Clock time=&#123; <span class="keyword">new</span> Date() &#125;/&gt;, ...);</span><br></pre></td></tr></table></figure></p><p>在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 <code>setInterval</code> ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: <code>_formatTime</code> 和<code>_updateTime</code> 。<code>_formatTime</code> 用来提取时分秒并确保它们是两位数的形式。<code>_updateTime</code> 用来将<code>time</code> 对象设置为当前时间加一秒。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这个组件中它做了好几件事，似乎承担了太多的职责。</p><ul><li>它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。</li><li><code>_formatTime</code> 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。</li></ul><h1 id="提取出容器型组件"><a href="#提取出容器型组件" class="headerlink" title="提取出容器型组件"></a>提取出容器型组件</h1><p>容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 <a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components" target="_blank" rel="noopener">高阶组件</a> 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。</p><p>下面是 <code>ClockContainer</code> 的代码:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/index.js</span></span><br><span class="line">import Clock from './Clock.jsx'; // &lt;-- 展示型组件</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockContainer</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; time: props.time &#125;;</span><br><span class="line">    <span class="keyword">this</span>._update = <span class="keyword">this</span>._updateTime.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Clock &#123; ...<span class="keyword">this</span>._extract(<span class="keyword">this</span>.state.time) &#125;/&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._interval = setInterval(<span class="keyword">this</span>._update, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>._interval);</span><br><span class="line">  &#125;</span><br><span class="line">  _extract(time) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      hours: time.getHours(),</span><br><span class="line">      minutes: time.getMinutes(),</span><br><span class="line">      seconds: time.getSeconds()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      time: <span class="keyword">new</span> Date(<span class="keyword">this</span>.state.time.getTime() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>它接收 <code>time</code> (date 对象) 属性，使用<code>setInterval</code> 循环并了解数据 (<code>getHours</code>、<code>getMinutes</code> 和 <code>getSeconds</code>) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。</p><h1 id="展示型组件"><a href="#展示型组件" class="headerlink" title="展示型组件"></a>展示型组件</h1><p>展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 <a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components" target="_blank" rel="noopener">无状态组件</a>，它们没有内部状态。</p><p>在本示例中，展示型组件只包含两位数的检查并返回 <code>&lt;h1&gt;</code> 标签:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/Clock.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Clock</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  var [ hours, minutes, seconds ] = [</span><br><span class="line">    props.hours,</span><br><span class="line">    props.minutes,</span><br><span class="line">    props.seconds</span><br><span class="line">  ].<span class="built_in">map</span>(num =&gt; num &lt; <span class="number">10</span> ? <span class="string">'0'</span> + num : num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。</p><p>容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 <code>render</code> 方法中的 ·<clock>· 组件。</clock></p><p>测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。</p>]]></content>
    
    <summary type="html">
    
      万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅——个人申请</title>
    <link href="https://duanruilong.github.io/2018/05/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%94%B3%E8%AF%B7/"/>
    <id>https://duanruilong.github.io/2018/05/15/小程序之旅——个人申请/</id>
    <published>2018-05-14T16:47:28.000Z</published>
    <updated>2018-05-15T15:38:53.707Z</updated>
    
    <content type="html"><![CDATA[<p>开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">小程序开发注册传送门</a>，按照步骤完成注册认证就可以开始开发咯。</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx.png" alt="小程序之旅——个人申请"></p><p>注册完之后就登录进入开发<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_1.png" alt="小程序之旅——个人申请"></p><p>填写个人资料<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_4.png" alt="小程序之旅——个人申请"></p><p>填写个人资料<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_3.png" alt="小程序之旅——个人申请"></p><blockquote><p>注意事项：</p></blockquote><ul><li><p>1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。</p></li><li><p>2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。</p></li><li><p>3.每次登录都需要扫码认证，确认成功后就可以正常登录了。</p></li></ul><p>个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_2.png" alt="小程序之旅——个人申请"></p><p>我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_5.png" alt="小程序之旅——个人申请"></p><p>新建一个项目文件，输入自己的APPID，确定</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_6.png" alt="小程序之旅——个人申请"></p><p>进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_7.png" alt="小程序之旅——个人申请"></p><blockquote><p>注意事项：</p></blockquote><ul><li><p>1.每次登录都需要扫码登录</p></li><li><p>2.需要输入自己的APPID</p></li><li><p>3.每次修改完代码都要编译</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！<br>微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。</p>]]></content>
    
    <summary type="html">
    
      是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-受控输入和非受控输入</title>
    <link href="https://duanruilong.github.io/2018/05/15/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5/"/>
    <id>https://duanruilong.github.io/2018/05/15/React开发常用设计模式-受控输入和非受控输入/</id>
    <published>2018-05-14T16:19:01.000Z</published>
    <updated>2018-05-14T16:21:11.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="受控输入和非受控输入"><a href="#受控输入和非受控输入" class="headerlink" title="受控输入和非受控输入"></a>受控输入和非受控输入</h1><p>在 React 表单管理中有两个经常使用的术语: <code>受控输入</code>和<code>非受控输入</code>。</p><ul><li>受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个<code>&lt;input&gt;</code> 字段，它就是受控的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码的结果是我们可以操作<code>input</code> 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让<code>input</code>正常工作的话，需要为其添加<code>onChange</code> 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 <code>input</code>中输入的文字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">    this._change = this._handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        value=&#123; this.state.value &#125;</span><br><span class="line">        onChange=&#123; this._change &#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange(e) &#123;</span><br><span class="line">    this.setState(&#123; value: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 <code>defaultValue</code> 属性来提供初始值，此后浏览器将负责保存输入的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>&lt;input&gt;</code>元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用<a href="Refs"> Refs</a> 来获取 DOM 元素的实际引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">    this._change = this._handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        defaultValue=&#123; this.state.value &#125;</span><br><span class="line">        onChange=&#123; this._change &#125;</span><br><span class="line">        ref=&#123; input =&gt; this.input = input &#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange() &#123;</span><br><span class="line">    this.setState(&#123; value: this.input.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>ref</code>属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量<code>input</code>中。之后当 <code>onChange</code>事件触发时，我们将 <code>input</code> 中的最新值保存到 <code>App</code> 组件的状态里。</p><p>大量使用<code>refs</code> 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>]]></content>
    
    <summary type="html">
    
      在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-组合 (composition)</title>
    <link href="https://duanruilong.github.io/2018/05/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88-composition/"/>
    <id>https://duanruilong.github.io/2018/05/14/React开发常用设计模式-组合-composition/</id>
    <published>2018-05-14T15:52:47.000Z</published>
    <updated>2018-05-14T16:21:23.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合-composition"><a href="#组合-composition" class="headerlink" title="组合 ( composition )"></a>组合 ( composition )</h1><p>React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。</p><p>我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 <code>Reac</code>t 组件 <code>—App</code>、<code>Header</code> 和 <code>Navigation</code> 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt;</span><br></pre></td></tr></table></figure></p><p>组合这些组件的简单方法是在需要它们的时候引用即可。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Navigation from './Navigation.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigation.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Navigation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;nav&gt; ... &lt;/nav&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，这种方式会引入一些问题:</p><ul><li>我们可以把 App 看作是主要的组合场所。<code>Header</code> 可能还有其他元素，比如 <code>logo</code>、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 <code>Navigation</code> 的 <code>Header</code> 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。</li><li>代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 <code>Navigation</code> 组件出了问题，那么 <code>Header</code> 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: <a href="https://facebook.github.io/react/docs/test-utils.html#shallow-rendering" target="_blank" rel="noopener">浅层渲染 ( shallow rendering</a> ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)</li></ul><h1 id="使用-React-children-API"><a href="#使用-React-children-API" class="headerlink" title="使用 React children API"></a>使用 React children API</h1><p>React 提供了便利的 <a href="https://facebook.github.io/react/docs/multiple-components.html#children" target="_blank" rel="noopener">children</a> 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 <code>Header</code> 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">(&#123; children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;header&gt;&#123; children &#125;&lt;/header&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，如果不在 <code>Heade</code>r 中使用 <code>{ children }</code>的话，那么 <code>Navigation</code> 组件永远不会渲染。</p><p>现在 Header 组件的测试变得更简单了，因为完全可以使用空 <code>&lt;div&gt;</code> 来渲染 <code>Header</code> 组件。这会使用组件更独立，并让我们专注于应用的一小部分。</p><h1 id="将-child-作为-prop-传入"><a href="#将-child-作为-prop-传入" class="headerlink" title="将 child 作为 prop 传入"></a>将 child 作为 prop 传入</h1><p>每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello there!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Header = function (&#123; title, children &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &#123; title &#125;</span><br><span class="line">      &#123; children &#125;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_5.png" alt="运行结果"></p><p>当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。</p><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 <a href="http://robdodson.me/javascript-design-patterns-decorator/" target="_blank" rel="noopener">装饰器模式</a> 十分相似，因为它是对组件的包装与增强。</p><p>从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component &#123;...<span class="keyword">this</span>.props&#125; /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;EnhancedTitle /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有<code>OriginalTitle</code>所需要的配置:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var config = require('path/to/configuration');</span><br><span class="line"></span><br><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p><p><code>appTitle</code> 是封装在高阶组件内部的。<code>OriginalTitle</code> 只知道它所接收的 <code>title</code> 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建<code>mocks</code> 。</p><p>这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 <code>OriginalTitle</code> 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 <code>OriginalTitle</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = &#123; remoteTitle: null &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetchRemoteData('path/to/endpoint').then(data =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">          remoteTitle=&#123; <span class="keyword">this</span>.state.remoteTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class="line">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p><p>这次，<code>OriginalTitle</code> 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。</p><ul><li>关于高阶组件的创建问题<a href="https://github.com/gaearon" target="_blank" rel="noopener">，Dan Abramov</a> 提出了一个 <a href="https://github.com/krasimir/react-in-patterns/issues/12" target="_blank" rel="noopener">非常棒的观点</a>，像调用 <code>enhanceComponent</code> 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 </li></ul><h1 id="将函数作为-children-传入和-render-prop"><a href="#将函数作为-children-传入和-render-prop" class="headerlink" title="将函数作为 children 传入和 render prop"></a>将函数作为 children 传入和 render prop</h1><p>React 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 <code>children</code> 属性都是 <code>React</code> 组件。然而，有一种新的模式越来越受欢迎，<code>children</code> 属性是一个 <code>JSX</code> 表达式。我们先从传入一个简单对象开始。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">UserName</span><span class="params">(&#123; children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;,</span><br><span class="line">      &#123; children.firstName &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: 'Krasimir',</span><br><span class="line">    lastName: 'Tsonev'</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_6.png" alt="运行结果"></p><p>这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。<code>TodoList</code> 组件只是简单地封装了所需的 HTML 标记。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">TodoList</span><span class="params">(&#123; todos, children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className='main-section'&gt;</span><br><span class="line">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class="line">        todos.<span class="built_in">map</span>((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; label: 'Write tests', status: 'done' &#125;,</span><br><span class="line">    &#123; label: 'Sent report', status: 'progress' &#125;,</span><br><span class="line">    &#123; label: 'Answer emails', status: 'done' &#125;</span><br><span class="line">  ];</span><br><span class="line">  const isCompleted = todo =&gt; todo.status === 'done';</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        todo =&gt; isCompleted(todo) ?</span><br><span class="line">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class="line">          todo.label</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/TodoList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_7.png" alt="运行结果"></p><p>注意观察 App 组件是如何不暴露数据结构的。<code>TodoList</code> 完全不知道 <code>label</code> 和 `status 属性。</p><p>名为 <code>render prop</code> 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 <code>render</code> 属性，而不是 <code>children</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">TodoList</span><span class="params">(&#123; todos, render &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className='main-section'&gt;</span><br><span class="line">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class="line">        todos.<span class="built_in">map</span>((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;TodoList</span><br><span class="line">    todos=&#123; todos &#125;</span><br><span class="line">    render=&#123;</span><br><span class="line">      todo =&gt; isCompleted(todo) ?</span><br><span class="line">        &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label</span><br><span class="line">    &#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_8.png" alt="运行结果"></p><p>这两种模式 将函数作为 <code>children</code> 传入 和 <code>render prop</code> 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; data: null &#125;;</span><br><span class="line">    setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.data === null) <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;section&gt;&#123; <span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state.data) &#125;&lt;/section&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DataProvider</code> 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个<code>&lt;section&gt;</code>，<code>&lt;section&gt;</code> 的内容是由 <code>render</code> 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>我们描述了我们想要做的事，而不是如何去做。细节都封装在了 <code>DataProvider</code> 中。最近，使用这种模式，某些界面限制只对具有 <code>read:products</code> 权限的用户开放。我们使用的是<code>render prop</code> 模式。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Authorize</span><br><span class="line">  permissionsInclude=&#123;[ 'read:products' ]&#125;</span><br><span class="line">  render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>  这种声明式的方式相当不错，不言自明。<code>Authorize</code> 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 <code>ProductList</code>。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>]]></content>
    
    <summary type="html">
    
      对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-事件处理</title>
    <link href="https://duanruilong.github.io/2018/05/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>https://duanruilong.github.io/2018/05/14/React开发常用设计模式-事件处理/</id>
    <published>2018-05-14T15:43:54.000Z</published>
    <updated>2018-05-14T16:13:12.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const theLogoIsClicked = () =&gt; alert('Clicked');</span><br><span class="line"></span><br><span class="line">&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;</span><br><span class="line">&lt;input</span><br><span class="line">  type='text'</span><br><span class="line">  onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>  通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  class Switcher extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123; this._handleButtonClick &#125;&gt;</span><br><span class="line">        click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleButtonClick() &#123;</span><br><span class="line">    console.log(&apos;Button is clicked&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样使用完全可以，因为 <code>_handleButtonClick</code> 是一个函数，而我们也确实将这个函数传给了 <code>onClick</code>  属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 <code>_handleButtonClick</code> 函数中使用 <code>this</code> 来获取 <code>Switcher</code> 组件的引用时将会报错。<br>通常，我们使用 bind 来解决:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="keyword">this</span>._handleButtonClick.bind(<span class="keyword">this</span>) &#125;&gt;</span><br><span class="line">  click me</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>但是，这样做的话 <code>bind</code> 函数会一次又一次地被调用，这是因为 <code>button</code> 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; name: 'React in patterns' &#125;;</span><br><span class="line">    <span class="keyword">this</span>._buttonClick = <span class="keyword">this</span>._handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123; <span class="keyword">this</span>._buttonClick &#125;&gt;</span><br><span class="line">        click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleButtonClick() &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Button is clicked inside $&#123; <span class="keyword">this</span>.state.name &#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-事件处理/react_3.png" alt="运行结果"></p><p>附带一提，在处理函数需要和组件的上下文保持统一时，Facebook <a href="https://facebook.github.io/react/docs/reusable-components.html#no-autobinding" target="_blank" rel="noopener">推荐</a> 的也是此技巧。</p><p>构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this._onNameChanged = this._onFieldChange.bind(this, 'name');</span><br><span class="line">    <span class="keyword">this</span>._onPasswordChanged =</span><br><span class="line">      this._onFieldChange.bind(this, 'password');</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;input onChange=&#123; <span class="keyword">this</span>._onNameChanged &#125; /&gt;</span><br><span class="line">        &lt;input onChange=&#123; <span class="keyword">this</span>._onPasswordChanged &#125; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _onFieldChange(field, event) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-事件处理/react_4.png" alt="运行结果"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。</p>]]></content>
    
    <summary type="html">
    
      对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-组件通讯</title>
    <link href="https://duanruilong.github.io/2018/05/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <id>https://duanruilong.github.io/2018/05/14/React开发常用设计模式-组件通讯/</id>
    <published>2018-05-14T15:09:05.000Z</published>
    <updated>2018-05-14T16:21:43.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><p>每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。</p><p><img src="/blog/2018/05/14/React开发常用设计模式-组件通讯/reactput.png" alt="输入"></p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>React 组件的输入是它的 props 。传递数据的方式如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.jsx</span></span><br><span class="line"><span class="function">function <span class="title">Demo</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.text &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">Demo.propTypes = &#123;</span><br><span class="line">  text: PropTypes.<span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line">Demo.defaultProps = &#123;</span><br><span class="line">  text: 'Hello world'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  return &lt;Demo text='Hello React' /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Demo</code> 组件只有一个输入属性 <code>text</code> 。父组件 (App) 在使用 <code>&lt;Demo&gt;</code> 标签时提供此属性。在定义组件的同时我们还定义了 <code>propTypes</code> 。在 <code>propTypes</code> 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。</p><p>React 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">SomethingElse</span><span class="params">(&#123; answer &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;The answer is &#123; answer &#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">Answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;span&gt;<span class="number">42</span>&lt;/span&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;SomethingElse answer=&#123; &lt;Answer /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>还有一个 <code>props.children</code> 属性，它可以让我们访问父组件标签内的子元素。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Title</span><span class="params">(&#123; text, children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123; text &#125;</span><br><span class="line">      &#123; children &#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Title text='Hello React'&gt;</span><br><span class="line">      &lt;span&gt;community&lt;/span&gt;</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组件通讯/react_1.png" title="React开发常用设计模式-组件通讯"><br><!-- ![运行结果](React开发常用设计模式-组件通讯/react_1.png) --></p><p>在这个示例中，App 组件中的 <code>&lt;span&gt;community&lt;/span&gt;</code> 就是 Title 组件中的 <code>children</code> 属性。注意，如果我们将 <code>{ children }</code> 从 Title 组件中移除，那么 <code>&lt;span&gt;</code> 标签将不会渲染。</p><p>16.3 版本之前，组件还有一种间接输入，叫做<code>context</code> 。整个 React 组件树可能有一个 <code>context</code> 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 <a href="http://sangka-z.com/react-in-patterns-cn/chapter-10/" target="_blank" rel="noopener">依赖注入</a> 章节。</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>React 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。</p><p>在下面的示例中，有一个组件<code>&lt;NameField /&gt;</code>，它接受用户的输入并能将结果发送出去。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">NameField</span><span class="params">(&#123; valueUpdated &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input</span><br><span class="line">      onChange=&#123; event =&gt; valueUpdated(event.target.value) &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; name: '' &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;NameField</span><br><span class="line">          valueUpdated=&#123; name =&gt; <span class="keyword">this</span>.setState(&#123; name &#125;) &#125; /&gt;</span><br><span class="line">        Name: &#123; <span class="keyword">this</span>.state.name &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组件通讯/react_2.png" title="React开发常用设计模式-组件通讯"></p><!-- ![运行结果](**React-开发常用设计模式-前言**/react_2.png) --><p>通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsPage</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.getResults();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.results) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;List results=&#123; <span class="keyword">this</span>.props.results &#125; /&gt;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;LoadingScreen /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 <code>/results</code> 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在<code>componentDidMount</code> 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 <code>&lt;List&gt;</code> 组件。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。</p>]]></content>
    
    <summary type="html">
    
      每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 开发常用设计模式-前言</title>
    <link href="https://duanruilong.github.io/2018/05/14/React-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%8D%E8%A8%80/"/>
    <id>https://duanruilong.github.io/2018/05/14/React-开发常用设计模式-前言/</id>
    <published>2018-05-14T14:48:42.000Z</published>
    <updated>2018-05-14T16:37:41.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-模式"><a href="#React-模式" class="headerlink" title="React 模式"></a>React 模式</h1><p>介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。</p><ul><li><p><a href="https://sangka.github.io/react-in-patterns-cn/" target="_blank" rel="noopener">Web https://sangka.github.io/react-in-patterns-cn/</a></p></li><li><p><a href="GitHub (https://github.com/SangKa/react-in-patterns-cn">GitHub https://github.com/SangKa/react-in-patterns-cn</a></p></li></ul><p><img src="/blog/2018/05/14/React-开发常用设计模式-前言/cover1.png" alt="设计模式"></p>]]></content>
    
    <summary type="html">
    
      介绍使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Javascript正则速查表</title>
    <link href="https://duanruilong.github.io/2018/05/13/Javascript%E6%AD%A3%E5%88%99%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>https://duanruilong.github.io/2018/05/13/Javascript正则速查表/</id>
    <published>2018-05-12T16:22:33.000Z</published>
    <updated>2018-05-12T16:27:36.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="replace"><a href="#replace" class="headerlink" title="replace:"></a>replace:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.</span><br><span class="line">function getLen(str) &#123;</span><br><span class="line">  return str.replace(/[^\x00-\xff]/g, &apos;xx&apos;).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 匹配是否符合邮件规则</span><br><span class="line">var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;</span><br><span class="line"></span><br><span class="line">// test返回一个布尔值, 表示是否匹配到制定字符串</span><br><span class="line">var mail = reg.test(&apos;anran758@gmail.com&apos;)</span><br><span class="line"></span><br><span class="line">if (mail) &#123;</span><br><span class="line">  // 如果邮件格式正确的话, 就可以做点啥了(雾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class="line">var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;</span><br><span class="line"></span><br><span class="line">// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class="line">var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;</span><br><span class="line"></span><br><span class="line">// 匹配邮箱地址</span><br><span class="line">var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;</span><br><span class="line"></span><br><span class="line">// 中国六位数的邮政编码</span><br><span class="line">var postalCode = /^\d&#123;6&#125;$/;</span><br><span class="line"></span><br><span class="line">// 匹配15~18位身份证</span><br><span class="line">var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;</span><br><span class="line"></span><br><span class="line">// 匹配18位的新版身份证</span><br><span class="line">var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/;</span><br></pre></td></tr></table></figure><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//ipv4地址正则</span><br><span class="line">var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;</span><br><span class="line"></span><br><span class="line">// Reg Hex颜色正则</span><br><span class="line">var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;</span><br><span class="line"></span><br><span class="line">// URL正则</span><br><span class="line">var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;</span><br><span class="line"></span><br><span class="line">// 匹配JSON格式</span><br><span class="line">var reg = /^\w+\((&#123;[^()]+&#125;)\)$/</span><br></pre></td></tr></table></figure><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 5-11位的腾讯qq号</span><br><span class="line">var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;</span><br><span class="line"></span><br><span class="line">// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线</span><br><span class="line">var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;</span><br><span class="line"></span><br><span class="line">// 国内常见</span><br><span class="line">var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;</span><br><span class="line"></span><br><span class="line">// 固定电话</span><br><span class="line">var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/;</span><br></pre></td></tr></table></figure><h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 匹配由26个英文字母组成的字符串</span><br><span class="line">var reg = /^[A-Za-z]+$/;</span><br><span class="line"></span><br><span class="line">// 匹配由26个英文字母的大写组成的字符串</span><br><span class="line">var reg = /^[A-Z]+$/;</span><br><span class="line"></span><br><span class="line">// 匹配由26个英文字母的小写组成的字符串</span><br><span class="line">var reg = /^[a-z]+$/;</span><br><span class="line"></span><br><span class="line">// 匹配由数字和26个英文字母组成的字符串</span><br><span class="line">var reg = /^[A-Za-z0-9]+$/;</span><br><span class="line"></span><br><span class="line">// 匹配由数字、26个英文字母或者下;划线组成的字符串</span><br><span class="line">var reg = /^\w+$/;</span><br><span class="line"></span><br><span class="line">// 匹配空白行的正则表达式</span><br><span class="line">var reg = /\n\s*\r/;</span><br><span class="line"></span><br><span class="line">// 匹配首尾空白字符的正则表达式</span><br><span class="line">var reg = /^\s*|\s*$/;</span><br><span class="line">var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;</span><br><span class="line"></span><br><span class="line">// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)</span><br><span class="line">var reg = /[^\x00-\xff]/g;</span><br></pre></td></tr></table></figure><h1 id="匹配特定数字"><a href="#匹配特定数字" class="headerlink" title="匹配特定数字"></a>匹配特定数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 匹配正整数</span><br><span class="line">var reg = /^[1-9]\d*$/;</span><br><span class="line"></span><br><span class="line">// 匹配负整数</span><br><span class="line">var reg = /^-[1-9]\d*$/;</span><br><span class="line"></span><br><span class="line">// 匹配整数</span><br><span class="line">var reg = /^-?[1-9]\d*$/;</span><br><span class="line"></span><br><span class="line">// 匹配非负整数（正整数 + 0）</span><br><span class="line">var reg = /^[1-9]\d*|0$/;</span><br><span class="line"></span><br><span class="line">// 匹配非正整数（负整数 + 0）</span><br><span class="line">var reg = /^-[1-9]\d*|0$/;</span><br><span class="line"></span><br><span class="line">// 匹配正浮点数</span><br><span class="line">var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;</span><br><span class="line"></span><br><span class="line">// 匹配负浮点数</span><br><span class="line">var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;</span><br><span class="line"></span><br><span class="line">// 匹配浮点数</span><br><span class="line">var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;</span><br><span class="line"></span><br><span class="line">// 匹配非负浮点数（正浮点数 + 0）</span><br><span class="line">var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;</span><br><span class="line"></span><br><span class="line">// 匹配非正浮点数（负浮点数 + 0）</span><br><span class="line">var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。
    
    </summary>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Rax，以及 Rax 的特点</title>
    <link href="https://duanruilong.github.io/2018/05/11/%E4%BB%80%E4%B9%88%E6%98%AF-Rax%EF%BC%8C%E4%BB%A5%E5%8F%8A-Rax-%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <id>https://duanruilong.github.io/2018/05/11/什么是-Rax，以及-Rax-的特点/</id>
    <published>2018-05-10T16:29:57.000Z</published>
    <updated>2018-05-10T16:54:08.145Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png" alt="Rac"></p><p>Rax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax.</p><h1 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h1><p>经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。<br>于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。</p><h1 id="Rax-与-React"><a href="#Rax-与-React" class="headerlink" title="Rax 与 React"></a>Rax 与 React</h1><p>React 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。</p><h1 id="Rax-的特点"><a href="#Rax-的特点" class="headerlink" title="Rax 的特点"></a>Rax 的特点</h1><h4 id="1、设计上支持不同容器"><a href="#1、设计上支持不同容器" class="headerlink" title="1、设计上支持不同容器"></a>1、设计上支持不同容器</h4><p>Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。</p><h4 id="2、体积足够小"><a href="#2、体积足够小" class="headerlink" title="2、体积足够小"></a>2、体积足够小</h4><p>如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。</p><h4 id="3、支持返回多个同级节点"><a href="#3、支持返回多个同级节点" class="headerlink" title="3、支持返回多个同级节点"></a>3、支持返回多个同级节点</h4><p>任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createElement, Component, render&#125; from &apos;rax&apos;;</span><br><span class="line"></span><br><span class="line">class Test extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return [1, 2, 3].map((item) =&gt; &#123;</span><br><span class="line">      return &lt;p&gt;&#123;item&#125;&lt;/p&gt;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。</p><h4 id="4、标准化"><a href="#4、标准化" class="headerlink" title="4、标准化"></a>4、标准化</h4><p>在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.<br>当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。<br>对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?<br>了解更多 Rax 相关内容，欢迎访问 <a href="alibaba.github.io/rax">alibaba.github.io/rax</a><br>来自Rax 团队敬上。<br>原文链接<a href="https://alibaba.github.io/rax/blog/whats-rax" target="_blank" rel="noopener">https://alibaba.github.io/rax/blog/whats-rax</a></p>]]></content>
    
    <summary type="html">
    
      React 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React一些路由</title>
    <link href="https://duanruilong.github.io/2018/05/08/React%E4%B8%80%E4%BA%9B%E8%B7%AF%E7%94%B1/"/>
    <id>https://duanruilong.github.io/2018/05/08/React一些路由/</id>
    <published>2018-05-08T15:44:22.000Z</published>
    <updated>2018-05-08T16:01:50.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Prompt组件"><a href="#1、Prompt组件" class="headerlink" title="1、Prompt组件"></a>1、Prompt组件</h1><blockquote><p>除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。</p></blockquote><p>它有一个必须的属性message，用于给用户提示信息。<br>基本使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。<br>基本使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt when=&#123;true&#125; message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p><hr><h1 id="2、Redirect组件"><a href="#2、Redirect组件" class="headerlink" title="2、Redirect组件"></a>2、Redirect组件</h1><blockquote><p>在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。</p></blockquote><p>Redirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。<br>基本使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&apos;/new-path&apos; /&gt;</span><br><span class="line">&lt;Route path=&apos;/new-path&apos; component=&#123;NewPage&#125;/&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure><p>Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它<br>基本使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">class Index extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;this a Index page&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;this a Other page&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Main extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            toast: false,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/index&quot;&gt;这是首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;这是其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                    &lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br><span class="line">                    &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/Router&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为重定向，所以每个路由展示界面都是other界面</span><br><span class="line"></span><br><span class="line">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p><hr><h1 id="3、Switch组件"><a href="#3、Switch组件" class="headerlink" title="3、Switch组件"></a>3、Switch组件</h1><blockquote><p>它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。</p></blockquote><p>基本使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/&quot; component=&#123;Test1&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/Test&quot; component=&#123;Test2&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></p><p>以下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">class Home extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Home&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Other&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Switchs extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Switchs test&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                    &lt;Switch&gt;</span><br><span class="line">                        &lt;Route path=&quot;/:id&quot; component=&#123;Switchs&#125;/&gt;</span><br><span class="line">                        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">                        &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class="line">                    &lt;/Switch&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/Router&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p><hr><h1 id="4、Match对象"><a href="#4、Match对象" class="headerlink" title="4、Match对象"></a>4、Match对象</h1><blockquote><p>match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。</p></blockquote><p>在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。</p><p>Match的获取方式：<br>在Route component中，组件通过this.props.match获取。<br>在Route render 和Route children中，通过传递一个参数的方式获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">以下实例：</span><br><span class="line">```hash</span><br><span class="line">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">class Match extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;id:&#123;this.props.match.params.id&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;Route path=&quot;/:id&quot; component=&#123;Match&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/Router&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//id是路径匹配参数。</span><br><span class="line">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      React路由Prompt、Redirect、match、Switch。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>记一次Hexo文章里的图片不显示问题</title>
    <link href="https://duanruilong.github.io/2018/05/06/%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E6%96%87%E7%AB%A0%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <id>https://duanruilong.github.io/2018/05/06/记一次Hexo文章里的图片不显示问题/</id>
    <published>2018-05-05T16:46:29.000Z</published>
    <updated>2018-05-10T16:57:02.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为true</p><p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p><p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p><h1 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h1><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><p><code>![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)</code><br><img src="/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png" alt="你想输入的替代文字"><br><code>![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)</code><br><img src="http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg" alt="直接给地址咋样"></p><img src="/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png" title="记一次Hexo文章里的图片不显示问题"><p>也可以直接使用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img long.png 记一次Hexo文章里的图片不显示问题 %&#125;</span><br></pre></td></tr></table></figure></p><p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p><p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>]]></content>
    
    <summary type="html">
    
      记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！
    
    </summary>
    
      <category term="Hexo" scheme="https://duanruilong.github.io/categories/Hexo/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>next主题模板一些配置</title>
    <link href="https://duanruilong.github.io/2018/05/05/next%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
    <id>https://duanruilong.github.io/2018/05/05/next主题模板一些配置/</id>
    <published>2018-05-05T13:23:49.000Z</published>
    <updated>2018-05-06T16:46:11.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-修改文章底部的那个带-号的标签"><a href="#1-修改文章底部的那个带-号的标签" class="headerlink" title="1.修改文章底部的那个带#号的标签"></a>1.修改文章底部的那个带#号的标签</h1><p>实现效果图</p><p>具体实现方法</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/themes/next/layout/_macro/post.swig</span><br><span class="line">找到 </span><br><span class="line">rel=<span class="string">"tag"</span>&gt;<span class="comment">#</span></span><br><span class="line">修改为</span><br><span class="line">&lt;i class=<span class="string">"fa fa-tag"</span>&gt;&lt;/i&gt;</span><br><span class="line">完整的应该是这样的：  &lt;a href=<span class="string">"&#123;&#123; url_for(tag.path) &#125;&#125;"</span> rel=<span class="string">"tag"</span>&gt;&lt;i class=<span class="string">"fa fa-tag"</span>&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure></code></pre><h1 id="2-在每篇文章末尾统一添加“本文结束”标记"><a href="#2-在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="2.在每篇文章末尾统一添加“本文结束”标记"></a>2.在每篇文章末尾统一添加“本文结束”标记</h1><p>实现效果图</p><p>具体实现方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后打开主题配置文件<code>（_config.yml)</code>,在末尾添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line">passage_end_tag:</span><br><span class="line">enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p><h1 id="3-修改“代码块自定义样式"><a href="#3-修改“代码块自定义样式" class="headerlink" title="3.修改“代码块自定义样式"></a>3.修改“代码块自定义样式</h1><p>具体实现方法<br>打开 <code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: <span class="comment">#ff7600;</span></span><br><span class="line">    background: <span class="comment">#fbf7f8;</span></span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid <span class="comment">#d6d6d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-侧边栏社交小图标设置"><a href="#4-侧边栏社交小图标设置" class="headerlink" title="4.侧边栏社交小图标设置"></a>4.侧边栏社交小图标设置</h1><p>具体实现方法<br>打开主题配置文件<code>（_config.yml）</code>，搜索<code>social_icons:</code>,在<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">图标库</a>找自己喜欢的小图标，并将名字复制在如下位置，保存即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 社交链接</span><br><span class="line"># Social Links</span><br><span class="line">social:</span><br><span class="line">GitHub: https://github.com/Duanruilong</span><br><span class="line">CSDN: https://github.com/Duanruilong</span><br><span class="line">微博: https://github.com/Duanruilong</span><br><span class="line">QQ: https://github.com/Duanruilong</span><br><span class="line">知乎: https://github.com/Duanruilong</span><br><span class="line"># Social Links Icons/设定链接的图标</span><br><span class="line">social_icons:</span><br><span class="line">enable: true</span><br><span class="line">icons_only: false</span><br><span class="line">transition: true</span><br><span class="line"># Icon Mappings.</span><br><span class="line"># KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">GitHub: github</span><br><span class="line">E-Mail: envelope</span><br><span class="line">Google: google</span><br><span class="line">Twitter: twitter</span><br><span class="line">Instagram: instagram</span><br><span class="line">StackOverflow: stack-overflow</span><br><span class="line">微博: weibo</span><br><span class="line">知乎: envelope</span><br><span class="line">QQ: qq</span><br><span class="line">微信: weixin</span><br><span class="line">CSDN: crosshairs</span><br><span class="line">links_title: discord</span><br></pre></td></tr></table></figure></p><h1 id="5-在网站底部加上访问量"><a href="#5-在网站底部加上访问量" class="headerlink" title="5.在网站底部加上访问量"></a>5.在网站底部加上访问量</h1><p>具体实现方法<br>打开<code>\themes\next\layout\_partials\footer.swig</code>文件,在copyright前加上这句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>然后再合适的位置添加显示统计的代码，如图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>在这里有两中不同计算方式的统计代码：</p><pre><code>1.pv的方式，单个用户连续点击n篇文章，记录n次访问量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></code></pre><p>添加之后再执行<code>hexo d -g</code>，然后再刷新页面就能看到效果</p><h1 id="6-添加热度"><a href="#6-添加热度" class="headerlink" title="6.添加热度"></a>6.添加热度</h1><p>具体实现方法<br>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code>,在画红线的区域添加<code>℃</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>,将画红框的改为热度就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">post:</span><br><span class="line">  created: 创建于</span><br><span class="line">  modified: 更新于</span><br><span class="line">  sticky: 置顶</span><br><span class="line">  posted: 发表于</span><br><span class="line">  in: 分类于</span><br><span class="line">  read_more: 阅读全文</span><br><span class="line">  untitled: 未命名</span><br><span class="line">  toc_empty: 此文章未包含目录</span><br><span class="line">  visitors: 热度</span><br><span class="line">  wordcount: 字数统计</span><br><span class="line">  min2read: 阅读时长</span><br><span class="line">  copyright:</span><br></pre></td></tr></table></figure></p><h1 id="7-网站底部字数统计"><a href="#7-网站底部字数统计" class="headerlink" title="7.网站底部字数统计"></a>7.网站底部字数统计</h1><p>具体方法实现<br>切换到根目录下，然后运行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h1 id="8-添加-README-md-文件"><a href="#8-添加-README-md-文件" class="headerlink" title="8.添加 README.md 文件"></a>8.添加 README.md 文件</h1><p>每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。</p><p>在 Hexo 目录下的 <code>source</code> 根目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure></p><p>保存退出即可。再次使用 <code>hexo d</code> 命令部署博客的时候就不会在渲染 README.md 这个文件了。</p><h1 id="9-设置网站的图标Favicon"><a href="#9-设置网站的图标Favicon" class="headerlink" title="9.设置网站的图标Favicon"></a>9.设置网站的图标Favicon</h1><p>在<a href="https://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在<code>/themes/next/source/images</code>里，并且修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Put your favicon.ico into `hexo-site/source/` directory.</span><br><span class="line">favicon: /favicon.ico</span><br></pre></td></tr></table></figure></p><h1 id="11-实现统计功能"><a href="#11-实现统计功能" class="headerlink" title="11.实现统计功能"></a>11.实现统计功能</h1><p>在根目录下安装 <code>hexo-wordcount</code>,运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在主题的配置文件中，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure></p><h1 id="12-添加顶部加载条"><a href="#12-添加顶部加载条" class="headerlink" title="12.添加顶部加载条"></a>12.添加顶部加载条</h1><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件，添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>但是，默认的是粉色的，要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .pace .pace-progress &#123;</span><br><span class="line">        background: #1E92FB; /*进度条颜色*/</span><br><span class="line">        height: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-progress-inner &#123;</span><br><span class="line">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-activity &#123;</span><br><span class="line">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class="line">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>现在升级最新版的next主题，升级后只需修改主题配置文件(<code>_config.yml</code>)将<code>pace: false</code>改为<code>pace: true</code>就行了，你还可以换不同样式的加载条.</p><h1 id="13-在文章底部增加版权信息"><a href="#13-在文章底部增加版权信息" class="headerlink" title="13.在文章底部增加版权信息"></a>13.在文章底部增加版权信息</h1><p>在目录 <code>next/layout/_macro/</code>下添加 <code>my-copyright.swig</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    var clipboard = new Clipboard(&apos;.fa-clipboard&apos;);</span><br><span class="line">    $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class="line">      clipboard.on(&apos;success&apos;, function()&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: &quot;&quot;,   </span><br><span class="line">          text: &apos;复制成功&apos;,</span><br><span class="line">          icon: &quot;success&quot;, </span><br><span class="line">          showConfirmButton: true</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改<code>next/layout/_macro/post.swig</code>，在代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &apos;wechat-subscriber.swig&apos; %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>之前添加增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &apos;my-copyright.swig&apos; %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></p><p>保存重新生成即可。<br>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：</p><p>小技巧：如果你觉得每次都要输入<code>copyright: true</code>很麻烦的话,那么在<code>/scaffolds/post.md</code>文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">description: </span><br><span class="line">copyright: </span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这样每次<code>hexo new &quot;你的内容&quot;</code>之后，生成的md文件会自动把<code>copyright:</code>加到里面去<br>(注意：如果解析出来之后，你的原始链接有问题：如：<code>http://yoursite.com/2018/05/05/next主题模板一些配置/</code>,那么在根目录下<code>_config.yml</code>中写成类似这样：）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://duanruilong.github.io/</span><br><span class="line">root: /blog</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><h1 id="14-修改网页底部的桃心"><a href="#14-修改网页底部的桃心" class="headerlink" title="14.修改网页底部的桃心"></a>14.修改网页底部的桃心</h1><p>打开<code>themes/next/layout/_partials/footer.swig</code>，找到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-&#123;&#123; theme.authoricon &#125;&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>然后还是在<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">图标库</a>中找到你自己喜欢的图标，然后修改画红线的部分就可以了。</p><h1 id="15-文章加密访问"><a href="#15-文章加密访问" class="headerlink" title="15.文章加密访问"></a>15.文章加密访问</h1><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在以下位置插入这样一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class="line">            if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class="line">                alert(&apos;密码错误！&apos;);</span><br><span class="line">                if (history.length === 1) &#123;</span><br><span class="line">                    location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    history.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>然后在文章上写成类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">description: </span><br><span class="line">copyright: </span><br><span class="line">categories:</span><br><span class="line">password: password</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="16-添加jiathis分享"><a href="#16-添加jiathis分享" class="headerlink" title="16.添加jiathis分享"></a>16.添加jiathis分享</h1><p>在主题配置文件中，jiathis为true，就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Share 分享</span><br><span class="line">jiathis: true</span><br><span class="line"># Warning: JiaThis does not support https.</span><br><span class="line">#add_this_id:</span><br></pre></td></tr></table></figure></p><p>如果你想自定义话，打开<code>themes/next/layout/_partials/share/jiathis.swig</code>修改就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JiaThis Button BEGIN --&gt;</span><br><span class="line">&lt;div class=&quot;jiathis_style&quot;&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_kaixin001&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;http://www.jiathis.com/share&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h1 id="17-博文置顶或者排序"><a href="#17-博文置顶或者排序" class="headerlink" title="17.博文置顶或者排序"></a>17.博文置顶或者排序</h1><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 第一篇blog</span><br><span class="line">date: 2018-05-04 23:38:11</span><br><span class="line">tags: 生活</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">copyright: true</span><br><span class="line">top: 12</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="18-修改字体大小"><a href="#18-修改字体大小" class="headerlink" title="18.修改字体大小"></a>18.修改字体大小</h1><p>打开<code>\themes\next\source\css\ _variables\base.styl</code>文件，将<code>$font-size-base</code>改成<code>16px</code>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$font-size-base            =16px</span><br></pre></td></tr></table></figure></p><h1 id="19-修改打赏字体不闪动"><a href="#19-修改打赏字体不闪动" class="headerlink" title="19.修改打赏字体不闪动"></a>19.修改打赏字体不闪动</h1><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 注释文字闪动函数</span><br><span class="line"> #wechat:hover p&#123;</span><br><span class="line">    animation: roll 0.1s infinite linear;</span><br><span class="line">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class="line">    -moz-animation: roll 0.1s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"> #alipay:hover p&#123;</span><br><span class="line">   animation: roll 0.1s infinite linear;</span><br><span class="line">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class="line">    -moz-animation: roll 0.1s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h1 id="20-点击爆炸效果"><a href="#20-点击爆炸效果" class="headerlink" title="20.点击爆炸效果"></a>20.点击爆炸效果</h1><p>跟那个红心是差不多的，首先在<code>themes/next/source/js/src</code>里面建一个叫f<code>ireworks.js</code>的文件，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure></p><p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.fireworks %&#125;</span><br><span class="line">   &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; </span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>打开主题配置文件，在里面最后写下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Fireworks</span><br><span class="line">fireworks: true</span><br></pre></td></tr></table></figure></p><h1 id="21-DaoVoice-在线联系"><a href="#21-DaoVoice-在线联系" class="headerlink" title="21.DaoVoice 在线联系"></a>21.DaoVoice 在线联系</h1><p>首先在 <a href="http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f" target="_blank" rel="noopener">daovoice</a> 注册账号,<a href="http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f" target="_blank" rel="noopener">邀请码</a>是<code>0f81ff2f</code>，注册完成后会得到一个 app_id :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">daovoice(&apos;init&apos;, &#123;</span><br><span class="line">  app_id: &quot;0000000&quot;</span><br><span class="line">&#125;);</span><br><span class="line">daovoice(&apos;update&apos;);</span><br></pre></td></tr></table></figure><p>记下这个 app_id的值，然后打开<code>/themes/next/layout/_partials/head.swig</code>,写下如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&apos;init&apos;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&apos;update&apos;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">```````````````````````````````````````````</span><br></pre></td></tr></table></figure></p><p><meta http-equiv="Cache-Control" content="no-transform"></p><meta http-equiv="Cache-Control" content="no-siteapp"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接着打开主题配置文件，在最后写下如下代码：</span><br><span class="line">```hash</span><br><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里填你的刚才获得的 app_id</span><br></pre></td></tr></table></figure><p>重新 <code>hexo g &amp;&amp; hexo s</code> 就能看到效果了。<br>安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式</p><h1 id="22-添加跟帖-来必力"><a href="#22-添加跟帖-来必力" class="headerlink" title="22.添加跟帖(来必力)"></a>22.添加跟帖(来必力)</h1><p>有两种实现方法：<br>①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p><p>②如果你不想更新的话，那么按下面步骤进行：<br>首先，还是在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。
    
    </summary>
    
      <category term="Hexo" scheme="https://duanruilong.github.io/categories/Hexo/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo + Github搭建个人博客详细配置</title>
    <link href="https://duanruilong.github.io/2018/05/05/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://duanruilong.github.io/2018/05/05/使用Hexo-Github搭建个人博客详细配置/</id>
    <published>2018-05-05T11:02:51.000Z</published>
    <updated>2018-05-06T16:46:38.088Z</updated>
    
    <summary type="html">
    
      开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。
    
    </summary>
    
      <category term="Hexo" scheme="https://duanruilong.github.io/categories/Hexo/"/>
    
    
      <category term="生活" scheme="https://duanruilong.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>第一篇blog</title>
    <link href="https://duanruilong.github.io/2018/05/04/%E7%AC%AC%E4%B8%80%E7%AF%87blog/"/>
    <id>https://duanruilong.github.io/2018/05/04/第一篇blog/</id>
    <published>2018-05-04T15:38:11.000Z</published>
    <updated>2018-05-08T15:47:23.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：<br><img src="/blog/images/drl.png" alt="image"></p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><a id="more"></a><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol><p>copyright —- 是不是有权限</p>]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
      <category term="随记" scheme="https://duanruilong.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="https://duanruilong.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://duanruilong.github.io/2018/05/04/hello-world/"/>
    <id>https://duanruilong.github.io/2018/05/04/hello-world/</id>
    <published>2018-05-03T16:39:03.884Z</published>
    <updated>2018-05-04T15:37:29.915Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
