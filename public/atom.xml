<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>About-龙大</title>
  
  <subtitle>不忘初心，继续前进。</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://duanruilong.github.io/"/>
  <updated>2018-12-07T08:13:17.000Z</updated>
  <id>https://duanruilong.github.io/</id>
  
  <author>
    <name>DRLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gitment使用 GitHub Issues 搭建评论系统</title>
    <link href="https://duanruilong.github.io/2018/12/07/Gitment%E4%BD%BF%E7%94%A8-GitHub-Issues-%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://duanruilong.github.io/2018/12/07/Gitment使用-GitHub-Issues-搭建评论系统/</id>
    <published>2018-12-07T07:42:06.000Z</published>
    <updated>2018-12-07T08:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png" alt="Gitment"></p><a id="more"></a><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="1-注册-OAuth-Application"><a href="#1-注册-OAuth-Application" class="headerlink" title="1. 注册 OAuth Application"></a>1. 注册 OAuth Application</h2><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href="https://imsun.net）。" target="_blank" rel="noopener">https://imsun.net）。</a></p><p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p><h2 id="2-引入-Gitment"><a href="#2-引入-Gitment" class="headerlink" title="2. 引入 Gitment"></a>2. 引入 Gitment</h2><p>将下面的代码添加到你的页面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">  id: '页面 ID', // 可选。默认为 location.href</span><br><span class="line">  owner: '你的 GitHub ID',</span><br><span class="line">  repo: '存储评论的 repo',</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    client_id: '你的 client ID',</span><br><span class="line">    client_secret: '你的 client secret',</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render('container')</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p><p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p><p><code>$ npm install --save gitment</code><br>关于构造函数中的更多可用参数请查看 Gitment Options</p><h2 id="3-初始化评论"><a href="#3-初始化评论" class="headerlink" title="3. 初始化评论"></a>3. 初始化评论</h2><p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p><p>之后其他用户即可在该页面发表评论。</p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p><p>比如你可以通过自定义主题将评论框放在评论列表前面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTheme = &#123;</span><br><span class="line">  render(state, instance) &#123;</span><br><span class="line">    const container = document.createElement('div')</span><br><span class="line">    container.lang = <span class="string">"en-US"</span></span><br><span class="line">    container.className = 'gitment-container gitment-root-container'</span><br><span class="line">    container.appendChild(instance.renderHeader(state, instance))</span><br><span class="line">    container.appendChild(instance.renderEditor(state, instance))</span><br><span class="line">    container.appendChild(instance.renderComments(state, instance))</span><br><span class="line">    container.appendChild(instance.renderFooter(state, instance))</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  theme: myTheme,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render('container')</span><br></pre></td></tr></table></figure><p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize" target="_blank" rel="noopener">文档</a>。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>语言问题<br>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png&quot; alt=&quot;Gitment&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="https://duanruilong.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件" scheme="https://duanruilong.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React16新特性来认识一波</title>
    <link href="https://duanruilong.github.io/2018/11/29/React16%E6%96%B0%E7%89%B9%E6%80%A7%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E6%B3%A2/"/>
    <id>https://duanruilong.github.io/2018/11/29/React16新特性来认识一波/</id>
    <published>2018-11-29T10:34:52.000Z</published>
    <updated>2018-12-13T08:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>React的16版本，采用了MIT开源许可证,React16新特性来认识一波。</p><ul><li><code>Fragments</code>：render函数可以返回数组和字符串</li><li><code>error boundaries</code>：错误处理</li><li><code>portals</code> ：支持声明性地将子树渲染到另一个DOM节点</li><li><code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</li><li><code>improved server-side rendering</code>:提升服务端渲染性能</li><li>支持自定义DOM属性</li><li>setState传入null时不会再触发更新</li><li>更好的服务器端渲染</li><li>新的打包策略</li></ul><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png" alt="React"></p><a id="more"></a><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h1 id="1、render可以return数组-，字符串"><a href="#1、render可以return数组-，字符串" class="headerlink" title="1、render可以return数组 ，字符串"></a>1、render可以return数组 ，字符串</h1><p> React16新增加了render的返回格式，你可以return返回<code>string，number，boolean，null，portal，以及fragments(带有key属性的数组)</code>，且不需要外层包含div标签。不过需要添加对应的key值。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string</span></span><br><span class="line">render()&#123;</span><br><span class="line">    return 'Hello,world'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//number</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0123456789</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> isTrue ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fragments，遇到控制台出现warning,是未加key标识符，</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &lt;div&gt;Hello&lt;/div&gt;,</span><br><span class="line">        &lt;span&gt;world&lt;/span&gt;,</span><br><span class="line">        &lt;p&gt;DRL&lt;/p&gt;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、error-boundaries错误处理"><a href="#2、error-boundaries错误处理" class="headerlink" title="2、error boundaries错误处理"></a>2、error boundaries错误处理</h1><p>React16新增加了抛异常的生命周期函数<code>componentDidCatch</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(err,info)&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;isError:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为<code>try-catch</code></p><p> 在容易出错的组件外使用ErrorBoundary将它包裹起来:</p> <figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from 'react'</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="title">extends</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; hasError: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidCatch(err, info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; hasError: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.hasError)&#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;div&gt;Something wrong!&lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ErrorBoundary&gt;</span><br><span class="line">                &lt;Listview user=&#123;<span class="keyword">this</span>.state.data&#125; /&gt;</span><br><span class="line">            &lt;/ErrorBoundary&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.onClickChange&#125;&gt;toUpdate&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Listview组件发生错误，将会使用ErrorBoundary提供的<code>&lt;div&gt;Something went wrong&lt;/div&gt;</code>代替它，不会引起整个组件树的卸载。</p><h1 id="3、portals支持声明性地将子树渲染到另一个DOM节点"><a href="#3、portals支持声明性地将子树渲染到另一个DOM节点" class="headerlink" title="3、portals支持声明性地将子树渲染到另一个DOM节点"></a>3、<code>portals</code>支持声明性地将子树渲染到另一个DOM节点</h1><p>Portals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个简易蒙层效果，抽象出一个通用的Overlay组件</span></span><br><span class="line">import React, &#123; Component &#125; from 'react';</span><br><span class="line">import ReactDOM from 'react-dom';</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Overlay</span> <span class="title">extends</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.container = document.createElement('div');</span><br><span class="line">        document.body.appendChild(<span class="keyword">this</span>.container);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        document.body.removeChild(<span class="keyword">this</span>.container);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">            &lt;div className='overlay'&gt;</span><br><span class="line">                &lt;span className='overlay-close' onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;/div&gt;,</span><br><span class="line">            <span class="keyword">this</span>.container</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该组件对应的样式如下</span></span><br><span class="line">.overlay&#123;</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top:<span class="number">50</span>%;</span><br><span class="line">    left:<span class="number">50</span>%;</span><br><span class="line">    width:<span class="number">260</span>px;</span><br><span class="line">    height:<span class="number">200</span>px;</span><br><span class="line">    margin-left:<span class="number">-130</span>px;</span><br><span class="line">    margin-top:<span class="number">-100</span>px;</span><br><span class="line">    padding:<span class="number">10</span>px;</span><br><span class="line">    background-color: <span class="meta">#fff;</span></span><br><span class="line">    outline: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>) solid <span class="number">9999</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.overlay-close&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top:<span class="number">10</span>px;</span><br><span class="line">    right:<span class="number">10</span>px;</span><br><span class="line">    color:red;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用方式如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      overlayActive: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.closeOverlay = <span class="keyword">this</span>.closeOverlay.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.showOverlay = <span class="keyword">this</span>.showOverlay.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  closeOverlay() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; overlayActive: <span class="literal">false</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  showOverlay() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; overlayActive: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;div&gt;hello world!&lt;/div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.overlayActive &amp;&amp;</span><br><span class="line">          &lt;Overlay onClose=&#123;<span class="keyword">this</span>.closeOverlay&#125;&gt;overlay content&lt;/Overlay&gt;&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.showOverlay&#125;&gt;show&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、custom-DOM-attributes-：ReactDom允许传递非标准属性"><a href="#4、custom-DOM-attributes-：ReactDom允许传递非标准属性" class="headerlink" title="4、custom DOM attributes ：ReactDom允许传递非标准属性"></a>4、<code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</h1><h1 id="5、-improved-server-side-rendering-提升服务端渲染性能"><a href="#5、-improved-server-side-rendering-提升服务端渲染性能" class="headerlink" title="5、 improved server-side rendering:提升服务端渲染性能"></a>5、 <code>improved server-side rendering</code>:提升服务端渲染性能</h1><h1 id="6、-支持自定义DOM属性"><a href="#6、-支持自定义DOM属性" class="headerlink" title="6、 支持自定义DOM属性"></a>6、 支持自定义DOM属性</h1><h1 id="7、-setState传入null时不会再触发更新"><a href="#7、-setState传入null时不会再触发更新" class="headerlink" title="7、 setState传入null时不会再触发更新"></a>7、 setState传入null时不会再触发更新</h1><h1 id="8、-更好的服务器端渲染"><a href="#8、-更好的服务器端渲染" class="headerlink" title="8、 更好的服务器端渲染"></a>8、 更好的服务器端渲染</h1><h1 id="9、-新的打包策略"><a href="#9、-新的打包策略" class="headerlink" title="9、 新的打包策略"></a>9、 新的打包策略</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React的16版本，采用了MIT开源许可证,React16新特性来认识一波。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fragments&lt;/code&gt;：render函数可以返回数组和字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error boundaries&lt;/code&gt;：错误处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;portals&lt;/code&gt; ：支持声明性地将子树渲染到另一个DOM节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;custom DOM attributes&lt;/code&gt; ：ReactDom允许传递非标准属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;improved server-side rendering&lt;/code&gt;:提升服务端渲染性能&lt;/li&gt;
&lt;li&gt;支持自定义DOM属性&lt;/li&gt;
&lt;li&gt;setState传入null时不会再触发更新&lt;/li&gt;
&lt;li&gt;更好的服务器端渲染&lt;/li&gt;
&lt;li&gt;新的打包策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript: 什么是纯函数以及为什么要用纯函数</title>
    <link href="https://duanruilong.github.io/2018/11/11/JavaScript-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>https://duanruilong.github.io/2018/11/11/JavaScript-什么是纯函数以及为什么要用纯函数/</id>
    <published>2018-11-11T09:57:25.000Z</published>
    <updated>2018-11-11T10:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？</p><p>除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png" alt="js"></p><a id="more"></a><h1 id="什么函数是纯"><a href="#什么函数是纯" class="headerlink" title="什么函数是纯"></a>什么函数是纯</h1><p>纯函数的定义是：</p><ul><li><p>1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p></li><li><p>2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</p></li></ul><p>这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。</p><p>在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。</p><h1 id="什么是可观察的副作用"><a href="#什么是可观察的副作用" class="headerlink" title="什么是可观察的副作用"></a>什么是可观察的副作用</h1><p>一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。</p><p>注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。</p><p>副作用来自，但不限于：</p><ul><li><p>进行一个 HTTP 请求</p></li><li><p>Mutating data</p></li><li><p>输出数据到屏幕或者控制台</p></li><li><p>DOM 查询/操作</p></li><li><p>Math.random()</p></li><li><p>获取的当前时间</p></li></ul><p>副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。</p><p>不过首先，让我们来看一些纯的和不纯的函数对比的例子……</p><h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">priceAfterTax</span><span class="params">(productPrice)</span> </span>&#123; <span class="keyword">return</span> (productPrice * <span class="number">0.20</span>) + productPrice;&#125;</span><br></pre></td></tr></table></figure></p><p>它符合我们所说的两条纯函数的定义。<code>不依赖于任何外部输入，不改变任何外部数据、没有副作用</code>。</p><p>即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。</p><h1 id="非纯函数"><a href="#非纯函数" class="headerlink" title="非纯函数"></a>非纯函数</h1><p>我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tax = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">calculateTax</span><span class="params">(productPrice)</span> </span>&#123; <span class="keyword">return</span> (productPrice * (tax/<span class="number">100</span>)) + productPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暂停片刻，看看你是否能看出为什么这个函数不纯。</p><p>其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。</p><h1 id="为什么说纯函数在-JavaScript-很重要"><a href="#为什么说纯函数在-JavaScript-很重要" class="headerlink" title="为什么说纯函数在 JavaScript 很重要"></a>为什么说纯函数在 JavaScript 很重要</h1><p>纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。</p><p>不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。</p><p>并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。</p><h1 id="可测试性和重构"><a href="#可测试性和重构" class="headerlink" title="可测试性和重构"></a>可测试性和重构</h1><p>另一个使用纯函数的原因是测试以及重构。</p><p>使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。</p><p>同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）</p><p><code>正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。</code></p><p>此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">Wiki</a>。同时也推荐阅读 <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html" target="_blank" rel="noopener">开发建议手册</a> 以及 <a href="https://toddmotto.com/pure-versus-impure-functions" target="_blank" rel="noopener">纯函数 vs. 非纯函数</a>.</p><p>原文链接： medium.com</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？&lt;/p&gt;
&lt;p&gt;除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在PHP里很好的使用ImageMagick---convert篇</title>
    <link href="https://duanruilong.github.io/2018/09/18/%E5%9C%A8PHP%E9%87%8C%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BD%BF%E7%94%A8ImageMagick-convert%E7%AF%87/"/>
    <id>https://duanruilong.github.io/2018/09/18/在PHP里很好的使用ImageMagick-convert篇/</id>
    <published>2018-09-17T16:15:54.000Z</published>
    <updated>2018-09-18T14:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>ImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是—-convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg" alt="PHP"></p><a id="more"></a><h1 id="基本命令与格式"><a href="#基本命令与格式" class="headerlink" title="基本命令与格式"></a>基本命令与格式</h1><h2 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h2><ul><li><code>magick:</code> 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。</li><li><code>convert:</code> 等同于 magick 命令。</li><li><code>identify:</code> 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。</li><li><code>mogrify:</code> 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。</li><li><code>composite:</code> 将一个图片或多个图片组合成新图片。</li><li><p><code>montage:</code> 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。</p></li><li><p><code>compare:</code> 从数学和视觉角度比较源图像与重建图像之间的差异。</p></li><li><code>display:</code>在任何 X server 上显示一个图像或图像序列。</li><li><code>animate:</code> 在任何 X server 上显示图像序列。</li><li><code>import:</code> 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。</li><li><code>conjure:</code>解释并执行 MSL ( Magick Scripting Language ) 写的脚本。</li><li><code>stream:</code> 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。</li></ul><h2 id="2、命令格式"><a href="#2、命令格式" class="headerlink" title="2、命令格式"></a>2、命令格式</h2><p>基本命令的使用，遵循 Unix 风格的标准格式，例如  <code>command [options] input_image output_image</code></p><blockquote><p>将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert -resize <span class="number">200</span>x200 goods.png goods.jpg</span><br></pre></td></tr></table></figure><hr><h1 id="开始绘制生成图片"><a href="#开始绘制生成图片" class="headerlink" title="开始绘制生成图片"></a>开始绘制生成图片</h1><h2 id="一些前期参数"><a href="#一些前期参数" class="headerlink" title="一些前期参数"></a>一些前期参数</h2><h3 id="1、入参"><a href="#1、入参" class="headerlink" title="1、入参"></a>1、入参</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';</span><br><span class="line">$item_title='测试字体';</span><br><span class="line">$shop_title='测试店铺';</span><br><span class="line">$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';</span><br><span class="line">$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';</span><br><span class="line">$numid_share='0000000';</span><br><span class="line">$qr_title='长按识别二维码';</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对宝贝标题裁剪</span></span><br><span class="line">$drawtitone=mb_substr($item_title,0,13, 'utf-8');</span><br><span class="line">$drawtittow=mb_substr($item_title,13,13, 'utf-8');</span><br><span class="line">$drawtitthree=mb_substr($item_title,26,13, 'utf-8');</span><br><span class="line">$time_date = time(); <span class="comment">// 时间戳</span></span><br><span class="line">$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径----&gt;指定一个文件夹保存生成图片过程里的图片</span><br></pre></td></tr></table></figure><h3 id="2、先下载素材文件"><a href="#2、先下载素材文件" class="headerlink" title="2、先下载素材文件"></a>2、先下载素材文件</h3><p>我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$item_img_down = $workDir<span class="number">.'</span>/itemimage.jpg';</span><br><span class="line">$shop_img_down = $workDir<span class="number">.'</span>/shopimage.jpg';</span><br><span class="line">$qr_img_down = $workDir<span class="number">.'</span>/qrimage.jpg';</span><br><span class="line"><span class="comment">// 下载宝贝主图</span></span><br><span class="line">\NetworkUtils::curlDownload($item_img, $item_img_down);</span><br><span class="line"><span class="comment">// 下载店铺图片</span></span><br><span class="line">\NetworkUtils::curlDownload($shop_img, $shop_img_down);</span><br><span class="line"><span class="comment">// 下载二维码</span></span><br><span class="line">\NetworkUtils::curlDownload($qr_img, $qr_img_down);</span><br></pre></td></tr></table></figure></p><p><code>\NetworkUtils::curlDownload($item_img, $item_img_down);</code> 下载<code>$item_img</code>保存在目标路径文件夹下的<code>$workDir.&#39;/itemimage.jpg&#39;</code>路径。</p><h3 id="3、指定字体和颜色"><a href="#3、指定字体和颜色" class="headerlink" title="3、指定字体和颜色"></a>3、指定字体和颜色</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';</span><br><span class="line">$fontColor = '#333333';</span><br><span class="line">$fontColor_shoptitle = '#999999';</span><br><span class="line">$fontColor_qrtitlt = '#666666';</span><br></pre></td></tr></table></figure><h3 id="4、创建一个底图"><a href="#4、创建一个底图" class="headerlink" title="4、创建一个底图"></a>4、创建一个底图</h3><p>创建一个<code>750x1046</code>白色的底图，我们可以在上面绘制文字</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个底图(并且加上一些文字)</span></span><br><span class="line"></span><br><span class="line">$back_img=$workDir<span class="number">.'</span>/bg.jpg'; <span class="comment">//要生成的图片的路径----&gt;可以在服务器端看到</span></span><br><span class="line">$back_cmds=<span class="string">"convert 'xc:[750x1046!]' -background white -font &#123;$fontFamily&#125; -draw 'text 580,994 \"&#123;$qr_title&#125;\"' -fill \"&#123;$fontColor_qrtitlt&#125;\" </span></span><br><span class="line"><span class="string">            -pointsize 20 -draw 'text 114,990 \"&#123;$shop_title&#125;\"' -font &#123;$fontFamily&#125; -pointsize 22 -fill '#999999' &#123;$workDir&#125;/bg.jpg"</span>;</span><br><span class="line">$result_back_cmds = \SystemCommon::runningCmd($back_cmds);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。<br><code>-font {$fontFamily} -draw &#39;text 580,994 \&quot;{$qr_title}\&quot;&#39; -fill \&quot;{$fontColor_qrtitlt}\&quot; -pointsize 20</code></p></blockquote><p>解释一下：</p><ul><li><code>xc:[100x40!]</code>: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !</li><li><code>-fill &#39;rgba(0, 0, 0, 0)&#39;</code>：设置了文本的填充颜色</li><li><code>text 114,990</code>: 对文字进行定位</li><li><code>-font</code>：指定字体</li><li><code>-pointsize</code>：指定文本的字体大小</li><li><code>-draw</code>：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )</li></ul><p>继续添加文字：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$back_img_shoptitle=$workDir<span class="number">.'</span>/btitle.jpg'; <span class="comment">//要生成的图片的路径</span></span><br><span class="line">$back_cmds_shoptitle=<span class="string">"convert -draw 'text 40,820 \"&#123;$drawtitone&#125;\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\" -draw 'text 40,866 \"&#123;$drawtittow&#125;\"' </span></span><br><span class="line"><span class="string">                    -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\" -draw 'text 40,912 \"&#123;$drawtitthree&#125;\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \"&#123;$fontColor&#125;\"  </span></span><br><span class="line"><span class="string">                    &#123;$back_img&#125; &#123;$workDir&#125;/btitle.jpg"</span>;</span><br><span class="line">$result_back_cmds_shoptitle = \SystemCommon::runningCmd($back_cmds_shoptitle);</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_6.png" alt="convert"></p><h3 id="5、拼接图片"><a href="#5、拼接图片" class="headerlink" title="5、拼接图片"></a>5、拼接图片</h3><p>现在就可以在之前得到的图片上拼接所需要的图片了</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 在底图上合并商品主图</span></span><br><span class="line">$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg';  //要生成的图片的路径</span><br><span class="line">$geometryX = <span class="string">"+"</span> . <span class="number">0</span>; <span class="comment">// 定位</span></span><br><span class="line">$geometryY = <span class="string">"+"</span> . <span class="number">0</span>; <span class="comment">// 定位</span></span><br><span class="line">$customPicPos = <span class="string">"northwest"</span>;</span><br><span class="line">$back_cmds_itemimg = <span class="string">"convert &#123;$back_img_shoptitle&#125; &#123;$workDir&#125;/item_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryX&#125;&#123;$geometryY&#125; </span></span><br><span class="line"><span class="string">                    -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result.jpg"</span>;</span><br><span class="line">$result_back_cmds_itemimg = \SystemCommon::runningCmd($back_cmds_itemimg);</span><br></pre></td></tr></table></figure><p>解释一下：</p><ul><li><code>-geometry</code>: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写</li><li><code>composite</code>: 将一个图片或多个图片组合成新图片。</li></ul><p>这里是把<code>{$workDir}/item_img_mag.jpg</code>路径的图片绘制到之前绘制文字的图片上<code>$back_img_shoptitle</code>，最终得到的图片保存路径是在<code>{$workDir}/result.jpg</code></p><p>让我们继续操作图片</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并二维码 </span></span><br><span class="line">$geometryXshop = <span class="string">"+"</span> . <span class="number">40</span>;</span><br><span class="line">$geometryYshop = <span class="string">"+"</span> . <span class="number">950</span>;</span><br><span class="line">$back_cmds_shopimg = <span class="string">"convert &#123;$workDir&#125;/result.jpg &#123;$workDir&#125;/shop_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXshop&#125;&#123;$geometryYshop&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result1.jpg"</span>;</span><br><span class="line">$result_back_cmds_shopimg = \SystemCommon::runningCmd($back_cmds_shopimg);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并店铺图标</span></span><br><span class="line">$geometryXqr = <span class="string">"+"</span> . <span class="number">520</span>;</span><br><span class="line">$geometryYqr = <span class="string">"+"</span> . <span class="number">784</span>;</span><br><span class="line">$back_cmds_qrimg = <span class="string">"convert &#123;$workDir&#125;/result1.jpg &#123;$workDir&#125;/qr_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXqr&#125;&#123;$geometryYqr&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result2.jpg"</span>;</span><br><span class="line">$result_back_cmds_qrimg = \SystemCommon::runningCmd($back_cmds_qrimg);</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_7.png" alt="convert"></p><p>发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。</p><h3 id="6、放大拼接图片尺寸"><a href="#6、放大拼接图片尺寸" class="headerlink" title="6、放大拼接图片尺寸"></a>6、放大拼接图片尺寸</h3><p>需要对多拼接的图片都进行操作</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 看来需要先放大主图</span></span><br><span class="line">$item_img_m=<span class="string">"convert -resize '750x766!' &#123;$item_img_down&#125; &#123;$workDir&#125;/item_img_mag.jpg"</span>;</span><br><span class="line">$item_img_mag = \SystemCommon::runningCmd($item_img_m);  </span><br><span class="line"><span class="comment">// 看来需要先放大二维码</span></span><br><span class="line">$shop_img_m=<span class="string">"convert -resize 64x64 &#123;$shop_img_down&#125; &#123;$workDir&#125;/shop_img_mag.jpg"</span>;</span><br><span class="line">$shop_img_mag = \SystemCommon::runningCmd($shop_img_m);  </span><br><span class="line"><span class="comment">// 看来需要先放大店铺图标</span></span><br><span class="line">$qr_img_m=<span class="string">"convert -resize 200x200 &#123;$qr_img_down&#125; &#123;$workDir&#125;/qr_img_mag.jpg"</span>;</span><br><span class="line">$qr_img_mag = \SystemCommon::runningCmd($qr_img_m);</span><br></pre></td></tr></table></figure><blockquote><p>-resize 延伸解读</p></blockquote><p> IamgeMagick 提供了几种符号来定义缩放</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">convert -resize '150x100!' goods.jpg thumbnail.jpg</span><br><span class="line"></span><br><span class="line">convert -resize '150x100&gt;' goods.jpg thumbnail.jpg</span><br><span class="line"></span><br><span class="line">convert -resize '150x100&lt;' goods.jpg thumbnail.jpg</span><br></pre></td></tr></table></figure><ul><li><code>!</code>：不管图片宽高如何，都缩放成 150x100 这样的尺寸。</li><li><code>&gt;</code>：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。</li><li><code>&lt;</code>：与 &gt; 功能相反</li></ul><p>缩放对比</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_1.png" alt="convert"></p><p>这样的结果也不是我们需要的<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_4.png" alt="convert"></p><p>只有<code>convert -resize &#39;750x766!&#39; {$item_img_down} {$workDir}/item_img_mag.jpg</code>这样固定尺寸之后可以得到：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_5.png" alt="convert"></p><h3 id="7、图片转换为-base64格式"><a href="#7、图片转换为-base64格式" class="headerlink" title="7、图片转换为 base64格式"></a>7、图片转换为 base64格式</h3><p>我们最后同样的以base64格式输出给前端</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in">stdout</span> = trim($result_back_cmds_qrimg[<span class="string">"stdout"</span>]);</span><br><span class="line">$Return = <span class="built_in">array</span>();</span><br><span class="line"><span class="keyword">if</span> (empty($<span class="built_in">stdout</span>) || strpos($result_back_cmds_qrimg[<span class="string">"stderr"</span>], <span class="string">"identify"</span>) != <span class="literal">false</span>) &#123;  <span class="comment">// runningCmd执行成功</span></span><br><span class="line">    $dest_img = $workDir<span class="number">.'</span>/result2.jpg';</span><br><span class="line">    <span class="comment">// /*图片转换为 base64格式编码*/</span></span><br><span class="line">    $base64_image = '';</span><br><span class="line">    $image_info = getimagesize($dest_img);</span><br><span class="line">    $image_data = fread(fopen($dest_img, <span class="string">'r'</span>), filesize($dest_img));</span><br><span class="line">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class="line"></span><br><span class="line">    $Return['data']=$base64_image;</span><br><span class="line">    $Return['dest_img']=$dest_img;</span><br><span class="line">    $Return['type']='success';</span><br><span class="line">    $Return['msg']=1;</span><br><span class="line">    <span class="keyword">return</span> $Return;</span><br><span class="line">&#125;</span><br><span class="line">$Return['data']='';</span><br><span class="line">$Return['msg']=2;</span><br><span class="line"><span class="keyword">return</span> $Return;</span><br></pre></td></tr></table></figure><p><code>$workDir.&#39;/result2.jpg</code>是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。</p><p>（小姐姐拼接图）<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_8.png" alt="convert"></p><p>这次<code>convert命令</code>的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。</p><p>欢迎光顾个人<a href="https://duanruilong.github.io/blog">Blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是—-convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg&quot; alt=&quot;PHP&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://duanruilong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="PHP" scheme="https://duanruilong.github.io/tags/PHP/"/>
    
      <category term="后端" scheme="https://duanruilong.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在PHP里使用ImageMagick生成base64图片</title>
    <link href="https://duanruilong.github.io/2018/09/05/%E5%9C%A8PHP%E9%87%8C%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BD%BF%E7%94%A8ImageMagick/"/>
    <id>https://duanruilong.github.io/2018/09/05/在PHP里很好的使用ImageMagick/</id>
    <published>2018-09-04T16:08:37.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg" alt="PHP"></p><a id="more"></a><blockquote><p>一些需要的知识点</p></blockquote><h1 id="PHP将图片转base64编码以及base64图片转换为图片并保存代码"><a href="#PHP将图片转base64编码以及base64图片转换为图片并保存代码" class="headerlink" title="PHP将图片转base64编码以及base64图片转换为图片并保存代码"></a>PHP将图片转base64编码以及base64图片转换为图片并保存代码</h1><h2 id="图片转base64编码"><a href="#图片转base64编码" class="headerlink" title="图片转base64编码"></a>图片转base64编码</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*图片转换为 base64格式编码*/</span></span><br><span class="line">$img = 'uploads/about.png';</span><br><span class="line">$base64_img = base64EncodeImage($img);</span><br><span class="line">echo '&lt;img src="' . $base64_img . '" /&gt;';</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">base64EncodeImage</span> <span class="params">($image_file)</span> </span>&#123;</span><br><span class="line">    $base64_image = '';</span><br><span class="line">    $image_info = getimagesize($image_file);</span><br><span class="line">    $image_data = fread(fopen($image_file, <span class="string">'r'</span>), filesize($image_file));</span><br><span class="line">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class="line">    <span class="keyword">return</span> $base64_image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="base64图片转换为图片并保存"><a href="#base64图片转换为图片并保存" class="headerlink" title="base64图片转换为图片并保存"></a>base64图片转换为图片并保存</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  base64格式编码转换为图片并保存对应文件夹 */</span></span><br><span class="line"><span class="function">function <span class="title">base64_image_content</span><span class="params">($base64_image_content,$path)</span></span>&#123;</span><br><span class="line">    <span class="comment">//匹配出图片的格式</span></span><br><span class="line">    if (preg_match('/^(data:\s*image\/(\w+);base64,)/', $base64_image_content, $result))&#123;</span><br><span class="line">        $type = $result[<span class="number">2</span>];</span><br><span class="line">        $new_file = $path."/".date('Ymd',time())."/";</span><br><span class="line">        <span class="keyword">if</span>(!file_exists($new_file))&#123;</span><br><span class="line">            <span class="comment">//检查是否有该文件夹，如果没有就创建，并给予最高权限</span></span><br><span class="line">            mkdir($new_file, <span class="number">0700</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        $new_file = $new_file.time().<span class="string">".&#123;$type&#125;"</span>;</span><br><span class="line">        if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content))))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'/'</span>.$new_file;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">echo <span class="title">base64_image_content</span><span class="params">($base64_img,<span class="string">"uploads/"</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。<br>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p><p><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code><br>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit</p><p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p><p>使用jpg图片体积要比png小<br>使用PHP的Imagick类进行图像的操作</p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><h2 id="1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片"><a href="#1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片" class="headerlink" title="(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片"></a>(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个画板</span></span><br><span class="line">        $img =<span class="keyword">new</span> Imagick();</span><br><span class="line">        $img-&gt;newImage(750,1046,'white','jpg') ;</span><br></pre></td></tr></table></figure><h2 id="2-在底图上添加需求图片"><a href="#2-在底图上添加需求图片" class="headerlink" title="(2).在底图上添加需求图片"></a>(2).在底图上添加需求图片</h2><p>前提是我们已经知道了需要合并的图片链接地址<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'</span><br><span class="line"></span><br><span class="line">第一步：实例化图片</span><br><span class="line">$imgtwo = <span class="keyword">new</span> Imagick($item_img);</span><br><span class="line"></span><br><span class="line">第二步：设置添加图片的大小</span><br><span class="line">$imgtwo-&gt;resizeImage(<span class="number">750</span>,<span class="number">764</span>,Imagick::FILTER_LANCZOS,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">关于resizeImage参数说明</span><br><span class="line">    <span class="keyword">bool</span> Imagick::resizeImage ( <span class="keyword">int</span> $columns , <span class="keyword">int</span> $rows , <span class="keyword">int</span> $filter , <span class="keyword">float</span> $blur [, <span class="keyword">bool</span> $bestfit = <span class="literal">false</span> ] )</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">  ● columns 图片的宽度</span><br><span class="line">  ● rows 图片高度</span><br><span class="line">  ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定</span><br><span class="line">  ● blur blur=<span class="number">1</span> 为虚化， blur =<span class="number">-1</span> 为锐化</span><br><span class="line"></span><br><span class="line">第三步：与底图合并</span><br><span class="line">$img-&gt;compositeImage($imgtwo,$imgtwo-&gt;getImageCompose(),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">使用compositeImage();</span><br><span class="line">    <span class="keyword">bool</span> Imagick::compositeImage ( Imagick $composite_object , <span class="keyword">int</span> $composite , <span class="keyword">int</span> $x , <span class="keyword">int</span> $y [, <span class="keyword">int</span> $channel = Imagick::CHANNEL_ALL ] )</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">  ● composite_object ：用于合并的图片的Imagick对象</span><br><span class="line">  ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表</span><br><span class="line">  ● x：相对图像顶点左上位置（<span class="number">0</span>,<span class="number">0</span>）的横坐标</span><br><span class="line">  ● y：相对图像顶点左上位置（<span class="number">0</span>,<span class="number">0</span>）的纵坐标</span><br><span class="line">  ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。</span><br><span class="line"></span><br><span class="line">到这里就可以得到一个合并的图片了</span><br><span class="line"><span class="number">1</span>、加一个header信息，可以直接在网页上查看图片</span><br><span class="line">    header(<span class="string">"Content-Type: img/png"</span>);</span><br><span class="line">    echo $img;</span><br><span class="line"><span class="number">2</span>、可以把图片在指定目录中生成，在指定目录下生成为img.png</span><br><span class="line">$file=<span class="string">"./img.png"</span>;</span><br><span class="line">$img-&gt;writeImage($file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我这里是这样处理：</span><br><span class="line">    header ( 'Content-type: ' . strtolower ($img-&gt;getImageFormat ()) );</span><br><span class="line">    $type = strtolower($img-&gt;getImageFormat());</span><br><span class="line">    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type;    //要生成的图片的路径，随机生成图片名称</span><br></pre></td></tr></table></figure></p><h2 id="3-图片上拼接文字"><a href="#3-图片上拼接文字" class="headerlink" title="(3).图片上拼接文字"></a>(3).图片上拼接文字</h2><p>写入文字以添加店铺文字为例，逐步完成文字的写入。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$shop_title='测试店铺'；</span><br><span class="line"><span class="comment">// 添加店铺文字</span></span><br><span class="line">$drawQr = <span class="keyword">new</span> ImagickDraw(); <span class="comment">// 实例化ImagickDraw</span></span><br><span class="line">$drawQr -&gt; setFillColor(new ImagickPixel('#999999')); // 颜色</span><br><span class="line">$drawQr -&gt; setFontSize('24'); // 大小</span><br><span class="line">$drawQr -&gt; setFont('../../conf/Microsoftyahei.ttf'); // 字体</span><br><span class="line">$drawQr -&gt; setTextAlignment(Imagick::ALIGN_LEFT); <span class="comment">// 字体方向</span></span><br><span class="line"><span class="comment">// ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</span></span><br><span class="line">$drawQr -&gt; setTextEncoding(<span class="string">"utf-8"</span>); <span class="comment">// 字体编码</span></span><br><span class="line">$drawQr -&gt; annotation(<span class="number">114</span>,<span class="number">990</span>,$shop_title); <span class="comment">// 画出文字</span></span><br><span class="line">$img -&gt; drawImage($drawQr);  <span class="comment">// 画在地板上</span></span><br></pre></td></tr></table></figure></p><p>详细解读：</p><ul><li>1、实例化ImagickDraw类：<br> <code>$drawQr = new ImagickDraw();</code> </li><li>2、设置字体颜色<br><code>$drawQr -&gt; setFillColor(new ImagickPixel(&#39;#999999&#39;));</code></li><li>3、设置字体大小<br><code>$drawQr -&gt; setFontSize(&#39;24&#39;);</code></li><li>4、设置字体格式<br><code>$drawQr -&gt; setFont(&#39;../../conf/Microsoftyahei.ttf&#39;);</code></li><li>5、设置字体方向<br><code>$draw-&gt;setTextAlignment(Imagick::ALIGN_RIGHT);</code><blockquote><p>ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</p></blockquote></li><li>6、设置字体编码<br><code>$drawQr -&gt; setTextEncoding(&quot;utf-8&quot;);</code></li><li>7、画出文字<br><code>$drawQr -&gt; annotation(114,990,$shop_title);</code></li><li>8、在底图上写入字体<br><code>$img -&gt; drawImage($drawQr);</code></li></ul><p>写入文字这个地方的一些坑：</p><p>没有设置字体格式时，中文字会解析错误<br>（英文没有问题）<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_1.png" alt="PHP"></p><p>（汉字解析失败）</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_2.png" alt="PHP"></p><p>(设置字体格式正常显示)</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_3.png" alt="PHP"></p><h2 id="4-图片base64导出"><a href="#4-图片base64导出" class="headerlink" title="(4).图片base64导出"></a>(4).图片base64导出</h2><p>最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径</span><br><span class="line">$Return = <span class="built_in">array</span>();</span><br><span class="line"><span class="comment">// *图片转换为 base64格式编码*</span></span><br><span class="line">$base64_image = '';</span><br><span class="line">$image_info = getimagesize($dest_img);</span><br><span class="line">$image_data = fread(fopen($dest_img, <span class="string">'r'</span>), filesize($dest_img));</span><br><span class="line">$base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class="line">$Return['data']=$base64_image;</span><br><span class="line"><span class="keyword">return</span>  $Return;</span><br></pre></td></tr></table></figure></p><p><code>$base64_image</code>就是base64格式的图片。</p><p>需要注意的是前端得到的额base64数据里包含有<code>&#39;\r\n&#39;</code>回车字符，需要特殊处理才可以正确显示图片。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_4.png" alt="PHP"></p><p>（最后得到的合并图片）</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_5.png" alt="PHP"></p><p>(调整拼接图片大小得到不同的图片)<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_6.png" alt="PHP"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg&quot; alt=&quot;PHP&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://duanruilong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="PHP" scheme="https://duanruilong.github.io/tags/PHP/"/>
    
      <category term="后端" scheme="https://duanruilong.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(七)</title>
    <link href="https://duanruilong.github.io/2018/08/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%B8%83/"/>
    <id>https://duanruilong.github.io/2018/08/08/小程序之旅-七/</id>
    <published>2018-08-08T15:56:51.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><p>这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex 阮一峰</a></p><h1 id="Num1"><a href="#Num1" class="headerlink" title="Num1"></a>Num1</h1><p>简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。</p><p>list.wxml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/<span class="built_in">list</span>/<span class="built_in">list</span>.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">box</span>"&gt;</span></span><br><span class="line"><span class="class"> &lt;text class="list_header"&gt;每日一看&lt;/text&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="list" wx:for="&#123;&#123;list&#125;&#125;"&gt;</span></span><br><span class="line"><span class="class">    &lt;view class='list_img'&gt;</span></span><br><span class="line"><span class="class">      &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="class">    &lt;/view&gt;</span></span><br><span class="line"><span class="class">    &lt;view class='list_main'&gt;</span></span><br><span class="line">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>list.wxss<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pages/list/list.wxss */</span></span><br><span class="line"><span class="comment">/*整个容器*/</span></span><br><span class="line">.box&#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: column;<span class="comment">/*竖直排列*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*title文字*/</span></span><br><span class="line">.list_header&#123;</span><br><span class="line">font-size: <span class="number">32</span>rpx;</span><br><span class="line">font-weight: bold;</span><br><span class="line">color: #<span class="number">444</span>;</span><br><span class="line">padding:<span class="number">20</span>rpx;</span><br><span class="line">border-bottom: <span class="number">2</span>rpx solid <span class="meta">#ccc;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*列表项容器*/</span></span><br><span class="line">.<span class="built_in">list</span>&#123;</span><br><span class="line">display:flex;</span><br><span class="line">flex-direction: row;<span class="comment">/*横向排列*/</span></span><br><span class="line">align-content: center;</span><br><span class="line">border-bottom:<span class="number">1</span>rpx solid <span class="meta">#ccc;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图片容器*/</span></span><br><span class="line">.list_img&#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-content: center;</span><br><span class="line">padding:<span class="number">20</span>rpx <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*图片*/</span></span><br><span class="line">.avatar&#123;</span><br><span class="line">width:<span class="number">130</span>rpx;</span><br><span class="line">height:<span class="number">130</span>rpx;</span><br><span class="line">border-radius: <span class="number">4</span>rpx;</span><br><span class="line">border: <span class="number">1</span>rpx solid #F2F2F2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*文字容器，包含标题和内容*/</span></span><br><span class="line">.list_main&#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: column;<span class="comment">/*文字竖直排列*/</span></span><br><span class="line">align-content: center;</span><br><span class="line">padding:<span class="number">40</span>rpx <span class="number">20</span>rpx;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.list_title&#123;</span><br><span class="line">font-size: <span class="number">28</span>rpx;</span><br><span class="line">color: #<span class="number">717171</span>;</span><br><span class="line">font-weight: bold;</span><br><span class="line">padding-bottom: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line">.list_content&#123;</span><br><span class="line">font-size: <span class="number">24</span>rpx;</span><br><span class="line">color: #<span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>list.js里的数据先写成假数据。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/list/list.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="built_in">list</span>:[&#123;</span><br><span class="line">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class="line">      title: '美丽的大海啊！',</span><br><span class="line">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class="line">        title: '回不去的那叫从前',</span><br><span class="line">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class="line">        title: '森林生存恐怖游戏',</span><br><span class="line">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class="line">      &#125;,</span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>（也可以使用本地node服务）<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var fs = require('fs');</span><br><span class="line">var app = express();</span><br><span class="line"><span class="comment">//处理静态资源</span></span><br><span class="line">app.use(express.static('./'));</span><br><span class="line">app.get('/list', function (req, res) &#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        code: <span class="number">200</span>,</span><br><span class="line">        data: [&#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class="line">                title: '美丽的大海啊！',</span><br><span class="line">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class="line">                title: '回不去的那叫从前',</span><br><span class="line">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class="line">                title: '森林生存恐怖游戏',</span><br><span class="line">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">9999</span>); <span class="comment">//监听端口</span></span><br></pre></td></tr></table></figure></p><h1 id="Num2"><a href="#Num2" class="headerlink" title="Num2"></a>Num2</h1><p>接下来是img在头部，下方是文字内容。</p><p>list.wxml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">box</span>"&gt;</span></span><br><span class="line"><span class="class"> &lt;text class="list_header"&gt;每日一看&lt;/text&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="list" wx:for="&#123;&#123;list&#125;&#125;"&gt;</span></span><br><span class="line"><span class="class">    &lt;view class='list_img'&gt;</span></span><br><span class="line"><span class="class">      &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="class">    &lt;/view&gt;</span></span><br><span class="line"><span class="class">    &lt;view class='list_main'&gt;</span></span><br><span class="line">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class="line">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>list.wxss<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pages/listview/listview.wxss */</span></span><br><span class="line"><span class="comment">/*整个容器*/</span></span><br><span class="line">.box&#123;</span><br><span class="line">display: flex;</span><br><span class="line">background: <span class="meta">#ccc;</span></span><br><span class="line">flex-direction: column;<span class="comment">/*竖直排列*/</span></span><br><span class="line">align-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*列表项容器*/</span></span><br><span class="line">.<span class="built_in">list</span>&#123;</span><br><span class="line">background: #FFF;</span><br><span class="line">display:flex;</span><br><span class="line">flex-direction: column;<span class="comment">/*竖直排列*/</span></span><br><span class="line">align-content: center;</span><br><span class="line">width:<span class="number">90</span>%;</span><br><span class="line">margin:<span class="number">20</span>rpx <span class="keyword">auto</span>;<span class="comment">/*居中对齐*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图片容器*/</span></span><br><span class="line">.list_img&#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-content: center;</span><br><span class="line">width:<span class="number">100</span>%;</span><br><span class="line">padding:<span class="number">20</span>rpx <span class="number">0</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*图片*/</span></span><br><span class="line">.avatar&#123;</span><br><span class="line">width:<span class="number">100</span>%;</span><br><span class="line">height:<span class="number">400</span>rpx;</span><br><span class="line">border-radius: <span class="number">4</span>rpx;</span><br><span class="line">border: <span class="number">1</span>rpx solid #F2F2F2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*文字容器，包含标题和内容*/</span></span><br><span class="line">.list_main&#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: column;<span class="comment">/*文字竖直排列*/</span></span><br><span class="line">align-content: center;</span><br><span class="line">padding:<span class="number">20</span>rpx;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.list_title&#123;</span><br><span class="line">font-size: <span class="number">28</span>rpx;</span><br><span class="line">color: #<span class="number">717171</span>;</span><br><span class="line">font-weight: bold;</span><br><span class="line">padding-bottom: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line">.list_address&#123;</span><br><span class="line">font-size: <span class="number">24</span>rpx;</span><br><span class="line">color: #<span class="number">717171</span>;</span><br><span class="line">font-weight: bold;</span><br><span class="line">padding-bottom: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line">.list_content&#123;</span><br><span class="line">font-size: <span class="number">24</span>rpx;</span><br><span class="line">color: #<span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>list.js里的数据先写成假数据。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/list/list.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="built_in">list</span>:[&#123;</span><br><span class="line">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class="line">      title: '美丽的大海啊！',</span><br><span class="line">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class="line">        title: '回不去的那叫从前',</span><br><span class="line">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class="line">        title: '森林生存恐怖游戏',</span><br><span class="line">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class="line">      &#125;,</span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>（也可以使用本地node服务）<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var fs = require('fs');</span><br><span class="line">var app = express();</span><br><span class="line"><span class="comment">//处理静态资源</span></span><br><span class="line">app.use(express.static('./'));</span><br><span class="line">app.get('/list', function (req, res) &#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        code: <span class="number">200</span>,</span><br><span class="line">        data: [&#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class="line">                title: '美丽的大海啊！',</span><br><span class="line">                address: '1美丽的大海啊！',</span><br><span class="line">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class="line">                title: '回不去的那叫从前',</span><br><span class="line">                address: '1回不去的那叫从前',</span><br><span class="line">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class="line">                title: '森林生存恐怖游戏',</span><br><span class="line">                address: '1森林生存恐怖游戏',</span><br><span class="line">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">9999</span>); <span class="comment">//监听端口</span></span><br></pre></td></tr></table></figure></p><h1 id="Num3"><a href="#Num3" class="headerlink" title="Num3"></a>Num3</h1><p>上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。</p><p>主要点：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>.json配置:</span><br><span class="line"></span><br><span class="line"><span class="string">"enablePullDownRefresh"</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">需要捕获这两个事件：</span><br><span class="line"></span><br><span class="line">onReachBottom（滚动到底部事件）</span><br><span class="line">onPullDownRefresh（下拉刷新事件）</span><br></pre></td></tr></table></figure></p><p>本地服务：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var fs = require('fs');</span><br><span class="line">var app = express();</span><br><span class="line"><span class="comment">//处理静态资源</span></span><br><span class="line">app.use(express.static('./'));</span><br><span class="line">app.get('/list/:num',function(req,res)&#123;</span><br><span class="line">var num = req.params.num;<span class="comment">//页码</span></span><br><span class="line">var arr = [];</span><br><span class="line">(function()&#123;</span><br><span class="line"><span class="keyword">for</span>(var i=(num*<span class="number">5</span><span class="number">-5</span>);i&lt;(num*<span class="number">5</span>);i++)&#123;</span><br><span class="line">var obj = &#123;id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'&#125;;</span><br><span class="line">arr.push(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">res.send(&#123;</span><br><span class="line">code: <span class="number">200</span>,</span><br><span class="line">page:num,</span><br><span class="line">data: arr</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">9999</span>);<span class="comment">//监听端口</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class="line"></span><br><span class="line">&lt;loading hidden=<span class="string">"&#123;&#123;isLoading&#125;&#125;"</span>&gt;加载中...&lt;/loading&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;view class=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;isRefesh&#125;&#125;"</span>&gt;</span><br><span class="line">   &lt;icon type='waiting' size='45'&gt;&lt;/icon&gt;</span><br><span class="line">   &lt;text&gt;刷新中...&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">list</span>" <span class="title">wx</span>:</span><span class="keyword">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> id=<span class="string">"&#123;&#123;page&#125;&#125;"</span>&gt;</span><br><span class="line">    &lt;view class='list_img'&gt;</span><br><span class="line">      &lt;image src="&#123;&#123;item.img&#125;&#125;" class='avatar'&gt;&lt;/image&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;view <span class="class"><span class="keyword">class</span>='<span class="title">list_main</span>'&gt;</span></span><br><span class="line">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class="line">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- listview.json --&gt;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"enablePullDownRefresh"</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/listview/listview.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="built_in">list</span>: [],<span class="comment">//列表项数据</span></span><br><span class="line">    page: <span class="number">1</span>,<span class="comment">//页码</span></span><br><span class="line">    isRefesh: <span class="literal">false</span>,<span class="comment">//是否刷新</span></span><br><span class="line">    isLoading: <span class="literal">true</span><span class="comment">//正在加载</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//下拉刷新</span></span><br><span class="line">  onPullDownRefresh: function () &#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    that.setData(&#123; isRefesh: <span class="literal">true</span> &#125;);<span class="comment">//刷新条出现</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: 'http://localhost:9999/list/1',</span><br><span class="line">      method: 'GET',</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        var listdata = res.data.data;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          wx.stopPullDownRefresh;<span class="comment">//停止下拉刷新效果</span></span><br><span class="line">          that.setData(&#123; page: <span class="number">1</span> &#125;);<span class="comment">//重置页码</span></span><br><span class="line">          that.setData(&#123; <span class="built_in">list</span>: listdata, isRefesh: <span class="literal">false</span> &#125;);<span class="comment">//重新设置列表项和刷新条消失</span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//滑到底部加载</span></span><br><span class="line">  onReachBottom: function () &#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    var page = that.data.page + <span class="number">1</span>;</span><br><span class="line">    var oldData = <span class="keyword">this</span>.data.<span class="built_in">list</span>;<span class="comment">//老数据</span></span><br><span class="line">    that.setData(&#123; isLoading: <span class="literal">false</span> &#125;);<span class="comment">//loading出现</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: 'http://localhost:9999/list/' + page,</span><br><span class="line">      method: 'GET',</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        var allData = [];</span><br><span class="line">        var listdata = res.data.data;<span class="comment">//新数据</span></span><br><span class="line">        allData = oldData.concat(listdata);<span class="comment">//老数据和新数据合并</span></span><br><span class="line">        that.setData(&#123; <span class="built_in">list</span>: allData, page: page &#125;);<span class="comment">//重新设置列表项和页码</span></span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          that.setData(&#123; isLoading: <span class="literal">true</span> &#125;);<span class="comment">//loading消失</span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//页码初始化</span></span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    that.setData(&#123; isLoading: <span class="literal">false</span> &#125;);<span class="comment">//loading出现</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: 'http://localhost:9999/list/1',</span><br><span class="line">      method: 'GET',</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        var listdata = res.data.data;</span><br><span class="line">        that.setData(&#123; <span class="built_in">list</span>: listdata &#125;);</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          that.setData(&#123; isLoading: <span class="literal">true</span> &#125;);<span class="comment">//loading消失</span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端小笔记本</title>
    <link href="https://duanruilong.github.io/2018/08/01/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    <id>https://duanruilong.github.io/2018/08/01/前端小笔记本/</id>
    <published>2018-07-31T16:09:43.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png" alt="js"></p><a id="more"></a><h1 id="Node环境起一个服务"><a href="#Node环境起一个服务" class="headerlink" title="Node环境起一个服务"></a>Node环境起一个服务</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要安装NodeJS环境</p><ul><li><p>1、安装Express<br><code>npm install express -g</code><br><code>npm install express-generator -g</code></p></li><li><p>2、初始化项目<br>新建项目<br><code>express 项目名称</code></p></li></ul><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  Weichat express serverDmo</span><br><span class="line"></span><br><span class="line">  warning: the <span class="keyword">default</span> view engine will <span class="keyword">not</span> be jade in future releases</span><br><span class="line">  warning: use `--view=jade' <span class="keyword">or</span> `--help' <span class="keyword">for</span> additional options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   create : serverDmo/</span><br><span class="line">   create : serverDmo/<span class="keyword">public</span>/</span><br><span class="line">   create : serverDmo/<span class="keyword">public</span>/javascripts/</span><br><span class="line">   create : serverDmo/<span class="keyword">public</span>/images/</span><br><span class="line">   create : serverDmo/<span class="keyword">public</span>/stylesheets/</span><br><span class="line">   create : serverDmo/<span class="keyword">public</span>/stylesheets/style.css</span><br><span class="line">   create : serverDmo/routes/</span><br><span class="line">   create : serverDmo/routes/index.js</span><br><span class="line">   create : serverDmo/routes/users.js</span><br><span class="line">   create : serverDmo/views/</span><br><span class="line">   create : serverDmo/views/error.jade</span><br><span class="line">   create : serverDmo/views/index.jade</span><br><span class="line">   create : serverDmo/views/layout.jade</span><br><span class="line">   create : serverDmo/app.js</span><br><span class="line">   create : serverDmo/package.json</span><br><span class="line">   create : serverDmo/bin/</span><br><span class="line">   create : serverDmo/bin/www</span><br><span class="line"></span><br><span class="line">   change directory:</span><br><span class="line">     $ cd serverDmo</span><br><span class="line"></span><br><span class="line">   install dependencies:</span><br><span class="line">     $ npm install</span><br><span class="line"></span><br><span class="line">   run the app:</span><br><span class="line">     $ DEBUG=serverdmo:* npm start</span><br></pre></td></tr></table></figure><p>目录介绍：<br>/bin:用来启动应用（服务器）<br>/public: 存放静态资源目录<br>/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。<br>/views: 模板文件所在目录 文件格式为.jade<br>目录app.js程序main文件 这个是服务器启动的入口</p><h2 id="首先启动服务器"><a href="#首先启动服务器" class="headerlink" title="首先启动服务器"></a>首先启动服务器</h2><p><code>npm start //启动服务器</code></p><p>在浏览器中访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>打开app.js 这里介绍下主要代码<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> var express = require('express');</span><br><span class="line"> var path = require('path');</span><br><span class="line"> var favicon = require('serve-favicon');</span><br><span class="line"> var logger = require('morgan');</span><br><span class="line"> var cookieParser = require('cookie-parser');</span><br><span class="line"> var bodyParser = require('body-parser');</span><br><span class="line"></span><br><span class="line"> var app = express();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///=======路由信息 （接口地址）开始 存放在./routes目录下===========//</span></span><br><span class="line"> var routes = require('./routes/index');//home page接口</span><br><span class="line"> var users = require('./routes/users'); //用户接口</span><br><span class="line"></span><br><span class="line"> app.use(<span class="string">'/'</span>, routes); <span class="comment">//在app中注册routes该接口 </span></span><br><span class="line"> app.use('/users', users);//在app中注册users接口</span><br><span class="line"><span class="comment">///=======路由信息 （接口地址 介绍===========//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///=======模板 开始===========//</span></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line"> app.set('views', path.join(__dirname, 'views'));</span><br><span class="line"> app.set('view engine', 'jade');</span><br><span class="line"><span class="comment">///=======模板 结束===========//</span></span><br><span class="line"></span><br><span class="line">当我们在浏览器中 访问 http:<span class="comment">//localhost:3000/ 调用的就是index中的接口</span></span><br><span class="line">我们打开index.js就可以看到该接口的定义：</span><br><span class="line">var express = require('express');</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个get请求 path为根目录</span></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, function(req, res, next) &#123;</span><br><span class="line"> res.render('index', &#123; title: 'Express' &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><p>定义一个路由的基本格式为：<br><code>app.METHOD(PATH, HANDLER)</code><br>其中：<br>app 是 express 的实例。<br>METHOD是 HTTP 请求方法。<br>PATH 是服务器上的路径。<br>HANDLER 是在路由匹配时执行的函数。<br>以上的定义代表</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://duanruilong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(六)</title>
    <link href="https://duanruilong.github.io/2018/07/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E5%85%AD/"/>
    <id>https://duanruilong.github.io/2018/07/31/小程序之旅-六/</id>
    <published>2018-07-31T15:32:25.000Z</published>
    <updated>2018-09-18T12:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><p>有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。<br>那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的<code>wx.uploadFile(obj)</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br><span class="line">npm install formidable</span><br></pre></td></tr></table></figure><p>Node-server文件</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line"><span class="comment">//处理post需要引入这个中间件,处理的是form-data</span></span><br><span class="line">var formidable = require('formidable');</span><br><span class="line">var fs = require('fs');</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理静态资源</span></span><br><span class="line">app.use(express.static('./'));</span><br><span class="line"><span class="comment">// 处理post的form-data 类型</span></span><br><span class="line"></span><br><span class="line">app.post('/postformdata',function (req,res) &#123;</span><br><span class="line">    var form = <span class="keyword">new</span> formidable.IncomingForm(); <span class="comment">// 输入流</span></span><br><span class="line">    form.encoding = 'utf-8';</span><br><span class="line">    form.uploadDir = 'upload'; //这里设置上传目录</span><br><span class="line">    form.parse(req,function(err,fields,files)&#123; <span class="comment">// 这里解析请求</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            res.send(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        var avatarName = Date.now() + '.jpg'; // 以时间作为名字</span><br><span class="line">        var newPath = form.uploadDir + avatarName;</span><br><span class="line">        fs.renameSync(files.my_upload.path,newPath); <span class="comment">// my_upload是前端设置的name，把图片储存下来并且重新命名</span></span><br><span class="line">        res.send(&#123;</span><br><span class="line">            code:<span class="number">200</span>,</span><br><span class="line">            path:'http:localhost:9998/'+newPath</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">9998</span>); <span class="comment">// 监听端口</span></span><br></pre></td></tr></table></figure><h1 id="Num-1"><a href="#Num-1" class="headerlink" title="Num 1"></a>Num 1</h1><blockquote><p>第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。</p></blockquote><p>在upload文件目录下操作</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/upload/upload.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>='<span class="title">container</span>'&gt;</span></span><br><span class="line"><span class="class">  &lt;button type='primary' bindtap='uploadImg'&gt;上传图片&lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;view class="imginfo" wx:for="&#123;&#123;imglist&#125;&#125;" wx:for-index="id" wx:for-item="item"&gt;</span></span><br><span class="line"><span class="class">      &lt;image src='&#123;&#123;item&#125;&#125;' bindtap='previewImg' data-imgid="&#123;&#123;id&#125;&#125;" class='myimg'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="class">    &lt;/view&gt;</span></span><br><span class="line"><span class="class">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* pages/upload/upload.wxss */</span></span><br><span class="line">.imginfo&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.myimg&#123;</span><br><span class="line">  width: <span class="number">70</span>px;</span><br><span class="line">  height: <span class="number">70</span>px;</span><br><span class="line">  border:<span class="number">1</span>px solid <span class="meta">#ccc;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/upload/upload.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    imgList:[] <span class="comment">// 图片列表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上传图片</span></span><br><span class="line">  uploadImg:function()&#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    wx.chooseImage(&#123;</span><br><span class="line">      success: function(res) &#123;</span><br><span class="line">        var tempFilePaths = res.tempFilePaths;</span><br><span class="line">        wx.uploadFile(&#123;</span><br><span class="line">          url: 'http://localhost:9998/postformdata', //nodeJS数据接口</span><br><span class="line">          filePath: tempFilePaths[<span class="number">0</span>],</span><br><span class="line">          name: 'my_upload',//这个前后台名称需要保持一致，别乱写。</span><br><span class="line">          formData: &#123;</span><br><span class="line">            'user': 'test'</span><br><span class="line">          &#125;,</span><br><span class="line">          success:function(res)&#123;</span><br><span class="line">            var data = JSON.parse(res.data);<span class="comment">//返回来的是字符串格式。</span></span><br><span class="line">            var arr = that.data.imgList;</span><br><span class="line">            arr.push(data.path);</span><br><span class="line">            that.setData(&#123; imgList: arr &#125;);<span class="comment">//只有这种方式才能更新视图</span></span><br><span class="line">            console.<span class="built_in">log</span>(that.data.imgList);</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              title: '文件上传成功',</span><br><span class="line">              icon: 'success',</span><br><span class="line">              duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//预览图片</span></span><br><span class="line">  previewImg: function (e) &#123;</span><br><span class="line">    var index = e.target.dataset.imgid;<span class="comment">//获取图片的id</span></span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    console.<span class="built_in">log</span>(index);</span><br><span class="line">    wx.previewImage(&#123;</span><br><span class="line">      current: that.data.imgList[index],<span class="comment">//当前的图片</span></span><br><span class="line">      urls: that.data.imgList <span class="comment">// 需要预览的图片http链接列表</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>以上就是不要的步骤。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>开发小锦囊</title>
    <link href="https://duanruilong.github.io/2018/07/30/%E5%BC%80%E5%8F%91%E5%B0%8F%E9%94%A6%E5%9B%8A/"/>
    <id>https://duanruilong.github.io/2018/07/30/开发小锦囊/</id>
    <published>2018-07-29T16:30:40.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png" alt="js"></p><a id="more"></a><div class="note danger"><p><code>JavaScript</code> </p></div># JavaScript## 1、js 判断字符串中是否包含某个字符串> String对象的方法方法一: indexOf()   (推荐)undefined方法二: search() undefined 方法三:match()undefined > RegExp 对象方法方法四:test() undefined 方法五:exec()undefined## 2、 JS中every()和some()的用法> every()与some()方法都是JS中数组的迭代方法。every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。undefined## 3、 用Set为数组去重undefined## 4、 删除数组尾部元素一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。undefined## 5、 平铺多维数组使用Spread操作，可以很容易去平铺嵌套多维数组：  undefined可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。undefined## 6、 格式化JSON代码JSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。undefined## 7、 await多个async函数在使用async/await的时候，可以使用Promise.all来await多个async函数。undefined## 8、JSON对象和JSON数组添加删除元素undefined***<div class="note primary"><p><code>React</code> </p></div><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><hr><h2 id="1、-关于this-setState更新的问题"><a href="#1、-关于this-setState更新的问题" class="headerlink" title="1、 关于this.setState更新的问题"></a>1、 关于this.setState更新的问题</h2><p>this.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法:</p><p>1.回调函数callback<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  val: <span class="keyword">this</span>.state.val+<span class="number">1</span></span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">this</span>.state.val)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.componentDidUpdate</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate()&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.state.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新</p><p>3.将this.setState放入setTimeout函数中<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let self = <span class="keyword">this</span>;</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  self.setState(&#123;</span><br><span class="line">    val:self.state.val+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  console.<span class="built_in">log</span>(self.state.val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。</p><hr><div class="note warning"><p><code>PHP</code> </p></div><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="php-字符串中是否包含指定字符串的多种方法"><a href="#php-字符串中是否包含指定字符串的多种方法" class="headerlink" title="php 字符串中是否包含指定字符串的多种方法"></a>php 字符串中是否包含指定字符串的多种方法</h2><h3 id="1-strstr"><a href="#1-strstr" class="headerlink" title="1. strstr"></a>1. strstr</h3><p>strstr() 函数搜索一个字符串在另一个字符串中的第一次出现。<br>该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。</p><p>代码如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> <span class="comment">/*如手册上的举例*/</span></span><br><span class="line"> $email = 'user@example.com';</span><br><span class="line"> $domain = <span class="built_in">strstr</span>($email, <span class="string">'@'</span>);</span><br><span class="line"> echo $domain;</span><br><span class="line"> <span class="comment">// prints @example.com</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-stristr"><a href="#2-stristr" class="headerlink" title="2. stristr"></a>2. stristr</h3><p>stristr() 函数查找字符串在另一个字符串中第一次出现的位置。<br>如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。</p><p>它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写.</p><h3 id="3-strpos"><a href="#3-strpos" class="headerlink" title="3. strpos"></a>3. strpos</h3><p>strpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好.</p><p>实例1<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(strpos('www.jb51.net','jb51') !== false)&#123; </span><br><span class="line"> echo '包含jb51'; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> echo '不包含jb51'; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例2<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str= 'abc';</span><br><span class="line">$needle= <span class="string">'a'</span>;</span><br><span class="line">$pos = strpos($str, $needle); <span class="comment">// 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False</span></span><br></pre></td></tr></table></figure></p><h3 id="4-explode"><a href="#4-explode" class="headerlink" title="4. explode"></a>4. explode</h3><p>用explode进行判断PHP判断字符串的包含代码如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">checkstr</span><span class="params">($str)</span></span>&#123;</span><br><span class="line"> $needle =<span class="string">'a'</span>;<span class="comment">//判断是否包含a这个字符</span></span><br><span class="line"> $tmparray = explode($needle,$str);</span><br><span class="line"> <span class="keyword">if</span>(count($tmparray)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5、substr例如我们需要判断最后一个字符是不是制定字符"><a href="#5、substr例如我们需要判断最后一个字符是不是制定字符" class="headerlink" title="5、substr例如我们需要判断最后一个字符是不是制定字符"></a>5、substr例如我们需要判断最后一个字符是不是制定字符</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$str1="&lt;p&gt;这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll&lt;/p&gt;";</span></span><br><span class="line"><span class="comment">if(substr($str1,-8)==".dll&lt;/p&gt;")&#123;</span></span><br><span class="line"><span class="comment">echo substr($str1,0,-4);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6、substr-count统计“子字符串”在“原始字符串中出现的次数”"><a href="#6、substr-count统计“子字符串”在“原始字符串中出现的次数”" class="headerlink" title="6、substr_count统计“子字符串”在“原始字符串中出现的次数”"></a>6、substr_count统计“子字符串”在“原始字符串中出现的次数”</h3><p>substr_count()函数本是一个小字符串在一个大字符串中出现的次数：<br>$number = substr_count(big_string, small_string);<br>正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle；</p><p>查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">check_str</span><span class="params">($str, $substr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> $nums=substr_count($str,$substr);</span><br><span class="line">  <span class="keyword">if</span> ($nums&gt;=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="php中数组和字符串的相互转换"><a href="#php中数组和字符串的相互转换" class="headerlink" title="php中数组和字符串的相互转换"></a>php中数组和字符串的相互转换</h2><p>数组转字符串：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implode(<span class="string">'!'</span>, $arr);<span class="comment">//将一维数组以！分隔组合成一个字符串，参数一可以为""</span></span><br></pre></td></tr></table></figure></p><p>字符串转数组：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explode(<span class="string">'!'</span>, $str);<span class="comment">//将字符串以!分割为一个一维数组,参数一不可以为""</span></span><br><span class="line"></span><br><span class="line">str_split($str, <span class="number">3</span>);<span class="comment">//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="php的strpos-函数判断字符串中是否包含某字符串的方法"><a href="#php的strpos-函数判断字符串中是否包含某字符串的方法" class="headerlink" title="php的strpos() 函数判断字符串中是否包含某字符串的方法"></a>php的strpos() 函数判断字符串中是否包含某字符串的方法</h2><p>判断某字符串中是否包含某字符串的方法<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(strpos('www.idc-gz.com','idc-gz') !== false)&#123;</span><br><span class="line">    echo '包含';</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    echo '不包含';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="PHP中实现中文字串截取无乱码的方法"><a href="#PHP中实现中文字串截取无乱码的方法" class="headerlink" title="PHP中实现中文字串截取无乱码的方法"></a>PHP中实现中文字串截取无乱码的方法</h2><p>在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。</p><p>直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用mbstring扩展库的mb_substr截取就不会出现乱码了。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、自己书写截取函数，但效率不如用mbstring扩展库来得高。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果仅是为了输出截取的串，可用如下方式实现：substr($str, <span class="number">0</span>, <span class="number">30</span>).chr(<span class="number">0</span>)。</span><br></pre></td></tr></table></figure></p><p>=============================</p><p>substr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。<br>举个例子：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class="line">?&gt;</span><br><span class="line">输出：这样一来我的字</span><br><span class="line">&lt;?php</span><br><span class="line">echo mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class="line">?&gt;</span><br><span class="line">输出：这样一</span><br><span class="line">从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://duanruilong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>怎样在JS里尽量少写for循环</title>
    <link href="https://duanruilong.github.io/2018/07/29/%E6%80%8E%E6%A0%B7%E5%9C%A8JS%E9%87%8C%E5%B0%BD%E9%87%8F%E5%B0%91%E5%86%99for%E5%BE%AA%E7%8E%AF/"/>
    <id>https://duanruilong.github.io/2018/07/29/怎样在JS里尽量少写for循环/</id>
    <published>2018-07-29T15:39:15.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>“很多场景，for来的更直接，更明了。”  “最喜欢for循环了。想break就break。可能会多数据的还是for循环。” “for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响”,这是很多时候都会考虑的问题。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png" alt="js"></p><a id="more"></a><h1 id="用好-filter，map，和其它-ES6-新增的高阶遍历函数"><a href="#用好-filter，map，和其它-ES6-新增的高阶遍历函数" class="headerlink" title="用好 filter，map，和其它 ES6 新增的高阶遍历函数"></a>用好 filter，map，和其它 ES6 新增的高阶遍历函数</h1><p>问题一： 将数组中的空值去除<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrContainsEmptyVal = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, undefined, null, <span class="number">0</span>, <span class="string">""</span>];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compact = arr =&gt; arr.filter(Boolean);</span><br></pre></td></tr></table></figure></p><p>问题二： 将数组中的 VIP 用户余额加 10<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; username: <span class="string">"Kelly"</span>, isVIP: <span class="literal">true</span>, balance: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; username: <span class="string">"Tom"</span>, isVIP: <span class="literal">false</span>, balance: <span class="number">19</span> &#125;,</span><br><span class="line">  &#123; username: <span class="string">"Stephanie"</span>, isVIP: <span class="literal">true</span>, balance: <span class="number">30</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">users.<span class="built_in">map</span>(</span><br><span class="line">  user =&gt; (user.isVIP ? &#123; ...user, balance: user.balance + <span class="number">10</span> &#125; : user)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。</span><br></pre></td></tr></table></figure></p><p>问题三： 判断字符串中是否含有元音字母<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStr = <span class="string">"hdjrwqpi"</span>;</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isVowel = <span class="keyword">char</span> =&gt; [<span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"o"</span>, <span class="string">"i"</span>, <span class="string">"u"</span>].includes(<span class="keyword">char</span>);</span><br><span class="line"><span class="keyword">const</span> containsVowel = str =&gt; [...str].some(isVowel);</span><br><span class="line"></span><br><span class="line">containsVowel(randomStr);</span><br></pre></td></tr></table></figure></p><p>问题四： 判断用户是否全部是成年人<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; name: <span class="string">"Jim"</span>, age: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Lily"</span>, age: <span class="number">17</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Will"</span>, age: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">users.every(user =&gt; user.age &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure></p><p>问题五： 找出上面用户中的未成年人<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; name: <span class="string">"Jim"</span>, age: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Lily"</span>, age: <span class="number">17</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Will"</span>, age: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findTeen = users =&gt; users.find(user =&gt; user.age &lt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">findTeen(users);</span><br></pre></td></tr></table></figure></p><p>问题六： 将数组中重复项清除<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> dupArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uniq = arr =&gt; [...<span class="keyword">new</span> Set(arr)];</span><br><span class="line"></span><br><span class="line">uniq(dupArr);</span><br></pre></td></tr></table></figure></p><p>问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：</span><br><span class="line"><span class="keyword">const</span> genNumArr = (length, limit) =&gt;</span><br><span class="line">  Array.from(&#123; length &#125;, _ =&gt; Math.<span class="built_in">floor</span>(Math.random() * limit));</span><br><span class="line"></span><br><span class="line">genNumArr(<span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><h1 id="理解和熟练使用-reduce"><a href="#理解和熟练使用-reduce" class="headerlink" title="理解和熟练使用 reduce"></a>理解和熟练使用 reduce</h1><p>问题一： 不借助原生高阶函数，定义 reduce<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：</span><br><span class="line"><span class="keyword">const</span> reduce = (f, acc, arr) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) <span class="keyword">return</span> acc;</span><br><span class="line">  <span class="keyword">const</span> [head, ...tail] = arr;</span><br><span class="line">  <span class="keyword">return</span> reduce(f, f(head, acc), tail);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>问题二： 将多层数组转换成一层数组<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = arr =&gt;</span><br><span class="line">  arr.reduce(</span><br><span class="line">    (flat, next) =&gt; flat.concat(Array.isArray(next) ? flatten(next) : next),</span><br><span class="line">    []</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><p>问题三：将下面数组转成对象，key/value 对应里层数组的两个值<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> objLikeArr = [[<span class="string">"name"</span>, <span class="string">"Jim"</span>], [<span class="string">"age"</span>, <span class="number">18</span>], [<span class="string">"single"</span>, <span class="literal">true</span>]];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fromPairs = pairs =&gt;</span><br><span class="line">  pairs.reduce((res, pair) =&gt; ((res[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>]), res), &#123;&#125;);</span><br><span class="line"></span><br><span class="line">fromPairs(objLikeArr);</span><br></pre></td></tr></table></figure></p><p>问题四： 取出对象中的深层属性<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepAttr = &#123; a: &#123; b: &#123; c: <span class="number">15</span> &#125; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluckDeep = path =&gt; obj =&gt;</span><br><span class="line">  path.split(<span class="string">"."</span>).reduce((val, attr) =&gt; val[attr], obj);</span><br><span class="line"></span><br><span class="line">pluckDeep(<span class="string">"a.b.c"</span>)(deepAttr);</span><br></pre></td></tr></table></figure></p><p>问题五：将用户中的男性和女性分别放到不同的数组里：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; name: <span class="string">"Adam"</span>, age: <span class="number">30</span>, sex: <span class="string">"male"</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Helen"</span>, age: <span class="number">27</span>, sex: <span class="string">"female"</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Amy"</span>, age: <span class="number">25</span>, sex: <span class="string">"female"</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">"Anthony"</span>, age: <span class="number">23</span>, sex: <span class="string">"male"</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partition = (arr, isValid) =&gt;</span><br><span class="line">  arr.reduce(</span><br><span class="line">    ([pass, fail], elem) =&gt;</span><br><span class="line">      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],</span><br><span class="line">    [[], []],</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> isMale = person =&gt; person.sex === <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [maleUser, femaleUser] = partition(users, isMale);</span><br></pre></td></tr></table></figure></p><p>问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> unfold = (f, seed) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> go = (f, seed, acc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = f(seed);</span><br><span class="line">    <span class="keyword">return</span> res ? go(f, res[<span class="number">1</span>], acc.concat(res[<span class="number">0</span>])) : acc;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> go(f, seed, []);</span><br><span class="line">&#125;;</span><br><span class="line">根据这个 unfold 函数，定义一个 Python 里面的 range 函数。</span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> range = (min, max, step = <span class="number">1</span>) =&gt;</span><br><span class="line">  unfold(x =&gt; x &lt; max &amp;&amp; [x, x + step], min);</span><br></pre></td></tr></table></figure><h1 id="用递归代替循环（可以break！）"><a href="#用递归代替循环（可以break！）" class="headerlink" title="用递归代替循环（可以break！）"></a>用递归代替循环（可以break！）</h1><p>问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> num2 = [<span class="number">43</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">67</span>, <span class="number">87</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zipWith = f =&gt; xs =&gt; ys =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (xs.length === <span class="number">0</span> || ys.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> [xHead, ...xTail] = xs;</span><br><span class="line">  <span class="keyword">const</span> [yHead, ...yTail] = ys;</span><br><span class="line">  <span class="keyword">return</span> [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = x =&gt; y =&gt; x + y;</span><br><span class="line"></span><br><span class="line">zipWith(add)(num1)(num2);</span><br></pre></td></tr></table></figure></p><p>问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> houses = [</span><br><span class="line">  <span class="string">"Eddard Stark"</span>,</span><br><span class="line">  <span class="string">"Catelyn Stark"</span>,</span><br><span class="line">  <span class="string">"Rickard Stark"</span>,</span><br><span class="line">  <span class="string">"Brandon Stark"</span>,</span><br><span class="line">  <span class="string">"Rob Stark"</span>,</span><br><span class="line">  <span class="string">"Sansa Stark"</span>,</span><br><span class="line">  <span class="string">"Arya Stark"</span>,</span><br><span class="line">  <span class="string">"Bran Stark"</span>,</span><br><span class="line">  <span class="string">"Rickon Stark"</span>,</span><br><span class="line">  <span class="string">"Lyanna Stark"</span>,</span><br><span class="line">  <span class="string">"Tywin Lannister"</span>,</span><br><span class="line">  <span class="string">"Cersei Lannister"</span>,</span><br><span class="line">  <span class="string">"Jaime Lannister"</span>,</span><br><span class="line">  <span class="string">"Tyrion Lannister"</span>,</span><br><span class="line">  <span class="string">"Joffrey Baratheon"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> takeWhile = f =&gt; ([head, ...tail]) =&gt;</span><br><span class="line">  f(head) ? [head, ...takeWhile(f)(tail)] : [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isStark = name =&gt; name.toLowerCase().includes(<span class="string">"stark"</span>);</span><br><span class="line"></span><br><span class="line">takeWhile(isStark)(houses);</span><br></pre></td></tr></table></figure></p><p>问题二： 找出数组中的奇数，然后取出前4个：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> numList = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> takeFirst = (limit, f, arr) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (limit === <span class="number">0</span> || arr.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> [head, ...tail] = arr;</span><br><span class="line">  <span class="keyword">return</span> f(head)</span><br><span class="line">    ? [head, ...takeFirst(limit - <span class="number">1</span>, f, tail)]</span><br><span class="line">    : takeFirst(limit, f, tail);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isOdd = n =&gt; n % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">takeFirst(<span class="number">4</span>, isOdd, numList);</span><br></pre></td></tr></table></figure></p><h1 id="使用高阶函数遍历数组时可能遇到的陷阱"><a href="#使用高阶函数遍历数组时可能遇到的陷阱" class="headerlink" title="使用高阶函数遍历数组时可能遇到的陷阱"></a>使用高阶函数遍历数组时可能遇到的陷阱</h1><p>问题一：  从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 用我们刚刚定义的辅助函数来生成符合要求的数组</span></span><br><span class="line"><span class="keyword">const</span> bigArr = genNumArr(<span class="number">1e6</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isEven = num =&gt; num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> triple = num =&gt; num * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">bigArr.filter(isEven).<span class="built_in">map</span>(triple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = [];</span><br><span class="line"><span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; bigArr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEven(bigArr[i])) &#123;</span><br><span class="line">    results.push(triple(bigArr[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！</span></span><br><span class="line"></span><br><span class="line"># Transduce</span><br><span class="line"></span><br><span class="line">先用 reduce 来定义 filter 和 <span class="built_in">map</span>，至于为什么这样做等下再解释。</span><br><span class="line">```h</span><br><span class="line"><span class="keyword">const</span> filter = (f, arr) =&gt;</span><br><span class="line">  arr.reduce((acc, val) =&gt; (f(val) &amp;&amp; acc.push(val), acc), []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (acc.push(f(val)), acc), []);</span><br></pre></td></tr></table></figure></p><p>重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = f =&gt; reducer =&gt; (acc, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (f(value)) <span class="keyword">return</span> reducer(acc, value);</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = f =&gt; reducer =&gt; (acc, value) =&gt; reducer(acc, f(value));</span><br></pre></td></tr></table></figure></p><p>现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pushReducer = (acc, value) =&gt; (acc.push(value), acc);</span><br><span class="line"></span><br><span class="line">bigNum.reduce(<span class="built_in">map</span>(triple)(filter(isEven)(pushReducer)), []);</span><br></pre></td></tr></table></figure></p><p>但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = (...fns) =&gt; (...args) =&gt; fns.reduce((fx, fy) =&gt; fy(fx), ...args);</span><br></pre></td></tr></table></figure></p><p>然后我们就可以优雅地组合函数了：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bigNum.reduce(</span><br><span class="line">  pipe(</span><br><span class="line">    filter(isEven),</span><br><span class="line">    <span class="built_in">map</span>(triple)</span><br><span class="line">  )(pushReducer),</span><br><span class="line">  []</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。<br>这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcognitect-labs%2Ftransducers-js" target="_blank" rel="noopener">transducers-js</a>。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。</p><h1 id="for-循环和-for-…-of-循环的区别"><a href="#for-循环和-for-…-of-循环的区别" class="headerlink" title="for 循环和 for … of 循环的区别"></a>for 循环和 for … of 循环的区别</h1><p>for … of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for … of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for … of 来遍历数组是会被禁止的。<br>那么，for … of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。</span><br><span class="line">```h</span><br><span class="line"></span><br><span class="line">const starks = [</span><br><span class="line">  &quot;Eddard Stark&quot;,</span><br><span class="line">  &quot;Catelyn Stark&quot;,</span><br><span class="line">  &quot;Rickard Stark&quot;,</span><br><span class="line">  &quot;Brandon Stark&quot;,</span><br><span class="line">  &quot;Rob Stark&quot;,</span><br><span class="line">  &quot;Sansa Stark&quot;,</span><br><span class="line">  &quot;Arya Stark&quot;,</span><br><span class="line">  &quot;Bran Stark&quot;,</span><br><span class="line">  &quot;Rickon Stark&quot;,</span><br><span class="line">  &quot;Lyanna Stark&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">function* repeatedArr(arr) &#123;</span><br><span class="line">  let i = 0;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield arr[i++ % arr.length];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const infiniteNameList = repeatedArr(starks);</span><br><span class="line"></span><br><span class="line">const wait = ms =&gt;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  for (const name of infiniteNameList) &#123;</span><br><span class="line">    await wait(1000);</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“很多场景，for来的更直接，更明了。”  “最喜欢for循环了。想break就break。可能会多数据的还是for循环。” “for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响”,这是很多时候都会考虑的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(五)</title>
    <link href="https://duanruilong.github.io/2018/07/22/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%BA%94/"/>
    <id>https://duanruilong.github.io/2018/07/22/小程序之旅-五/</id>
    <published>2018-07-22T15:54:08.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。<br>而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！</p><p>那么来看个需求：</p><ul><li>做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。</li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>wx.chooseImage：选择图片</li><li>wx.saveFile(OBJ)：将临时图片保存在本地</li><li>wx.setStorage(OBJ)：保存图片的路径。</li></ul><p>当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。<br>好了，理顺了思路，我们看一下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// &lt;!--index.wxml--&gt;</span></span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" mode="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;button bindtap='keepImg'&gt;保存图片&lt;/button&gt;</span><br><span class="line">    &lt;button bindtap='deleteImg'&gt;删除图片&lt;/button&gt;</span><br><span class="line">    &lt;image src='&#123;&#123;imgPath&#125;&#125;'&gt;&lt;/image&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: 'Hello World',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo'),</span><br><span class="line">    imgPath:<span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  keepImg:function()&#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 浏览文件</span></span><br><span class="line">    wx.chooseImage(&#123;</span><br><span class="line">      count:<span class="number">1</span>,</span><br><span class="line">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class="line">      sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有</span><br><span class="line">      success: function(res) &#123;</span><br><span class="line">        <span class="comment">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class="line">        var tempFilePaths = res.tempFilePaths;</span><br><span class="line">        console.<span class="built_in">log</span>(tempFilePaths)</span><br><span class="line">        <span class="comment">//将本地照片保存在小程序内</span></span><br><span class="line">        wx.saveFile(&#123;</span><br><span class="line">          tempFilePath: tempFilePaths[<span class="number">0</span>],</span><br><span class="line">          success:function(res)&#123;</span><br><span class="line">            var savedFilePath = res.savedFilePath; <span class="comment">// 图片成功之后存储在本地的路径</span></span><br><span class="line">            console.<span class="built_in">log</span>(savedFilePath)</span><br><span class="line"></span><br><span class="line">            if (!wx.getStorageSync('storageImgPath')) &#123; //数据存储，保存图片的路径</span><br><span class="line">              wx.setStorageSync('storageImgPath', savedFilePath)</span><br><span class="line">            &#125;</span><br><span class="line">            that.setData(&#123; imgPath: wx.getStorageSync('storageImgPath')&#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteImg:function()&#123;</span><br><span class="line">    wx.removeStorageSync('storageImgPath'); //从数据缓存中删除</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    wx.getSavedFileList(&#123; <span class="comment">//获取本地的文件列表</span></span><br><span class="line">      success:function(res)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(res.errMsg);</span><br><span class="line">        var files = res.fileList;</span><br><span class="line">        <span class="keyword">if</span>(res.fileList.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 删除第一张</span></span><br><span class="line">          wx.removeSavedFile(&#123;</span><br><span class="line">            filePath:res.fileList[<span class="number">0</span>].filePath,</span><br><span class="line">            success:function(res)&#123;</span><br><span class="line">              <span class="comment">// 提示语</span></span><br><span class="line">              wx.showToast(&#123;</span><br><span class="line">                title: '删除成功',</span><br><span class="line">                icon:'success',</span><br><span class="line">                duration:<span class="number">2000</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_05.png" alt="微信小程序"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 + oh my zsh打造最强Mac终端</title>
    <link href="https://duanruilong.github.io/2018/07/22/iTerm2-oh-my-zsh-agnoster-%E6%89%93%E9%80%A0%E6%9C%80%E5%BC%BAMac%E7%BB%88%E7%AB%AF/"/>
    <id>https://duanruilong.github.io/2018/07/22/iTerm2-oh-my-zsh-agnoster-打造最强Mac终端/</id>
    <published>2018-07-22T14:53:37.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>iTerm2 + oh my zsh 打造最强Mac终端</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg" alt="iTerm2"></p><a id="more"></a><p>#安装iTerm2<br>iTerm2官方下载地址 <a href="http://www.iterm2.com/downloads.html" target="_blank" rel="noopener">http://www.iterm2.com/downloads.html</a></p><p>#安装 oh-my-zsh</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:<span class="comment">//raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span></span><br></pre></td></tr></table></figure><p>#配置<br>创建配置文件<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-<span class="keyword">template</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p><h1 id="设置zsh为默认的shell"><a href="#设置zsh为默认的shell" class="headerlink" title="设置zsh为默认的shell"></a>设置zsh为默认的shell</h1><p><code>chsh -s /bin/zsh</code></p><p>此时，zsh已经安装成功 </p><p>接来下，可以去<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a> 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iTerm2 + oh my zsh 打造最强Mac终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg&quot; alt=&quot;iTerm2&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="https://duanruilong.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件" scheme="https://duanruilong.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Async Functions (异步函数)</title>
    <link href="https://duanruilong.github.io/2018/07/15/Async-Functions-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    <id>https://duanruilong.github.io/2018/07/15/Async-Functions-异步函数/</id>
    <published>2018-07-15T13:43:58.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p> ECMAScript 2017 新特性 Async Functions(异步函数) 。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png" alt="js"></p><a id="more"></a><h1 id="async-异步-函数变体"><a href="#async-异步-函数变体" class="headerlink" title="async(异步) 函数变体"></a>async(异步) 函数变体</h1><p>以下是已经存在的异步函数变体。请注意无处不在的  async 关键字。</p><ul><li>异步函数声明： async function foo() {}</li><li>异步函数表达式： const foo = async function () {};</li><li>异步函数定义：let obj = { async foo() {} }</li><li>异步箭头函数： const foo = async () =&gt; {};</li></ul><h1 id="async-异步-函数总是返回-Promises"><a href="#async-异步-函数总是返回-Promises" class="headerlink" title="async(异步) 函数总是返回 Promises"></a>async(异步) 函数总是返回 Promises</h1><p>async(异步) 函数的 Promise 完成状态：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">asyncFunc()</span><br><span class="line">.then(x =&gt; console.<span class="built_in">log</span>(x));</span><br><span class="line">    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>async(异步) 函数的 Promise 拒绝状态：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    throw new Error('Problem!');</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">asyncFunc()</span><br><span class="line">.<span class="keyword">catch</span>(err =&gt; console.<span class="built_in">log</span>(err));</span><br><span class="line">    <span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure><h1 id="通过-await-处理-async-异步-计算的结果和错误"><a href="#通过-await-处理-async-异步-计算的结果和错误" class="headerlink" title="通过 await 处理 async(异步) 计算的结果和错误"></a>通过 await 处理 async(异步) 计算的结果和错误</h1><p>await（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回：</p><ul><li>如果 Promise 是完成状态，await 的结果是完成态的值。</li><li>如果 Promise 是拒绝状态，await 会抛出拒绝值。</li></ul><p>处理单个 async(异步) 返回值：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = await otherAsyncFunc();</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function">function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .then(result =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按顺序处理多个 async(异步) 返回值：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = await otherAsyncFunc1();</span><br><span class="line">    console.<span class="built_in">log</span>(result1);</span><br><span class="line">    <span class="keyword">const</span> result2 = await otherAsyncFunc2();</span><br><span class="line">    console.<span class="built_in">log</span>(result2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function">function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc1()</span><br><span class="line">    .then(result1 =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(result1);</span><br><span class="line">        <span class="keyword">return</span> otherAsyncFunc2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(result2 =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行处理多个 async(异步) 返回值：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = await Promise.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ]);</span><br><span class="line">    console.<span class="built_in">log</span>(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function">function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Promise.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ])</span><br><span class="line">    .then([result1, result2] =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(result1, result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误处理：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">await <span class="title">otherAsyncFunc</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function">function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解-async-异步-函数"><a href="#理解-async-异步-函数" class="headerlink" title="理解 async(异步) 函数"></a>理解 async(异步) 函数</h1><p>解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p><p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fetchJson</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url)</span><br><span class="line">    .then(request =&gt; request.text())</span><br><span class="line">    .then(text =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(text);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(error =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`ERROR: $&#123;error.<span class="built_in">stack</span>&#125;`);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">fetchJson('http://example.com/some_file.json')</span><br><span class="line">.then(obj =&gt; console.<span class="built_in">log</span>(obj));</span><br></pre></td></tr></table></figure><h1 id="通过-generator-来编写异步代码"><a href="#通过-generator-来编写异步代码" class="headerlink" title="通过 generator 来编写异步代码"></a>通过 generator 来编写异步代码</h1><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchJson = co.wrap(function* (url) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        let request = yield fetch(url);</span><br><span class="line">        let text = yield request.text();</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`ERROR: $&#123;error.<span class="built_in">stack</span>&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于  then() 所做的工作）。</p><h1 id="通过-async-异步-函数来编写异步代码"><a href="#通过-async-异步-函数来编写异步代码" class="headerlink" title="通过 async(异步) 函数来编写异步代码"></a>通过 async(异步) 函数来编写异步代码</h1><p>async(异步) 函数用的特定语法基本上和 co 类似：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">fetchJson</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        let request = await fetch(url);</span><br><span class="line">        let text = await request.text();</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`ERROR: $&#123;error.<span class="built_in">stack</span>&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在内部，异步函数写法更类似于 generators 。</p><h1 id="以同步开始，异步处理的-async-异步-函数"><a href="#以同步开始，异步处理的-async-异步-函数" class="headerlink" title="以同步开始，异步处理的 async(异步) 函数"></a>以同步开始，异步处理的 async(异步) 函数</h1><p>以下是 async(异步)函数是如何工作的：</p><ul><li>1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。</li><li>2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。</li><li>3、返回 Promise 对象 p。</li></ul><p>当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和  catch() 的回调总是在当前代码完成后执行。</p><p>以下是代码示例：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('asyncFunc()'); // (A)</span><br><span class="line">    return 'abc';</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc().</span><br><span class="line">then(x =&gt; console.<span class="built_in">log</span>(`Resolved: $&#123;x&#125;`)); <span class="comment">// (B)</span></span><br><span class="line">console.log('main'); // (C)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// asyncFunc()</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// Resolved: abc</span></span><br></pre></td></tr></table></figure><p>您可以认为是以下的执行顺序：</p><ul><li>1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。</li><li>2、行C：执行继续。</li><li>3、行B：Promise 完成状态通知是异步发生的。</li></ul><h1 id="返回不被包裹的-Promise-对象"><a href="#返回不被包裹的-Promise-对象" class="headerlink" title="返回不被包裹的 Promise 对象"></a>返回不被包裹的 Promise 对象</h1><p>Promise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise  p 的。这意味着：</p><ul><li>1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。</li><li>2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。<br>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Promise.resolve(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc()</span><br><span class="line">.then(x =&gt; console.<span class="built_in">log</span>(x)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    return Promise.reject(new Error('Problem!'));</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc()</span><br><span class="line">.<span class="keyword">catch</span>(err =&gt; console.error(err)); <span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure><p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹  anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> await anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="使用-await-小贴士"><a href="#使用-await-小贴士" class="headerlink" title="使用 await 小贴士"></a>使用 await 小贴士</h1><h2 id="不要忘记使用-await"><a href="#不要忘记使用-await" class="headerlink" title="不要忘记使用 await"></a>不要忘记使用 await</h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = otherAsyncFunc(); <span class="comment">// missing `await`!</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。</p><p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">await <span class="title">step1</span><span class="params">()</span></span>; <span class="comment">// (A)</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。</p><h2 id="不需要使用-await-的情况"><a href="#不需要使用-await-的情况" class="headerlink" title="不需要使用 await 的情况"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    const writer = openFile('someFile.txt');</span><br><span class="line">    writer.write('hello'); // don’t wait</span><br><span class="line">    writer.write('world'); // don’t wait</span><br><span class="line">    await writer.close(); <span class="comment">// wait for file to close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p><p>asyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。</p><p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return 替换  await writer.close() ：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    const writer = openFile('someFile.txt');</span><br><span class="line">    writer.write('hello');</span><br><span class="line">    writer.write('world');</span><br><span class="line">    <span class="keyword">return</span> writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个版本各有利弊，await 版本可能稍微更容易理解。</p><h2 id="await-是顺序执行的，Promise-all-是并行的"><a href="#await-是顺序执行的，Promise-all-是并行的" class="headerlink" title="await 是顺序执行的，Promise.all() 是并行的"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = await asyncFunc1();</span><br><span class="line">    <span class="keyword">const</span> result2 = await asyncFunc2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = await Promise.all([</span><br><span class="line">        asyncFunc1(),</span><br><span class="line">        asyncFunc2(),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p><h1 id="异步函数和回调"><a href="#异步函数和回调" class="headerlink" title="异步函数和回调"></a>异步函数和回调</h1><p>async(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。</p><h1 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h1><p>我们从数组方法 map() 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">downloadContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> urls.<span class="built_in">map</span>(url =&gt; &#123;</span><br><span class="line">        <span class="comment">// 错误的语法!</span></span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">downloadContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> urls.<span class="built_in">map</span>(async (url) =&gt; &#123; <span class="comment">// 注意这一行中的 async ;</span></span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码有两个问题：</p><p>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。<br>一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待  downloadContent() 执行结束。<br>我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">downloadContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promiseArray = urls.<span class="built_in">map</span>(async (url) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> await Promise.all(promiseArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>map() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">downloadContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promiseArray = urls.<span class="built_in">map</span>(</span><br><span class="line">        url =&gt; httpGet(url));</span><br><span class="line">    <span class="keyword">return</span> await Promise.all(promiseArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开  Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">downloadContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promiseArray = urls.<span class="built_in">map</span>(</span><br><span class="line">        url =&gt; httpGet(url));</span><br><span class="line">    <span class="keyword">return</span> Promise.all(promiseArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h1><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">logContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    urls.forEach(url =&gt; &#123;</span><br><span class="line">        <span class="comment">// Wrong syntax</span></span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        console.<span class="built_in">log</span>(content);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 await 。</p><p>我们换作异步箭头函数：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">logContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    urls.forEach(async url =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        console.<span class="built_in">log</span>(content);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Not finished here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码起作用了，但是会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。</p><p>如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">logContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> url of urls) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">        console.<span class="built_in">log</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">logContent</span><span class="params">(urls)</span> </span>&#123;</span><br><span class="line">    await Promise.all(urls.<span class="built_in">map</span>(</span><br><span class="line">        async url =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> content = await httpGet(url);</span><br><span class="line">            console.<span class="built_in">log</span>(content);</span><br><span class="line">        &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>map() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p><h1 id="使用异步函数小贴士"><a href="#使用异步函数小贴士" class="headerlink" title="使用异步函数小贴士"></a>使用异步函数小贴士</h1><h2 id="了解你的-Promises"><a href="#了解你的-Promises" class="headerlink" title="了解你的 Promises"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href="http://exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p><p>举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">function <span class="title">httpGet</span><span class="params">(url, responseType=<span class="string">""</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(</span><br><span class="line">        function (resolve, reject) &#123;</span><br><span class="line">            <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            request.onload = function () &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success</span></span><br><span class="line">                    resolve(<span class="keyword">this</span>.response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Something went wrong (404 etc.)</span></span><br><span class="line">                    reject(<span class="keyword">new</span> Error(<span class="keyword">this</span>.statusText));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            request.onerror = function () &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> Error(</span><br><span class="line">                    'XMLHttpRequest Error: '+this.statusText));</span><br><span class="line">            &#125;;</span><br><span class="line">            request.open('GET', url);</span><br><span class="line">            xhr.responseType = responseType;</span><br><span class="line">            request.send();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者  throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。</p><p>因此，异步函数的通用编码风格是：</p><ul><li>直接使用 Promise 对象来构建异步原语。</li><li>用异步函数来使用这些原语。<br>扩展阅读：“Exploring ES6” 中的 “<a href="http://exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">异步编程中的 Promises 对象</a>” 章节</li></ul><h1 id="立即调用异步函数表达式"><a href="#立即调用异步函数表达式" class="headerlink" title="立即调用异步函数表达式"></a>立即调用异步函数表达式</h1><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main()  并立即调用它：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(await asyncFunction());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main();<br>或者您可以使用立即调用异步函数表达式：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line">(async function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(await asyncFunction());</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>另一个选择是立即调用异步箭头函数：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(await asyncFunction());</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h1 id="用异步函数进行单元测试"><a href="#用异步函数进行单元测试" class="headerlink" title="用异步函数进行单元测试"></a>用异步函数进行单元测试</h1><p>以下代码使用 <a href="https://mochajs.org/" target="_blank" rel="noopener">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import assert from 'assert';</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Bug: the following test always succeeds</span></span><br><span class="line">test('Testing async code', function () &#123;</span><br><span class="line">    asyncFunc1() <span class="comment">// (A)</span></span><br><span class="line">    .then(result1 =&gt; &#123;</span><br><span class="line">        assert.strictEqual(result1, <span class="string">'a'</span>); <span class="comment">// (B)</span></span><br><span class="line">        <span class="keyword">return</span> asyncFunc2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(result2 =&gt; &#123;</span><br><span class="line">        assert.strictEqual(result2, <span class="string">'b'</span>); <span class="comment">// (C)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p><p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="keyword">return</span> asyncFunc1() <span class="comment">// (A)</span></span><br></pre></td></tr></table></figure></p><p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line">import assert from 'assert';</span><br><span class="line">test('Testing async code', async function () &#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = await asyncFunc1();</span><br><span class="line">    assert.strictEqual(result1, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">const</span> result2 = await asyncFunc2();</span><br><span class="line">    assert.strictEqual(result2, <span class="string">'b'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p><h1 id="不要担心没有处理的拒绝拒态"><a href="#不要担心没有处理的拒绝拒态" class="headerlink" title="不要担心没有处理的拒绝拒态"></a>不要担心没有处理的拒绝拒态</h1><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:</span><br><span class="line"><span class="function">async function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    throw new Error('Problem!');</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><h1 id="阅读延伸"><a href="#阅读延伸" class="headerlink" title="阅读延伸"></a>阅读延伸</h1><ul><li><a href="https://github.com/tc39/ecmascript-asyncawait" target="_blank" rel="noopener">异步函数</a> （提出者Brian Terlson）</li><li><a href="http://exploringjs.com/es6/ch_generators.html#sec_co-library" target="_blank" rel="noopener">通过generators来简化异步计算</a>（“Exporing ES6”中的部分章节）<br>原文地址：<a href="http://exploringjs.com/es2016-es2017/ch_async-functions.html" target="_blank" rel="noopener">http://exploringjs.com/es2016-es2017/ch_async-functions.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; ECMAScript 2017 新特性 Async Functions(异步函数) 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(四)</title>
    <link href="https://duanruilong.github.io/2018/06/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E5%9B%9B/"/>
    <id>https://duanruilong.github.io/2018/06/28/小程序之旅-四/</id>
    <published>2018-06-27T16:23:57.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序<code>websocket</code>之旅。<code>websocket</code>是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><h1 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h1><p>以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用<code>ajax</code>轮询（<code>setinterval</code>函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。<br>对于<code>websocket</code>技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。<code>websocket</code>很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。</p><blockquote><p>快速生成标准文件</p></blockquote><p>以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- app.json文件 --&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>:[</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span>,</span><br><span class="line">    <span class="string">"pages/charts/charts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>:&#123;</span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>:<span class="string">"light"</span>,</span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"WeChat"</span>,</span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>:<span class="string">"black"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="1、小栗子试图插件"><a href="#1、小栗子试图插件" class="headerlink" title="1、小栗子试图插件"></a>1、小栗子试图插件</h2><p>图表类的插件一般就是<code>echarts</code>和<code>highcharts</code>,而在小程序里，我们可以使用<code>wxcharts</code>,<code>wxcharts</code>的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，<a href="https://raw.githubusercontent.com/jiangzy27/how_to_react/master/tools/wxcharts.js" target="_blank" rel="noopener">下载链接</a></p><h2 id="2、数据接口支持"><a href="#2、数据接口支持" class="headerlink" title="2、数据接口支持"></a>2、数据接口支持</h2><p>这里的数据支持使用的是<code>Nodejs</code>，还要了解一下<code>websocket</code>,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。</p><p>Nodejs有个插件封装了socket，叫<code>nodejs-websocket</code>。使用npm安装一下:<br><code>npm install nodejs-websocket</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ npm i nodejs-websocket -g</span><br><span class="line">/usr/local/lib</span><br><span class="line">└── nodejs-websocket@<span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><blockquote><p>server.js</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var ws = require('nodejs-websocket');</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建server</span></span><br><span class="line"></span><br><span class="line">var server = ws.createServer(function(conn)&#123;</span><br><span class="line">    conn.on(<span class="string">"text"</span>,function(str)&#123; <span class="comment">// 监听文本输入</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"stock"</span>) &#123;</span><br><span class="line">            setInterval(function()&#123;</span><br><span class="line">                var arr=[];</span><br><span class="line">                <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    var count = (Math.<span class="built_in">ceil</span>((Math.random()*<span class="number">100</span>))/<span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">                    arr.push(count)</span><br><span class="line">                &#125;</span><br><span class="line">                var obj = &#123;data:arr&#125;</span><br><span class="line">                conn.send(JSON.stringify(obj))</span><br><span class="line">            &#125;,<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p><code>websocket</code>建立专用通道后，服务端只要监听到客户端发来的文本内容是”stock”,就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。</p><blockquote><p>注意</p></blockquote><p>利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。<br>ws就相当于http，wss就相当于https，所以正确的写法应该是：<code>ws://localhost:8000</code></p><blockquote><p>微信客户端</p></blockquote><p>使用websocket很容易，主要就是你这几个步骤：</p><ul><li>建立连接</li><li>发送数据</li><li>接收数据</li><li>结束</li></ul><blockquote><p>charts.js</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/charts/charts.js</span></span><br><span class="line">var wxCharts = require('wxcharts.js');</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    <span class="comment">// var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8];</span></span><br><span class="line">    <span class="comment">// var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接</span></span><br><span class="line">    wx.connectSocket(&#123;</span><br><span class="line">      url: 'ws://localhost:8000',//这里连接的就是服务端的socket</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//连接成功监听</span></span><br><span class="line">    wx.onSocketOpen(function (res) &#123;</span><br><span class="line">      <span class="comment">//发送信息</span></span><br><span class="line">      wx.sendSocketMessage(&#123;</span><br><span class="line">        data: <span class="string">"stock"</span></span><br><span class="line">      &#125;);</span><br><span class="line">      console.log('WebSocket连接已打开！')</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//连接失败监听</span></span><br><span class="line">    wx.onSocketError(function (res) &#123;</span><br><span class="line">      console.log('WebSocket连接打开失败，请检查！')</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    wx.onSocketMessage(function (res) &#123;</span><br><span class="line">      <span class="comment">//收到的信息</span></span><br><span class="line">      console.log('收到服务器内容：' + res.data);</span><br><span class="line">      var obj = JSON.parse(res.data);</span><br><span class="line">      console.<span class="built_in">log</span>(obj);</span><br><span class="line">      <span class="comment">//绘制图表，利用canvas绘图技术。</span></span><br><span class="line">      <span class="keyword">new</span> wxCharts(&#123;</span><br><span class="line">        canvasId: 'lineCanvas',//指定canvas的id</span><br><span class="line">        type: 'line',//类型是线形图</span><br><span class="line">        categories: ['2012', '2013', '2014', '2015', '2016', '2017'],</span><br><span class="line"></span><br><span class="line">        series: [&#123;</span><br><span class="line">          name: '成交量1',</span><br><span class="line">          data: obj.data,<span class="comment">//websocket接收到的数据</span></span><br><span class="line">          format: function (val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeof val == <span class="string">"string"</span>) &#123;</span><br><span class="line">              val = parseFloat(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val.toFixed(<span class="number">2</span>) + <span class="string">'万'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: '成交量2',</span><br><span class="line">          data: [<span class="number">0.30</span>, <span class="number">0.37</span>, <span class="number">0.65</span>, <span class="number">0.78</span>, <span class="number">0.69</span>, <span class="number">0.94</span>],</span><br><span class="line">          format: function (val) &#123;</span><br><span class="line">            <span class="keyword">return</span> val.toFixed(<span class="number">2</span>) + <span class="string">'万'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;],</span><br><span class="line">        yAxis: &#123;</span><br><span class="line">          title: '成交金额 (万元)',</span><br><span class="line">          format: function (val) &#123;</span><br><span class="line">            <span class="keyword">return</span> val.toFixed(<span class="number">2</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          min: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        width: <span class="number">320</span>,</span><br><span class="line">        height: <span class="number">200</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>charts.wxml:</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/charts/charts.wxml--&gt;</span><br><span class="line">&lt;canvas style=<span class="string">"width: 100%; height: 200px;border:1px solid #ccc;"</span> canvas-id=<span class="string">"lineCanvas"</span>&gt;</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gj5uzrzPwcpeEniaAXGSYSiaUZI3g7gZqlZaeoAROMHB9MVjgqfrL68JHQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="websocket请"></p><p>看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。<br>下面通过控制台，看下websocket请求的特征：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gjeNlDTTIGia8eLvAy3zWjAOV9WTicDFbBONETA7BHvwSpMsK4A5k7Jw8A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="websocket请"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序&lt;code&gt;websocket&lt;/code&gt;之旅。&lt;code&gt;websocket&lt;/code&gt;是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ES6里 三种异步解决方案</title>
    <link href="https://duanruilong.github.io/2018/06/27/ES6%E9%87%8C-%E4%B8%89%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://duanruilong.github.io/2018/06/27/ES6里-三种异步解决方案/</id>
    <published>2018-06-27T15:47:45.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下ES6里的三种异步方案。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="知识尝鲜"><a href="#知识尝鲜" class="headerlink" title="知识尝鲜"></a>知识尝鲜</h1><blockquote><p>1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用<code>next()</code>  方法；<br>2、next() 方法，可以给他传入一个参数。调用<code>next()</code>方法，会返回一个对象<code>{value: res,done: false}</code> ,这里的done 表示迭代器。</p></blockquote><h1 id="方法一：-Generator-Promise"><a href="#方法一：-Generator-Promise" class="headerlink" title="方法一： Generator + Promise"></a>方法一： Generator + Promise</h1><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fund = require('fund')</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 版的readFile</span></span><br><span class="line"><span class="keyword">const</span> readFile = function (fileName) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">    fund.readFile(fileName, function(err, data)&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newgen = function * () &#123;</span><br><span class="line">  let demo1 = yield readFile('a.txt');</span><br><span class="line">  let demo2 = yield readFile('b.txt');</span><br><span class="line"></span><br><span class="line">  console.log('demo1---&gt;', demo1.toString());</span><br><span class="line">  console.log('demo2---&gt;', demo2.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 Generator 和 Promise 的自动执行器</span></span><br><span class="line"><span class="function">function <span class="title">run</span><span class="params">(gen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  let g = gen();</span><br><span class="line">  </span><br><span class="line">  <span class="function">function <span class="title">next</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    let result = g.next(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    result.value.then(function(data) &#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>执行器 中的 <code>result.value</code> 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样  <code>let f1 = yield readFile(&#39;a.txt&#39;);</code>就可以拿到值.</p><h1 id="方法二：-Generator-Thunk函数"><a href="#方法二：-Generator-Thunk函数" class="headerlink" title="方法二： Generator + Thunk函数"></a>方法二： Generator + Thunk函数</h1><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const fs = require('fs')</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数</span></span><br><span class="line"><span class="function">function <span class="title">thunkify</span><span class="params">(fn, obj = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        let args = Array.from(arguments);</span><br><span class="line">        <span class="keyword">return</span> function (m) &#123;</span><br><span class="line">            args.push(m)</span><br><span class="line">            <span class="keyword">return</span> fn.apply(obj, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile, fs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = function* () &#123;</span><br><span class="line">    let f1 = yield readFile('a.txt');</span><br><span class="line">    let f2 = yield readFile('b.txt');</span><br><span class="line"></span><br><span class="line">    console.log('F1--&gt;', f1.toString());</span><br><span class="line">    console.log('F2--&gt;', f2.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 Generator 和 Thunk函数的自动执行器</span></span><br><span class="line"><span class="function">function <span class="title">run</span><span class="params">(fn)</span> </span>&#123;</span><br><span class="line">    let gen = fn();</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">next</span><span class="params">(err, data)</span> </span>&#123;</span><br><span class="line">        let result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p><code>Thunk</code>转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法</p><h1 id="方法三：async-函数-await-的异步处理方式"><a href="#方法三：async-函数-await-的异步处理方式" class="headerlink" title="方法三：async 函数 + await 的异步处理方式"></a>方法三：async 函数 + await 的异步处理方式</h1><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fs = require('fs')</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 版的readFile</span></span><br><span class="line"><span class="keyword">const</span> readFile = function (fileName) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, function(err, data)&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = async function () &#123;</span><br><span class="line">  const f1 = await readFile('a.txt');</span><br><span class="line">  const f2 = await readFile('b.txt');</span><br><span class="line">  console.<span class="built_in">log</span>(f1.toString());</span><br><span class="line">  console.<span class="built_in">log</span>(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><p><code>readFile</code>函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍一下ES6里的三种异步方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(三)</title>
    <link href="https://duanruilong.github.io/2018/06/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%B8%89/"/>
    <id>https://duanruilong.github.io/2018/06/19/小程序之旅-三/</id>
    <published>2018-06-19T15:40:53.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><h1 id="修改导航栏信息"><a href="#修改导航栏信息" class="headerlink" title="修改导航栏信息"></a>修改导航栏信息</h1><p>先从修改导航栏信息开始，主要修改的文件是<code>app.json</code>文件，在里面可以定义一些样式</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_2.png" alt="微信小程序"></p><h1 id="定义底部tab导航栏"><a href="#定义底部tab导航栏" class="headerlink" title="定义底部tab导航栏"></a>定义底部tab导航栏</h1><p>可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在<code>app.json</code>文件里操作。</p><blockquote><p>app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。</p></blockquote><p>简单说一下这个配置各个项的含义:</p><p>1、<code>pages字段</code> —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。<br>2、<code>window字段</code> —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。<br>其他配置项细节可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html" target="_blank" rel="noopener">小程序的配置 app.json</a> 。</p><p>以下是一个包含了所有配置选项的 app.json ：<br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html" target="_blank" rel="noopener">参考地址</a><br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/index"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>: &#123;</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"Demo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tabBar"</span>: &#123;</span><br><span class="line">    <span class="string">"list"</span>: [&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"pages/index/index"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"首页"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"pages/logs/logs"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"日志"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"networkTimeout"</span>: &#123;</span><br><span class="line">    <span class="string">"request"</span>: <span class="number">10000</span>,</span><br><span class="line">    <span class="string">"downloadFile"</span>: <span class="number">10000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"debug"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.json 配置项列表</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_3.png" alt="微信小程序"></p><p>tabBar的配置参数可以在<code>list</code>里面配置，包括icon的设置，可以去<a href="">iconfont</a>去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_4.png" alt="微信小程序"></p><p>iconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_5.png" alt="微信小程序"></p><h1 id="抽离公共部分"><a href="#抽离公共部分" class="headerlink" title="抽离公共部分"></a>抽离公共部分</h1><p>把头像和昵称抽离成公共部分共用，小程序提供了<code>import</code>和<code>include</code>两种方式，微信头像和昵称，显然是异步获取的。<br>为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到<code>app.wxss</code>全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。</p><p>把<code>index.wxss</code>里的用户样式移动到<code>app.wxss</code>下：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**index.wxss用户信息样式**/</span></span><br><span class="line">.userinfo &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-avatar &#123;</span><br><span class="line">  width: <span class="number">128</span>rpx;</span><br><span class="line">  height: <span class="number">128</span>rpx;</span><br><span class="line">  margin: <span class="number">20</span>rpx;</span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-nickname &#123;</span><br><span class="line">  color: <span class="meta">#aaa;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.usermotto &#123;</span><br><span class="line">  margin-top: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来新建<code>common</code>目录，新建文件<code>header.wxml</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在这个文件里把index页面的用户信息移动过来 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">userinfo</span>"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>在 <code>index.wxml</code>合适位置引入文件：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include src=<span class="string">"../common/header.wxml"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在 <code>index.js</code>合适位置缓存本地：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存本地</span></span><br><span class="line">wx.setStorageSync('userData', this.data.userInfo)</span><br></pre></td></tr></table></figure><p>在需要展示的页面就可以引入公共模块，和数据具体配置：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include src=<span class="string">"../common/header.wxml"</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_6.png" alt="微信小程序"></p><p>同时小程序还提供了<code>template</code>模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。<br>接下来可以试着加入一个<code>footer.wxml</code>公共组件文件吧。</p><p>footer.wxml：<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_7.png" alt="微信小程序"></p><p>需要引入的文件配置：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_8.png" alt="微信小程序"></p><p>注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><code>app.js</code>文件,就是个<code>App()</code>函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有<code>var app = getApp()</code>这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。<br>再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。<br>这个object，除了<code>getUserInfo</code>这个自定义函数，还有<code>onLaunch</code>是内置的函数，那么onLaunch是啥意思呢？<br>先来说下生命周期的概念。<br>生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：<code>初始化，渲染前，渲染中，渲染后，销毁</code>等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。<br>以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_9.png" alt="微信小程序"></p><blockquote><p>1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。<br>2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。<br>3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。<br>4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。<br>5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。<br>6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。<br>7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。</p></blockquote><p>正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。<br>小程序生命周期，分为注册App和注册Page两段。<br>其实也简单。App可以比作浏览器，Page可以比作网页。<br>那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已.</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_10.png" alt="微信小程序"></p><p>onShow和onHide，也就是前台和后台的定义。<br> 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。<br>当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。<br>而对于onError和其他选项，一般不经常使用。</p><p>Page（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_11.png" alt="微信小程序"><br>这里也有<code>onShow</code>和<code>onHide</code>，那么这俩哥们又是啥时候触发呢？<br>onShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。<br>啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？</p><blockquote><p>页面跳转分两种情况：<br>1、wx.navigateTo保留当前页面，跳转<br>2、wx.redirectTo关闭当前页面，跳转</p></blockquote><p>这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button open-type=<span class="string">"getUserInfo"</span> bindtap=<span class="string">"keepJump"</span>&gt;保留当前页面并跳转 &lt;/button&gt;</span><br><span class="line">&lt;button open-type=<span class="string">"getUserInfo"</span> bindtap=<span class="string">"closeJump"</span>&gt;关闭当前页面并跳转 &lt;/button&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_12.png" alt="微信小程序"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅(二)</title>
    <link href="https://duanruilong.github.io/2018/06/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%BA%8C/"/>
    <id>https://duanruilong.github.io/2018/06/15/小程序之旅-二/</id>
    <published>2018-06-14T17:00:05.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于<code>form</code>组件、本地存储和页面的跳转和回退的小程序之旅。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><p>介绍下 <code>form</code>组件、本地存储和页面的跳转和回退</p><h1 id="表单组件和数据存储功能"><a href="#表单组件和数据存储功能" class="headerlink" title="表单组件和数据存储功能"></a>表单组件和数据存储功能</h1><p>新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能</p><p>在<code>pages</code>下新增一个<code>login</code>文件夹。</p><blockquote><p>操作步骤为：pages文件夹右键-&gt;新建-&gt;目录，</p></blockquote><p>然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。</p><p>配置代码：</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2.png" alt="微信小程序"></p><p>login.wxml:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--login.wxml--&gt;</span><br><span class="line">&lt;form bindsubmit=<span class="string">"formSubmit"</span>&gt;</span><br><span class="line">  &lt;view class=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input name=<span class="string">"userName"</span> type=<span class="string">"text"</span> class=<span class="string">"myinput"</span> placeholder=<span class="string">"请输入用户名"</span> value=<span class="string">"&#123;&#123;userName&#125;&#125;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input name=<span class="string">"userPass"</span> type=<span class="string">"text"</span> class=<span class="string">"myinput"</span> password placeholder=<span class="string">"请输入密码"</span> value=<span class="string">"&#123;&#123;userPass&#125;&#125;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button formType=<span class="string">"submit"</span>&gt;标记我&lt;/button&gt;</span><br><span class="line"> &lt;/view&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>login.js:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//login.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userName: '',//用户名</span><br><span class="line">    userPass: '',//密码</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class="line">  formSubmit: function (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.detail.value);<span class="comment">//返回格式：Object &#123;userName: "hello", userPass: "123"&#125;</span></span><br><span class="line">    var obj = e.detail.value;</span><br><span class="line">    <span class="keyword">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class="line">      <span class="comment">//本地存储用户名和密码</span></span><br><span class="line">      wx.setStorageSync('userName', obj.userName);</span><br><span class="line">      wx.setStorageSync('userPass', obj.userPass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var name = wx.getStorageSync('userName');</span><br><span class="line">    var password = wx.getStorageSync('userPass');</span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; userName: name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; userPass: password &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>login.wxsss:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.myinput&#123;</span><br><span class="line">  border:<span class="number">1</span>px solid cyan;</span><br><span class="line">  border-radius: <span class="number">40</span>px;</span><br><span class="line">  margin-bottom: <span class="number">10</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在首页创建一个按钮，然后利用<code>wx.navigateTo</code>组件跳转一下即可，直接看一下效果：<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m1.gif" alt="微信小程序"></p><p>小程序的表单，默认是异步提交的。它在<code>form</code>上全局绑定一个事件，然后根据<code>name</code>去寻找表单元素的值。所以每个<code>input</code>输入框一定要跟上<code>name</code>，否则找不到。这里只是input，至于其他的表单元素可以再去看看。<br>还有就是有关数据存储，要用小程序提供的api：</p><blockquote><p>wx.setStorage(OBJ)：异步存储内容。<br>wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。<br>wx.getStorage(OBJ)：异步获取内容。<br>wx.getStorageSync(key)：同步获取内容。</p></blockquote><p>一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。<br>而异步存储的话，要注意其<code>OBJ参数</code>的书写格式，它包括：</p><blockquote><p>key，data，success回调函数，fail回调函数等参数的对象</p></blockquote><p>小程序的本地数据存储也有大小限制：<code>不能超过10MB</code></p><h1 id="异步存储登录页的用户名和密码"><a href="#异步存储登录页的用户名和密码" class="headerlink" title="异步存储登录页的用户名和密码"></a>异步存储登录页的用户名和密码</h1><p>在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。</p><p>login.js：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//login.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userName: null,</span><br><span class="line">    userPass: null</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class="line">  formSubmit: function (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.detail.value);<span class="comment">//返回格式：Object &#123;userName: "hello", userPass: "123"&#125;</span></span><br><span class="line">    var obj = e.detail.value;</span><br><span class="line">    <span class="keyword">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class="line">      <span class="comment">//异步存储</span></span><br><span class="line">      wx.setStorage(&#123;</span><br><span class="line">        key: 'userInfo',</span><br><span class="line">        data: obj,</span><br><span class="line">        success: function (res) &#123;</span><br><span class="line">          <span class="comment">// success</span></span><br><span class="line">          wx.navigateBack(&#123;</span><br><span class="line">            delta: <span class="number">1</span>, <span class="comment">// 回退前 delta(默认为1) 页面</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function () &#123;</span><br><span class="line">          <span class="comment">// fail</span></span><br><span class="line">          console.log('error');</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: function () &#123;</span><br><span class="line">          <span class="comment">// complete</span></span><br><span class="line">          console.log('complete');</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    wx.getStorage(&#123;</span><br><span class="line">      key: 'userInfo',</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        <span class="comment">// success</span></span><br><span class="line">        that.setData(&#123; userName: res.data.userName &#125;);</span><br><span class="line">        that.setData(&#123; userPass: res.data.userPass &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: function () &#123;</span><br><span class="line">        <span class="comment">// fail</span></span><br><span class="line">        console.log('error');</span><br><span class="line">      &#125;,</span><br><span class="line">      complete: function () &#123;</span><br><span class="line">        <span class="comment">// complete</span></span><br><span class="line">        console.log('complete');</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m2.gif" alt="微信小程序"></p><p>还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api：</p><blockquote><p>wx.removeStorage(OBJ)：异步移除某条数据。<br>wx.removeStorageSync(key)：同步移除某条数据。<br>wx.clearStorage()：异步清除所有数据。<br>wx.clearStorageSync()：同步清除所有数据。</p></blockquote><p>在之前的页面里加入一个清除本地缓存数据的一个按钮</p><p>index.js:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: 'Hello World',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function () &#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//页面跳转事件处理函数</span></span><br><span class="line">  bindViewLogin: function () &#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: '../login/login'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  clearData: function () &#123;</span><br><span class="line">    <span class="comment">//清除所有数据</span></span><br><span class="line">    wx.clearStorageSync();</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_1.png" alt="微信小程序"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是表单和本地数据存储的一些练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于&lt;code&gt;form&lt;/code&gt;组件、本地存储和页面的跳转和回退的小程序之旅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-集成第三方库</title>
    <link href="https://duanruilong.github.io/2018/06/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://duanruilong.github.io/2018/06/14/React开发常用设计模式-集成第三方库/</id>
    <published>2018-06-14T15:49:58.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png" alt="React"></p><a id="more"></a><h1 id="集成第三方库"><a href="#集成第三方库" class="headerlink" title="集成第三方库"></a>集成第三方库</h1><p>接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个示例挑选了 <a href="https://github.com/aehlke/tag-it" target="_blank" rel="noopener">tag-it</a> 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;JavaScript&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;CSS&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>转换成:</p><p><img src="http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png" alt="react"></p><p>要运行起来，需要引入 <code>jQueyr、jQuery UI 和 tag-it</code>插件。这是运行的代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$('&lt;dom element selector&gt;').tagit();</span><br></pre></td></tr></table></figure></p><p>选择 DOM 元素，然后调用 <code>tagit()</code> 。</p><p>现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tags.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; tags: ['JavaScript', 'CSS' ] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Tags tags=&#123; <span class="keyword">this</span>.state.tags &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.querySelector('#container'));</span><br></pre></td></tr></table></figure><p>App 类是入口。它使用了<code>Tags</code>组件，Tags 组件会根据传入的 <code>tags</code> 属性来展示无序列表。当 React 在页面上渲染列表时就有了<code>&lt;ul&gt;</code>标签，这样就可以和 <code>jQuery</code> 插件连接起来。</p><h2 id="强制单通道渲染"><a href="#强制单通道渲染" class="headerlink" title="强制单通道渲染"></a>强制单通道渲染</h2><p>首先，要做的就是强制 <code>Tags</code> 组件进行单通道渲染。这是因为当 React 在实际 <code>DOM</code>中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 <code>shouldComponentUpdate</code>，像这样:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 <code>shouldComponentUpdate</code> 对于 React 组件来说，是让其知道是否触发 <code>render</code> 方法。这适用于的场景，因为想使用 React 来添加 <code>HTML</code> 标记，添加完后就不想再依靠 React 。</p><h2 id="初始化插件"><a href="#初始化插件" class="headerlink" title="初始化插件"></a>初始化插件</h2><p>React 提供了 <a href="https://facebook.github.io/react/docs/refs-and-the-dom.html" target="_blank" rel="noopener">API</a> 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span> = $(<span class="keyword">this</span>.refs.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span>.tagit();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul ref='list'&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>上面的代码和 <code>shouldComponentUpdate</code> 一起使用就会使 React 渲染出有两项的 <code>&lt;ul&gt;</code>，然后 <code>tag-it</code> 会其转换成标签可编辑的插件。</p><h2 id="使用-React-控制插件"><a href="#使用-React-控制插件" class="headerlink" title="使用 React 控制插件"></a>使用 React 控制插件</h2><p>假如说我们想要通过代码来为已经运行的 <code>tag-it</code> 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 <code>Tags</code> 组件，但同时还要保持单通道渲染。</p><p>为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 <code>Tags</code> 组件。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._addNewTag = <span class="keyword">this</span>._addNewTag.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      tags: ['JavaScript', 'CSS' ],</span><br><span class="line">      newTag: null</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _addNewTag() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; newTag: <span class="keyword">this</span>.refs.field.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Add <span class="keyword">new</span> tag:&lt;/p&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input type='text' ref='field' /&gt;</span><br><span class="line">          &lt;button onClick=&#123; <span class="keyword">this</span>._addNewTag &#125;&gt;Add&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;Tags</span><br><span class="line">          tags=&#123; <span class="keyword">this</span>.state.tags &#125;</span><br><span class="line">          newTag=&#123; <span class="keyword">this</span>.state.newTag &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 <code>Tags</code> 组件的重新渲染。但由于 <code>shouldComponentUpdate</code>的存在，页面上不会有任何的更新。唯一的变化就是得到 <code>newTag</code>属性的新值，另一个生命周期方法 <code>componentWillReceiveProps</code> 会捕获到属性的新值:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">    this.list.tagit('createTag', newProps.newTag);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>.tagit(&#39;createTag&#39;, newProps.newTag)</code>是纯粹的 jQuery 代码。如果想调用第三方库的方法，<code>componentWillReceiveProps</code>是个不错的选择。</p><p>下面是 Tags 组件的完整代码:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span> = $(<span class="keyword">this</span>.refs.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span>.tagit();</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">    this.list.tagit('createTag', newProps.newTag);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul ref='list'&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        ) </span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>React 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-组件样式</title>
    <link href="https://duanruilong.github.io/2018/06/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F/"/>
    <id>https://duanruilong.github.io/2018/06/14/React开发常用设计模式-组件样式/</id>
    <published>2018-06-13T16:10:32.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png" alt="React"></p><a id="more"></a><h1 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h1><h2 id="经典-CSS-类"><a href="#经典-CSS-类" class="headerlink" title="经典 CSS 类"></a>经典 CSS 类</h2><p>JSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 <code>.css</code>文件中的。唯一需要注意的是 React 中使用的是 <code>className</code>，而不是 <code>class</code> 。例如:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 className='title'&gt;Styling&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inlineStyles = &#123;</span><br><span class="line">  color: 'red',</span><br><span class="line">  fontSize: '10px',</span><br><span class="line">  marginTop: '2em',</span><br><span class="line">  'border-top': 'solid 1px #000'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;h2 style=&#123; inlineStyles &#125;&gt;Inline styling&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">  fontFamily: 'Georgia',</span><br><span class="line">  color: 'blue'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> paragraphText = &#123;</span><br><span class="line">  ...theme,</span><br><span class="line">  fontSize: '20px'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>theme</code>中有一些基础样式，然后在 <code>paragraphText</code> 中混入 <code>theme</code> 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。</p><h2 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h2><p><a href="https://github.com/css-modules/css-modules/blob/master/docs/get-started.md" target="_blank" rel="noopener">CSS 模块</a> 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。</p><p>下面的示例可以让你快速对其运行原理有个大致的了解:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line">.title &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> styles from <span class="string">"./style.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1 style=&#123; styles.title &#125;&gt;Hello world&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。</p><p>当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">  composes: mainColor from <span class="string">"./brand-colors.css"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Styled-components"><a href="#Styled-components" class="headerlink" title="Styled-components"></a>Styled-components</h2><p><a href="https://www.styled-components.com/" target="_blank" rel="noopener">Styled-components</a> 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 <code>Link</code>组件，它具有特定的风格和用法，而再使用 <code>&lt;a&gt;</code>标签。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = styled.a`</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  padding: <span class="number">4</span>px;</span><br><span class="line">  border: solid <span class="number">1</span>px #<span class="number">999</span>;</span><br><span class="line">  color: black;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">&lt;Link href='http://google.com'&gt;Google&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AnotherLink = styled(Link)`</span><br><span class="line">  color: blue;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">&lt;AnotherLink href='http://facebook.com'&gt;Facebook&lt;/AnotherLink&gt;</span><br></pre></td></tr></table></figure></p><p>到目前为止 <code>styled-components</code> 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-依赖注入</title>
    <link href="https://duanruilong.github.io/2018/06/13/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>https://duanruilong.github.io/2018/06/13/React开发常用设计模式-依赖注入/</id>
    <published>2018-06-12T16:13:53.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 <a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank" rel="noopener">依赖注入</a> 的技术 (大多数人认为它是一种模式) 用来解决这种问题。</p><p>在 React 中，对依赖注入的需要是显而易见的。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png" alt="React"></p><a id="more"></a><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>来考虑下面的应用的组件树:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Title</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; title: 'React in patterns' &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>字符串 “React in patterns” 应该以某种方式到达 <code>Title</code> 组件。最直接的方式就从 <code>App</code> 传到 <code>Header</code>，再从 <code>Header</code> 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。</p><p>已经了解过 <a href="http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">高阶组件</a> ，它可以用来注入数据。来使用同样的技术来注入 title 变量:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inject.jsx</span></span><br><span class="line">const title = 'React in patterns';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">inject</span><span class="params">(Component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> class Injector extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; title &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import inject from './inject.jsx';</span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line">var EnhancedTitle = inject(Title);</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;EnhancedTitle /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>title</code>隐藏在了中间层 (高阶组件) ，在中间层将<code>title</code>属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。</p><h2 id="使用-React-context-16-3-之前的版本"><a href="#使用-React-context-16-3-之前的版本" class="headerlink" title="使用 React context (16.3 之前的版本)"></a>使用 React context (16.3 之前的版本)</h2><blockquote><p>在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。</p></blockquote><p>React 有 <code>context</code> 的概念。每个 React 组件都可以访问 <code>context</code>。它有些类似于 <a href="https://github.com/krasimir/EventBus" target="_blank" rel="noopener">事件总线</a> ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 <code>store</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 context 的地方</span></span><br><span class="line">var context = &#123; title: 'React in patterns' &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.<span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 context 的地方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    var title = <span class="keyword">this</span>.context.title;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Inject.contextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.<span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，需要使用<code>childContextTypes</code>和 <code>contextTypes</code> 来指定 <code>context</code>对象的具体签名。如果不指定的话，那么 <code>context</code> 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 <code>context</code>写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">register</span>(key, value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，回到示例中，App 组件应该是这样的:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import dependencies from './dependencies';</span><br><span class="line"></span><br><span class="line">dependencies.register('title', 'React in patterns');</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Title 组件通过 context 来获取数据:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Title.contextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>理想情况下，不想每次需要访问 <code>context</code>时都指定<code>contextTypes</code>。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用<code>this.context.get(&#39;title&#39;)</code> 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line">import wire from './wire';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Title</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default wire(Title, ['title'], function resolve(title) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; title &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>wire</code>函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 <code>mapper</code>的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。</p><p><code>wire</code> 函数的代码如下所示:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">wire</span><span class="params">(Component, dependencies, mapper)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">    render() &#123;</span><br><span class="line">      var resolved = dependencies.<span class="built_in">map</span>(</span><br><span class="line">        <span class="keyword">this</span>.context.get.bind(<span class="keyword">this</span>.context)</span><br><span class="line">      );</span><br><span class="line">      var props = mapper(...resolved);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> React.createElement(Component, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Inject.contextTypes = &#123;</span><br><span class="line">    data: React.PropTypes.object,</span><br><span class="line">    get: React.PropTypes.func,</span><br><span class="line">    <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Inject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>Inject</code> 是高阶组件，它可以访问 <code>context</code>并获取 <code>dependencies</code>数组中的所有项。<code>mapper</code> 函数接收 context 数据并将其转换成我们组建所需要的属性。</p><h2 id="使用-React-context-16-3-及之后的版本"><a href="#使用-React-context-16-3-及之后的版本" class="headerlink" title="使用 React context (16.3 及之后的版本)"></a>使用 React context (16.3 及之后的版本)</h2><p>Fackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。</p><p>还是使用同一个示例，让字符串抵达<code>&lt;Title&gt;</code>组件。</p><p>先来定义包含 <code>context</code>初始化的文件:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line">import &#123; createContext &#125; from 'react';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = Context.Provider;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure></p><p><code>createContext</code>返回的对象具有 <code>Provider 和 Consumer</code>属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。</p><p>假设说 App 组件是根组件。在此需要传入 <code>context</code>。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from './context';</span><br><span class="line"></span><br><span class="line">const context = &#123; title: 'React In Patterns' &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包装组件以及子组件现在共享同一个 context 。<code>&lt;Title&gt;</code>组件是需要 title 字符串的组件之一，所以要在组件中使用 <code>&lt;Consumer&gt;</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Consumer &#125; from './context';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Title</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;&#123;</span><br><span class="line">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class="line">    &#125;&lt;/Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，<code>Consumer</code>类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</p><p>新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。</p><h2 id="使用模块系统"><a href="#使用模块系统" class="headerlink" title="使用模块系统"></a>使用模块系统</h2><p>如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。</p><p>众所周知，JavaScript 中的典型模块系统具有缓存机制。在 <a href="https://nodejs.org/api/modules.html#modules_caching" target="_blank" rel="noopener">Node 官方文档</a> 中可以看到:</p><blockquote><p>模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象。<br>多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。</p></blockquote><p>这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 <a href="https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript" target="_blank" rel="noopener">单例</a>，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。</p><p>来创建一个新文件<code>di.jsx</code> ，它的代码如下所示:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var dependencies = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">register</span><span class="params">(key, dependency)</span> </span>&#123;</span><br><span class="line">  dependencies[key] = dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">fetch</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dependencies[key]) <span class="keyword">return</span> dependencies[key];</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error(`<span class="string">"$&#123; key &#125; is not registered as dependency.`);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export function wire(Component, deps, mapper) &#123;</span></span><br><span class="line"><span class="string">  return class Injector extends React.Component &#123;</span></span><br><span class="line"><span class="string">    constructor(props) &#123;</span></span><br><span class="line"><span class="string">      super(props);</span></span><br><span class="line"><span class="string">      this._resolvedDependencies = mapper(...deps.map(fetch));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">      return (</span></span><br><span class="line"><span class="string">        &lt;Component</span></span><br><span class="line"><span class="string">          &#123;...this.state&#125;</span></span><br><span class="line"><span class="string">          &#123;...this.props&#125;</span></span><br><span class="line"><span class="string">          &#123;...this._resolvedDependencies&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      );</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>将依赖保存在了 <code>dependencies</code>这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 <code>register 和 fetch</code>这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 <code>setter 和 getter</code>。再然后是 <code>wire</code>函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 <code>mapper</code> 函数来提取所需属性。</p><p>有了<code>di.jsx</code> 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line">import &#123; register &#125; from './di.jsx';</span><br><span class="line"></span><br><span class="line">register('my-awesome-title', 'React in patterns');</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line">import &#123; wire &#125; from './di.jsx';</span><br><span class="line"></span><br><span class="line">var Title = function(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title">wire</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Title,</span></span></span><br><span class="line">  ['my-awesome-title'],</span><br><span class="line">  title =&gt; (&#123; title &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果查看 Title.jsx 文件的话，可以看到实际的组件和 <code>wire</code> 存在于不同的文件中。这种方式让组件和 <code>mapper</code> 函数的单元测试更简单。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 &lt;a href=&quot;http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;依赖注入&lt;/a&gt; 的技术 (大多数人认为它是一种模式) 用来解决这种问题。&lt;/p&gt;
&lt;p&gt;在 React 中，对依赖注入的需要是显而易见的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-Redux</title>
    <link href="https://duanruilong.github.io/2018/06/11/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Redux/"/>
    <id>https://duanruilong.github.io/2018/06/11/React开发常用设计模式-Redux/</id>
    <published>2018-06-11T15:52:51.000Z</published>
    <updated>2018-12-18T03:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a> 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (<a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank" rel="noopener">视频</a>)。它类似于 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics" target="_blank" rel="noopener">Flux 架构</a> 并有很多共同点。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png" alt="React"></p><a id="more"></a><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Redux-架构及其主要特点"><a href="#Redux-架构及其主要特点" class="headerlink" title="Redux 架构及其主要特点"></a>Redux 架构及其主要特点</h2><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react_type/redux-architecture.jpg" alt="redux"></p><p>类似于 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md" target="_blank" rel="noopener">Flux</a> 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 <code>store</code>中。注意，我们说的是 <code>store</code>，而不是 <code>stores</code> ，这是因为在 <code>Redux</code> 中只有一个 <code>store</code> ，这是 <code>Redux</code> 与 <code>Flux</code> 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 <code>reducers</code> 。一旦 <code>store</code>接收到动作，它会将当前状态和给定动作发送给<code>reducer</code>并要求其返回一个新的状态。然后，在数据不可变的方式下， <code>reducer</code>需要返回新的状态。再然后， <code>store</code>更新自身的内部状态。最后，与 <code>store</code>连接的 <code>React</code>组件会重新渲染。</p><p>概念相当清晰并再次遵循了 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md" target="_blank" rel="noopener">单向数据流</a> 。我们来讨论每一个部分并引入一些支持 <code>Redux</code> 模式工作的新术语。</p><h2 id="动作-Actions"><a href="#动作-Actions" class="headerlink" title="动作 ( Actions )"></a>动作 ( Actions )</h2><p><code>Redux</code> 中的动作和 <code>Flux</code>一样，也只是有 <code>type</code>属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用像 <code>CHANGE_VISIBILITY</code> 这样的常量作为动作的类型是一种最佳实践。有很多支持 <code>Redux</code>的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。</p><p><code>visible</code> 属性是我们所提到过的元数据。它与 <code>Redux</code>本身无关，它表示应用中某处需要使用的数据。</p><p>每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 <code>action creators</code> 诞生的原因。<code>action creator</code> 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">changeVisibility(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// &#123; type: CHANGE_VISIBILITY, visible: false &#125;</span></span><br></pre></td></tr></table></figure></p><p>注意，将 <code>visible</code> 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p><code>Redux</code> 提供辅助函数 <code>createStore</code> 来创建 <code>store</code> 。它的函数签名如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from 'redux';</span><br><span class="line"></span><br><span class="line">createStore([reducer], [initial state], [enhancer]);</span><br></pre></td></tr></table></figure></p><p>正如之前所提到的，<code>reducer</code> 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 <code>store</code> 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数<code>enhancer</code>提供 API 来使用第三方的中间件来扩展<code>Redux</code>，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。</p><p>创建好的<code>store</code> 具有四个方法:<code>getState、dispatch、subscribe</code>和 <code>replaceReducer</code> 。其中最重要的或许就是<code>dispatch</code>:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(changeVisibility(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure></p><p>这里我们使用的是 <code>action creator</code>。我们将其结果 (即 action 对象) 传给 <code>dispatch</code>方法。然后，它会传播给应用中的 <code>reducers</code>。</p><p>在典型的<code>React</code>应用中，我们通常不会直接使用<code>getState 和 subscribe</code>，因为有辅助函数  可以将<code>组件</code>和 <code>store</code>联系起来并有效地订阅 <code>store</code> 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用<code>getState</code>。<code>replaceReducer</code>是一个高级 API ，它用来交互 <code>store</code>所使用的当前 <code>reducer</code> 。</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><code>reducer</code>函数大概是<code>Redux</code>中最精华的部分。<code>reducer</code>还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。</p><div class="note danger"><p>(1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 </p></div><div class="note danger"><p>(2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 </p></div><p>下面是个很简单的计数器 reducer :</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; value: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。</p><h2 id="连接-React-组件"><a href="#连接-React-组件" class="headerlink" title="连接 React 组件"></a>连接 React 组件</h2><p>如果是在 <code>React</code>上下文中讨论<code>Redux</code>的话，那基本离不开 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a> 模块。它提供两样东西来进行 <code>Redux</code> 到组件的连接。</p><blockquote><p>(1) <code>&lt;Provider&gt; 组件</code> - 它是一个组件，它接收 <code>store</code>并使得所有的子组件都可以通过 React 的 context API 来访问 <code>store</code>。</p></blockquote><p>例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store=&#123; myStore &#125;&gt;</span><br><span class="line">  &lt;MyApp /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure></p><p>通常，我们只在应用中的单个地方使用它。</p><blockquote><p>(2) <code>connect 函数</code> - 它是一个函数，它负责订阅 <code>store</code>的更新和重新渲染组件。它是通过 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component" target="_blank" rel="noopener">高阶组件</a> 实现的。</p></blockquote><p>这是它的函数签名:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connect(</span><br><span class="line">  [mapStateToProps],</span><br><span class="line">  [mapDispatchToProps],</span><br><span class="line">  [mergeProps],</span><br><span class="line">  [options]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>mapDispatchToProps</code>也是类似的，只是它接收的是 <code>dispatch</code>函数，而不是<code>state</code> 。这里是我们将派发动作定义成属性的地方。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">  changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>mergeProps</code>将 <code>mapStateToProps、 mapDispatchToProps</code>和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。<code>options</code> 接收一组如何控制连接的设置。</p><h2 id="使用-Redux-的简单计数器应用"><a href="#使用-Redux-的简单计数器应用" class="headerlink" title="使用 Redux 的简单计数器应用"></a>使用 Redux 的简单计数器应用</h2><p>使用上面所有的 API 来创建一个简单的计数器应用。<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react_type/redux-counter-app.png" alt="react"></p><p>“Add” 和 “Subtract” 按钮只是改变 <code>store</code> 的值。”Visible” 和 “Hidden” 按钮用来控制计数器是否显示。</p><h3 id="创建动作"><a href="#创建动作" class="headerlink" title="创建动作"></a>创建动作</h3><p>每个 <code>Redux</code> 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:<code>增加、减少和管理可见性</code>。所有动作代码如下所示:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ADD = 'ADD';</span><br><span class="line">const SUBTRACT = 'SUBTRACT';</span><br><span class="line">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = () =&gt; (&#123; type: ADD &#125;);</span><br><span class="line"><span class="keyword">const</span> subtract = () =&gt; (&#123; type: SUBTRACT &#125;);</span><br><span class="line"><span class="keyword">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Store-及其-reducers"><a href="#Store-及其-reducers" class="headerlink" title="Store 及其 reducers"></a>Store 及其 reducers</h3><p>在解释 <code>store</code> 和 <code>reudcers</code>时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。<code>store</code> 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  counter: &#123;</span><br><span class="line">    value: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  visible: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>需要为这两部分分别定义 <code>reducer</code>。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 <code>reducer</code> 函数来进行维护，这样管理起来将会非常困难。</p><p><code>Redux</code>提供辅助函数来让我们能够锁定<code>state</code>的某个特定部分并为其分配一个 <code>reducer</code>。它就是 <code>combineReducers</code> :<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, combineReducers &#125; from 'redux';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: function A() &#123; ... &#125;,</span><br><span class="line">  visible: function B() &#123; ... &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure></p><p>函数 A 只接收 <code>counter</code> 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。</p><p><code>counter</code> 切片的<code>reducer</code> 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 <code>counter</code> 状态。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state || &#123; value: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当 <code>store</code> 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 <code>{ type: &quot;@@redux/INIT&quot;}</code> 。在这个实例中，reducer 应该返回数据的初始值 <code>{ value: 0 }</code> 。</p><p>visible 的 reducer 相当简单，它只处理动作 <code>CHANGE_VISIBILITY</code> :<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visibilityReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === CHANGE_VISIBILITY) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.visible;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  visible: visibilityReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="选择器-Selectors"><a href="#选择器-Selectors" class="headerlink" title="选择器 ( Selectors )"></a>选择器 ( Selectors )</h3><p>我们知道状态通常都是细化成多个状态切片。我们有专门的 <code>reducer</code>来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCounterValue = state =&gt; state.counter.value;</span><br><span class="line"><span class="keyword">const</span> getVisibility = state =&gt; state.visible;</span><br></pre></td></tr></table></figure></p><p>这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。</p><h3 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h3><p>先来处理管理计数器可见性的 UI 部分。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Visibility</span><span class="params">(&#123; changeVisibility &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class="literal">true</span>) &#125;&gt;</span><br><span class="line">        Visible</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class="literal">false</span>) &#125;&gt;</span><br><span class="line">        Hidden</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibilityConnected = connect(</span><br><span class="line">  null,</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class="line">  &#125;)</span><br><span class="line">)(Visibility);</span><br></pre></td></tr></table></figure></p><p>第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Counter</span><span class="params">(&#123; value, add, subtract &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Value: &#123; value &#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123; add &#125;&gt;Add&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123; subtract &#125;&gt;Subtract&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterConnected = connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    value: getCounterValue(state)</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    add: () =&gt; dispatch(add()),</span><br><span class="line">    subtract: () =&gt; dispatch(subtract())</span><br><span class="line">  &#125;)</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure><p>这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: <code>value、add 和 subtract</code>。</p><p>最后要完成的就是 App 组件，我们在这里进行应用的组装。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">App</span><span class="params">(&#123; visible &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;VisibilityConnected /&gt;</span><br><span class="line">      &#123; visible &amp;&amp; &lt;CounterConnected /&gt; &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AppConnected = connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    visible: getVisibility(state)</span><br><span class="line">  &#125;)</span><br><span class="line">)(App);</span><br></pre></td></tr></table></figure><p>再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Redux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react_type/redux-reallife.jpg" alt="react"></p><p>顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。</p><p>我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://redux.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redux&lt;/a&gt; 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频&lt;/a&gt;)。它类似于 &lt;a href=&quot;https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flux 架构&lt;/a&gt; 并有很多共同点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(五)</title>
    <link href="https://duanruilong.github.io/2018/05/29/ES6%E6%94%BB%E7%95%A5-%E4%BA%94/"/>
    <id>https://duanruilong.github.io/2018/05/29/ES6攻略-五/</id>
    <published>2018-05-29T14:50:35.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h1><h2 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h2><p>这个方法其实是<code>es5</code>的，还是很好用的。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line">arr.forEach(function(val)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h2><p>它是将两类对象装换为真的数组：<code>类数组对象arguments</code>、<code>可遍历对象</code>（可数Object、Set、Map).</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let myObj = &#123;length:2,'0':'hello','1':'world'&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(myObj));</span><br><span class="line"><span class="comment">//[ 'hello', 'world' ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- Set --&gt;</span><br><span class="line"></span><br><span class="line">let mySet = <span class="keyword">new</span> Set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">mySet.add('hello');</span><br><span class="line">mySet.add('hello');</span><br><span class="line">mySet.add(NaN);</span><br><span class="line">mySet.add(NaN);</span><br><span class="line">mySet.add(undefined);</span><br><span class="line">mySet.add(undefined);</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(mySet));</span><br><span class="line"><span class="comment">//[ 1, 2, 3, 'hello', NaN, undefined ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- Map --&gt;</span><br><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.set(0,'hello');</span><br><span class="line">myMap.set(true,'world');</span><br><span class="line">myMap.set(1,'haha');</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(myMap));</span><br><span class="line"><span class="comment">//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- arguments --&gt;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(arguments));</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//[ 1, 3, 5 ]</span></span><br></pre></td></tr></table></figure><h2 id="find-和findindex"><a href="#find-和findindex" class="headerlink" title="find()和findindex()"></a>find()和findindex()</h2><p><code>find()</code>查找数组里符合条件的<code>第一个值</code><br><code>findindex()</code>是查找数组里符合条件的第一个索引的<code>下标</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- find() --&gt;</span><br><span class="line">console.<span class="built_in">log</span>([<span class="number">-1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">2</span>));</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">&lt;!-- findindex() --&gt;</span><br><span class="line">console.<span class="built_in">log</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(function(value, index, arr) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">4</span>;</span><br><span class="line"> <span class="comment">//5这个值的索引下标是1</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="fill-填充方法"><a href="#fill-填充方法" class="headerlink" title="fill()填充方法"></a>fill()填充方法</h2><p>将<code>空数组</code>填充固定的某一个值。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> Array(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//[ , , , ]</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> Array(<span class="number">4</span>).fill(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//[2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure><h2 id="lterator-遍历器"><a href="#lterator-遍历器" class="headerlink" title="lterator 遍历器"></a>lterator 遍历器</h2><p>使用最多的遍历器是：<code>for...in</code>和<code>for</code><br>前者是循环遍历<code>Object</code>对象，后者是遍历数组<br>在<code>ES6</code>里又新增加了2种数据结构：<code>Set</code>和<code>Map</code>。这里就用到了<code>lterator</code>，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用<code>for....of</code>循环。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.set(0,'hello');</span><br><span class="line">myMap.set(1,'world');</span><br><span class="line">myMap.set('hi','jack');</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(let v of myMap)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(v);</span><br><span class="line"> console.log(v[0]+'--'+v[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [0, "hello"]</span></span><br><span class="line"><span class="comment">    0--hello</span></span><br><span class="line"><span class="comment">    [1, "world"]</span></span><br><span class="line"><span class="comment">    1--world</span></span><br><span class="line"><span class="comment">    ["hi", "jack"]</span></span><br><span class="line"><span class="comment">    hi--jack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">let mySet = <span class="keyword">new</span> Set([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(let v of mySet)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p><code>Module</code>它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。</p><p>这里需要注意：<br><code>Node</code>环境下使用<code>export</code>和<code>require</code><br><code>前端JS</code>环境下使用<code>export</code>和<code>import</code>(需要babel等工具来解析)</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- foo.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出方法</span></span><br><span class="line"><span class="keyword">module</span>.exports.sayHi = function()&#123;</span><br><span class="line"> console.log('hello,world');</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象</span></span><br><span class="line"><span class="keyword">module</span>.exports.obj = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> constructor( name)&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> eat() &#123;</span><br><span class="line">  console.log(this.name+' eat');</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出一个类</span></span><br><span class="line"><span class="keyword">module</span>.exports.Person = Person;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- text.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入模块</span></span><br><span class="line">var text = require('./foo.js');</span><br><span class="line"><span class="comment">//使用模块</span></span><br><span class="line">text.sayHi();</span><br><span class="line">console.<span class="built_in">log</span>(text.obj.a);</span><br><span class="line"></span><br><span class="line">var p = new text.Person('jack');</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>在se6的语法下，需要babel 的支持。<br>1、安装</p><p><code>npm install   babel-preset-es2015</code><br><code>npminstall --global  babel-cli</code></p><p>2、配置.babelrc文件</p><p><code>{&quot;presets&quot;:[&quot;es2015&quot;]}</code></p><p>3、测试一下</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">export</span>.js --&gt;</span><br><span class="line"></span><br><span class="line">var yourname = 'Jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;yourname, age&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">import</span>.js --&gt;</span><br><span class="line"></span><br><span class="line">import &#123;yourname, age&#125; from './export.js';</span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(yourname,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行</p><p><code>babel export.js --out-file export_out.js</code><br><code>babel import.js --out-file import_out.js</code></p><p>运行结束之后，目录下增加了2个输出文件，<code>export_out.js</code>和<code>import_out.js</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  export_out.js--&gt;</span><br><span class="line"></span><br><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">Object.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">var yourname = 'Jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">exports.yourname = yourname;</span><br><span class="line">exports.age = age;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- import_out.js --&gt;</span><br><span class="line"></span><br><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">var _export = require('./export.js');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(_export.yourname, _export.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实翻译过来后，仍旧是<code>exports</code>和<code>require</code>！</p><p>5、在前端测试text.html</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;测试一下&lt;/title&gt;</span><br><span class="line">&lt;script src=<span class="string">"./import_out.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    say();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样是运行不了的，他们环境都不一样，怎么可能运行。<br><code>babel</code>只是一个编译工具，这里只是把es6编译为<code>common.js</code>规范的语法，<code>require</code>这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。</p><blockquote><p>common、cmd、amd:<br><code>cmd</code>是seajs遵循的规范<br><code>amd</code>是requirejs遵循的规范<br><code>commomJS</code>是node遵循的规范</p></blockquote><p>就需要加入<code>webpack</code>.</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>1、安装<br><code>npm install webpack -g (全局安装)</code><br><code>npm install webpack (本地安装)</code></p><p>2、运行编译<br><code>webpack import_out.js bundle.js</code></p><p>因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。</p><p>3、 再一次测试test.html</p><blockquote><p>会有错误抛出：say is not defined</p></blockquote><p>这个其实是模块化的问题，<code>say()</code>方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有<br><code>(function(modules) { ....... })();</code> 这就是一个自执行的封闭空间。<br>如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。<br>webpack有个<code>expose-loader</code>这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">var _export = require('./export.js');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(_export.yourname, _export.age);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 把say()方法挂到window下面 --&gt;</span><br><span class="line">window.say = say;</span><br></pre></td></tr></table></figure></p><p>然后再运行一下webpack命令：<br><code>webpack import_out.js bundle.js</code><br>好啦，你再运行下test.html，发现终于成功啦！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。</p><blockquote><p>参考原文：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&amp;hid=13&amp;sn=7b07c59cafcf19e4805a803bf9f34347&amp;scene=1&amp;devicetype=android-26&amp;version=26060637&amp;lang=zh_CN&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_be748ba8c36a&amp;wx_header=1" target="_blank" rel="noopener">ES6攻略</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(四)</title>
    <link href="https://duanruilong.github.io/2018/05/29/ES6%E6%94%BB%E7%95%A5-%E5%9B%9B/"/>
    <id>https://duanruilong.github.io/2018/05/29/ES6攻略-四/</id>
    <published>2018-05-28T16:09:06.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>之前的JS只提供了两种容器：<code>数组</code>和<code>对象</code>。es6又添加了另一种非常有用的数据结构：<code>Set</code>。他就是<code>集合</code>的意思，本身也是一种容器。<br>既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？<br>拿他跟数组比较的话，<code>Set</code>的最大的特点就是<code>每个值都是唯一的，不能有重复值</code>。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let container = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);<span class="comment">//可以直接传入数组进行初始化</span></span><br><span class="line">container.add(<span class="number">5</span>);<span class="comment">//添加元素</span></span><br><span class="line">container.<span class="keyword">delete</span>(<span class="number">5</span>);<span class="comment">//删除元素</span></span><br><span class="line">console.<span class="built_in">log</span>(container.has(<span class="number">5</span>));<span class="comment">//false，5这个元素被删除了</span></span><br><span class="line">console.<span class="built_in">log</span>(container);<span class="comment">//Set &#123; 1, 2, 3, 4 &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(container.size);<span class="comment">//长度4</span></span><br><span class="line">let unique_arr = [...container];<span class="comment">//省略号语法</span></span><br><span class="line">console.<span class="built_in">log</span>(unique_arr);<span class="comment">//唯一值数组：[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>Set的构造方法可以直接传数组进行初始化，当然也可以这样声明：<br><code>let mySet = new Set();</code></p><p>Set跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单去重方案</span></span><br><span class="line">var arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">console.<span class="built_in">log</span>([...<span class="keyword">new</span> Set(arr)]);<span class="comment">//一句话搞定</span></span><br></pre></td></tr></table></figure><p>这并不适用于含有<code>重复对象的数组</code>，因为对象是比较的是内存地址。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(&#123;&#125;==&#123;&#125;);<span class="comment">//false,内存地址不同</span></span><br><span class="line">let arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.<span class="built_in">log</span>([...<span class="keyword">new</span> Set(arr)]);<span class="comment">//对象是无法去重的</span></span><br></pre></td></tr></table></figure></p><p>对象数组到底如何去重呢？<br>一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用<code>Set</code>的不重复特性，把对象先转成字符串存入<code>Set</code>，去掉重复值后，再转回来就好。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">unique</span><span class="params">(arr)</span></span>&#123;</span><br><span class="line"> var container = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"> arr.forEach(function(val)&#123;</span><br><span class="line"><span class="comment">//将对象转换为字符串,存入set容器中，确保唯一性。</span></span><br><span class="line">  container.add(JSON.stringify(val));</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> var newarr = [...container].<span class="built_in">map</span>(function(item)&#123;</span><br><span class="line">   <span class="keyword">return</span> JSON.parse(item);<span class="comment">//转换回去</span></span><br><span class="line">  &#125;);</span><br><span class="line"> <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新数据结构：Map"><a href="#新数据结构：Map" class="headerlink" title="新数据结构：Map"></a>新数据结构：Map</h1><p>这个是<code>Map</code>容器，而不是前面的<code>map()</code>方法，千万别弄混了（注意大小写）！<code>Map</code>就是键值对容器，跟<code>Object</code>非常类似。它有什么特别之处呢？<br>其实<code>Object</code>有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。<br>如果让键不限于字符串，而是各种数据类型呢？比如num？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;<span class="built_in">map</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button id=<span class="string">"btn1"</span>&gt;提交&lt;/button&gt;</span><br><span class="line">            &lt;button id=<span class="string">"btn2"</span>&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;　　　</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dom1 = document.getElementById('btn1');</span><br><span class="line">    var dom2 = document.getElementById('btn2');</span><br><span class="line"></span><br><span class="line">    var callback1 = function()&#123;</span><br><span class="line">        alert('提交');</span><br><span class="line">    &#125;;</span><br><span class="line">    var callback2 = function()&#123;</span><br><span class="line">        alert('关闭');</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">    m.<span class="built_in">set</span>(dom1,callback1); <span class="comment">//键是dom</span></span><br><span class="line">    m.<span class="built_in">set</span>(dom2,callback2);</span><br><span class="line">    console.<span class="built_in">log</span>(m);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p><p>一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line"><span class="built_in">map</span>.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因为对象比较的是内存地址，所以<code>[&#39;a&#39;]</code>作为新开辟的空间，无法在<code>Map容器</code>中找到。</p><p>再来看一下Map的增查改删，非常简单。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用二维数组，可以构建Map</span></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> Map([</span><br><span class="line"> ['name', '张三'],</span><br><span class="line"> ['content', 'hello,world']</span><br><span class="line">]);</span><br><span class="line">console.<span class="built_in">log</span>(myMap);<span class="comment">//Map &#123; 'name' =&gt; '张三', 'content' =&gt; 'hello,world' &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(myMap.size); <span class="comment">// 长度</span></span><br><span class="line">myMap.set('age',18);//增加属性</span><br><span class="line">console.log(myMap.get('name')); //获取属性</span><br><span class="line">myMap.delete('content');//删除属性</span><br><span class="line">console.log(myMap.has('content')); // 判断是否有这个属性</span><br><span class="line">console.<span class="built_in">log</span>(myMap.keys());<span class="comment">//获取所有的键 MapIterator &#123; 'name', 'age' &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(myMap.values());<span class="comment">//获取所有的值 MapIterator &#123; '张三', 18 &#125;</span></span><br></pre></td></tr></table></figure><p>获取的keys集合是<code>MapIterator</code>类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构</p><h1 id="Reflect是面镜子"><a href="#Reflect是面镜子" class="headerlink" title="Reflect是面镜子"></a>Reflect是面镜子</h1><p><code>Reflect</code>就是反射的意思，那究竟反射啥呢？<br>大家知道镜子可以反射吧？<br><code>Reflect</code>就是一面镜子。那是谁照镜子呢？就是<code>Object</code>。<br>也就是说，<code>Object</code>把自己的属于语言内部的方法（比如Object.defineProperty）照到了<code>Reflect</code>上。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;利用反射实现数据和视图联动&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;测试Object：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;测试Reflect：&lt;input type="text" id='age'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"showName"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"showAge"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var userInfo = &#123;&#125;;</span><br><span class="line"><span class="comment">//Object的方式</span></span><br><span class="line">Object.defineProperty(userInfo, <span class="string">"userName"</span>, &#123;</span><br><span class="line">get: function()&#123;</span><br><span class="line">return document.getElementById('showName').innerHTML;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">document.getElementById('showName').innerHTML = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reflect是一面大镜子，Object你有的我就有！</span></span><br><span class="line">Reflect.defineProperty(userInfo, <span class="string">"age"</span>, &#123;</span><br><span class="line">get: function()&#123;</span><br><span class="line">return document.getElementById('showAge').innerHTML;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">document.getElementById('showAge').innerHTML = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class="line"></span><br><span class="line">userInfo.userName = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">document.getElementById('age').onkeyup = function(e)&#123;</span><br><span class="line"></span><br><span class="line">userInfo.age = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>Reflect</code>一共是13个静态方法，就是13种武器哈：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Reflect.apply(target,thisArg,args)</span><br><span class="line">Reflect.construct(target,args)</span><br><span class="line">Reflect.get(target,name,receiver)</span><br><span class="line">Reflect.<span class="built_in">set</span>(target,name,value,receiver)</span><br><span class="line">Reflect.defineProperty(target,name,desc)</span><br><span class="line">Reflect.deleteProperty(target,name)</span><br><span class="line">Reflect.has(target,name)</span><br><span class="line">Reflect.ownKeys(target)</span><br><span class="line">Reflect.isExtensible(target)</span><br><span class="line">Reflect.preventExtensions(target)</span><br><span class="line">Reflect.getOwnPropertyDescriptor(target, name)</span><br><span class="line">Reflect.getPrototypeOf(target)</span><br><span class="line">Reflect.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure></p></blockquote><p>看下几个常用的方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">name:'jack',</span><br><span class="line">age:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//简单set方法</span></span><br><span class="line">Reflect.set(obj,'name','tom');</span><br><span class="line">console.<span class="built_in">log</span>(obj.name);<span class="comment">//tom</span></span><br><span class="line"><span class="comment">//简单get方法</span></span><br><span class="line">let age = Reflect.get(obj,'age');</span><br><span class="line">console.<span class="built_in">log</span>(age);<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带有接收者对象的set方法</span></span><br><span class="line">let receiver = &#123;</span><br><span class="line">name:'lily'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。</span></span><br><span class="line"><span class="comment">//所以，obj的name属性还是tom，但接收者receiver的name被改变了。</span></span><br><span class="line"><span class="comment">//这种机制的作用是，可以在对象A中操作对象B。</span></span><br><span class="line">Reflect.set(obj,'name','bill',receiver);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.name);<span class="comment">//tom</span></span><br><span class="line">console.<span class="built_in">log</span>(receiver.name);<span class="comment">//bill</span></span><br><span class="line"><span class="comment">//判断obj是否有name属性？</span></span><br><span class="line"><span class="comment">//旧写法--in</span></span><br><span class="line">console.log('name' in obj);//true</span><br><span class="line"><span class="comment">//新写法--has</span></span><br><span class="line">console.log(Reflect.has(obj,'name'));//true</span><br></pre></td></tr></table></figure><p>他与<code>Proxy</code>结合使用更合理。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code>就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟<code>Reflect</code>是一一对应的。<br>只要<code>Proxy</code>对象有的方法，<code>Reflect</code>对象上都有。当然咯，<code>Proxy</code>没有的，<code>Reflect</code>也有。</p><p>拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：<br><code>var proxy = new Proxy(target, handler);</code></p><blockquote><p>1.target就是目标对象，我们要给哪个对象加拦截？<br>2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。</p></blockquote><p>拿最简单的set方法为例:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参说明：</span></span><br><span class="line"><span class="comment">// target:待测试的Person实例</span></span><br><span class="line"><span class="comment">// validator:验证规则personValidators</span></span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createValidator</span><span class="params">(target, validator)</span> </span>&#123;</span><br><span class="line"><span class="comment">//拦截器，拦截赋值操作，触发set函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Proxy(target, &#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">set</span>(target, key, value) &#123;</span><br><span class="line"><span class="comment">//如果待测试的Person对象中含有这个属性，就启用验证规则，</span></span><br><span class="line"><span class="comment">// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。</span></span><br><span class="line">  <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line"></span><br><span class="line">    let rules = validator[key];<span class="comment">//rules拿到的是name方法的引用</span></span><br><span class="line"><span class="comment">//相当于调用方法name('hello')</span></span><br><span class="line">    <span class="keyword">if</span> (rules(value)) &#123;</span><br><span class="line"><span class="comment">//如果验证无误，target的name属性可以修改成功</span></span><br><span class="line">     <span class="keyword">return</span> Reflect.<span class="built_in">set</span>(target, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则失败</span></span><br><span class="line">      return 'error';</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     return 'error';</span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证规则</span></span><br><span class="line"><span class="keyword">const</span> personRules = &#123;</span><br><span class="line"> name(val) &#123;</span><br><span class="line">   return typeof val === 'string';</span><br><span class="line"> &#125;,</span><br><span class="line"> age(val) &#123;</span><br><span class="line">   return typeof val === 'number' &amp;&amp; val &gt; 18;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> constructor(name, age) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="comment">//开启验证，传入这个类的实例和验证规则personRules</span></span><br><span class="line">   <span class="keyword">return</span> createValidator(<span class="keyword">this</span>, personRules);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bill = new Person('Bill', 25);</span><br><span class="line">bill.name = 'jack';//赋值成功</span><br><span class="line">bill.age = <span class="number">10</span>;<span class="comment">//赋值失败</span></span><br><span class="line">console.<span class="built_in">log</span>(bill.name);<span class="comment">//jack</span></span><br><span class="line">console.<span class="built_in">log</span>(bill.age);<span class="comment">//25</span></span><br></pre></td></tr></table></figure><p><code>createValidator</code>这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。</p><p>再来看下<code>Reflect.apply</code>的用法。这个方法的使用频率还是蛮高的</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如这个foo函数是同事张三写的</span></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//李四引入并使用了这个函数</span></span><br><span class="line">foo.apply(obj);</span><br><span class="line"><span class="comment">//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。</span></span><br><span class="line"><span class="comment">//可以在不依赖函数名的情况下改变函数的作用域么？</span></span><br><span class="line">Function.prototype.apply.call(foo,obj);</span><br><span class="line"><span class="comment">//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。</span></span><br><span class="line">Reflect.apply(foo,obj,[]);<span class="comment">//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>Proxy</code>是用于修改语言内部行为的机制，因为<code>Object</code>对象内部的方法大多属于这种情况，所以<code>handler</code>的配置，又跟<code>Reflect</code>紧密联系在一起（因为Reflect是Object的镜子嘛）。<br>应该说，<code>Reflect</code>和<code>Proxy</code>之间的关系还是不太容易理顺的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(三)</title>
    <link href="https://duanruilong.github.io/2018/05/28/ES6%E6%94%BB%E7%95%A5-%E4%B8%89/"/>
    <id>https://duanruilong.github.io/2018/05/28/ES6攻略-三/</id>
    <published>2018-05-28T15:54:45.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p><code>es6</code>的<code>promise</code>写法还是不够优雅，因为后面会跟很多<code>then()</code>。应该说，<code>async/await</code>是目前解决回调问题最好的方案了。</p><blockquote><p>a:<code>async</code>函数是什么？<br>b:一句话，它就是 <code>Generator</code> 函数的语法糖。<br>a:而<code>Generator</code>又是神马？<br>b:是<code>es6</code>的一个语法。<br>a:这个语法干嘛的？<br>b:不用管它，只需要把async搞明白。</p></blockquote><p>要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是<code>10.*</code>，稳定版出到<code>8.*</code>，所以安装好就可以使用了。</p><p>使用<code>async/await</code>的目的就是去除掉<code>Promise</code>后面的<code>then()</code>,在并行下也没有<code>then()</code>的，主要是串行，就是互相依靠的请求方式。</p><ul><li>假设有三个请求：<br>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。</li></ul><p>那么，如果可以这么写就好了：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var userid = getRequest1();</span><br><span class="line">var ssoid = getRequest2(userid);</span><br><span class="line">var res = getRequest3(userid,ssoid);</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">res.then(function(data)&#123;console.<span class="built_in">log</span>(data);&#125;);</span><br></pre></td></tr></table></figure><p>把之前es6的写法改一下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var request = require('request');</span><br><span class="line">var urls = [</span><br><span class="line">'http://localhost:3000/hello1',</span><br><span class="line">'http://localhost:3000/hello2',</span><br><span class="line">'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"><span class="comment">//创建任务函数不变</span></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"> var callback = function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//布置任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//返回promise承诺</span></span><br><span class="line"> <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明async函数，返回的一定是promise对象</span></span><br><span class="line"><span class="function">async function <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line"> var data_userid = await createPromise(urls[<span class="number">0</span>]);<span class="comment">//第一个请求任务</span></span><br><span class="line"> data_userid = JSON.parse(data_userid);<span class="comment">//解析成对象</span></span><br><span class="line"> var userid = data_userid.userid;<span class="comment">//获取userid</span></span><br><span class="line"> var data_ssoid = await createPromise(urls[<span class="number">1</span>]+<span class="string">"?userid="</span>+userid);<span class="comment">//第二个请求任务</span></span><br><span class="line"> data_ssoid = JSON.parse(data_ssoid);<span class="comment">//解析成对象</span></span><br><span class="line"> var ssoid = data_ssoid.ssoid;<span class="comment">//获取ssoid</span></span><br><span class="line"> var result = await createPromise(urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid);//第三个请求任务</span><br><span class="line"> <span class="keyword">return</span> result;<span class="comment">//返回promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终执行</span></span><br><span class="line">doIt().then(function(data)&#123;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line">console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p><blockquote><p>注意：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>async需要放在函数声明前，表示这个函数返回的一定是promise对象。</span><br><span class="line"><span class="number">2.</span>await后面也必须是promise对象，表示这个任务是需要等待的。</span><br><span class="line"><span class="number">3.</span>最后用then()获取所有接口的信息，<span class="keyword">catch</span>()捕获所有异常。</span><br><span class="line"><span class="number">4.</span>这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！</span><br><span class="line"></span><br><span class="line">这样，简单整洁，只留一个then和<span class="keyword">catch</span>。</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(二)</title>
    <link href="https://duanruilong.github.io/2018/05/28/ES6%E6%94%BB%E7%95%A5-%E4%BA%8C/"/>
    <id>https://duanruilong.github.io/2018/05/28/ES6攻略-二/</id>
    <published>2018-05-28T15:36:57.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p><code>回调</code>使我们时常需要面对的问题，现在<code>node</code>已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于<code>babel</code>去编译。</p><p>关于es6的pormise他就是一个对象，看下面：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对比一下他们的差异 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//布置一项任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line"><span class="comment">// ... some code</span></span><br><span class="line"><span class="comment">//resolve和reject是对象提供的两个回调函数</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">   resolve(value);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">promise.then(function(data) &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从中可以看出，他和<code>Q</code>模块有点类似，比如：<br><code>var deferred = Q.defer()</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var request = require('request');</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line">var callback = function(resolve, reject)&#123;</span><br><span class="line"> var url = 'http://localhost:3000/hello1';</span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//布置一项任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">promise.then(function(data)&#123;</span><br><span class="line"><span class="comment">//正确响应</span></span><br><span class="line"> console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"> console.log('error info:',err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果"></p><p>将url地址<a href="http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：" target="_blank" rel="noopener">http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：</a></p><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果"></p><p>再一次修改一下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">'http://localhost:3000/hello1',</span><br><span class="line">'http://localhost:3000/hello2',</span><br><span class="line">'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"><span class="comment">//这里需要改写一下~~</span></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"> var callback = function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//布置任务</span></span><br><span class="line"> var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//返回promise承诺</span></span><br><span class="line"> <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个请求的回调</span></span><br><span class="line">var callback_Request1 = function(data)&#123;</span><br><span class="line">data = JSON.parse(data);</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">var userid = data.userid;</span><br><span class="line">var url = urls[1]+'?userid='+userid;</span><br><span class="line"><span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个请求的回调</span></span><br><span class="line">var callback_Request2 = function(data)&#123;</span><br><span class="line">data = JSON.parse(data);</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">var userid = data.userid;</span><br><span class="line">var ssoid = data.ssoid;</span><br><span class="line">var url = urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid;</span><br><span class="line"><span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务逻辑被剥离出去咯~~</span></span><br><span class="line">createPromise(urls[<span class="number">0</span>]).then(function(data)&#123;</span><br><span class="line">console.log('第一次请求');</span><br><span class="line"><span class="keyword">return</span> callback_Request1(data);</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">console.log('第二次请求');</span><br><span class="line"><span class="keyword">return</span> callback_Request2(data);</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">console.log('第三次请求');</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(一)</title>
    <link href="https://duanruilong.github.io/2018/05/27/ES6%E6%94%BB%E7%95%A5-%E4%B8%80/"/>
    <id>https://duanruilong.github.io/2018/05/27/ES6攻略-一/</id>
    <published>2018-05-27T13:33:27.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>两个很有用的原生JS函数：<code>map</code>和<code>reduce</code>。</p><ul><li>1、map() 方法：</li></ul><p>它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var callback = function(a)&#123;</span><br><span class="line">    <span class="comment">// 这里的a就是数组每一项的值</span></span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var demo = data.<span class="built_in">map</span>(callback);</span><br><span class="line">consloe.<span class="built_in">log</span>(demo)</span><br><span class="line"><span class="comment">//[2,3,4]</span></span><br></pre></td></tr></table></figure><p>在这里需要注意的是<code>map</code>里面的回调函数，参数只有一个</p><ul><li>2、reduce()方法</li></ul><p>这个方法先从代码例子开始<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var callback = function(a,b)&#123;</span><br><span class="line">    console.log('初始值=',a);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">var demo = data.reduce(callback,<span class="number">100</span>);</span><br><span class="line">console.<span class="built_in">log</span>(demo);</span><br><span class="line"><span class="comment">//初始值=100</span></span><br><span class="line"><span class="comment">//初始值=101</span></span><br><span class="line"><span class="comment">//初始值=103</span></span><br><span class="line"><span class="comment">//106</span></span><br></pre></td></tr></table></figure></p><p>reduce它有2个参数：</p><ul><li>第一个是<code>callback</code>回调函数，主要是针对数组的操作；</li><li>第二个是传入的<code>初始值</code></li></ul><p>工作原理：</p><ul><li>1、传入一个初始值；</li><li>2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；</li><li>3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；</li><li>…..</li></ul><p>依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。<br>这和<code>ajax</code>的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个<code>并行</code>，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者<br><code>Q模块</code>是用来解决回调问题，与之类似的有<code>jQuery</code>的延迟对象，ES6的<code>promise</code>对象，ES7的<code>async</code>和<code>await</code>.<br>可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。</p><blockquote><p>爬虫的工作原理：</p></blockquote><p>先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。</p><p>先安装一个发送请求模块<code>request</code>和Q模块：</p><blockquote><p><code>npm install request --dev</code><br><code>npm install q --dev</code></p></blockquote><p>然后开始写个脚本，先用<code>express</code>搭建一个服务：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express')</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET home page</span></span><br><span class="line">router.get('./',function(req,res,next)&#123;</span><br><span class="line">res.render('index',&#123;title:'Express'&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求1</span></span><br><span class="line">router.get('/list1',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求1完成了！')</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求2</span></span><br><span class="line">router.get('/list2',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求2完成了！')</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求3</span></span><br><span class="line">router.get('/list3',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求3完成了！')</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><p>以上为数据接口。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line">    var deferred = Q.defer(); <span class="comment">// 创建任务</span></span><br><span class="line"></span><br><span class="line">    request(url, function(err,response,body)&#123;</span><br><span class="line">        console.log('requested',url);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            deferred.reject(err); <span class="comment">// 错误返回</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            deferred.resolve(body) <span class="comment">// 成功返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> deferred.promise; <span class="comment">// 返回一个承诺</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createPromise('http://localhost:3000/list1').then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>resolve</code>就是继续执行，<code>reject</code>就是拒绝，<code>defer</code>就是布置任务。<br>Q把每一个请求都会布置成一个任务，然后返回一个<code>promise</code>对象，<code>promise</code>就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从<code>then()</code>方法里面拿到需要的数据。</p></blockquote><p>并行请求：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3',</span><br><span class="line">    'http//localhost:3000/hello_110' //这是个错误的地址</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer(); <span class="comment">//创建任务</span></span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"requested "</span> + url);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            deferred.reject(err); <span class="comment">//错误返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferred.resolve(body); <span class="comment">//成功返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise; <span class="comment">//返回一个承诺</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var promises = urls.<span class="built_in">map</span>(function (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q.allSettled(promises).then(function (results) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(results);</span><br><span class="line">    results.forEach(function (result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === <span class="string">"fulfilled"</span>) &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(result.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            console.error(result.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用<code>map()</code>方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）</p><p>串行请求。先来个传统写法:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">request('http://localhost:3000/hello1' , function(err1 , response1 , body1)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(body1);</span><br><span class="line"> request('http://localhost:3000/hello2',function(err2 , response2 , body2)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(body2);</span><br><span class="line">    request('http://localhost:3000/hello3',function(err3 , response3 , body3)&#123;</span><br><span class="line">      console.<span class="built_in">log</span>(body3);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。<br>Q是如何解决回调地狱问题的呢？<br>其实也简单，就是把发请求部分单独拆出去，做成子任务即可。<br>前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3',</span><br><span class="line">    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer();</span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            deferred.reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            deferred.resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是亮点~~</span></span><br><span class="line">urls.reduce(function (promiseObj, url) &#123;</span><br><span class="line">    <span class="comment">//promiseObj第一次是Q(null)，也就是空的任务</span></span><br><span class="line">    <span class="keyword">return</span> promiseObj.then(function (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回promise，层级传递，直到最后一个拿到结果</span></span><br><span class="line">        <span class="keyword">return</span> createPromise(url);</span><br><span class="line">    &#125;, function (err) &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">        <span class="keyword">return</span> createPromise(url);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, Q(null));</span><br></pre></td></tr></table></figure><blockquote><p>比较难理解的还是reduce。我们这里再来分析一遍他：<br>第1步：给定一个初始值Q(null)。<br>第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。<br>第3步：把第2步的结果<code>Q(&#39;http://localhost:3000/hello1&#39;)</code>作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。</p></blockquote><p>现实中我们需求一般是这样的：</p><blockquote><p>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。<br>我们根据这种情况，再来一次：<br>改造下接口：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, function (req, res, next) &#123;</span><br><span class="line">    res.render('index', &#123;</span><br><span class="line">        title: 'Express'</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求1</span></span><br><span class="line">router.get('/hello1', function (req, res, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: <span class="number">123</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求2</span></span><br><span class="line">router.get('/hello2', function (req, res, next) &#123;</span><br><span class="line">    var param = req.query || req.params;</span><br><span class="line">    var userid = param.userid;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: userid,</span><br><span class="line">            ssoid: <span class="number">456</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求3</span></span><br><span class="line">router.get('/hello3', function (req, res, next) &#123;</span><br><span class="line">    var param = req.query || req.params;</span><br><span class="line">    var userid = param.userid;</span><br><span class="line">    var ssoid = param.ssoid;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: userid,</span><br><span class="line">            ssoid: ssoid,</span><br><span class="line">            msg: '完成啦！'</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p></blockquote><p>其次：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer();</span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            deferred.reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            deferred.resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个请求的回调</span></span><br><span class="line">var callback_Request1 = function (data) &#123;</span><br><span class="line">    data = JSON.parse(data);</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">    var userid = data.userid;</span><br><span class="line">    var url = urls[1] + '?userid=' + userid;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个请求的回调</span></span><br><span class="line">var callback_Request2 = function (data) &#123;</span><br><span class="line">    data = JSON.parse(data);</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">    var userid = data.userid;</span><br><span class="line">    var ssoid = data.ssoid;</span><br><span class="line">    var url = urls[2] + '?userid=' + userid + '&amp;ssoid=' + ssoid;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务逻辑被剥离出去咯~~</span></span><br><span class="line">createPromise(urls[<span class="number">0</span>]).then(function (data) &#123;</span><br><span class="line">    console.log('第一次请求');</span><br><span class="line">    <span class="keyword">return</span> callback_Request1(data);</span><br><span class="line">&#125;).then(function (data) &#123;</span><br><span class="line">    console.log('第二次请求');</span><br><span class="line">    <span class="keyword">return</span> callback_Request2(data);</span><br><span class="line">&#125;).then(function (data) &#123;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    console.log('第三次请求');</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略</title>
    <link href="https://duanruilong.github.io/2018/05/25/ES6%E6%94%BB%E7%95%A5/"/>
    <id>https://duanruilong.github.io/2018/05/25/ES6攻略/</id>
    <published>2018-05-24T16:17:09.000Z</published>
    <updated>2018-12-18T03:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="搞定变量作用域问题：let"><a href="#搞定变量作用域问题：let" class="headerlink" title="搞定变量作用域问题：let"></a>搞定变量作用域问题：let</h1><p>ES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。<br>es6引入了let这个关键字，问题得到了解决：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let i=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//循环语句1</span></span><br><span class="line"><span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br><span class="line"><span class="comment">//循环语句2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    let i=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br><span class="line"><span class="comment">//分支语句</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    let i=<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    let i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br></pre></td></tr></table></figure></p><p>let关键字让变量作用域变得清晰可控</p><h1 id="利用const，保证全局变量不被更改"><a href="#利用const，保证全局变量不被更改" class="headerlink" title="利用const，保证全局变量不被更改"></a>利用const，保证全局变量不被更改</h1><p>有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">"jack"</span>;</span><br><span class="line"><span class="comment">//重新声明</span></span><br><span class="line">var username = 'hello';</span><br><span class="line"><span class="comment">//直接修改</span></span><br><span class="line">username = <span class="number">123</span>;</span><br><span class="line">console.<span class="built_in">log</span>(username);</span><br></pre></td></tr></table></figure></p><h1 id="类的声明与继承"><a href="#类的声明与继承" class="headerlink" title="类的声明与继承"></a>类的声明与继承</h1><p>按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到<code>高内聚低耦合</code>的设计目的。<br>其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。<br>而es6引入了静态语言的<code>class</code>之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="comment">//构造函数，注意函数之间不用加;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line">  this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  console.log(this.type + ' says ' + say);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hello'); //animal says hello</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line"> super();<span class="comment">//继承了父类的属性和方法</span></span><br><span class="line"> this.type = 'cat';</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.says('hello'); //cat says hello</span><br></pre></td></tr></table></figure></p><h1 id="箭头函数，解决this指向问题"><a href="#箭头函数，解决this指向问题" class="headerlink" title="箭头函数，解决this指向问题"></a>箭头函数，解决this指向问题</h1><p>JS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line"> this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">   console.log(this.type + ' says ' + say);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hi'); //undefined says hi</span><br></pre></td></tr></table></figure></p><p>这是一个比较经典的this被篡改的问题，因为这个该死的<code>setTimeout</code>函数，他的<code>this</code>指向的是window对象。<br>我们可以利用一个变量保存住这个<code>this</code>指针，也或者使用<code>bind(this)</code>方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line">  this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  setTimeout( () =&gt; &#123;</span><br><span class="line">   console.log(this.type + ' says ' + say);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hi'); //animal says hi</span><br></pre></td></tr></table></figure></p><h1 id="插入大段html文本"><a href="#插入大段html文本" class="headerlink" title="插入大段html文本"></a>插入大段html文本</h1><p>这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟<code>html</code>拼接好，最后追加到某个div下。<br>拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。<br>如果能不改变html的结构就好了！于是es6引入了<code>模板字串</code>的概念。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"container"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var cont = document.getElementById('container');</span><br><span class="line"><span class="comment">//一些变量</span></span><br><span class="line">var name = 'jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line">cont.innerHTML =</span><br><span class="line"> `&lt;div style=<span class="string">"color:red;"</span>&gt;</span><br><span class="line">   &lt;span class=<span class="string">"name"</span>&gt;$&#123;name&#125;&lt;/span&gt;</span><br><span class="line">   &lt;b class=<span class="string">"age"</span>&gt;$&#123;age&#125;&lt;/b&gt;</span><br><span class="line">  &lt;/div&gt;`;</span><br></pre></td></tr></table></figure></p><p>在<code>反引号</code>中随意使用各种引号，其中的变量都用<code>${}</code>来表示。这样代码就变得优雅了。</p><h1 id="默认值default"><a href="#默认值default" class="headerlink" title="默认值default"></a>默认值default</h1><p>有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。<br>那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">hello</span><span class="params">(name)</span></span>&#123;</span><br><span class="line"> name = name || 'jack';</span><br><span class="line"></span><br><span class="line"> console.log(name+' say hello!');</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure></p><p>但这样写不够直观，es6提供了默认值的写法。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name ='jack')&#123;</span><br><span class="line"> console.log(name + ' say hello!');</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure></p><h1 id="省略号语法"><a href="#省略号语法" class="headerlink" title="省略号语法"></a>省略号语法</h1><p>省略号是一种语法糖，在处理函数不定参时十分有用。<br>像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">hello</span><span class="params">(a,b,...others)</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(others);<span class="comment">//[ 'amily', 'mike', 'sam' ]</span></span><br><span class="line">&#125;</span><br><span class="line">hello('jack','tom','amily','mike','sam');</span><br></pre></td></tr></table></figure></p><h1 id="Object几个好用的扩展"><a href="#Object几个好用的扩展" class="headerlink" title="Object几个好用的扩展"></a>Object几个好用的扩展</h1><blockquote><p>Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。</p></blockquote><ul><li>1.<code>assign()</code>方法：用于对象的合并或拷贝。<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象合并</span></span><br><span class="line">var target = &#123;a:<span class="number">1</span>&#125;;</span><br><span class="line">var source = &#123;b:<span class="number">2</span>&#125;;</span><br><span class="line">Object.assign(target,source);</span><br><span class="line">console.<span class="built_in">log</span>(target);<span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，拷贝是浅拷贝，而不是深拷贝。</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象拷贝，是浅拷贝。</span></span><br><span class="line">let target = &#123; a: &#123; b: 'hello'&#125; &#125;;</span><br><span class="line">let source = &#123; c: &#123; d: 'world' &#125; &#125;;</span><br><span class="line">Object.assign(target, source);</span><br><span class="line">console.<span class="built_in">log</span>(target);<span class="comment">//&#123; a: &#123; b: 'hello' &#125;, c: &#123; d: 'world' &#125; &#125;</span></span><br><span class="line">target.c.d = 'haha';</span><br><span class="line">console.<span class="built_in">log</span>(source);<span class="comment">//&#123; c: &#123; d: 'haha' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。<br>究竟是用哪种拷贝，得看实际应用场景。</p><ul><li>2.<code>defineProperty()</code>方法：双向绑定的秘密！</li></ul><p>在angular或vue等框架里，对双向绑定并不陌生。<br>数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？<br>我们可以通过这个es6新提供的方法轻松搞定它。<br>先来看一下用法：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor) </span><br><span class="line">obj：待修改的对象。</span><br><span class="line">prop：待修改的属性名称。</span><br><span class="line">descriptor：待修改属性的相关描述，要求传入一个对象。</span><br><span class="line">&#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: '',</span><br><span class="line">    <span class="built_in">set</span>: function()&#123;&#125;,</span><br><span class="line">    get: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ <span class="keyword">delete</span> ），是否可以修改属性的 writable 、 enumerable 属性。</span><br><span class="line">- enumerable：属性是否可遍历出来（可通过 <span class="keyword">for</span>...in 遍历到）。</span><br><span class="line">- writable：属性是否可重写（是否可以对属性进行重新赋值？）</span><br><span class="line">- value：属性的默认值。</span><br><span class="line">- <span class="built_in">set</span>：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。</span><br><span class="line">- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。</span><br></pre></td></tr></table></figure></p><p>看个例子：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性name，值为jack</span></span><br><span class="line">Object.defineProperty(obj, 'name', &#123;</span><br><span class="line"> value: 'jack'</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性age，值为100</span></span><br><span class="line">Object.defineProperty(obj, 'age', &#123;</span><br><span class="line"> value: <span class="number">100</span>,</span><br><span class="line"> configurable: <span class="literal">true</span>,<span class="comment">//可配置</span></span><br><span class="line"> enumerable: <span class="literal">true</span>,<span class="comment">//可遍历出来</span></span><br><span class="line"> writable: <span class="literal">true</span><span class="comment">//可写</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.age); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">18</span>;<span class="comment">//重写</span></span><br><span class="line">console.<span class="built_in">log</span>(obj.age); <span class="comment">// 18. 因为age属性是可重写的</span></span><br><span class="line"><span class="comment">//遍历obj</span></span><br><span class="line"><span class="keyword">for</span>(let key in obj)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(key+<span class="string">":"</span>+obj[key]);<span class="comment">//age:18，默认是不可配置的，所以name读不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性sex，值为male</span></span><br><span class="line">Object.defineProperty(obj, 'sex', &#123;</span><br><span class="line"> value: 'male',</span><br><span class="line"> writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.sex = 'female'; // 不可重写</span><br><span class="line">console.<span class="built_in">log</span>(obj.sex); <span class="comment">// 'male'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.sex; <span class="comment">// 属性删除无效，默认是不可配置的</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.sex);<span class="comment">// 'male'，依然可以读出</span></span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, 'weight', &#123;</span><br><span class="line"><span class="comment">//value: '75kg',//如果打开这个value就会报错</span></span><br><span class="line"> <span class="built_in">set</span>: function(str) &#123;</span><br><span class="line">console.log('set weight',str);</span><br><span class="line">&#125;,</span><br><span class="line"> get:function()&#123;</span><br><span class="line">console.log('get weight');</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。<br>下面就来看一下如何实现一个数据和视图双向绑定效果。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;数据和视图联动&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;测试用户名：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"show"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var userInfo = &#123;&#125;;</span><br><span class="line">Object.defineProperty(userInfo, <span class="string">"userName"</span>, &#123;</span><br><span class="line"> get: function()&#123;</span><br><span class="line">  return document.getElementById('show').innerHTML;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">  document.getElementById('show').innerHTML = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class="line"><span class="comment">//改变数据，触发set方法，从而改变了视图。</span></span><br><span class="line"> userInfo.userName = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/es6/es6_1.png" alt="运行效果："></p><ul><li>3.对象简写<br>es6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> name:'jack',</span><br><span class="line"> age:<span class="number">18</span>,</span><br><span class="line"> method() &#123;</span><br><span class="line">   return this.name+'--'+this.age;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(obj.method());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端面试集锦</title>
    <link href="https://duanruilong.github.io/2018/05/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"/>
    <id>https://duanruilong.github.io/2018/05/24/前端面试集锦/</id>
    <published>2018-05-24T14:30:17.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png" alt="js"></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>一些更新从最新的开始</p></blockquote><h1 id="Ract"><a href="#Ract" class="headerlink" title="Ract"></a>Ract</h1><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期?"></a>React生命周期?</h2><h3 id="React-生命周期分为三种状态-1-初始化-2-更新-3-销毁"><a href="#React-生命周期分为三种状态-1-初始化-2-更新-3-销毁" class="headerlink" title="React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁"></a>React 生命周期分为三种状态 <code>1. 初始化</code> <code>2.更新</code> <code>3.销毁</code></h3><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png" alt="react生命周期"></p><!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) --><blockquote><p>初始化</p></blockquote><p>1、<code>getDefaultProps()</code> 设置默认的props，也可以使用<code>dufaultProps</code>设置组件的默认属性<br>2、<code>getInitialState()</code>在es6的class语法里是没有这个函数的，可直接在<code>construction</code>里去定义<code>this.state</code>也就可以访问到<code>this.props</code><br>3、<code>compontentWillMount()</code>整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改<code>state</code>值<br>4、<code>render</code> 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了<br>5、<code>compontentDidMount()</code> 组件渲染完成之后调用，且只调用一次</p><blockquote><p>更新</p></blockquote><p>6、<code>componentWillReceiverProps(nextProps)</code> 在组件初始化的时候不会触发，组件接收到新的<code>props</code>时触发<br>7、<code>shouldCompontUpdate(nextProps, nextState)</code> 这里是<code>React</code>性能优化非常重要的生命周期。在组件接收到新的<code>props</code>或者<code>state</code>时可以触发这个生命周期，可以对比前后<code>props</code>和<code>state</code>是否一样，如果相同一样则返回<code>false</code>去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行<code>diff</code>算法对比，极大地节省性能。<br>8、<code>componentWillUpdate(nextProps, nextState)</code> 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改<code>state</code><br>9、<code>render()</code> 渲染组件<br>10、 <code>componentDidUpdate()</code> 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取<code>dom</code>节点</p><blockquote><p>卸载</p></blockquote><p>11、<code>componentWillUnmount()</code> 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等</p><hr><h1 id="前端的一些知识模块"><a href="#前端的一些知识模块" class="headerlink" title="前端的一些知识模块"></a>前端的一些知识模块</h1><p><strong> HTML </strong><br>对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储</p><p><strong> CSS </strong><br>flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性</p><p><strong> JavaScript </strong><br>数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE</p><p><strong> 其他 </strong><br>移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作</p><p>作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Doctype作用？标准模式与兼容模式各有什么区别"><a href="#Doctype作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype作用？标准模式与兼容模式各有什么区别?"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h2><p>1、<code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于 <code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现。</p><p>2、<code>标准模式的排版</code> 和 <code>JS运作模式</code>都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。</p><hr><h2 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h2><p>HTML5不基于<code>SGML</code>,所以不需要对DTD进行引用，但是他也需要<code>DOCTYPE</code>来规范浏览器的行为。</p><hr><h2 id="常见的浏览器有哪些，及其浏览器的内核是啥？"><a href="#常见的浏览器有哪些，及其浏览器的内核是啥？" class="headerlink" title="常见的浏览器有哪些，及其浏览器的内核是啥？"></a>常见的浏览器有哪些，及其浏览器的内核是啥？</h2><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]</p><hr><h2 id="浏览器内核的理解？"><a href="#浏览器内核的理解？" class="headerlink" title="浏览器内核的理解？"></a>浏览器内核的理解？</h2><p>主要分为两部分：<code>渲染引擎（Layout engineer或Rendering Engine）</code>和<code>JS引擎</code></p><blockquote><p>渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。</p></blockquote><blockquote><p>JS引擎：解析和执行JavaScript实现网页动态效果。</p></blockquote><hr><h2 id="页面样式引入，link与-import-的区别？"><a href="#页面样式引入，link与-import-的区别？" class="headerlink" title="页面样式引入，link与@import`的区别？"></a>页面样式引入，<code>link</code>与<code></code>@import`的区别？</h2><p>1、<code>link</code>属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<br>2、<code>@import</code>是CSS提供的，只能用于加载CSS;<br>3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>4、<code>import</code>是CSS2.1 提出的，只在IE5以上才能被识别，而<code>link</code>是XHTML标签，<code>无兼容问题</code>;</p><hr><h2 id="行内元素有哪些，块级元素有哪些，空元素有哪些？"><a href="#行内元素有哪些，块级元素有哪些，空元素有哪些？" class="headerlink" title="行内元素有哪些，块级元素有哪些，空元素有哪些？"></a>行内元素有哪些，块级元素有哪些，空元素有哪些？</h2><blockquote><p>CSS规范规定，每个元素都有<code>display</code>属性，确定该元素的类型，每个元素都有默认的<code>display</code>值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p></blockquote><p>行内元素: <code>a b span img input select strong(强调的语气)</code><br>块级元素：<code>div p ul ol li dl dt dd h1 h2 h3 h4 ...</code><br>常见的空元素: <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>和<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p><hr><h2 id="HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class="line">    - 绘画 canvas;</span><br><span class="line">    - 用于媒介回放的 video 和 audio 元素;</span><br><span class="line">    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class="line">    - sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class="line">    - 语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class="line">    - 表单控件，calendar、date、time、email、url、search;</span><br><span class="line">    - 新的技术webworker, websocket, Geolocation;</span><br><span class="line"></span><br><span class="line">    - 移除的元素：</span><br><span class="line">        纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class="line">        对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class="line"></span><br><span class="line">   - 支持HTML5新标签：</span><br><span class="line">        IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class="line">        可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class="line">        浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class="line"></span><br><span class="line">        当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class="line">        &lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line">            &lt;script&gt; src=<span class="string">"http://html5shim.googlecode.com/svn/trunk/html5.js"</span>&lt;/script&gt;</span><br><span class="line">        &lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</span><br></pre></td></tr></table></figure><hr><h2 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h2><p><code>用正确的标签做正确的事情。</code><br>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p><hr><h2 id="HTML5的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下？</h2><blockquote><p> 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p></blockquote><p>如何使用：<br>1、页面头部像下面一样加入一个<code>manifest</code>的属性；<br>2、在<code>cache.manifest</code>文件的编写离线存储的资源；<br>    <code>CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html</code><br>3、在离线状态时，操作<code>window.applicationCache</code>进行需求实现。</p><p>详细的使用请参考：<a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener">HTML5 离线缓存-manifest简介</a>,<a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></p><hr><h2 id="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。<br>详细请参考：<a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></p><hr><h2 id="描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？"><a href="#描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？" class="headerlink" title="描述一下 Cookies，SessionStorage 和 LocalStorage 的区别？"></a>描述一下 <code>Cookies</code>，<code>SessionStorage</code> 和 <code>LocalStorage</code> 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。<br>存储大小：</p><ul><li>cookie数据大小不能超过4k。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><p>有期时间：</p><ul><li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li><li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><hr><h2 id="Iframe有那些缺点？"><a href="#Iframe有那些缺点？" class="headerlink" title="Iframe有那些缺点？"></a><strong>Iframe有那些缺点？</strong></h2><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><blockquote><p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p></blockquote><hr><h2 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h2><blockquote><p><code>label</code>标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>（1）有两种， <code>IE 盒子模型</code>、<code>W3C 盒子模型</code>；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;</p><hr><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路:</p><ul><li>随机选择数组中的一个数 A，以这个数为基准</li><li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li><li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li><li>这时候将左边和右边的数再递归上面的过程<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Arr = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>];</span><br><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let pivotIndex = Math.<span class="built_in">floor</span>(arr.length / <span class="number">2</span>);</span><br><span class="line">    let pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    let left = [];</span><br><span class="line">    let right = [];</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(quickSort(Arr));</span><br></pre></td></tr></table></figure></li></ul><p>ps:<br>这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。<br>其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。</p><p>这里是不同的声音： <a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40" target="_blank" rel="noopener">面试官：阮一峰版的快速排序完全是错的</a></p><hr><h3 id="二分排序法"><a href="#二分排序法" class="headerlink" title="二分排序法"></a>二分排序法</h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。<br>二分查找是一种「分治」思想的算法，大概流程如下：</p><ul><li>数组中排在中间的数字 A，与要找的数字比较大小</li><li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A</li><li>较小则说明应该从查找数字的后半部分查找</li><li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li></ul><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Find</span><span class="params">(target, <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    let i = <span class="number">0</span>;</span><br><span class="line">    let j = <span class="built_in">array</span>[i].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">array</span>.length &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用例</span></span><br><span class="line">console.<span class="built_in">log</span>(Find(<span class="number">10</span>, [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], </span><br><span class="line">    [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>], </span><br><span class="line">    [<span class="number">13</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">23</span>]</span><br><span class="line">    ])</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><hr><h3 id="解析url后的参数"><a href="#解析url后的参数" class="headerlink" title="解析url后的参数"></a>解析url后的参数</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">parseParam</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  let arr = url.split(<span class="string">"?"</span>);</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123; <span class="comment">//判断没有问号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"无参数"</span></span><br><span class="line">  &#125;</span><br><span class="line">  let total = arr[<span class="number">1</span>].split(<span class="string">"&amp;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; total.length; i++) &#123;</span><br><span class="line">    let single = total[i].split(<span class="string">"="</span>);</span><br><span class="line">    if (single[0] == '') &#123; //判断有？但是没有参数</span><br><span class="line">      return '无参数'</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!single[<span class="number">1</span>]) &#123;</span><br><span class="line">      obj[single[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj[single[<span class="number">0</span>]]) &#123;</span><br><span class="line">        let concat</span><br><span class="line">        <span class="keyword">if</span> (!Array.isArray(obj[single[<span class="number">0</span>]])) &#123; <span class="comment">//判断是否数组</span></span><br><span class="line">          concat = [obj[single[<span class="number">0</span>]]]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          concat = obj[single[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        concat.push(single[<span class="number">1</span>]);</span><br><span class="line">        concat = <span class="keyword">new</span> Set(concat);</span><br><span class="line">        concat = Array.from(concat) <span class="comment">//数组去重</span></span><br><span class="line">        obj[single[<span class="number">0</span>]] = concat</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[single[<span class="number">0</span>]] = decodeURI(single[<span class="number">1</span>]) <span class="comment">//进行转码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var url = 'http://www.baidu.com/?user=huixin&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled';</span><br><span class="line"></span><br><span class="line">var params = parseParam(url)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(params)</span><br></pre></td></tr></table></figure><hr><h3 id="实现一个简单的模版引擎："><a href="#实现一个简单的模版引擎：" class="headerlink" title="实现一个简单的模版引擎："></a>实现一个简单的模版引擎：</h3><p>例如：我叫a,年龄b，性别c； let data = { name: ‘小明’, age: 18, } 没有定义的返回undefined</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let template = '我是&#123;name&#125;，年龄&#123;age&#125;，性别&#123;sex&#125;';</span><br><span class="line">let data = &#123;</span><br><span class="line">    name: '小明',</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  reg= /(&#123;([a-zA-Z]+)&#125;)/g;</span><br><span class="line">var r= '',regrounp=&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span>( r = reg.exec(<span class="keyword">template</span>) )&#123;</span><br><span class="line">    Object.defineProperty(regrounp,r[<span class="number">2</span>],&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        value:r[<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var render = (<span class="keyword">template</span>,regrounp)=&gt;&#123;</span><br><span class="line">    var result='';</span><br><span class="line">    <span class="keyword">for</span>( key in regrounp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[key] == undefined)&#123;</span><br><span class="line">            result  = (result || <span class="keyword">template</span>).replace(<span class="keyword">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class="string">"g"</span>),undefined);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result  = (result || <span class="keyword">template</span>).replace(<span class="keyword">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class="string">"g"</span>),data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">let newtemple = render(<span class="keyword">template</span>, regrounp);</span><br><span class="line">console.<span class="built_in">log</span>(newtemple) <span class="comment">// 结果： 我是小明，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure><p>对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。</p><p>这里有一片很好的文章 推荐 <a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46" target="_blank" rel="noopener">编写一个简单的JavaScript模板引擎</a></p><hr><h3 id="如何快速让字符串变成已千为精度的数字"><a href="#如何快速让字符串变成已千为精度的数字" class="headerlink" title="如何快速让字符串变成已千为精度的数字"></a>如何快速让字符串变成已千为精度的数字</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">exchange</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">    num += ''; //转成字符串</span><br><span class="line">    <span class="keyword">if</span> (num.length &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num = num.replace(/\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(?=(\d&#123;<span class="number">3</span>&#125;)+$)/g, (v) =&gt; &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(v)</span><br><span class="line">        <span class="keyword">return</span> v + <span class="string">','</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(exchange(<span class="number">1234567</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="实现-JS-对象的深拷贝"><a href="#实现-JS-对象的深拷贝" class="headerlink" title="实现 JS 对象的深拷贝"></a>实现 JS 对象的深拷贝</h3><p>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。<br>分析下怎么做 深拷贝 ：</p><ul><li>首先假设深拷贝这个方法已经完成，为 deepClo</li><li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li></ul><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">deepClo</span><span class="params">(o1, o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (let k in o2) &#123;</span><br><span class="line">        if (typeof o2[k] === 'object') &#123;</span><br><span class="line">            o1[k] = &#123;&#125;;</span><br><span class="line">            deepClo(o1[k], o2[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o1[k] = o2[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">let obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    c: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let emptyObj = Object.create(null);</span><br><span class="line">deepClo(emptyObj, obj);</span><br><span class="line">console.<span class="built_in">log</span>(emptyObj.a == obj.a);</span><br><span class="line">console.<span class="built_in">log</span>(emptyObj.b == obj.b);</span><br></pre></td></tr></table></figure><p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。</p><hr><h3 id="求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项"><a href="#求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项" class="headerlink" title="求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项"></a>求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：</span><br><span class="line"> let count = <span class="number">0</span>;</span><br><span class="line"> <span class="function">function <span class="title">fn</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    let cache = &#123;&#125;;</span><br><span class="line">    function _fn(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[n]) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        let prev = _fn(n - <span class="number">1</span>);</span><br><span class="line">        cache[n - <span class="number">1</span>] = prev;</span><br><span class="line">        let next = _fn(n - <span class="number">2</span>);</span><br><span class="line">        cache[n - <span class="number">2</span>] = next;</span><br><span class="line">        <span class="keyword">return</span> prev + next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _fn(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let count2 = <span class="number">0</span>;</span><br><span class="line"><span class="function">function <span class="title">fn2</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    count2++;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2(n - <span class="number">1</span>) + fn2(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(fn(<span class="number">20</span>), count); <span class="comment">// 6765 20</span></span><br><span class="line">console.<span class="built_in">log</span>(fn2(<span class="number">20</span>), count2); <span class="comment">// 6765 13529</span></span><br></pre></td></tr></table></figure><hr><h3 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h3><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。<br>常见的时间复杂度有：</p><ul><li>常数阶 O(1)</li><li>对数阶 O(logN)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlogN)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3)</li><li>!k次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ul><p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。<br>一般做算法复杂度分析的时候，遵循下面的技巧：</p><ul><li>看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推</li><li>如果有二分，则为O(logN)</li><li>保留最高项，去除常数项</li></ul><p>题目：分析下面代码的算法复杂度</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let i =<span class="number">0</span>; <span class="comment">// 语句执行一次 </span></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 语句执行 n 次 </span></span><br><span class="line">  console.<span class="built_in">log</span>(`Current i is $&#123;i&#125;`); <span class="comment">//语句执行 n 次</span></span><br><span class="line">  i++; <span class="comment">// 语句执行 n 次</span></span><br><span class="line">&#125;</span><br><span class="line">根据注释可以得到，算法复杂度为<span class="number">1</span> + n + n + n = <span class="number">1</span> + <span class="number">3</span>n，去除常数项，为O(n)。</span><br></pre></td></tr></table></figure><p>更多阅读：<br><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18" target="_blank" rel="noopener">在 JavaScript 中学习数据结构与算法</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension" target="_blank" rel="noopener">我接触过的前端数据结构与算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://duanruilong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
      <category term="CSS" scheme="https://duanruilong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅—认识一下</title>
    <link href="https://duanruilong.github.io/2018/05/22/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B/"/>
    <id>https://duanruilong.github.io/2018/05/22/小程序之旅—-认识一下/</id>
    <published>2018-05-22T15:19:02.000Z</published>
    <updated>2018-12-18T03:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png" alt="微信小程序"></p><a id="more"></a><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li>page — 项目所有的页面模板</li><li>utils — 公共js工具</li><li>app.js — 启动入口文件</li><li>app.wxss — 项目的全局样式文件</li><li>app.json — 项目的配置文件</li></ul><p>在<code>app.json</code>里我们可以看到<code>page</code>下面就是我们可以配置的页面路径，<code>pages/index/index</code>这个路径就可以访问<code>index.wxml</code>下的东西，每一个页面都有“三大件”—<code>js、wxml、wxss</code>组成。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/xcx1.png" alt="小程序"><br>下面开始我们小栗子：</p><p>新增一个view，<code>wxml</code>与<code>wxss</code>就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text <span class="class"><span class="keyword">class</span>="<span class="title">demo</span>"&gt;这是一个测试小栗子&lt;/text&gt;</span></span><br><span class="line"><span class="class">  &lt;/view&gt;</span></span><br><span class="line"><span class="class">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line">.userinfo &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-avatar &#123;</span><br><span class="line">  width: <span class="number">128</span>rpx;</span><br><span class="line">  height: <span class="number">128</span>rpx;</span><br><span class="line">  margin: <span class="number">20</span>rpx;</span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-nickname &#123;</span><br><span class="line">  color: <span class="meta">#aaa;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.usermotto &#123;</span><br><span class="line">  margin-top: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新增加的  */</span></span><br><span class="line">.demo&#123;</span><br><span class="line">  color:blueviolet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存好就可以看到效果了。<br>接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;  <span class="comment">// 页面跳转函数</span></span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123; <span class="comment">//获取用户信息</span></span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>具体函数对应含义也可以参考<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject" target="_blank" rel="noopener">微信公众平台开发</a>。</p><p>先去wxml文件下增加一个按<code>&lt;button class=&#39;primary&#39; bindtap=&#39;changeDemo&#39;&gt;点击改变状态&lt;/button&gt;</code>,接着去js文件下添加初始数据，和点击的事件函数。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span>='<span class="title">primary</span>' <span class="title">bindtap</span>='<span class="title">changeDemo</span>'&gt;点击改变状态&lt;/button&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;  <span class="comment">// 页面跳转函数</span></span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//新增加的事件</span></span><br><span class="line">  changeDemo:function()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setDate(&#123;</span><br><span class="line">      demotext: '点击之后就改变了我的状态',</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123; <span class="comment">//获取用户信息</span></span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/xcx1_1.png" alt="小程序"><br><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/xcx1_2.png" alt="小程序"></p><p>在wxml文件里加入<code>if-else</code>的判断：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    demovalue:'if判断的数据',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>接下来是<code>for</code>循环遍历数据：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;fordata&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"id"</span> wx:<span class="keyword">for</span>-item=<span class="string">"itemvalue"</span>&gt;</span><br><span class="line">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    demovalue:'if判断的数据',</span><br><span class="line">    fordata: [&#123; name: '测试1', num: 12 &#125;, &#123; name: '测试2', num: 22 &#125;, &#123; name: '测试3', num: 32 &#125;],</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>本地数据都没有问题了，那么接下来就是<code>Ajax 跨域请求</code>,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject" target="_blank" rel="noopener">wx.request(OBJECT)</a></p><p>示例代码：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: 'test.php', //仅为示例，并非真实的接口地址</span><br><span class="line">  data: &#123;</span><br><span class="line">     x: '' ,</span><br><span class="line">     y: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">      'content-type': 'application/json' // 默认值</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject" target="_blank" rel="noopener">wx.chooseImage(OBJECT)</a>,在js文件里新增一个方法。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    wx.chooseImage(&#123; <span class="comment">// 获取本地图片</span></span><br><span class="line">      count: <span class="number">1</span>, <span class="comment">// 默认9</span></span><br><span class="line">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class="line">      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        <span class="comment">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class="line">        var tempFilePaths = res.tempFilePaths</span><br><span class="line">        console.<span class="built_in">log</span>(tempFilePaths)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          demoImg: tempFilePaths</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>wxml文件：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image wx:if="&#123;&#123;demoImg!=null&#125;&#125;" src='&#123;&#123;demoImg&#125;&#125;'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="class">      &lt;image wx:else bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line">  &lt;view wx:key=<span class="string">"id"</span> wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;fordata&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"id"</span> wx:<span class="keyword">for</span>-item=<span class="string">"itemvalue"</span>&gt;</span><br><span class="line">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>mongodb数据库的使用</title>
    <link href="https://duanruilong.github.io/2018/05/21/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://duanruilong.github.io/2018/05/21/mongodb数据库的使用/</id>
    <published>2018-05-20T16:05:33.000Z</published>
    <updated>2018-09-17T15:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。</p><p><img src="https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png" alt="js"></p><a id="more"></a><h1 id="一、mongodb的开启和关闭"><a href="#一、mongodb的开启和关闭" class="headerlink" title="一、mongodb的开启和关闭"></a>一、mongodb的开启和关闭</h1><h2 id="1-查找mongod是否可用"><a href="#1-查找mongod是否可用" class="headerlink" title="1. 查找mongod是否可用"></a>1. 查找mongod是否可用</h2><p><code>which mongod</code></p><h2 id="2-启动mongodb"><a href="#2-启动mongodb" class="headerlink" title="2. 启动mongodb"></a>2. 启动mongodb</h2><p>指定path 和log日志<br><code>mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log</code></p><h2 id="3-关闭数据库"><a href="#3-关闭数据库" class="headerlink" title="3. 关闭数据库"></a>3. 关闭数据库</h2><p><code>mongod --shutdown</code></p><h1 id="二、mongodb的操作"><a href="#二、mongodb的操作" class="headerlink" title="二、mongodb的操作"></a>二、mongodb的操作</h1><h2 id="1-连接服务器"><a href="#1-连接服务器" class="headerlink" title="1. 连接服务器"></a>1. 连接服务器</h2><p><code>mongod 115.29.137.34:27017</code></p><h2 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2. 使用数据库"></a>2. 使用数据库</h2><p>(不存在的数据库也可以使用,插入数据之后会自动保存)<br><code>use mydb</code></p><h2 id="3-权限登陆"><a href="#3-权限登陆" class="headerlink" title="3. 权限登陆"></a>3. 权限登陆</h2><p><code>db.auth(&#39;username&#39;,&#39;password&#39;)</code></p><h2 id="4-展示数据库列表"><a href="#4-展示数据库列表" class="headerlink" title="4. 展示数据库列表"></a>4. 展示数据库列表</h2><p><code>show dbs</code></p><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><p>(类似于mysql的表)<br><code>db.users.insert({&#39;name&#39;:&#39;xiaomo&#39;})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:25})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:24,&#39;sex&#39;:&#39;女&#39;})</code></p><h2 id="6-查询集合"><a href="#6-查询集合" class="headerlink" title="6. 查询集合"></a>6. 查询集合</h2><p>(前提是use了一个数据库)<br>有一个System.indexes 是索引<br><code>show collections</code></p><h2 id="7-不带条件查询"><a href="#7-不带条件查询" class="headerlink" title="7. 不带条件查询"></a>7. 不带条件查询</h2><p><code>db.users.find()</code></p><h2 id="8-带条件查询"><a href="#8-带条件查询" class="headerlink" title="8. 带条件查询"></a>8. 带条件查询</h2><p>(参数是一个对象)<br><code>db.users.find({&#39;name&#39;:&#39;xiaomo&#39;})</code></p><h2 id="9-更新数据"><a href="#9-更新数据" class="headerlink" title="9. 更新数据"></a>9. 更新数据</h2><p>(有三个参数,1:查询条件,2:更新的内容 3：更新的配置)<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}})</code>修改满足条件的第一条数据<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}},{multi:true})</code>修改所有满足条件的数据</p><h2 id="10-保存数据"><a href="#10-保存数据" class="headerlink" title="10. 保存数据"></a>10. 保存数据</h2><p>(只有一个参数，必须要传id，后面是要修改的数据)<br><code>db.users.save({&#39;id&#39;:&#39;objectId(574710a97a3afd63cde56a49)&#39;,&#39;age&#39;:30})</code></p><h2 id="11-删除数据"><a href="#11-删除数据" class="headerlink" title="11. 删除数据"></a>11. 删除数据</h2><p>(1:条件 2 是否删除所有符合条件的)<br><code>db.users.remove({&#39;name&#39;:&#39;xiaomoing&#39;},true)</code></p><h2 id="12-删除集合"><a href="#12-删除集合" class="headerlink" title="12. 删除集合"></a>12. 删除集合</h2><p><code>db.users.drop()</code></p><h1 id="三、使用mongoose操作数据库"><a href="#三、使用mongoose操作数据库" class="headerlink" title="三、使用mongoose操作数据库"></a>三、使用mongoose操作数据库</h1><h2 id="1-模块的介绍"><a href="#1-模块的介绍" class="headerlink" title="1. 模块的介绍"></a>1. 模块的介绍</h2><p>连接mongdodb的驱动</p><h2 id="2-配置和链接"><a href="#2-配置和链接" class="headerlink" title="2. 配置和链接"></a>2. 配置和链接</h2><p><code>npm install --save mongoose</code><br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">&lt;!-- var uri = 'mongodb://username:password@hostname:port/databasename'; --&gt;</span><br><span class="line">var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';</span><br><span class="line">mongoose.connect(uri);</span><br></pre></td></tr></table></figure></p><h2 id="3-Model-和Shema"><a href="#3-Model-和Shema" class="headerlink" title="3. Model 和Shema"></a>3. Model 和Shema</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// model.js</span></span><br><span class="line">var Schema = mongoose.Schema,</span><br><span class="line">    ObjectId = Schema.ObjectId;</span><br><span class="line"></span><br><span class="line">var BlogPost = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    author    : ObjectId,</span><br><span class="line">    title     : String,</span><br><span class="line">    body      : String,</span><br><span class="line">    date      : Date</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Model</span></span><br><span class="line">mongoose.model('blog',Schema);</span><br><span class="line"></span><br><span class="line">var Comment = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: &#123; type: String, default: 'hahaha' &#125;,</span><br><span class="line">  age: &#123; type: Number, min: <span class="number">18</span>, index: <span class="literal">true</span> &#125;,</span><br><span class="line">  bio: &#123; type: String, match: /[a-z]/ &#125;,</span><br><span class="line">  date: &#123; type: Date, <span class="keyword">default</span>: Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a setter</span></span><br><span class="line">Comment.path('name').set(function (v) &#123;</span><br><span class="line">  <span class="keyword">return</span> capitalize(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line">Comment.pre('save', function (next) &#123;</span><br><span class="line">  notify(this.get('email'));</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-创建文档"><a href="#4-创建文档" class="headerlink" title="4. 创建文档"></a>4. 创建文档</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert.js</span></span><br><span class="line">var mongoose ＝ require('mongoose');</span><br><span class="line">require('./model.js'); //执行</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">var blog = <span class="keyword">new</span> Blog(&#123;</span><br><span class="line">    name:'xiaomo',</span><br><span class="line">    age:<span class="number">25</span>,</span><br><span class="line">    bio:'don't know',</span><br><span class="line">    date:<span class="keyword">new</span> Date</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">book.save(function(err)&#123;</span><br><span class="line">    console.log('save status:'+err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="5-删除文档"><a href="#5-删除文档" class="headerlink" title="5. 删除文档"></a>5. 删除文档</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(doc)&#123;</span><br><span class="line">  doc.reomove();</span><br><span class="line">&#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="6-简单查询"><a href="#6-简单查询" class="headerlink" title="6. 简单查询"></a>6. 简单查询</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.find(&#123;&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log('result',doc)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>第一个满足条件的结果<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log('result',doc)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7. 条件语句"></a>7. 条件语句</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condation.js</span></span><br><span class="line"> var mongoose = require('mongoose');</span><br><span class="line"> require('./model.js');</span><br><span class="line"> var Blog = mongoose.model('blog');</span><br><span class="line"> <span class="comment">//名字是xiaomo或者xiaoming 可以用$or和$and</span></span><br><span class="line"> var condation = &#123;</span><br><span class="line">   $<span class="keyword">or</span>  $<span class="keyword">and</span>:[</span><br><span class="line">   &#123;'name':'xiaomo'&#125;,</span><br><span class="line">   &#123;'name':'xiaoming'&#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"> Blog.find(condation,function(err,doc)&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(err)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log('result',doc)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h1 id="三、在项目中使用mongoose"><a href="#三、在项目中使用mongoose" class="headerlink" title="三、在项目中使用mongoose"></a>三、在项目中使用mongoose</h1><h2 id="1-生成项目"><a href="#1-生成项目" class="headerlink" title="1. 生成项目"></a>1. 生成项目</h2><p><code>koa koatest -e koatest</code></p><h2 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h2><p><code>cd koatest &amp;&amp; npm install</code></p><h2 id="3-安装mongoose"><a href="#3-安装mongoose" class="headerlink" title="3. 安装mongoose"></a>3. 安装mongoose</h2><p><code>npm install --save mongoose</code></p><h2 id="4-创建模型"><a href="#4-创建模型" class="headerlink" title="4. 创建模型"></a>4. 创建模型</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/users.server.model.js</span></span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    uid:Number,</span><br><span class="line">    username:String,</span><br><span class="line">    createTime:Date,</span><br><span class="line">    lastLogin:Date</span><br><span class="line">  &#125;)</span><br><span class="line">module.exports = mongoose.model('User',UserSchema);</span><br></pre></td></tr></table></figure><h2 id="5-创建配置文件"><a href="#5-创建配置文件" class="headerlink" title="5. 创建配置文件"></a>5. 创建配置文件</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.js</span></span><br><span class="line"><span class="keyword">module</span>.exports=&#123;</span><br><span class="line">  mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//config/mongoose.js</span></span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var config = require('./config.js');</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports=function()&#123;</span><br><span class="line">  var db = mongoose.connect(config.mongodb);</span><br><span class="line">  require('./../models/users.server.model.js');</span><br><span class="line">  <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-操作mongdodb-代码"><a href="#6-操作mongdodb-代码" class="headerlink" title="6. 操作mongdodb 代码"></a>6. 操作mongdodb 代码</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//routers/users.js</span></span><br><span class="line">var router = require('koa-router')();</span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var User = mongoose.model('User');</span><br><span class="line">router.get(<span class="string">'/'</span>, function *(next) &#123;</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">    var user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">      uid:</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">this</span>.body = yield User.find(&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>  嗯嗯,就这样吧，完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongoDB" scheme="https://duanruilong.github.io/categories/mongoDB/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="mongoDB" scheme="https://duanruilong.github.io/tags/mongoDB/"/>
    
      <category term="Node" scheme="https://duanruilong.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
