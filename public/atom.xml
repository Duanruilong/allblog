<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>About-龙大</title>
  
  <subtitle>不忘初心，继续前进。</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://duanruilong.github.io/"/>
  <updated>2018-06-14T17:00:28.433Z</updated>
  <id>https://duanruilong.github.io/</id>
  
  <author>
    <name>DRLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序之旅(二)</title>
    <link href="https://duanruilong.github.io/2018/06/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85-%E4%BA%8C/"/>
    <id>https://duanruilong.github.io/2018/06/15/小程序之旅-二/</id>
    <published>2018-06-14T17:00:05.000Z</published>
    <updated>2018-06-14T17:00:28.433Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png" alt="微信小程序"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-集成第三方库</title>
    <link href="https://duanruilong.github.io/2018/06/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://duanruilong.github.io/2018/06/14/React开发常用设计模式-集成第三方库/</id>
    <published>2018-06-14T15:49:58.000Z</published>
    <updated>2018-06-16T09:12:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="集成第三方库"><a href="#集成第三方库" class="headerlink" title="集成第三方库"></a>集成第三方库</h1><p>接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个示例挑选了 <a href="https://github.com/aehlke/tag-it" target="_blank" rel="noopener">tag-it</a> 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;JavaScript&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;CSS&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>转换成:</p><p><img src="http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png" alt="react"></p><p>要运行起来，需要引入 <code>jQueyr、jQuery UI 和 tag-it</code>插件。这是运行的代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$('&lt;dom element selector&gt;').tagit();</span><br></pre></td></tr></table></figure></p><p>选择 DOM 元素，然后调用 <code>tagit()</code> 。</p><p>现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tags.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; tags: ['JavaScript', 'CSS' ] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Tags tags=&#123; <span class="keyword">this</span>.state.tags &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.querySelector('#container'));</span><br></pre></td></tr></table></figure><p>App 类是入口。它使用了<code>Tags</code>组件，Tags 组件会根据传入的 <code>tags</code> 属性来展示无序列表。当 React 在页面上渲染列表时就有了<code>&lt;ul&gt;</code>标签，这样就可以和 <code>jQuery</code> 插件连接起来。</p><h2 id="强制单通道渲染"><a href="#强制单通道渲染" class="headerlink" title="强制单通道渲染"></a>强制单通道渲染</h2><p>首先，要做的就是强制 <code>Tags</code> 组件进行单通道渲染。这是因为当 React 在实际 <code>DOM</code>中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 <code>shouldComponentUpdate</code>，像这样:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 <code>shouldComponentUpdate</code> 对于 React 组件来说，是让其知道是否触发 <code>render</code> 方法。这适用于的场景，因为想使用 React 来添加 <code>HTML</code> 标记，添加完后就不想再依靠 React 。</p><h2 id="初始化插件"><a href="#初始化插件" class="headerlink" title="初始化插件"></a>初始化插件</h2><p>React 提供了 <a href="https://facebook.github.io/react/docs/refs-and-the-dom.html" target="_blank" rel="noopener">API</a> 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span> = $(<span class="keyword">this</span>.refs.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span>.tagit();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul ref='list'&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>上面的代码和 <code>shouldComponentUpdate</code> 一起使用就会使 React 渲染出有两项的 <code>&lt;ul&gt;</code>，然后 <code>tag-it</code> 会其转换成标签可编辑的插件。</p><h2 id="使用-React-控制插件"><a href="#使用-React-控制插件" class="headerlink" title="使用 React 控制插件"></a>使用 React 控制插件</h2><p>假如说我们想要通过代码来为已经运行的 <code>tag-it</code> 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 <code>Tags</code> 组件，但同时还要保持单通道渲染。</p><p>为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 <code>Tags</code> 组件。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._addNewTag = <span class="keyword">this</span>._addNewTag.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      tags: ['JavaScript', 'CSS' ],</span><br><span class="line">      newTag: null</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _addNewTag() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; newTag: <span class="keyword">this</span>.refs.field.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Add <span class="keyword">new</span> tag:&lt;/p&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input type='text' ref='field' /&gt;</span><br><span class="line">          &lt;button onClick=&#123; <span class="keyword">this</span>._addNewTag &#125;&gt;Add&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;Tags</span><br><span class="line">          tags=&#123; <span class="keyword">this</span>.state.tags &#125;</span><br><span class="line">          newTag=&#123; <span class="keyword">this</span>.state.newTag &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 <code>Tags</code> 组件的重新渲染。但由于 <code>shouldComponentUpdate</code>的存在，页面上不会有任何的更新。唯一的变化就是得到 <code>newTag</code>属性的新值，另一个生命周期方法 <code>componentWillReceiveProps</code> 会捕获到属性的新值:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">    this.list.tagit('createTag', newProps.newTag);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>.tagit(&#39;createTag&#39;, newProps.newTag)</code>是纯粹的 jQuery 代码。如果想调用第三方库的方法，<code>componentWillReceiveProps</code>是个不错的选择。</p><p>下面是 Tags 组件的完整代码:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tags</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span> = $(<span class="keyword">this</span>.refs.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">list</span>.tagit();</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">    this.list.tagit('createTag', newProps.newTag);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul ref='list'&gt;</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">this</span>.props.tags.<span class="built_in">map</span>(</span><br><span class="line">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class="line">        ) </span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>React 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-组件样式</title>
    <link href="https://duanruilong.github.io/2018/06/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F/"/>
    <id>https://duanruilong.github.io/2018/06/14/React开发常用设计模式-组件样式/</id>
    <published>2018-06-13T16:10:32.000Z</published>
    <updated>2018-06-16T09:12:33.898Z</updated>
    
    <content type="html"><![CDATA[<p>React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h1><h2 id="经典-CSS-类"><a href="#经典-CSS-类" class="headerlink" title="经典 CSS 类"></a>经典 CSS 类</h2><p>JSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 <code>.css</code>文件中的。唯一需要注意的是 React 中使用的是 <code>className</code>，而不是 <code>class</code> 。例如:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 className='title'&gt;Styling&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inlineStyles = &#123;</span><br><span class="line">  color: 'red',</span><br><span class="line">  fontSize: '10px',</span><br><span class="line">  marginTop: '2em',</span><br><span class="line">  'border-top': 'solid 1px #000'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;h2 style=&#123; inlineStyles &#125;&gt;Inline styling&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">  fontFamily: 'Georgia',</span><br><span class="line">  color: 'blue'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> paragraphText = &#123;</span><br><span class="line">  ...theme,</span><br><span class="line">  fontSize: '20px'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>theme</code>中有一些基础样式，然后在 <code>paragraphText</code> 中混入 <code>theme</code> 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。</p><h2 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h2><p><a href="https://github.com/css-modules/css-modules/blob/master/docs/get-started.md" target="_blank" rel="noopener">CSS 模块</a> 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。</p><p>下面的示例可以让你快速对其运行原理有个大致的了解:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line">.title &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> styles from <span class="string">"./style.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1 style=&#123; styles.title &#125;&gt;Hello world&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。</p><p>当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">  composes: mainColor from <span class="string">"./brand-colors.css"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Styled-components"><a href="#Styled-components" class="headerlink" title="Styled-components"></a>Styled-components</h2><p><a href="https://www.styled-components.com/" target="_blank" rel="noopener">Styled-components</a> 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 <code>Link</code>组件，它具有特定的风格和用法，而再使用 <code>&lt;a&gt;</code>标签。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = styled.a`</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  padding: <span class="number">4</span>px;</span><br><span class="line">  border: solid <span class="number">1</span>px #<span class="number">999</span>;</span><br><span class="line">  color: black;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">&lt;Link href='http://google.com'&gt;Google&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AnotherLink = styled(Link)`</span><br><span class="line">  color: blue;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">&lt;AnotherLink href='http://facebook.com'&gt;Facebook&lt;/AnotherLink&gt;</span><br></pre></td></tr></table></figure></p><p>到目前为止 <code>styled-components</code> 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-依赖注入</title>
    <link href="https://duanruilong.github.io/2018/06/13/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>https://duanruilong.github.io/2018/06/13/React开发常用设计模式-依赖注入/</id>
    <published>2018-06-12T16:13:53.000Z</published>
    <updated>2018-06-16T09:12:00.330Z</updated>
    
    <content type="html"><![CDATA[<p>写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 <a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank" rel="noopener">依赖注入</a> 的技术 (大多数人认为它是一种模式) 用来解决这种问题。</p><p>在 React 中，对依赖注入的需要是显而易见的。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>来考虑下面的应用的组件树:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Title</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; title: 'React in patterns' &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>字符串 “React in patterns” 应该以某种方式到达 <code>Title</code> 组件。最直接的方式就从 <code>App</code> 传到 <code>Header</code>，再从 <code>Header</code> 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。</p><p>已经了解过 <a href="http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">高阶组件</a> ，它可以用来注入数据。来使用同样的技术来注入 title 变量:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inject.jsx</span></span><br><span class="line">const title = 'React in patterns';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">inject</span><span class="params">(Component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> class Injector extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; title &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import inject from './inject.jsx';</span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line">var EnhancedTitle = inject(Title);</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;EnhancedTitle /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>title</code>隐藏在了中间层 (高阶组件) ，在中间层将<code>title</code>属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。</p><h2 id="使用-React-context-16-3-之前的版本"><a href="#使用-React-context-16-3-之前的版本" class="headerlink" title="使用 React context (16.3 之前的版本)"></a>使用 React context (16.3 之前的版本)</h2><blockquote><p>在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。</p></blockquote><p>React 有 <code>context</code> 的概念。每个 React 组件都可以访问 <code>context</code>。它有些类似于 <a href="https://github.com/krasimir/EventBus" target="_blank" rel="noopener">事件总线</a> ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 <code>store</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 context 的地方</span></span><br><span class="line">var context = &#123; title: 'React in patterns' &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.<span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 context 的地方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    var title = <span class="keyword">this</span>.context.title;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Inject.contextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.<span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，需要使用<code>childContextTypes</code>和 <code>contextTypes</code> 来指定 <code>context</code>对象的具体签名。如果不指定的话，那么 <code>context</code> 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 <code>context</code>写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">register</span>(key, value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，回到示例中，App 组件应该是这样的:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import dependencies from './dependencies';</span><br><span class="line"></span><br><span class="line">dependencies.register('title', 'React in patterns');</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Title 组件通过 context 来获取数据:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Title.contextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>理想情况下，不想每次需要访问 <code>context</code>时都指定<code>contextTypes</code>。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用<code>this.context.get(&#39;title&#39;)</code> 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line">import wire from './wire';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Title</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default wire(Title, ['title'], function resolve(title) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; title &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>wire</code>函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 <code>mapper</code>的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。</p><p><code>wire</code> 函数的代码如下所示:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">wire</span><span class="params">(Component, dependencies, mapper)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">    render() &#123;</span><br><span class="line">      var resolved = dependencies.<span class="built_in">map</span>(</span><br><span class="line">        <span class="keyword">this</span>.context.get.bind(<span class="keyword">this</span>.context)</span><br><span class="line">      );</span><br><span class="line">      var props = mapper(...resolved);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> React.createElement(Component, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Inject.contextTypes = &#123;</span><br><span class="line">    data: React.PropTypes.object,</span><br><span class="line">    get: React.PropTypes.func,</span><br><span class="line">    <span class="keyword">register</span>: React.PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Inject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>Inject</code> 是高阶组件，它可以访问 <code>context</code>并获取 <code>dependencies</code>数组中的所有项。<code>mapper</code> 函数接收 context 数据并将其转换成我们组建所需要的属性。</p><h2 id="使用-React-context-16-3-及之后的版本"><a href="#使用-React-context-16-3-及之后的版本" class="headerlink" title="使用 React context (16.3 及之后的版本)"></a>使用 React context (16.3 及之后的版本)</h2><p>Fackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。</p><p>还是使用同一个示例，让字符串抵达<code>&lt;Title&gt;</code>组件。</p><p>先来定义包含 <code>context</code>初始化的文件:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line">import &#123; createContext &#125; from 'react';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = Context.Provider;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure></p><p><code>createContext</code>返回的对象具有 <code>Provider 和 Consumer</code>属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。</p><p>假设说 App 组件是根组件。在此需要传入 <code>context</code>。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from './context';</span><br><span class="line"></span><br><span class="line">const context = &#123; title: 'React In Patterns' &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包装组件以及子组件现在共享同一个 context 。<code>&lt;Title&gt;</code>组件是需要 title 字符串的组件之一，所以要在组件中使用 <code>&lt;Consumer&gt;</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Consumer &#125; from './context';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Title</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;&#123;</span><br><span class="line">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class="line">    &#125;&lt;/Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，<code>Consumer</code>类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</p><p>新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。</p><h2 id="使用模块系统"><a href="#使用模块系统" class="headerlink" title="使用模块系统"></a>使用模块系统</h2><p>如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。</p><p>众所周知，JavaScript 中的典型模块系统具有缓存机制。在 <a href="https://nodejs.org/api/modules.html#modules_caching" target="_blank" rel="noopener">Node 官方文档</a> 中可以看到:</p><blockquote><p>模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象。<br>多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。</p></blockquote><p>这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 <a href="https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript" target="_blank" rel="noopener">单例</a>，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。</p><p>来创建一个新文件<code>di.jsx</code> ，它的代码如下所示:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var dependencies = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">register</span><span class="params">(key, dependency)</span> </span>&#123;</span><br><span class="line">  dependencies[key] = dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">fetch</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dependencies[key]) <span class="keyword">return</span> dependencies[key];</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error(`<span class="string">"$&#123; key &#125; is not registered as dependency.`);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export function wire(Component, deps, mapper) &#123;</span></span><br><span class="line"><span class="string">  return class Injector extends React.Component &#123;</span></span><br><span class="line"><span class="string">    constructor(props) &#123;</span></span><br><span class="line"><span class="string">      super(props);</span></span><br><span class="line"><span class="string">      this._resolvedDependencies = mapper(...deps.map(fetch));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">      return (</span></span><br><span class="line"><span class="string">        &lt;Component</span></span><br><span class="line"><span class="string">          &#123;...this.state&#125;</span></span><br><span class="line"><span class="string">          &#123;...this.props&#125;</span></span><br><span class="line"><span class="string">          &#123;...this._resolvedDependencies&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      );</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>将依赖保存在了 <code>dependencies</code>这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 <code>register 和 fetch</code>这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 <code>setter 和 getter</code>。再然后是 <code>wire</code>函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 <code>mapper</code> 函数来提取所需属性。</p><p>有了<code>di.jsx</code> 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line">import &#123; register &#125; from './di.jsx';</span><br><span class="line"></span><br><span class="line">register('my-awesome-title', 'React in patterns');</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line">import &#123; wire &#125; from './di.jsx';</span><br><span class="line"></span><br><span class="line">var Title = function(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title">wire</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Title,</span></span></span><br><span class="line">  ['my-awesome-title'],</span><br><span class="line">  title =&gt; (&#123; title &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果查看 Title.jsx 文件的话，可以看到实际的组件和 <code>wire</code> 存在于不同的文件中。这种方式让组件和 <code>mapper</code> 函数的单元测试更简单。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 &lt;a href=&quot;http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;依赖注入&lt;/a&gt; 的技术 (大多数人认为它是一种模式) 用来解决这种问题。&lt;/p&gt;
&lt;p&gt;在 React 中，对依赖注入的需要是显而易见的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-Redux</title>
    <link href="https://duanruilong.github.io/2018/06/11/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Redux/"/>
    <id>https://duanruilong.github.io/2018/06/11/React开发常用设计模式-Redux/</id>
    <published>2018-06-11T15:52:51.000Z</published>
    <updated>2018-06-16T09:11:45.641Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a> 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (<a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank" rel="noopener">视频</a>)。它类似于 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics" target="_blank" rel="noopener">Flux 架构</a> 并有很多共同点。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Redux-架构及其主要特点"><a href="#Redux-架构及其主要特点" class="headerlink" title="Redux 架构及其主要特点"></a>Redux 架构及其主要特点</h2><p><img src="/blog/2018/06/11/React开发常用设计模式-Redux/redux-architecture.jpg" alt="redux"></p><p>类似于 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md" target="_blank" rel="noopener">Flux</a> 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 <code>store</code>中。注意，我们说的是 <code>store</code>，而不是 <code>stores</code> ，这是因为在 <code>Redux</code> 中只有一个 <code>store</code> ，这是 <code>Redux</code> 与 <code>Flux</code> 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 <code>reducers</code> 。一旦 <code>store</code>接收到动作，它会将当前状态和给定动作发送给<code>reducer</code>并要求其返回一个新的状态。然后，在数据不可变的方式下， <code>reducer</code>需要返回新的状态。再然后， <code>store</code>更新自身的内部状态。最后，与 <code>store</code>连接的 <code>React</code>组件会重新渲染。</p><p>概念相当清晰并再次遵循了 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md" target="_blank" rel="noopener">单向数据流</a> 。我们来讨论每一个部分并引入一些支持 <code>Redux</code> 模式工作的新术语。</p><h2 id="动作-Actions"><a href="#动作-Actions" class="headerlink" title="动作 ( Actions )"></a>动作 ( Actions )</h2><p><code>Redux</code> 中的动作和 <code>Flux</code>一样，也只是有 <code>type</code>属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用像 <code>CHANGE_VISIBILITY</code> 这样的常量作为动作的类型是一种最佳实践。有很多支持 <code>Redux</code>的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。</p><p><code>visible</code> 属性是我们所提到过的元数据。它与 <code>Redux</code>本身无关，它表示应用中某处需要使用的数据。</p><p>每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 <code>action creators</code> 诞生的原因。<code>action creator</code> 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">changeVisibility(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// &#123; type: CHANGE_VISIBILITY, visible: false &#125;</span></span><br></pre></td></tr></table></figure></p><p>注意，将 <code>visible</code> 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p><code>Redux</code> 提供辅助函数 <code>createStore</code> 来创建 <code>store</code> 。它的函数签名如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from 'redux';</span><br><span class="line"></span><br><span class="line">createStore([reducer], [initial state], [enhancer]);</span><br></pre></td></tr></table></figure></p><p>正如之前所提到的，<code>reducer</code> 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 <code>store</code> 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数<code>enhancer</code>提供 API 来使用第三方的中间件来扩展<code>Redux</code>，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。</p><p>创建好的<code>store</code> 具有四个方法:<code>getState、dispatch、subscribe</code>和 <code>replaceReducer</code> 。其中最重要的或许就是<code>dispatch</code>:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(changeVisibility(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure></p><p>这里我们使用的是 <code>action creator</code>。我们将其结果 (即 action 对象) 传给 <code>dispatch</code>方法。然后，它会传播给应用中的 <code>reducers</code>。</p><p>在典型的<code>React</code>应用中，我们通常不会直接使用<code>getState 和 subscribe</code>，因为有辅助函数  可以将<code>组件</code>和 <code>store</code>联系起来并有效地订阅 <code>store</code> 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用<code>getState</code>。<code>replaceReducer</code>是一个高级 API ，它用来交互 <code>store</code>所使用的当前 <code>reducer</code> 。</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><code>reducer</code>函数大概是<code>Redux</code>中最精华的部分。<code>reducer</code>还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。</p><div class="note danger"><p>(1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 </p></div><div class="note danger"><p>(2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 </p></div><p>下面是个很简单的计数器 reducer :</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; value: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。</p><h2 id="连接-React-组件"><a href="#连接-React-组件" class="headerlink" title="连接 React 组件"></a>连接 React 组件</h2><p>如果是在 <code>React</code>上下文中讨论<code>Redux</code>的话，那基本离不开 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a> 模块。它提供两样东西来进行 <code>Redux</code> 到组件的连接。</p><blockquote><p>(1) <code>&lt;Provider&gt; 组件</code> - 它是一个组件，它接收 <code>store</code>并使得所有的子组件都可以通过 React 的 context API 来访问 <code>store</code>。</p></blockquote><p>例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store=&#123; myStore &#125;&gt;</span><br><span class="line">  &lt;MyApp /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure></p><p>通常，我们只在应用中的单个地方使用它。</p><blockquote><p>(2) <code>connect 函数</code> - 它是一个函数，它负责订阅 <code>store</code>的更新和重新渲染组件。它是通过 <a href="https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component" target="_blank" rel="noopener">高阶组件</a> 实现的。</p></blockquote><p>这是它的函数签名:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connect(</span><br><span class="line">  [mapStateToProps],</span><br><span class="line">  [mapDispatchToProps],</span><br><span class="line">  [mergeProps],</span><br><span class="line">  [options]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>mapDispatchToProps</code>也是类似的，只是它接收的是 <code>dispatch</code>函数，而不是<code>state</code> 。这里是我们将派发动作定义成属性的地方。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">  changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>mergeProps</code>将 <code>mapStateToProps、 mapDispatchToProps</code>和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。<code>options</code> 接收一组如何控制连接的设置。</p><h2 id="使用-Redux-的简单计数器应用"><a href="#使用-Redux-的简单计数器应用" class="headerlink" title="使用 Redux 的简单计数器应用"></a>使用 Redux 的简单计数器应用</h2><p>使用上面所有的 API 来创建一个简单的计数器应用。<br><img src="/blog/2018/06/11/React开发常用设计模式-Redux/redux-counter-app.png" alt="react"></p><p>“Add” 和 “Subtract” 按钮只是改变 <code>store</code> 的值。”Visible” 和 “Hidden” 按钮用来控制计数器是否显示。</p><h3 id="创建动作"><a href="#创建动作" class="headerlink" title="创建动作"></a>创建动作</h3><p>每个 <code>Redux</code> 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:<code>增加、减少和管理可见性</code>。所有动作代码如下所示:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ADD = 'ADD';</span><br><span class="line">const SUBTRACT = 'SUBTRACT';</span><br><span class="line">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = () =&gt; (&#123; type: ADD &#125;);</span><br><span class="line"><span class="keyword">const</span> subtract = () =&gt; (&#123; type: SUBTRACT &#125;);</span><br><span class="line"><span class="keyword">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Store-及其-reducers"><a href="#Store-及其-reducers" class="headerlink" title="Store 及其 reducers"></a>Store 及其 reducers</h3><p>在解释 <code>store</code> 和 <code>reudcers</code>时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。<code>store</code> 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  counter: &#123;</span><br><span class="line">    value: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  visible: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>需要为这两部分分别定义 <code>reducer</code>。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 <code>reducer</code> 函数来进行维护，这样管理起来将会非常困难。</p><p><code>Redux</code>提供辅助函数来让我们能够锁定<code>state</code>的某个特定部分并为其分配一个 <code>reducer</code>。它就是 <code>combineReducers</code> :<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, combineReducers &#125; from 'redux';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: function A() &#123; ... &#125;,</span><br><span class="line">  visible: function B() &#123; ... &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure></p><p>函数 A 只接收 <code>counter</code> 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。</p><p><code>counter</code> 切片的<code>reducer</code> 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 <code>counter</code> 状态。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state || &#123; value: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当 <code>store</code> 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 <code>{ type: &quot;@@redux/INIT&quot;}</code> 。在这个实例中，reducer 应该返回数据的初始值 <code>{ value: 0 }</code> 。</p><p>visible 的 reducer 相当简单，它只处理动作 <code>CHANGE_VISIBILITY</code> :<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visibilityReducer = function (state, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === CHANGE_VISIBILITY) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.visible;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  visible: visibilityReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="选择器-Selectors"><a href="#选择器-Selectors" class="headerlink" title="选择器 ( Selectors )"></a>选择器 ( Selectors )</h3><p>我们知道状态通常都是细化成多个状态切片。我们有专门的 <code>reducer</code>来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCounterValue = state =&gt; state.counter.value;</span><br><span class="line"><span class="keyword">const</span> getVisibility = state =&gt; state.visible;</span><br></pre></td></tr></table></figure></p><p>这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。</p><h3 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h3><p>先来处理管理计数器可见性的 UI 部分。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Visibility</span><span class="params">(&#123; changeVisibility &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class="literal">true</span>) &#125;&gt;</span><br><span class="line">        Visible</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class="literal">false</span>) &#125;&gt;</span><br><span class="line">        Hidden</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibilityConnected = connect(</span><br><span class="line">  null,</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class="line">  &#125;)</span><br><span class="line">)(Visibility);</span><br></pre></td></tr></table></figure></p><p>第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Counter</span><span class="params">(&#123; value, add, subtract &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Value: &#123; value &#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123; add &#125;&gt;Add&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123; subtract &#125;&gt;Subtract&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterConnected = connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    value: getCounterValue(state)</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    add: () =&gt; dispatch(add()),</span><br><span class="line">    subtract: () =&gt; dispatch(subtract())</span><br><span class="line">  &#125;)</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure><p>这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: <code>value、add 和 subtract</code>。</p><p>最后要完成的就是 App 组件，我们在这里进行应用的组装。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">App</span><span class="params">(&#123; visible &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;VisibilityConnected /&gt;</span><br><span class="line">      &#123; visible &amp;&amp; &lt;CounterConnected /&gt; &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AppConnected = connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    visible: getVisibility(state)</span><br><span class="line">  &#125;)</span><br><span class="line">)(App);</span><br></pre></td></tr></table></figure><p>再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Redux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:</p><p><img src="/blog/2018/06/11/React开发常用设计模式-Redux/redux-reallife.jpg" alt="react"></p><p>顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。</p><p>我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://redux.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redux&lt;/a&gt; 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频&lt;/a&gt;)。它类似于 &lt;a href=&quot;https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flux 架构&lt;/a&gt; 并有很多共同点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(五)</title>
    <link href="https://duanruilong.github.io/2018/05/29/ES6%E6%94%BB%E7%95%A5-%E4%BA%94/"/>
    <id>https://duanruilong.github.io/2018/05/29/ES6攻略-五/</id>
    <published>2018-05-29T14:50:35.000Z</published>
    <updated>2018-06-16T08:37:22.383Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h1><h2 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h2><p>这个方法其实是<code>es5</code>的，还是很好用的。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line">arr.forEach(function(val)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h2><p>它是将两类对象装换为真的数组：<code>类数组对象arguments</code>、<code>可遍历对象</code>（可数Object、Set、Map).</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let myObj = &#123;length:2,'0':'hello','1':'world'&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(myObj));</span><br><span class="line"><span class="comment">//[ 'hello', 'world' ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- Set --&gt;</span><br><span class="line"></span><br><span class="line">let mySet = <span class="keyword">new</span> Set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">mySet.add('hello');</span><br><span class="line">mySet.add('hello');</span><br><span class="line">mySet.add(NaN);</span><br><span class="line">mySet.add(NaN);</span><br><span class="line">mySet.add(undefined);</span><br><span class="line">mySet.add(undefined);</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(mySet));</span><br><span class="line"><span class="comment">//[ 1, 2, 3, 'hello', NaN, undefined ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- Map --&gt;</span><br><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.set(0,'hello');</span><br><span class="line">myMap.set(true,'world');</span><br><span class="line">myMap.set(1,'haha');</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(myMap));</span><br><span class="line"><span class="comment">//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- arguments --&gt;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(Array.from(arguments));</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//[ 1, 3, 5 ]</span></span><br></pre></td></tr></table></figure><h2 id="find-和findindex"><a href="#find-和findindex" class="headerlink" title="find()和findindex()"></a>find()和findindex()</h2><p><code>find()</code>查找数组里符合条件的<code>第一个值</code><br><code>findindex()</code>是查找数组里符合条件的第一个索引的<code>下标</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- find() --&gt;</span><br><span class="line">console.<span class="built_in">log</span>([<span class="number">-1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">2</span>));</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">&lt;!-- findindex() --&gt;</span><br><span class="line">console.<span class="built_in">log</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(function(value, index, arr) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">4</span>;</span><br><span class="line"> <span class="comment">//5这个值的索引下标是1</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="fill-填充方法"><a href="#fill-填充方法" class="headerlink" title="fill()填充方法"></a>fill()填充方法</h2><p>将<code>空数组</code>填充固定的某一个值。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> Array(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//[ , , , ]</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> Array(<span class="number">4</span>).fill(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//[2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure><h2 id="lterator-遍历器"><a href="#lterator-遍历器" class="headerlink" title="lterator 遍历器"></a>lterator 遍历器</h2><p>使用最多的遍历器是：<code>for...in</code>和<code>for</code><br>前者是循环遍历<code>Object</code>对象，后者是遍历数组<br>在<code>ES6</code>里又新增加了2种数据结构：<code>Set</code>和<code>Map</code>。这里就用到了<code>lterator</code>，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用<code>for....of</code>循环。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.set(0,'hello');</span><br><span class="line">myMap.set(1,'world');</span><br><span class="line">myMap.set('hi','jack');</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(let v of myMap)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(v);</span><br><span class="line"> console.log(v[0]+'--'+v[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [0, "hello"]</span></span><br><span class="line"><span class="comment">    0--hello</span></span><br><span class="line"><span class="comment">    [1, "world"]</span></span><br><span class="line"><span class="comment">    1--world</span></span><br><span class="line"><span class="comment">    ["hi", "jack"]</span></span><br><span class="line"><span class="comment">    hi--jack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">let mySet = <span class="keyword">new</span> Set([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(let v of mySet)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p><code>Module</code>它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。</p><p>这里需要注意：<br><code>Node</code>环境下使用<code>export</code>和<code>require</code><br><code>前端JS</code>环境下使用<code>export</code>和<code>import</code>(需要babel等工具来解析)</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- foo.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出方法</span></span><br><span class="line"><span class="keyword">module</span>.exports.sayHi = function()&#123;</span><br><span class="line"> console.log('hello,world');</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象</span></span><br><span class="line"><span class="keyword">module</span>.exports.obj = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> constructor( name)&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> eat() &#123;</span><br><span class="line">  console.log(this.name+' eat');</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出一个类</span></span><br><span class="line"><span class="keyword">module</span>.exports.Person = Person;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- text.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入模块</span></span><br><span class="line">var text = require('./foo.js');</span><br><span class="line"><span class="comment">//使用模块</span></span><br><span class="line">text.sayHi();</span><br><span class="line">console.<span class="built_in">log</span>(text.obj.a);</span><br><span class="line"></span><br><span class="line">var p = new text.Person('jack');</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>在se6的语法下，需要babel 的支持。<br>1、安装</p><p><code>npm install   babel-preset-es2015</code><br><code>npminstall --global  babel-cli</code></p><p>2、配置.babelrc文件</p><p><code>{&quot;presets&quot;:[&quot;es2015&quot;]}</code></p><p>3、测试一下</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">export</span>.js --&gt;</span><br><span class="line"></span><br><span class="line">var yourname = 'Jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;yourname, age&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">import</span>.js --&gt;</span><br><span class="line"></span><br><span class="line">import &#123;yourname, age&#125; from './export.js';</span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(yourname,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行</p><p><code>babel export.js --out-file export_out.js</code><br><code>babel import.js --out-file import_out.js</code></p><p>运行结束之后，目录下增加了2个输出文件，<code>export_out.js</code>和<code>import_out.js</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  export_out.js--&gt;</span><br><span class="line"></span><br><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">Object.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">var yourname = 'Jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">exports.yourname = yourname;</span><br><span class="line">exports.age = age;</span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- import_out.js --&gt;</span><br><span class="line"></span><br><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">var _export = require('./export.js');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(_export.yourname, _export.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实翻译过来后，仍旧是<code>exports</code>和<code>require</code>！</p><p>5、在前端测试text.html</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;测试一下&lt;/title&gt;</span><br><span class="line">&lt;script src=<span class="string">"./import_out.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    say();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样是运行不了的，他们环境都不一样，怎么可能运行。<br><code>babel</code>只是一个编译工具，这里只是把es6编译为<code>common.js</code>规范的语法，<code>require</code>这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。</p><blockquote><p>common、cmd、amd:<br><code>cmd</code>是seajs遵循的规范<br><code>amd</code>是requirejs遵循的规范<br><code>commomJS</code>是node遵循的规范</p></blockquote><p>就需要加入<code>webpack</code>.</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>1、安装<br><code>npm install webpack -g (全局安装)</code><br><code>npm install webpack (本地安装)</code></p><p>2、运行编译<br><code>webpack import_out.js bundle.js</code></p><p>因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。</p><p>3、 再一次测试test.html</p><blockquote><p>会有错误抛出：say is not defined</p></blockquote><p>这个其实是模块化的问题，<code>say()</code>方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有<br><code>(function(modules) { ....... })();</code> 这就是一个自执行的封闭空间。<br>如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。<br>webpack有个<code>expose-loader</code>这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">var _export = require('./export.js');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(_export.yourname, _export.age);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 把say()方法挂到window下面 --&gt;</span><br><span class="line">window.say = say;</span><br></pre></td></tr></table></figure></p><p>然后再运行一下webpack命令：<br><code>webpack import_out.js bundle.js</code><br>好啦，你再运行下test.html，发现终于成功啦！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。</p><blockquote><p>参考原文：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&amp;hid=13&amp;sn=7b07c59cafcf19e4805a803bf9f34347&amp;scene=1&amp;devicetype=android-26&amp;version=26060637&amp;lang=zh_CN&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_be748ba8c36a&amp;wx_header=1" target="_blank" rel="noopener">ES6攻略</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(四)</title>
    <link href="https://duanruilong.github.io/2018/05/29/ES6%E6%94%BB%E7%95%A5-%E5%9B%9B/"/>
    <id>https://duanruilong.github.io/2018/05/29/ES6攻略-四/</id>
    <published>2018-05-28T16:09:06.000Z</published>
    <updated>2018-06-16T08:37:47.517Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>之前的JS只提供了两种容器：<code>数组</code>和<code>对象</code>。es6又添加了另一种非常有用的数据结构：<code>Set</code>。他就是<code>集合</code>的意思，本身也是一种容器。<br>既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？<br>拿他跟数组比较的话，<code>Set</code>的最大的特点就是<code>每个值都是唯一的，不能有重复值</code>。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let container = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);<span class="comment">//可以直接传入数组进行初始化</span></span><br><span class="line">container.add(<span class="number">5</span>);<span class="comment">//添加元素</span></span><br><span class="line">container.<span class="keyword">delete</span>(<span class="number">5</span>);<span class="comment">//删除元素</span></span><br><span class="line">console.<span class="built_in">log</span>(container.has(<span class="number">5</span>));<span class="comment">//false，5这个元素被删除了</span></span><br><span class="line">console.<span class="built_in">log</span>(container);<span class="comment">//Set &#123; 1, 2, 3, 4 &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(container.size);<span class="comment">//长度4</span></span><br><span class="line">let unique_arr = [...container];<span class="comment">//省略号语法</span></span><br><span class="line">console.<span class="built_in">log</span>(unique_arr);<span class="comment">//唯一值数组：[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>Set的构造方法可以直接传数组进行初始化，当然也可以这样声明：<br><code>let mySet = new Set();</code></p><p>Set跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单去重方案</span></span><br><span class="line">var arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">console.<span class="built_in">log</span>([...<span class="keyword">new</span> Set(arr)]);<span class="comment">//一句话搞定</span></span><br></pre></td></tr></table></figure><p>这并不适用于含有<code>重复对象的数组</code>，因为对象是比较的是内存地址。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(&#123;&#125;==&#123;&#125;);<span class="comment">//false,内存地址不同</span></span><br><span class="line">let arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.<span class="built_in">log</span>([...<span class="keyword">new</span> Set(arr)]);<span class="comment">//对象是无法去重的</span></span><br></pre></td></tr></table></figure></p><p>对象数组到底如何去重呢？<br>一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用<code>Set</code>的不重复特性，把对象先转成字符串存入<code>Set</code>，去掉重复值后，再转回来就好。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">unique</span><span class="params">(arr)</span></span>&#123;</span><br><span class="line"> var container = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"> arr.forEach(function(val)&#123;</span><br><span class="line"><span class="comment">//将对象转换为字符串,存入set容器中，确保唯一性。</span></span><br><span class="line">  container.add(JSON.stringify(val));</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> var newarr = [...container].<span class="built_in">map</span>(function(item)&#123;</span><br><span class="line">   <span class="keyword">return</span> JSON.parse(item);<span class="comment">//转换回去</span></span><br><span class="line">  &#125;);</span><br><span class="line"> <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新数据结构：Map"><a href="#新数据结构：Map" class="headerlink" title="新数据结构：Map"></a>新数据结构：Map</h1><p>这个是<code>Map</code>容器，而不是前面的<code>map()</code>方法，千万别弄混了（注意大小写）！<code>Map</code>就是键值对容器，跟<code>Object</code>非常类似。它有什么特别之处呢？<br>其实<code>Object</code>有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。<br>如果让键不限于字符串，而是各种数据类型呢？比如num？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;<span class="built_in">map</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button id=<span class="string">"btn1"</span>&gt;提交&lt;/button&gt;</span><br><span class="line">            &lt;button id=<span class="string">"btn2"</span>&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;　　　</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dom1 = document.getElementById('btn1');</span><br><span class="line">    var dom2 = document.getElementById('btn2');</span><br><span class="line"></span><br><span class="line">    var callback1 = function()&#123;</span><br><span class="line">        alert('提交');</span><br><span class="line">    &#125;;</span><br><span class="line">    var callback2 = function()&#123;</span><br><span class="line">        alert('关闭');</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">    m.<span class="built_in">set</span>(dom1,callback1); <span class="comment">//键是dom</span></span><br><span class="line">    m.<span class="built_in">set</span>(dom2,callback2);</span><br><span class="line">    console.<span class="built_in">log</span>(m);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p><p>一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line"><span class="built_in">map</span>.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因为对象比较的是内存地址，所以<code>[&#39;a&#39;]</code>作为新开辟的空间，无法在<code>Map容器</code>中找到。</p><p>再来看一下Map的增查改删，非常简单。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用二维数组，可以构建Map</span></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> Map([</span><br><span class="line"> ['name', '张三'],</span><br><span class="line"> ['content', 'hello,world']</span><br><span class="line">]);</span><br><span class="line">console.<span class="built_in">log</span>(myMap);<span class="comment">//Map &#123; 'name' =&gt; '张三', 'content' =&gt; 'hello,world' &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(myMap.size); <span class="comment">// 长度</span></span><br><span class="line">myMap.set('age',18);//增加属性</span><br><span class="line">console.log(myMap.get('name')); //获取属性</span><br><span class="line">myMap.delete('content');//删除属性</span><br><span class="line">console.log(myMap.has('content')); // 判断是否有这个属性</span><br><span class="line">console.<span class="built_in">log</span>(myMap.keys());<span class="comment">//获取所有的键 MapIterator &#123; 'name', 'age' &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(myMap.values());<span class="comment">//获取所有的值 MapIterator &#123; '张三', 18 &#125;</span></span><br></pre></td></tr></table></figure><p>获取的keys集合是<code>MapIterator</code>类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构</p><h1 id="Reflect是面镜子"><a href="#Reflect是面镜子" class="headerlink" title="Reflect是面镜子"></a>Reflect是面镜子</h1><p><code>Reflect</code>就是反射的意思，那究竟反射啥呢？<br>大家知道镜子可以反射吧？<br><code>Reflect</code>就是一面镜子。那是谁照镜子呢？就是<code>Object</code>。<br>也就是说，<code>Object</code>把自己的属于语言内部的方法（比如Object.defineProperty）照到了<code>Reflect</code>上。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;利用反射实现数据和视图联动&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;测试Object：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;测试Reflect：&lt;input type="text" id='age'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"showName"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"showAge"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var userInfo = &#123;&#125;;</span><br><span class="line"><span class="comment">//Object的方式</span></span><br><span class="line">Object.defineProperty(userInfo, <span class="string">"userName"</span>, &#123;</span><br><span class="line">get: function()&#123;</span><br><span class="line">return document.getElementById('showName').innerHTML;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">document.getElementById('showName').innerHTML = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reflect是一面大镜子，Object你有的我就有！</span></span><br><span class="line">Reflect.defineProperty(userInfo, <span class="string">"age"</span>, &#123;</span><br><span class="line">get: function()&#123;</span><br><span class="line">return document.getElementById('showAge').innerHTML;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">document.getElementById('showAge').innerHTML = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class="line"></span><br><span class="line">userInfo.userName = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">document.getElementById('age').onkeyup = function(e)&#123;</span><br><span class="line"></span><br><span class="line">userInfo.age = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>Reflect</code>一共是13个静态方法，就是13种武器哈：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Reflect.apply(target,thisArg,args)</span><br><span class="line">Reflect.construct(target,args)</span><br><span class="line">Reflect.get(target,name,receiver)</span><br><span class="line">Reflect.<span class="built_in">set</span>(target,name,value,receiver)</span><br><span class="line">Reflect.defineProperty(target,name,desc)</span><br><span class="line">Reflect.deleteProperty(target,name)</span><br><span class="line">Reflect.has(target,name)</span><br><span class="line">Reflect.ownKeys(target)</span><br><span class="line">Reflect.isExtensible(target)</span><br><span class="line">Reflect.preventExtensions(target)</span><br><span class="line">Reflect.getOwnPropertyDescriptor(target, name)</span><br><span class="line">Reflect.getPrototypeOf(target)</span><br><span class="line">Reflect.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure></p></blockquote><p>看下几个常用的方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">name:'jack',</span><br><span class="line">age:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//简单set方法</span></span><br><span class="line">Reflect.set(obj,'name','tom');</span><br><span class="line">console.<span class="built_in">log</span>(obj.name);<span class="comment">//tom</span></span><br><span class="line"><span class="comment">//简单get方法</span></span><br><span class="line">let age = Reflect.get(obj,'age');</span><br><span class="line">console.<span class="built_in">log</span>(age);<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带有接收者对象的set方法</span></span><br><span class="line">let receiver = &#123;</span><br><span class="line">name:'lily'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。</span></span><br><span class="line"><span class="comment">//所以，obj的name属性还是tom，但接收者receiver的name被改变了。</span></span><br><span class="line"><span class="comment">//这种机制的作用是，可以在对象A中操作对象B。</span></span><br><span class="line">Reflect.set(obj,'name','bill',receiver);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.name);<span class="comment">//tom</span></span><br><span class="line">console.<span class="built_in">log</span>(receiver.name);<span class="comment">//bill</span></span><br><span class="line"><span class="comment">//判断obj是否有name属性？</span></span><br><span class="line"><span class="comment">//旧写法--in</span></span><br><span class="line">console.log('name' in obj);//true</span><br><span class="line"><span class="comment">//新写法--has</span></span><br><span class="line">console.log(Reflect.has(obj,'name'));//true</span><br></pre></td></tr></table></figure><p>他与<code>Proxy</code>结合使用更合理。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code>就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟<code>Reflect</code>是一一对应的。<br>只要<code>Proxy</code>对象有的方法，<code>Reflect</code>对象上都有。当然咯，<code>Proxy</code>没有的，<code>Reflect</code>也有。</p><p>拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：<br><code>var proxy = new Proxy(target, handler);</code></p><blockquote><p>1.target就是目标对象，我们要给哪个对象加拦截？<br>2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。</p></blockquote><p>拿最简单的set方法为例:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参说明：</span></span><br><span class="line"><span class="comment">// target:待测试的Person实例</span></span><br><span class="line"><span class="comment">// validator:验证规则personValidators</span></span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createValidator</span><span class="params">(target, validator)</span> </span>&#123;</span><br><span class="line"><span class="comment">//拦截器，拦截赋值操作，触发set函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Proxy(target, &#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">set</span>(target, key, value) &#123;</span><br><span class="line"><span class="comment">//如果待测试的Person对象中含有这个属性，就启用验证规则，</span></span><br><span class="line"><span class="comment">// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。</span></span><br><span class="line">  <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line"></span><br><span class="line">    let rules = validator[key];<span class="comment">//rules拿到的是name方法的引用</span></span><br><span class="line"><span class="comment">//相当于调用方法name('hello')</span></span><br><span class="line">    <span class="keyword">if</span> (rules(value)) &#123;</span><br><span class="line"><span class="comment">//如果验证无误，target的name属性可以修改成功</span></span><br><span class="line">     <span class="keyword">return</span> Reflect.<span class="built_in">set</span>(target, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则失败</span></span><br><span class="line">      return 'error';</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     return 'error';</span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证规则</span></span><br><span class="line"><span class="keyword">const</span> personRules = &#123;</span><br><span class="line"> name(val) &#123;</span><br><span class="line">   return typeof val === 'string';</span><br><span class="line"> &#125;,</span><br><span class="line"> age(val) &#123;</span><br><span class="line">   return typeof val === 'number' &amp;&amp; val &gt; 18;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> constructor(name, age) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="comment">//开启验证，传入这个类的实例和验证规则personRules</span></span><br><span class="line">   <span class="keyword">return</span> createValidator(<span class="keyword">this</span>, personRules);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bill = new Person('Bill', 25);</span><br><span class="line">bill.name = 'jack';//赋值成功</span><br><span class="line">bill.age = <span class="number">10</span>;<span class="comment">//赋值失败</span></span><br><span class="line">console.<span class="built_in">log</span>(bill.name);<span class="comment">//jack</span></span><br><span class="line">console.<span class="built_in">log</span>(bill.age);<span class="comment">//25</span></span><br></pre></td></tr></table></figure><p><code>createValidator</code>这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。</p><p>再来看下<code>Reflect.apply</code>的用法。这个方法的使用频率还是蛮高的</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如这个foo函数是同事张三写的</span></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//李四引入并使用了这个函数</span></span><br><span class="line">foo.apply(obj);</span><br><span class="line"><span class="comment">//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。</span></span><br><span class="line"><span class="comment">//可以在不依赖函数名的情况下改变函数的作用域么？</span></span><br><span class="line">Function.prototype.apply.call(foo,obj);</span><br><span class="line"><span class="comment">//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。</span></span><br><span class="line">Reflect.apply(foo,obj,[]);<span class="comment">//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>Proxy</code>是用于修改语言内部行为的机制，因为<code>Object</code>对象内部的方法大多属于这种情况，所以<code>handler</code>的配置，又跟<code>Reflect</code>紧密联系在一起（因为Reflect是Object的镜子嘛）。<br>应该说，<code>Reflect</code>和<code>Proxy</code>之间的关系还是不太容易理顺的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(三)</title>
    <link href="https://duanruilong.github.io/2018/05/28/ES6%E6%94%BB%E7%95%A5-%E4%B8%89/"/>
    <id>https://duanruilong.github.io/2018/05/28/ES6攻略-三/</id>
    <published>2018-05-28T15:54:45.000Z</published>
    <updated>2018-06-16T08:36:19.523Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p><code>es6</code>的<code>promise</code>写法还是不够优雅，因为后面会跟很多<code>then()</code>。应该说，<code>async/await</code>是目前解决回调问题最好的方案了。</p><blockquote><p>a:<code>async</code>函数是什么？<br>b:一句话，它就是 <code>Generator</code> 函数的语法糖。<br>a:而<code>Generator</code>又是神马？<br>b:是<code>es6</code>的一个语法。<br>a:这个语法干嘛的？<br>b:不用管它，只需要把async搞明白。</p></blockquote><p>要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是<code>10.*</code>，稳定版出到<code>8.*</code>，所以安装好就可以使用了。</p><p>使用<code>async/await</code>的目的就是去除掉<code>Promise</code>后面的<code>then()</code>,在并行下也没有<code>then()</code>的，主要是串行，就是互相依靠的请求方式。</p><ul><li>假设有三个请求：<br>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。</li></ul><p>那么，如果可以这么写就好了：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var userid = getRequest1();</span><br><span class="line">var ssoid = getRequest2(userid);</span><br><span class="line">var res = getRequest3(userid,ssoid);</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">res.then(function(data)&#123;console.<span class="built_in">log</span>(data);&#125;);</span><br></pre></td></tr></table></figure><p>把之前es6的写法改一下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var request = require('request');</span><br><span class="line">var urls = [</span><br><span class="line">'http://localhost:3000/hello1',</span><br><span class="line">'http://localhost:3000/hello2',</span><br><span class="line">'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"><span class="comment">//创建任务函数不变</span></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"> var callback = function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//布置任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//返回promise承诺</span></span><br><span class="line"> <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明async函数，返回的一定是promise对象</span></span><br><span class="line"><span class="function">async function <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line"> var data_userid = await createPromise(urls[<span class="number">0</span>]);<span class="comment">//第一个请求任务</span></span><br><span class="line"> data_userid = JSON.parse(data_userid);<span class="comment">//解析成对象</span></span><br><span class="line"> var userid = data_userid.userid;<span class="comment">//获取userid</span></span><br><span class="line"> var data_ssoid = await createPromise(urls[<span class="number">1</span>]+<span class="string">"?userid="</span>+userid);<span class="comment">//第二个请求任务</span></span><br><span class="line"> data_ssoid = JSON.parse(data_ssoid);<span class="comment">//解析成对象</span></span><br><span class="line"> var ssoid = data_ssoid.ssoid;<span class="comment">//获取ssoid</span></span><br><span class="line"> var result = await createPromise(urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid);//第三个请求任务</span><br><span class="line"> <span class="keyword">return</span> result;<span class="comment">//返回promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终执行</span></span><br><span class="line">doIt().then(function(data)&#123;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line">console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p><blockquote><p>注意：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>async需要放在函数声明前，表示这个函数返回的一定是promise对象。</span><br><span class="line"><span class="number">2.</span>await后面也必须是promise对象，表示这个任务是需要等待的。</span><br><span class="line"><span class="number">3.</span>最后用then()获取所有接口的信息，<span class="keyword">catch</span>()捕获所有异常。</span><br><span class="line"><span class="number">4.</span>这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！</span><br><span class="line"></span><br><span class="line">这样，简单整洁，只留一个then和<span class="keyword">catch</span>。</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(二)</title>
    <link href="https://duanruilong.github.io/2018/05/28/ES6%E6%94%BB%E7%95%A5-%E4%BA%8C/"/>
    <id>https://duanruilong.github.io/2018/05/28/ES6攻略-二/</id>
    <published>2018-05-28T15:36:57.000Z</published>
    <updated>2018-06-16T08:36:42.467Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p><code>回调</code>使我们时常需要面对的问题，现在<code>node</code>已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于<code>babel</code>去编译。</p><p>关于es6的pormise他就是一个对象，看下面：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对比一下他们的差异 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//布置一项任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line"><span class="comment">// ... some code</span></span><br><span class="line"><span class="comment">//resolve和reject是对象提供的两个回调函数</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">   resolve(value);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">promise.then(function(data) &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从中可以看出，他和<code>Q</code>模块有点类似，比如：<br><code>var deferred = Q.defer()</code></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var request = require('request');</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line">var callback = function(resolve, reject)&#123;</span><br><span class="line"> var url = 'http://localhost:3000/hello1';</span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//布置一项任务</span></span><br><span class="line">var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">promise.then(function(data)&#123;</span><br><span class="line"><span class="comment">//正确响应</span></span><br><span class="line"> console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(function(err)&#123;</span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"> console.log('error info:',err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果"></p><p>将url地址<a href="http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：" target="_blank" rel="noopener">http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：</a></p><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果"></p><p>再一次修改一下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">'http://localhost:3000/hello1',</span><br><span class="line">'http://localhost:3000/hello2',</span><br><span class="line">'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"><span class="comment">//这里需要改写一下~~</span></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"> var callback = function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line"> request(url , function(err , response , body)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   reject(err);<span class="comment">//错误返回</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   resolve(body);<span class="comment">//成功返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//布置任务</span></span><br><span class="line"> var promise = <span class="keyword">new</span> Promise(callback);</span><br><span class="line"><span class="comment">//返回promise承诺</span></span><br><span class="line"> <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个请求的回调</span></span><br><span class="line">var callback_Request1 = function(data)&#123;</span><br><span class="line">data = JSON.parse(data);</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">var userid = data.userid;</span><br><span class="line">var url = urls[1]+'?userid='+userid;</span><br><span class="line"><span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个请求的回调</span></span><br><span class="line">var callback_Request2 = function(data)&#123;</span><br><span class="line">data = JSON.parse(data);</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">var userid = data.userid;</span><br><span class="line">var ssoid = data.ssoid;</span><br><span class="line">var url = urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid;</span><br><span class="line"><span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务逻辑被剥离出去咯~~</span></span><br><span class="line">createPromise(urls[<span class="number">0</span>]).then(function(data)&#123;</span><br><span class="line">console.log('第一次请求');</span><br><span class="line"><span class="keyword">return</span> callback_Request1(data);</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">console.log('第二次请求');</span><br><span class="line"><span class="keyword">return</span> callback_Request2(data);</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">console.log('第三次请求');</span><br><span class="line">console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="结果："></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略(一)</title>
    <link href="https://duanruilong.github.io/2018/05/27/ES6%E6%94%BB%E7%95%A5-%E4%B8%80/"/>
    <id>https://duanruilong.github.io/2018/05/27/ES6攻略-一/</id>
    <published>2018-05-27T13:33:27.000Z</published>
    <updated>2018-06-16T08:35:48.923Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>两个很有用的原生JS函数：<code>map</code>和<code>reduce</code>。</p><ul><li>1、map() 方法：</li></ul><p>它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var callback = function(a)&#123;</span><br><span class="line">    <span class="comment">// 这里的a就是数组每一项的值</span></span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var demo = data.<span class="built_in">map</span>(callback);</span><br><span class="line">consloe.<span class="built_in">log</span>(demo)</span><br><span class="line"><span class="comment">//[2,3,4]</span></span><br></pre></td></tr></table></figure><p>在这里需要注意的是<code>map</code>里面的回调函数，参数只有一个</p><ul><li>2、reduce()方法</li></ul><p>这个方法先从代码例子开始<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var callback = function(a,b)&#123;</span><br><span class="line">    console.log('初始值=',a);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">var demo = data.reduce(callback,<span class="number">100</span>);</span><br><span class="line">console.<span class="built_in">log</span>(demo);</span><br><span class="line"><span class="comment">//初始值=100</span></span><br><span class="line"><span class="comment">//初始值=101</span></span><br><span class="line"><span class="comment">//初始值=103</span></span><br><span class="line"><span class="comment">//106</span></span><br></pre></td></tr></table></figure></p><p>reduce它有2个参数：</p><ul><li>第一个是<code>callback</code>回调函数，主要是针对数组的操作；</li><li>第二个是传入的<code>初始值</code></li></ul><p>工作原理：</p><ul><li>1、传入一个初始值；</li><li>2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；</li><li>3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；</li><li>…..</li></ul><p>依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。<br>这和<code>ajax</code>的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个<code>并行</code>，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者<br><code>Q模块</code>是用来解决回调问题，与之类似的有<code>jQuery</code>的延迟对象，ES6的<code>promise</code>对象，ES7的<code>async</code>和<code>await</code>.<br>可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。</p><blockquote><p>爬虫的工作原理：</p></blockquote><p>先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。</p><p>先安装一个发送请求模块<code>request</code>和Q模块：</p><blockquote><p><code>npm install request --dev</code><br><code>npm install q --dev</code></p></blockquote><p>然后开始写个脚本，先用<code>express</code>搭建一个服务：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express')</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET home page</span></span><br><span class="line">router.get('./',function(req,res,next)&#123;</span><br><span class="line">res.render('index',&#123;title:'Express'&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求1</span></span><br><span class="line">router.get('/list1',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求1完成了！')</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求2</span></span><br><span class="line">router.get('/list2',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求2完成了！')</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求3</span></span><br><span class="line">router.get('/list3',function(req,res,next)&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        res.send('请求3完成了！')</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><p>以上为数据接口。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span></span>&#123;</span><br><span class="line">    var deferred = Q.defer(); <span class="comment">// 创建任务</span></span><br><span class="line"></span><br><span class="line">    request(url, function(err,response,body)&#123;</span><br><span class="line">        console.log('requested',url);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            deferred.reject(err); <span class="comment">// 错误返回</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            deferred.resolve(body) <span class="comment">// 成功返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> deferred.promise; <span class="comment">// 返回一个承诺</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createPromise('http://localhost:3000/list1').then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>resolve</code>就是继续执行，<code>reject</code>就是拒绝，<code>defer</code>就是布置任务。<br>Q把每一个请求都会布置成一个任务，然后返回一个<code>promise</code>对象，<code>promise</code>就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从<code>then()</code>方法里面拿到需要的数据。</p></blockquote><p>并行请求：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3',</span><br><span class="line">    'http//localhost:3000/hello_110' //这是个错误的地址</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer(); <span class="comment">//创建任务</span></span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"requested "</span> + url);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            deferred.reject(err); <span class="comment">//错误返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferred.resolve(body); <span class="comment">//成功返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise; <span class="comment">//返回一个承诺</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var promises = urls.<span class="built_in">map</span>(function (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q.allSettled(promises).then(function (results) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(results);</span><br><span class="line">    results.forEach(function (result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === <span class="string">"fulfilled"</span>) &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(result.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            console.error(result.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用<code>map()</code>方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）</p><p>串行请求。先来个传统写法:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">request('http://localhost:3000/hello1' , function(err1 , response1 , body1)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(body1);</span><br><span class="line"> request('http://localhost:3000/hello2',function(err2 , response2 , body2)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(body2);</span><br><span class="line">    request('http://localhost:3000/hello3',function(err3 , response3 , body3)&#123;</span><br><span class="line">      console.<span class="built_in">log</span>(body3);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。<br>Q是如何解决回调地狱问题的呢？<br>其实也简单，就是把发请求部分单独拆出去，做成子任务即可。<br>前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3',</span><br><span class="line">    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer();</span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            deferred.reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            deferred.resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是亮点~~</span></span><br><span class="line">urls.reduce(function (promiseObj, url) &#123;</span><br><span class="line">    <span class="comment">//promiseObj第一次是Q(null)，也就是空的任务</span></span><br><span class="line">    <span class="keyword">return</span> promiseObj.then(function (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回promise，层级传递，直到最后一个拿到结果</span></span><br><span class="line">        <span class="keyword">return</span> createPromise(url);</span><br><span class="line">    &#125;, function (err) &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">        <span class="keyword">return</span> createPromise(url);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, Q(null));</span><br></pre></td></tr></table></figure><blockquote><p>比较难理解的还是reduce。我们这里再来分析一遍他：<br>第1步：给定一个初始值Q(null)。<br>第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。<br>第3步：把第2步的结果<code>Q(&#39;http://localhost:3000/hello1&#39;)</code>作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。</p></blockquote><p>现实中我们需求一般是这样的：</p><blockquote><p>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。<br>我们根据这种情况，再来一次：<br>改造下接口：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var express = require('express');</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, function (req, res, next) &#123;</span><br><span class="line">    res.render('index', &#123;</span><br><span class="line">        title: 'Express'</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求1</span></span><br><span class="line">router.get('/hello1', function (req, res, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: <span class="number">123</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求2</span></span><br><span class="line">router.get('/hello2', function (req, res, next) &#123;</span><br><span class="line">    var param = req.query || req.params;</span><br><span class="line">    var userid = param.userid;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: userid,</span><br><span class="line">            ssoid: <span class="number">456</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//请求3</span></span><br><span class="line">router.get('/hello3', function (req, res, next) &#123;</span><br><span class="line">    var param = req.query || req.params;</span><br><span class="line">    var userid = param.userid;</span><br><span class="line">    var ssoid = param.ssoid;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: <span class="number">200</span>,</span><br><span class="line">            userid: userid,</span><br><span class="line">            ssoid: ssoid,</span><br><span class="line">            msg: '完成啦！'</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p></blockquote><p>其次：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(<span class="string">'q'</span>);</span><br><span class="line">var request = require('request');</span><br><span class="line"></span><br><span class="line">var urls = [</span><br><span class="line">    'http://localhost:3000/hello1',</span><br><span class="line">    'http://localhost:3000/hello2',</span><br><span class="line">    'http://localhost:3000/hello3'</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">createPromise</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    var deferred = Q.defer();</span><br><span class="line">    request(url, function (err, response, body) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            deferred.reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            deferred.resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个请求的回调</span></span><br><span class="line">var callback_Request1 = function (data) &#123;</span><br><span class="line">    data = JSON.parse(data);</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">    var userid = data.userid;</span><br><span class="line">    var url = urls[1] + '?userid=' + userid;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个请求的回调</span></span><br><span class="line">var callback_Request2 = function (data) &#123;</span><br><span class="line">    data = JSON.parse(data);</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">    var userid = data.userid;</span><br><span class="line">    var ssoid = data.ssoid;</span><br><span class="line">    var url = urls[2] + '?userid=' + userid + '&amp;ssoid=' + ssoid;</span><br><span class="line">    <span class="keyword">return</span> createPromise(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务逻辑被剥离出去咯~~</span></span><br><span class="line">createPromise(urls[<span class="number">0</span>]).then(function (data) &#123;</span><br><span class="line">    console.log('第一次请求');</span><br><span class="line">    <span class="keyword">return</span> callback_Request1(data);</span><br><span class="line">&#125;).then(function (data) &#123;</span><br><span class="line">    console.log('第二次请求');</span><br><span class="line">    <span class="keyword">return</span> callback_Request2(data);</span><br><span class="line">&#125;).then(function (data) &#123;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    console.log('第三次请求');</span><br><span class="line">    console.<span class="built_in">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6攻略</title>
    <link href="https://duanruilong.github.io/2018/05/25/ES6%E6%94%BB%E7%95%A5/"/>
    <id>https://duanruilong.github.io/2018/05/25/ES6攻略/</id>
    <published>2018-05-24T16:17:09.000Z</published>
    <updated>2018-06-16T08:38:00.814Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png" alt="ES6攻略"></p><a id="more"></a><h1 id="搞定变量作用域问题：let"><a href="#搞定变量作用域问题：let" class="headerlink" title="搞定变量作用域问题：let"></a>搞定变量作用域问题：let</h1><p>ES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。<br>es6引入了let这个关键字，问题得到了解决：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let i=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//循环语句1</span></span><br><span class="line"><span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br><span class="line"><span class="comment">//循环语句2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    let i=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br><span class="line"><span class="comment">//分支语句</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    let i=<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    let i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i);<span class="comment">//100</span></span><br></pre></td></tr></table></figure></p><p>let关键字让变量作用域变得清晰可控</p><h1 id="利用const，保证全局变量不被更改"><a href="#利用const，保证全局变量不被更改" class="headerlink" title="利用const，保证全局变量不被更改"></a>利用const，保证全局变量不被更改</h1><p>有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">"jack"</span>;</span><br><span class="line"><span class="comment">//重新声明</span></span><br><span class="line">var username = 'hello';</span><br><span class="line"><span class="comment">//直接修改</span></span><br><span class="line">username = <span class="number">123</span>;</span><br><span class="line">console.<span class="built_in">log</span>(username);</span><br></pre></td></tr></table></figure></p><h1 id="类的声明与继承"><a href="#类的声明与继承" class="headerlink" title="类的声明与继承"></a>类的声明与继承</h1><p>按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到<code>高内聚低耦合</code>的设计目的。<br>其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。<br>而es6引入了静态语言的<code>class</code>之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="comment">//构造函数，注意函数之间不用加;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line">  this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  console.log(this.type + ' says ' + say);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hello'); //animal says hello</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line"> super();<span class="comment">//继承了父类的属性和方法</span></span><br><span class="line"> this.type = 'cat';</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.says('hello'); //cat says hello</span><br></pre></td></tr></table></figure></p><h1 id="箭头函数，解决this指向问题"><a href="#箭头函数，解决this指向问题" class="headerlink" title="箭头函数，解决this指向问题"></a>箭头函数，解决this指向问题</h1><p>JS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line"> this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">   console.log(this.type + ' says ' + say);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hi'); //undefined says hi</span><br></pre></td></tr></table></figure></p><p>这是一个比较经典的this被篡改的问题，因为这个该死的<code>setTimeout</code>函数，他的<code>this</code>指向的是window对象。<br>我们可以利用一个变量保存住这个<code>this</code>指针，也或者使用<code>bind(this)</code>方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"> constructor()&#123;</span><br><span class="line">  this.type = 'animal';</span><br><span class="line"> &#125;</span><br><span class="line"> says(say)&#123;</span><br><span class="line">  setTimeout( () =&gt; &#123;</span><br><span class="line">   console.log(this.type + ' says ' + say);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says('hi'); //animal says hi</span><br></pre></td></tr></table></figure></p><h1 id="插入大段html文本"><a href="#插入大段html文本" class="headerlink" title="插入大段html文本"></a>插入大段html文本</h1><p>这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟<code>html</code>拼接好，最后追加到某个div下。<br>拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。<br>如果能不改变html的结构就好了！于是es6引入了<code>模板字串</code>的概念。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"container"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var cont = document.getElementById('container');</span><br><span class="line"><span class="comment">//一些变量</span></span><br><span class="line">var name = 'jack';</span><br><span class="line">var age = <span class="number">18</span>;</span><br><span class="line">cont.innerHTML =</span><br><span class="line"> `&lt;div style=<span class="string">"color:red;"</span>&gt;</span><br><span class="line">   &lt;span class=<span class="string">"name"</span>&gt;$&#123;name&#125;&lt;/span&gt;</span><br><span class="line">   &lt;b class=<span class="string">"age"</span>&gt;$&#123;age&#125;&lt;/b&gt;</span><br><span class="line">  &lt;/div&gt;`;</span><br></pre></td></tr></table></figure></p><p>在<code>反引号</code>中随意使用各种引号，其中的变量都用<code>${}</code>来表示。这样代码就变得优雅了。</p><h1 id="默认值default"><a href="#默认值default" class="headerlink" title="默认值default"></a>默认值default</h1><p>有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。<br>那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">hello</span><span class="params">(name)</span></span>&#123;</span><br><span class="line"> name = name || 'jack';</span><br><span class="line"></span><br><span class="line"> console.log(name+' say hello!');</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure></p><p>但这样写不够直观，es6提供了默认值的写法。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name ='jack')&#123;</span><br><span class="line"> console.log(name + ' say hello!');</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure></p><h1 id="省略号语法"><a href="#省略号语法" class="headerlink" title="省略号语法"></a>省略号语法</h1><p>省略号是一种语法糖，在处理函数不定参时十分有用。<br>像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">hello</span><span class="params">(a,b,...others)</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(others);<span class="comment">//[ 'amily', 'mike', 'sam' ]</span></span><br><span class="line">&#125;</span><br><span class="line">hello('jack','tom','amily','mike','sam');</span><br></pre></td></tr></table></figure></p><h1 id="Object几个好用的扩展"><a href="#Object几个好用的扩展" class="headerlink" title="Object几个好用的扩展"></a>Object几个好用的扩展</h1><blockquote><p>Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。</p></blockquote><ul><li>1.<code>assign()</code>方法：用于对象的合并或拷贝。<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象合并</span></span><br><span class="line">var target = &#123;a:<span class="number">1</span>&#125;;</span><br><span class="line">var source = &#123;b:<span class="number">2</span>&#125;;</span><br><span class="line">Object.assign(target,source);</span><br><span class="line">console.<span class="built_in">log</span>(target);<span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，拷贝是浅拷贝，而不是深拷贝。</p></blockquote><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象拷贝，是浅拷贝。</span></span><br><span class="line">let target = &#123; a: &#123; b: 'hello'&#125; &#125;;</span><br><span class="line">let source = &#123; c: &#123; d: 'world' &#125; &#125;;</span><br><span class="line">Object.assign(target, source);</span><br><span class="line">console.<span class="built_in">log</span>(target);<span class="comment">//&#123; a: &#123; b: 'hello' &#125;, c: &#123; d: 'world' &#125; &#125;</span></span><br><span class="line">target.c.d = 'haha';</span><br><span class="line">console.<span class="built_in">log</span>(source);<span class="comment">//&#123; c: &#123; d: 'haha' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。<br>究竟是用哪种拷贝，得看实际应用场景。</p><ul><li>2.<code>defineProperty()</code>方法：双向绑定的秘密！</li></ul><p>在angular或vue等框架里，对双向绑定并不陌生。<br>数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？<br>我们可以通过这个es6新提供的方法轻松搞定它。<br>先来看一下用法：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor) </span><br><span class="line">obj：待修改的对象。</span><br><span class="line">prop：待修改的属性名称。</span><br><span class="line">descriptor：待修改属性的相关描述，要求传入一个对象。</span><br><span class="line">&#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: '',</span><br><span class="line">    <span class="built_in">set</span>: function()&#123;&#125;,</span><br><span class="line">    get: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ <span class="keyword">delete</span> ），是否可以修改属性的 writable 、 enumerable 属性。</span><br><span class="line">- enumerable：属性是否可遍历出来（可通过 <span class="keyword">for</span>...in 遍历到）。</span><br><span class="line">- writable：属性是否可重写（是否可以对属性进行重新赋值？）</span><br><span class="line">- value：属性的默认值。</span><br><span class="line">- <span class="built_in">set</span>：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。</span><br><span class="line">- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。</span><br></pre></td></tr></table></figure></p><p>看个例子：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性name，值为jack</span></span><br><span class="line">Object.defineProperty(obj, 'name', &#123;</span><br><span class="line"> value: 'jack'</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性age，值为100</span></span><br><span class="line">Object.defineProperty(obj, 'age', &#123;</span><br><span class="line"> value: <span class="number">100</span>,</span><br><span class="line"> configurable: <span class="literal">true</span>,<span class="comment">//可配置</span></span><br><span class="line"> enumerable: <span class="literal">true</span>,<span class="comment">//可遍历出来</span></span><br><span class="line"> writable: <span class="literal">true</span><span class="comment">//可写</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.age); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">18</span>;<span class="comment">//重写</span></span><br><span class="line">console.<span class="built_in">log</span>(obj.age); <span class="comment">// 18. 因为age属性是可重写的</span></span><br><span class="line"><span class="comment">//遍历obj</span></span><br><span class="line"><span class="keyword">for</span>(let key in obj)&#123;</span><br><span class="line"> console.<span class="built_in">log</span>(key+<span class="string">":"</span>+obj[key]);<span class="comment">//age:18，默认是不可配置的，所以name读不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给obj对象赋予了一个属性sex，值为male</span></span><br><span class="line">Object.defineProperty(obj, 'sex', &#123;</span><br><span class="line"> value: 'male',</span><br><span class="line"> writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.sex = 'female'; // 不可重写</span><br><span class="line">console.<span class="built_in">log</span>(obj.sex); <span class="comment">// 'male'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.sex; <span class="comment">// 属性删除无效，默认是不可配置的</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj.sex);<span class="comment">// 'male'，依然可以读出</span></span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, 'weight', &#123;</span><br><span class="line"><span class="comment">//value: '75kg',//如果打开这个value就会报错</span></span><br><span class="line"> <span class="built_in">set</span>: function(str) &#123;</span><br><span class="line">console.log('set weight',str);</span><br><span class="line">&#125;,</span><br><span class="line"> get:function()&#123;</span><br><span class="line">console.log('get weight');</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。<br>下面就来看一下如何实现一个数据和视图双向绑定效果。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;数据和视图联动&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;测试用户名：&lt;input type="text" id='userName'/&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"show"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;　　　</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var userInfo = &#123;&#125;;</span><br><span class="line">Object.defineProperty(userInfo, <span class="string">"userName"</span>, &#123;</span><br><span class="line"> get: function()&#123;</span><br><span class="line">  return document.getElementById('show').innerHTML;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="built_in">set</span>: function(name)&#123;</span><br><span class="line">  document.getElementById('show').innerHTML = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class="line"><span class="comment">//改变数据，触发set方法，从而改变了视图。</span></span><br><span class="line"> userInfo.userName = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="/blog/2018/05/25/ES6攻略/01.png" alt="运行效果："></p><ul><li>3.对象简写<br>es6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> name:'jack',</span><br><span class="line"> age:<span class="number">18</span>,</span><br><span class="line"> method() &#123;</span><br><span class="line">   return this.name+'--'+this.age;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(obj.method());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/es6_d.png&quot; alt=&quot;ES6攻略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://duanruilong.github.io/categories/ES6/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端面试集锦</title>
    <link href="https://duanruilong.github.io/2018/05/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"/>
    <id>https://duanruilong.github.io/2018/05/24/前端面试集锦/</id>
    <published>2018-05-24T14:30:17.000Z</published>
    <updated>2018-06-16T09:21:12.115Z</updated>
    
    <content type="html"><![CDATA[<p>这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/webtry_d.png" alt="React"></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>一些更新从最新的开始</p></blockquote><h1 id="Ract"><a href="#Ract" class="headerlink" title="Ract"></a>Ract</h1><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期?"></a>React生命周期?</h2><h3 id="React-生命周期分为三种状态-1-初始化-2-更新-3-销毁"><a href="#React-生命周期分为三种状态-1-初始化-2-更新-3-销毁" class="headerlink" title="React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁"></a>React 生命周期分为三种状态 <code>1. 初始化</code> <code>2.更新</code> <code>3.销毁</code></h3><p><img src="https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg" alt="react生命周期"></p><!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) --><blockquote><p>初始化</p></blockquote><p>1、<code>getDefaultProps()</code> 设置默认的props，也可以使用<code>dufaultProps</code>设置组件的默认属性<br>2、<code>getInitialState()</code>在es6的class语法里是没有这个函数的，可直接在<code>construction</code>里去定义<code>this.state</code>也就可以访问到<code>this.props</code><br>3、<code>compontentWillMount()</code>整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改<code>state</code>值<br>4、<code>render</code> 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了<br>5、<code>compontentDidMount()</code> 组件渲染完成之后调用，且只调用一次</p><blockquote><p>更新</p></blockquote><p>6、<code>componentWillReceiverProps(nextProps)</code> 在组件初始化的时候不会触发，组件接收到新的<code>props</code>时触发<br>7、<code>shouldCompontUpdate(nextProps, nextState)</code> 这里是<code>React</code>性能优化非常重要的生命周期。在组件接收到新的<code>props</code>或者<code>state</code>时可以触发这个生命周期，可以对比前后<code>props</code>和<code>state</code>是否一样，如果相同一样则返回<code>false</code>去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行<code>diff</code>算法对比，极大地节省性能。<br>8、<code>componentWillUpdate(nextProps, nextState)</code> 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改<code>state</code><br>9、<code>render()</code> 渲染组件<br>10、 <code>componentDidUpdate()</code> 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取<code>dom</code>节点</p><blockquote><p>卸载</p></blockquote><p>11、<code>componentWillUnmount()</code> 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等</p><hr><h1 id="前端的一些知识模块"><a href="#前端的一些知识模块" class="headerlink" title="前端的一些知识模块"></a>前端的一些知识模块</h1><p><strong> HTML </strong><br>对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储</p><p><strong> CSS </strong><br>flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性</p><p><strong> JavaScript </strong><br>数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE</p><p><strong> 其他 </strong><br>移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作</p><p>作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Doctype作用？标准模式与兼容模式各有什么区别"><a href="#Doctype作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype作用？标准模式与兼容模式各有什么区别?"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h2><p>1、<code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于 <code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现。</p><p>2、<code>标准模式的排版</code> 和 <code>JS运作模式</code>都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。</p><hr><h2 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h2><p>HTML5不基于<code>SGML</code>,所以不需要对DTD进行引用，但是他也需要<code>DOCTYPE</code>来规范浏览器的行为。</p><hr><h2 id="常见的浏览器有哪些，及其浏览器的内核是啥？"><a href="#常见的浏览器有哪些，及其浏览器的内核是啥？" class="headerlink" title="常见的浏览器有哪些，及其浏览器的内核是啥？"></a>常见的浏览器有哪些，及其浏览器的内核是啥？</h2><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]</p><hr><h2 id="浏览器内核的理解？"><a href="#浏览器内核的理解？" class="headerlink" title="浏览器内核的理解？"></a>浏览器内核的理解？</h2><p>主要分为两部分：<code>渲染引擎（Layout engineer或Rendering Engine）</code>和<code>JS引擎</code></p><blockquote><p>渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。</p></blockquote><blockquote><p>JS引擎：解析和执行JavaScript实现网页动态效果。</p></blockquote><hr><h2 id="页面样式引入，link与-import-的区别？"><a href="#页面样式引入，link与-import-的区别？" class="headerlink" title="页面样式引入，link与@import`的区别？"></a>页面样式引入，<code>link</code>与<code></code>@import`的区别？</h2><p>1、<code>link</code>属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<br>2、<code>@import</code>是CSS提供的，只能用于加载CSS;<br>3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>4、<code>import</code>是CSS2.1 提出的，只在IE5以上才能被识别，而<code>link</code>是XHTML标签，<code>无兼容问题</code>;</p><hr><h2 id="行内元素有哪些，块级元素有哪些，空元素有哪些？"><a href="#行内元素有哪些，块级元素有哪些，空元素有哪些？" class="headerlink" title="行内元素有哪些，块级元素有哪些，空元素有哪些？"></a>行内元素有哪些，块级元素有哪些，空元素有哪些？</h2><blockquote><p>CSS规范规定，每个元素都有<code>display</code>属性，确定该元素的类型，每个元素都有默认的<code>display</code>值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p></blockquote><p>行内元素: <code>a b span img input select strong(强调的语气)</code><br>块级元素：<code>div p ul ol li dl dt dd h1 h2 h3 h4 ...</code><br>常见的空元素: <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>和<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p><hr><h2 id="HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class="line">    - 绘画 canvas;</span><br><span class="line">    - 用于媒介回放的 video 和 audio 元素;</span><br><span class="line">    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class="line">    - sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class="line">    - 语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class="line">    - 表单控件，calendar、date、time、email、url、search;</span><br><span class="line">    - 新的技术webworker, websocket, Geolocation;</span><br><span class="line"></span><br><span class="line">    - 移除的元素：</span><br><span class="line">        纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class="line">        对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class="line"></span><br><span class="line">   - 支持HTML5新标签：</span><br><span class="line">        IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class="line">        可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class="line">        浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class="line"></span><br><span class="line">        当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class="line">        &lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line">            &lt;script&gt; src=<span class="string">"http://html5shim.googlecode.com/svn/trunk/html5.js"</span>&lt;/script&gt;</span><br><span class="line">        &lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</span><br></pre></td></tr></table></figure><hr><h2 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h2><p><code>用正确的标签做正确的事情。</code><br>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p><hr><h2 id="HTML5的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下？</h2><blockquote><p> 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p></blockquote><p>如何使用：<br>1、页面头部像下面一样加入一个<code>manifest</code>的属性；<br>2、在<code>cache.manifest</code>文件的编写离线存储的资源；<br>    <code>CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html</code><br>3、在离线状态时，操作<code>window.applicationCache</code>进行需求实现。</p><p>详细的使用请参考：<a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener">HTML5 离线缓存-manifest简介</a>,<a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></p><hr><h2 id="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。<br>详细请参考：<a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></p><hr><h2 id="描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？"><a href="#描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？" class="headerlink" title="描述一下 Cookies，SessionStorage 和 LocalStorage 的区别？"></a>描述一下 <code>Cookies</code>，<code>SessionStorage</code> 和 <code>LocalStorage</code> 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。<br>存储大小：</p><ul><li>cookie数据大小不能超过4k。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><p>有期时间：</p><ul><li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li><li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><hr><h2 id="Iframe有那些缺点？"><a href="#Iframe有那些缺点？" class="headerlink" title="Iframe有那些缺点？"></a><strong>Iframe有那些缺点？</strong></h2><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><blockquote><p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p></blockquote><hr><h2 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h2><blockquote><p><code>label</code>标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>（1）有两种， <code>IE 盒子模型</code>、<code>W3C 盒子模型</code>；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/webtry_d.png&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://duanruilong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://duanruilong.github.io/tags/ES6/"/>
    
      <category term="CSS" scheme="https://duanruilong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅—认识一下</title>
    <link href="https://duanruilong.github.io/2018/05/22/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B/"/>
    <id>https://duanruilong.github.io/2018/05/22/小程序之旅—-认识一下/</id>
    <published>2018-05-22T15:19:02.000Z</published>
    <updated>2018-06-14T16:59:21.213Z</updated>
    
    <content type="html"><![CDATA[<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png" alt="微信小程序"></p><a id="more"></a><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li>page — 项目所有的页面模板</li><li>utils — 公共js工具</li><li>app.js — 启动入口文件</li><li>app.wxss — 项目的全局样式文件</li><li>app.json — 项目的配置文件</li></ul><p>在<code>app.json</code>里我们可以看到<code>page</code>下面就是我们可以配置的页面路径，<code>pages/index/index</code>这个路径就可以访问<code>index.wxml</code>下的东西，每一个页面都有“三大件”—<code>js、wxml、wxss</code>组成。</p><p><img src="/blog/2018/05/22/小程序之旅—-认识一下/xcx1.png" alt="小程序"><br>下面开始我们小栗子：</p><p>新增一个view，<code>wxml</code>与<code>wxss</code>就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text <span class="class"><span class="keyword">class</span>="<span class="title">demo</span>"&gt;这是一个测试小栗子&lt;/text&gt;</span></span><br><span class="line"><span class="class">  &lt;/view&gt;</span></span><br><span class="line"><span class="class">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line">.userinfo &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-avatar &#123;</span><br><span class="line">  width: <span class="number">128</span>rpx;</span><br><span class="line">  height: <span class="number">128</span>rpx;</span><br><span class="line">  margin: <span class="number">20</span>rpx;</span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-nickname &#123;</span><br><span class="line">  color: <span class="meta">#aaa;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.usermotto &#123;</span><br><span class="line">  margin-top: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新增加的  */</span></span><br><span class="line">.demo&#123;</span><br><span class="line">  color:blueviolet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存好就可以看到效果了。<br>接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;  <span class="comment">// 页面跳转函数</span></span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123; <span class="comment">//获取用户信息</span></span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>具体函数对应含义也可以参考<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject" target="_blank" rel="noopener">微信公众平台开发</a>。</p><p>先去wxml文件下增加一个按<code>&lt;button class=&#39;primary&#39; bindtap=&#39;changeDemo&#39;&gt;点击改变状态&lt;/button&gt;</code>,接着去js文件下添加初始数据，和点击的事件函数。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text class="demo"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span>='<span class="title">primary</span>' <span class="title">bindtap</span>='<span class="title">changeDemo</span>'&gt;点击改变状态&lt;/button&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;  <span class="comment">// 页面跳转函数</span></span><br><span class="line">      url: '../logs/logs'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//新增加的事件</span></span><br><span class="line">  changeDemo:function()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setDate(&#123;</span><br><span class="line">      demotext: '点击之后就改变了我的状态',</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123; <span class="comment">//获取用户信息</span></span><br><span class="line">    console.<span class="built_in">log</span>(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/blog/2018/05/22/小程序之旅—-认识一下/xcx1-1.png" alt="小程序"><br><img src="/blog/2018/05/22/小程序之旅—-认识一下/xcx1-2.png" alt="小程序"></p><p>在wxml文件里加入<code>if-else</code>的判断：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    demovalue:'if判断的数据',</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>接下来是<code>for</code>循环遍历数据：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;fordata&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"id"</span> wx:<span class="keyword">for</span>-item=<span class="string">"itemvalue"</span>&gt;</span><br><span class="line">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 当前页面的所有数据</span></span><br><span class="line">    motto: '我们的第一个小程序。',</span><br><span class="line">    demotext:'当前我的状态', // 新增初始值</span><br><span class="line">    demovalue:'if判断的数据',</span><br><span class="line">    fordata: [&#123; name: '测试1', num: 12 &#125;, &#123; name: '测试2', num: 22 &#125;, &#123; name: '测试3', num: 32 &#125;],</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>本地数据都没有问题了，那么接下来就是<code>Ajax 跨域请求</code>,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject" target="_blank" rel="noopener">wx.request(OBJECT)</a></p><p>示例代码：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: 'test.php', //仅为示例，并非真实的接口地址</span><br><span class="line">  data: &#123;</span><br><span class="line">     x: '' ,</span><br><span class="line">     y: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">      'content-type': 'application/json' // 默认值</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject" target="_blank" rel="noopener">wx.chooseImage(OBJECT)</a>,在js文件里新增一个方法。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function () &#123;  <span class="comment">// 加载页面时触发函数集合</span></span><br><span class="line">    var that = <span class="keyword">this</span>;</span><br><span class="line">    wx.chooseImage(&#123; <span class="comment">// 获取本地图片</span></span><br><span class="line">      count: <span class="number">1</span>, <span class="comment">// 默认9</span></span><br><span class="line">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class="line">      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        <span class="comment">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class="line">        var tempFilePaths = res.tempFilePaths</span><br><span class="line">        console.<span class="built_in">log</span>(tempFilePaths)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          demoImg: tempFilePaths</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>wxml文件：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span>="<span class="title">container</span>"&gt;</span></span><br><span class="line"><span class="class">  &lt;view class="userinfo"&gt;</span></span><br><span class="line"><span class="class">    &lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class="line"><span class="class">    &lt;block wx:else&gt;</span></span><br><span class="line"><span class="class">      &lt;image wx:if="&#123;&#123;demoImg!=null&#125;&#125;" src='&#123;&#123;demoImg&#125;&#125;'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="class">      &lt;image wx:else bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line">      &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span>="<span class="title">usermotto</span>"&gt;</span></span><br><span class="line">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;demotext=='当前我的状态'&#125;&#125;"</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;text wx:<span class="keyword">else</span> class=<span class="string">"demo"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class="line">  &lt;view wx:key=<span class="string">"id"</span> wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;fordata&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"id"</span> wx:<span class="keyword">for</span>-item=<span class="string">"itemvalue"</span>&gt;</span><br><span class="line">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>mongodb数据库的使用</title>
    <link href="https://duanruilong.github.io/2018/05/21/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://duanruilong.github.io/2018/05/21/mongodb数据库的使用/</id>
    <published>2018-05-20T16:05:33.000Z</published>
    <updated>2018-06-16T08:56:31.279Z</updated>
    
    <content type="html"><![CDATA[<p>突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/mongodb_d.png" alt="js"></p><a id="more"></a><h1 id="一、mongodb的开启和关闭"><a href="#一、mongodb的开启和关闭" class="headerlink" title="一、mongodb的开启和关闭"></a>一、mongodb的开启和关闭</h1><h2 id="1-查找mongod是否可用"><a href="#1-查找mongod是否可用" class="headerlink" title="1. 查找mongod是否可用"></a>1. 查找mongod是否可用</h2><p><code>which mongod</code></p><h2 id="2-启动mongodb"><a href="#2-启动mongodb" class="headerlink" title="2. 启动mongodb"></a>2. 启动mongodb</h2><p>指定path 和log日志<br><code>mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log</code></p><h2 id="3-关闭数据库"><a href="#3-关闭数据库" class="headerlink" title="3. 关闭数据库"></a>3. 关闭数据库</h2><p><code>mongod --shutdown</code></p><h1 id="二、mongodb的操作"><a href="#二、mongodb的操作" class="headerlink" title="二、mongodb的操作"></a>二、mongodb的操作</h1><h2 id="1-连接服务器"><a href="#1-连接服务器" class="headerlink" title="1. 连接服务器"></a>1. 连接服务器</h2><p><code>mongod 115.29.137.34:27017</code></p><h2 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2. 使用数据库"></a>2. 使用数据库</h2><p>(不存在的数据库也可以使用,插入数据之后会自动保存)<br><code>use mydb</code></p><h2 id="3-权限登陆"><a href="#3-权限登陆" class="headerlink" title="3. 权限登陆"></a>3. 权限登陆</h2><p><code>db.auth(&#39;username&#39;,&#39;password&#39;)</code></p><h2 id="4-展示数据库列表"><a href="#4-展示数据库列表" class="headerlink" title="4. 展示数据库列表"></a>4. 展示数据库列表</h2><p><code>show dbs</code></p><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><p>(类似于mysql的表)<br><code>db.users.insert({&#39;name&#39;:&#39;xiaomo&#39;})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:25})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:24,&#39;sex&#39;:&#39;女&#39;})</code></p><h2 id="6-查询集合"><a href="#6-查询集合" class="headerlink" title="6. 查询集合"></a>6. 查询集合</h2><p>(前提是use了一个数据库)<br>有一个System.indexes 是索引<br><code>show collections</code></p><h2 id="7-不带条件查询"><a href="#7-不带条件查询" class="headerlink" title="7. 不带条件查询"></a>7. 不带条件查询</h2><p><code>db.users.find()</code></p><h2 id="8-带条件查询"><a href="#8-带条件查询" class="headerlink" title="8. 带条件查询"></a>8. 带条件查询</h2><p>(参数是一个对象)<br><code>db.users.find({&#39;name&#39;:&#39;xiaomo&#39;})</code></p><h2 id="9-更新数据"><a href="#9-更新数据" class="headerlink" title="9. 更新数据"></a>9. 更新数据</h2><p>(有三个参数,1:查询条件,2:更新的内容 3：更新的配置)<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}})</code>修改满足条件的第一条数据<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}},{multi:true})</code>修改所有满足条件的数据</p><h2 id="10-保存数据"><a href="#10-保存数据" class="headerlink" title="10. 保存数据"></a>10. 保存数据</h2><p>(只有一个参数，必须要传id，后面是要修改的数据)<br><code>db.users.save({&#39;id&#39;:&#39;objectId(574710a97a3afd63cde56a49)&#39;,&#39;age&#39;:30})</code></p><h2 id="11-删除数据"><a href="#11-删除数据" class="headerlink" title="11. 删除数据"></a>11. 删除数据</h2><p>(1:条件 2 是否删除所有符合条件的)<br><code>db.users.remove({&#39;name&#39;:&#39;xiaomoing&#39;},true)</code></p><h2 id="12-删除集合"><a href="#12-删除集合" class="headerlink" title="12. 删除集合"></a>12. 删除集合</h2><p><code>db.users.drop()</code></p><h1 id="三、使用mongoose操作数据库"><a href="#三、使用mongoose操作数据库" class="headerlink" title="三、使用mongoose操作数据库"></a>三、使用mongoose操作数据库</h1><h2 id="1-模块的介绍"><a href="#1-模块的介绍" class="headerlink" title="1. 模块的介绍"></a>1. 模块的介绍</h2><p>连接mongdodb的驱动</p><h2 id="2-配置和链接"><a href="#2-配置和链接" class="headerlink" title="2. 配置和链接"></a>2. 配置和链接</h2><p><code>npm install --save mongoose</code><br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">&lt;!-- var uri = 'mongodb://username:password@hostname:port/databasename'; --&gt;</span><br><span class="line">var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';</span><br><span class="line">mongoose.connect(uri);</span><br></pre></td></tr></table></figure></p><h2 id="3-Model-和Shema"><a href="#3-Model-和Shema" class="headerlink" title="3. Model 和Shema"></a>3. Model 和Shema</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// model.js</span></span><br><span class="line">var Schema = mongoose.Schema,</span><br><span class="line">    ObjectId = Schema.ObjectId;</span><br><span class="line"></span><br><span class="line">var BlogPost = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    author    : ObjectId,</span><br><span class="line">    title     : String,</span><br><span class="line">    body      : String,</span><br><span class="line">    date      : Date</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Model</span></span><br><span class="line">mongoose.model('blog',Schema);</span><br><span class="line"></span><br><span class="line">var Comment = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: &#123; type: String, default: 'hahaha' &#125;,</span><br><span class="line">  age: &#123; type: Number, min: <span class="number">18</span>, index: <span class="literal">true</span> &#125;,</span><br><span class="line">  bio: &#123; type: String, match: /[a-z]/ &#125;,</span><br><span class="line">  date: &#123; type: Date, <span class="keyword">default</span>: Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a setter</span></span><br><span class="line">Comment.path('name').set(function (v) &#123;</span><br><span class="line">  <span class="keyword">return</span> capitalize(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line">Comment.pre('save', function (next) &#123;</span><br><span class="line">  notify(this.get('email'));</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-创建文档"><a href="#4-创建文档" class="headerlink" title="4. 创建文档"></a>4. 创建文档</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert.js</span></span><br><span class="line">var mongoose ＝ require('mongoose');</span><br><span class="line">require('./model.js'); //执行</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">var blog = <span class="keyword">new</span> Blog(&#123;</span><br><span class="line">    name:'xiaomo',</span><br><span class="line">    age:<span class="number">25</span>,</span><br><span class="line">    bio:'don't know',</span><br><span class="line">    date:<span class="keyword">new</span> Date</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">book.save(function(err)&#123;</span><br><span class="line">    console.log('save status:'+err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="5-删除文档"><a href="#5-删除文档" class="headerlink" title="5. 删除文档"></a>5. 删除文档</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(doc)&#123;</span><br><span class="line">  doc.reomove();</span><br><span class="line">&#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="6-简单查询"><a href="#6-简单查询" class="headerlink" title="6. 简单查询"></a>6. 简单查询</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.find(&#123;&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log('result',doc)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>第一个满足条件的结果<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">require('./model.js');</span><br><span class="line">var Blog = mongoose.model('blog');</span><br><span class="line">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log('result',doc)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7. 条件语句"></a>7. 条件语句</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condation.js</span></span><br><span class="line"> var mongoose = require('mongoose');</span><br><span class="line"> require('./model.js');</span><br><span class="line"> var Blog = mongoose.model('blog');</span><br><span class="line"> <span class="comment">//名字是xiaomo或者xiaoming 可以用$or和$and</span></span><br><span class="line"> var condation = &#123;</span><br><span class="line">   $<span class="keyword">or</span>  $<span class="keyword">and</span>:[</span><br><span class="line">   &#123;'name':'xiaomo'&#125;,</span><br><span class="line">   &#123;'name':'xiaoming'&#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"> Blog.find(condation,function(err,doc)&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(err)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log('result',doc)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h1 id="三、在项目中使用mongoose"><a href="#三、在项目中使用mongoose" class="headerlink" title="三、在项目中使用mongoose"></a>三、在项目中使用mongoose</h1><h2 id="1-生成项目"><a href="#1-生成项目" class="headerlink" title="1. 生成项目"></a>1. 生成项目</h2><p><code>koa koatest -e koatest</code></p><h2 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h2><p><code>cd koatest &amp;&amp; npm install</code></p><h2 id="3-安装mongoose"><a href="#3-安装mongoose" class="headerlink" title="3. 安装mongoose"></a>3. 安装mongoose</h2><p><code>npm install --save mongoose</code></p><h2 id="4-创建模型"><a href="#4-创建模型" class="headerlink" title="4. 创建模型"></a>4. 创建模型</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/users.server.model.js</span></span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    uid:Number,</span><br><span class="line">    username:String,</span><br><span class="line">    createTime:Date,</span><br><span class="line">    lastLogin:Date</span><br><span class="line">  &#125;)</span><br><span class="line">module.exports = mongoose.model('User',UserSchema);</span><br></pre></td></tr></table></figure><h2 id="5-创建配置文件"><a href="#5-创建配置文件" class="headerlink" title="5. 创建配置文件"></a>5. 创建配置文件</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.js</span></span><br><span class="line"><span class="keyword">module</span>.exports=&#123;</span><br><span class="line">  mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//config/mongoose.js</span></span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var config = require('./config.js');</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports=function()&#123;</span><br><span class="line">  var db = mongoose.connect(config.mongodb);</span><br><span class="line">  require('./../models/users.server.model.js');</span><br><span class="line">  <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-操作mongdodb-代码"><a href="#6-操作mongdodb-代码" class="headerlink" title="6. 操作mongdodb 代码"></a>6. 操作mongdodb 代码</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//routers/users.js</span></span><br><span class="line">var router = require('koa-router')();</span><br><span class="line">var mongoose = require('mongoose');</span><br><span class="line">var User = mongoose.model('User');</span><br><span class="line">router.get(<span class="string">'/'</span>, function *(next) &#123;</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">    var user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">      uid:</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">this</span>.body = yield User.find(&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>  嗯嗯,就这样吧，完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/mongodb_d.png&quot; alt=&quot;js&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongoDB" scheme="https://duanruilong.github.io/categories/mongoDB/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="mongoDB" scheme="https://duanruilong.github.io/tags/mongoDB/"/>
    
      <category term="Node" scheme="https://duanruilong.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-Flux</title>
    <link href="https://duanruilong.github.io/2018/05/18/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flux/"/>
    <id>https://duanruilong.github.io/2018/05/18/React开发常用设计模式-Flux/</id>
    <published>2018-05-17T16:37:45.000Z</published>
    <updated>2018-06-16T09:11:37.660Z</updated>
    
    <content type="html"><![CDATA[<p>Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。</p><p><a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a> 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 <a href="https://youtu.be/nYkdrAPrdcw?t=568" target="_blank" rel="noopener">F8</a> 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 <a href="http://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 搭配使用。React 是 Facebook 发布的另外一个库。在 <a href="http://antidote.me/" target="_blank" rel="noopener">日常工作</a> 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p><h1 id="Flux-架构及其主要特点"><a href="#Flux-架构及其主要特点" class="headerlink" title="Flux 架构及其主要特点"></a>Flux 架构及其主要特点</h1><p><img src="http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_basic_flux_architecture.jpg" alt="Flex"></p><p>这种模式的主角是<code>dispatcher</code> 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 <code>actions</code> (动作) 的通知并将其传给所有的 <code>stores</code> 。<code>store</code> 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 <code>views</code>(视图，这里指 React 组件) 的重新渲染。如果非要将 <code>Flux</code>和大名鼎鼎的<code>MVC</code> 相比较的话，<code>Flux</code> 中的<code>store</code> 类似于<code>MVC</code>中的 <code>model</code> 。它负责保存和修改数据。</p><p>传给 <code>dispatcher</code> 的动作可以来自于视图，也可以来自于系统的其他部分，比如 <code>services</code> 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。</p><h1 id="实现-Flux-架构"><a href="#实现-Flux-架构" class="headerlink" title="实现 Flux 架构"></a>实现 Flux 架构</h1><p>如其他流行的概念一样，Flux 也有一些 <a href="https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73" target="_blank" rel="noopener">变种</a> 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。</p><h1 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h1><p>大多数场景下，我们只需要一个单个的<code>dispatcher</code> 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。<code>dispatcher</code> 需要知道两样东西: 动作和 <code>stores</code> 。动作只是简单地转发给 <code>stores</code>，所以没必要保存它们。然而，<code>stores</code> 应该在 <code>dispatcher</code> 中进行追踪，这样才可以遍历它们:<br><img src="http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_the_dispatcher.jpg" alt="Flex"></p><p>可以这样写：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var Dispatcher = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [],</span><br><span class="line">    <span class="keyword">register</span>: function (store) &#123;  </span><br><span class="line">      <span class="keyword">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: function (action) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(function (entry) &#123;</span><br><span class="line">          entry.store.update(action);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>首先需要注意的是我们期望传入的 <code>stores</code> 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="将视图和-stores-进行绑定"><a href="#将视图和-stores-进行绑定" class="headerlink" title="将视图和 stores 进行绑定"></a>将视图和 stores 进行绑定</h1><p>下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。<br><img src="http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_change_view.jpg" alt="flex"></p><h3 id="使用辅助函数"><a href="#使用辅助函数" class="headerlink" title="使用辅助函数"></a>使用辅助函数</h3><p>一些 flux 的实现会自带辅助函数来完成此工作。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Framework.attachToStore(view, store);</span><br></pre></td></tr></table></figure></p><p>要让 <code>attachToStore</code>正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。</p><h3 id="使用-mixin"><a href="#使用-mixin" class="headerlink" title="使用 mixin"></a>使用 mixin</h3><p>那么如果使用 React 的 <a href="https://facebook.github.io/react/docs/reusable-components.html#mixins" target="_blank" rel="noopener">mixins</a> 呢？<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var View = React.createClass(&#123;</span><br><span class="line">  mixins: [Framework.attachToStore(store)]</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建<code>mixin</code> 来完成绑定工作。但说实话，并认为这是个好主意。<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" target="_blank" rel="noopener">看起来</a> 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。</p><h3 id="使用-context"><a href="#使用-context" class="headerlink" title="使用 context"></a>使用 context</h3><p>解决此问题的另一项技术便是 React 的 <a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="noopener">context</a> 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 <code>context</code>。</p><blockquote><p>偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 “context” 功能可以让你做到这一点。</p></blockquote><p>看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。</p><h3 id="高阶组件概念"><a href="#高阶组件概念" class="headerlink" title="高阶组件概念"></a>高阶组件概念</h3><p>高阶组件模式是由 Sebastian Markbåge 所<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" target="_blank" rel="noopener">提出</a>的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">attachToStore</span><span class="params">(Component, store, consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Wrapper = React.createClass(&#123;</span><br><span class="line">    getInitialState() &#123;</span><br><span class="line">      <span class="keyword">return</span> consumer(<span class="keyword">this</span>.props, store);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      store.onChangeEvent(<span class="keyword">this</span>._handleStoreChange);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      store.offChangeEvent(<span class="keyword">this</span>._handleStoreChange);</span><br><span class="line">    &#125;,</span><br><span class="line">    _handleStoreChange() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(consumer(<span class="keyword">this</span>.props, store));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;Component &#123;...<span class="keyword">this</span>.props&#125; &#123;...<span class="keyword">this</span>.state&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> Wrapper;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Component 是我们想要附加到 <code>store</code> 中的视图。<code>consumer</code> 函数说明应该提取<code>store</code> 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProfilePage = connectToStores(MyView, store, (props, store) =&gt; (&#123;</span><br><span class="line">  data: store.get('key')</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><p>这是个有趣的模式，因为它转移了职责。它是视图从 <code>store</code> 中拉取数据，而不是 <code>store</code> 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 <code>store</code> 变得简单。现在 <code>store</code> 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。</p><h1 id="最终的选择"><a href="#最终的选择" class="headerlink" title="最终的选择"></a>最终的选择</h1><p> 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。</p><p>目前为止，我们的实现中只有 <code>register</code> 方法与 store 进行交互。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_view.jpg" alt="flex"></p><p>将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。</p><p>下面是更改后的 <code>register</code> 方法:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">      'You should provide a store that has an `update` method.'</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var consumers = [];</span><br><span class="line">    var subscribe = function (consumer) &#123;</span><br><span class="line">      consumers.push(consumer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class="line">    <span class="keyword">return</span> subscribe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 <code>consumer</code> 函数，但现在还没有任何代码来执行它们。</p><p>根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 <code>action</code>，但我们还应该发出 change 函数。调用此函数来触发 <code>consumers</code> :<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">      'You should provide a store that has an `update` method.'</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var consumers = [];</span><br><span class="line">    var change = function () &#123;</span><br><span class="line">      consumers.forEach(function (consumer) &#123;</span><br><span class="line">        consumer(store);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    var subscribe = function (consumer) &#123;</span><br><span class="line">      consumers.push(consumer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class="line">    <span class="keyword">return</span> subscribe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line">dispatch: function (action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._stores.forEach(function (entry) &#123;</span><br><span class="line">      entry.store.update(action, entry.change);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意如何在<code>_stores</code>数组中将 <code>change</code> 和<code>store</code> 一起推送出去。稍后，在<code>dispatch</code>方法中通过传入<code>action</code> 和 <code>change</code> 函数来调用<code>update</code></p><p>常见用法是使用<code>store</code> 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 <code>consumer</code> 函数一次。这可以在<code>subscribe</code> 方法中轻松完成:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var subscribe = function (consumer, noInit) &#123;</span><br><span class="line">  consumers.push(consumer);</span><br><span class="line">  !noInit ? consumer(store) : null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var Dispatcher = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [],</span><br><span class="line">    <span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">          'You should provide a store that has an `update` method'</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var consumers = [];</span><br><span class="line">        var change = function () &#123;</span><br><span class="line">          consumers.forEach(function (consumer) &#123;</span><br><span class="line">            consumer(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        var subscribe = function (consumer, noInit) &#123;</span><br><span class="line">          consumers.push(consumer);</span><br><span class="line">          !noInit ? consumer(store) : null;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: function (action) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(function (entry) &#123;</span><br><span class="line">          entry.store.update(action, entry.change);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="动作-Actions"><a href="#动作-Actions" class="headerlink" title="动作 ( Actions )"></a>动作 ( Actions )</h1><p>或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: <code>type</code>和<code>payload</code> ：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: 'USER_LOGIN_REQUEST',</span><br><span class="line">  payload: &#123;</span><br><span class="line">    username: '...',</span><br><span class="line">    password: '...'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。</p><p>有趣的是<code>type</code>从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 <code>stores</code> 对哪些动作感兴趣。因此，我们可以应用 <a href="http://krasimirtsonev.com/blog/article/a-story-about-currying-bind" target="_blank" rel="noopener">partial application</a> 并避免传入动作对象。例如:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var createAction = function (type) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">    throw new Error('Please, provide action\'s type.');</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> function (payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> dispatcher.dispatch(&#123;</span><br><span class="line">        type: type,</span><br><span class="line">        payload: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createAction 具有以下优点:</p><ul><li>我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。</li><li>我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。</li><li>最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。</li></ul><p><img src="http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_action_creator.jpg" alt="flex"></p><p>这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。</p><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var createSubscriber = function (store) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="keyword">register</span>(store);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var Dispatcher = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [],</span><br><span class="line">    <span class="keyword">register</span>: function (store) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">          'You should provide a store that has an `update` method'</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var consumers = [];</span><br><span class="line">        var change = function () &#123;</span><br><span class="line">          consumers.forEach(function (consumer) &#123;</span><br><span class="line">            consumer(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        var subscribe = function (consumer, noInit) &#123;</span><br><span class="line">          consumers.push(consumer);</span><br><span class="line">          !noInit ? consumer(store) : null;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: function (action) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(function (entry) &#123;</span><br><span class="line">          entry.store.update(action, entry.change);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">  create: function () &#123;</span><br><span class="line">    var dispatcher = Dispatcher();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      createAction: function (type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">          throw new Error('Please, provide action\'s type.');</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> function (payload) &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatcher.dispatch(&#123;</span><br><span class="line">              type: type,</span><br><span class="line">              payload: payload</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      createSubscriber: function (store) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatcher.<span class="keyword">register</span>(store);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。</p><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><p>我们写好的模块提供两个辅助函数来构建 <code>Flux</code> 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>我们需要一些 UI 元素来进行互动:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"counter"</span>&gt;</span><br><span class="line">  &lt;span&gt;&lt;/span&gt;</span><br><span class="line">  &lt;button&gt;increase&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;decrease&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><code>span</code> 用来显示计数器的当前值。点击按钮会改变计数器的值。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = function (subscribeToStore, increase, decrease) &#123;</span><br><span class="line">  var value = null;</span><br><span class="line">  var el = document.querySelector('#counter');</span><br><span class="line">  var display = el.querySelector('span');</span><br><span class="line">  var [ increaseBtn, decreaseBtn ] =</span><br><span class="line">    Array.from(el.querySelectorAll('button'));</span><br><span class="line"></span><br><span class="line">  var render = () =&gt; display.innerHTML = value;</span><br><span class="line">  var updateState = (store) =&gt; value = store.getValue();</span><br><span class="line"></span><br><span class="line">  subscribeToStore([updateState, render]);</span><br><span class="line"></span><br><span class="line">  increaseBtn.addEventListener('click', increase);</span><br><span class="line">  decreaseBtn.addEventListener('click', decrease);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>View 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。</p><p>之后我们定义了<code>render</code>函数，它负责将值渲染到 <code>spa</code>n 标签中。当 <code>store</code> 发生变化时会调用<code>updateState</code> 方法。我们将这两个函数传给<code>subscribeToStore</code> 是因为我们想要视图更新以及进行初首次渲染。还记得<code>consumers</code> 函数默认至少要调用一次吧？</p><p>最后要做的是为按钮绑定点击事件。</p><h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><p>每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const INCREASE = 'INCREASE';</span><br><span class="line">const DECREASE = 'DECREASE';</span><br></pre></td></tr></table></figure></p><p>通常每个 <code>store</code>只有一个实例。为了简单起见，我们将直接创建一个单例对象。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CounterStore = &#123;</span><br><span class="line">  _data: &#123; value: <span class="number">0</span> &#125;,</span><br><span class="line">  getValue: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._data.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  update: function (action, change) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.type === INCREASE) &#123;</span><br><span class="line">      <span class="keyword">this</span>._data.value += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === DECREASE) &#123;</span><br><span class="line">      <span class="keyword">this</span>._data.value -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    change();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_data</code> 是 <code>store</code> 的内部状态。<code>update</code> 是<code>dispatcher</code> 所调用的方法，我们在 <code>update</code> 中处理动作，并在完成时调用<code>change()</code>方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。)</p><h1 id="整合各个部分"><a href="#整合各个部分" class="headerlink" title="整合各个部分"></a>整合各个部分</h1><p>这样，<code>store</code> 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 <code>store</code> 的订阅者、动作并让这一切运转起来。</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createAction, createSubscriber &#125; = Fluxiny.create();</span><br><span class="line"><span class="keyword">const</span> counterStoreSubscriber = createSubscriber(CounterStore);</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increase: createAction(INCREASE),</span><br><span class="line">  decrease: createAction(DECREASE)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">View(counterStoreSubscriber, actions.increase, actions.decrease);</span><br></pre></td></tr></table></figure><p>这样就完成了。视图订阅<code>store</code>并进行渲染，因为我们的<code>consumers</code>实际上就是 render 方法。</p><h1 id="在线示例"><a href="#在线示例" class="headerlink" title="在线示例"></a>在线示例</h1><p><img src="/blog/2018/05/18/React开发常用设计模式-Flux/flex.png" alt="flex"></p><p>这里有 JSBin 的 <a href="http://jsbin.com/koxidu/embed?js,output" target="_blank" rel="noopener">在线示例</a>。如果你觉得这个示例过于简单的话，请查阅 <a href="https://github.com/krasimir/fluxiny/tree/master/example" target="_blank" rel="noopener">Fluxiny 仓库中的示例</a>。它使用 React 作为视图层。</p><p>在本章中所讨论的 Flux 实现可以在 <a href="https://github.com/krasimir/fluxiny" target="_blank" rel="noopener">这里</a> 找到。可以 <a href="https://github.com/krasimir/fluxiny/tree/master/lib" target="_blank" rel="noopener">直接在浏览器中</a> 使用，也可以通过<a href="https://www.npmjs.com/package/fluxiny" target="_blank" rel="noopener"> npm 依赖 </a>进行安装。</p>]]></content>
    
    <summary type="html">
    
      Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-单向数据流</title>
    <link href="https://duanruilong.github.io/2018/05/16/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>https://duanruilong.github.io/2018/05/16/React开发常用设计模式-单向数据流/</id>
    <published>2018-05-16T14:57:28.000Z</published>
    <updated>2018-06-16T09:12:21.283Z</updated>
    
    <content type="html"><![CDATA[<p>单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>假设说有一个简单的 <code>Switcher</code> 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; flag: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>._onButtonClick = e =&gt; <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      flag: !<span class="keyword">this</span>.state.flag</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123; <span class="keyword">this</span>._onButtonClick &#125;&gt;</span><br><span class="line">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 渲染组件</span></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Switcher /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 <code>Switcher</code> 组件。我们来将<code>flag</code> 提取到 <code>store</code> 中:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var Store = &#123;</span><br><span class="line">  _flag: <span class="literal">false</span>,</span><br><span class="line">  <span class="built_in">set</span>: function(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._flag = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; flag: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>._onButtonClick = e =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; flag: !<span class="keyword">this</span>.state.flag &#125;, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.onChange(<span class="keyword">this</span>.state.flag);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123; <span class="keyword">this</span>._onButtonClick &#125;&gt;</span><br><span class="line">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Switcher onChange=&#123; Store.<span class="built_in">set</span>.bind(Store) &#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>Store</code> 对象是一个 单例，它提供辅助函数 ( <code>getter</code> 和 <code>setter</code> ) 来读取/设置 <code>_flag</code> 属性。通过将 <code>setter</code> 传给<code>Switcher</code> 组件，我们能够更新外部数据。目前应用的工作流程大致如下:</p><p><img src="/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store.jpg" alt="单向数据流"></p><p>假设我们可以通过 <code>Store</code> 将 <code>flag</code> 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 <code>flag</code> 为 <code>true</code> ，那么我们应该显示 “lights on”，而不是默认值 “lights off” 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 <code>Store</code> 中都有自身的状态。我们需要进行双向通讯，<code>Store</code>到组件和组件到<code>Store</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 在 App 组件中</span></span><br><span class="line">&lt;Switcher</span><br><span class="line">  value=&#123; Store.get() &#125;</span><br><span class="line">  onChange=&#123; Store.<span class="built_in">set</span>.bind(Store) &#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在 Switcher 组件中</span></span><br><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123; flag: <span class="keyword">this</span>.props.value &#125;;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>  工作流程改变后如下所示:</p><p>  <img src="/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store1.jpg" alt="单向数据流"></p><p>  以上这些导致了需要在两处管理状态。如果 <code>Store</code> 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给<code>Switcher</code> 组件，这样就会增加应用的复杂度。</p><p>单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 <code>store</code>) 进行状态管理。要实现单向数据流的话，我们需要改造一下 <code>Store</code> 对象。我们需要允许我们订阅数据变化的逻辑：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Store = &#123;</span><br><span class="line">  _handlers: [],</span><br><span class="line">  _flag: '',</span><br><span class="line">  subscribe: function(handler) &#123;</span><br><span class="line">    <span class="keyword">this</span>._handlers.push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: function(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._flag = value;</span><br><span class="line">    <span class="keyword">this</span>._handlers.forEach(handler =&gt; handler(value))</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后我们将其与 <code>App</code> 组件联系起来，每次 <code>Store</code> 中的值产生变化时，都将重新渲染组件:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; value: Store.get() &#125;;</span><br><span class="line">    Store.subscribe(value =&gt; <span class="keyword">this</span>.setState(&#123; value &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Switcher</span><br><span class="line">          value=&#123; <span class="keyword">this</span>.state.value &#125;</span><br><span class="line">          onChange=&#123; Store.<span class="built_in">set</span>.bind(Store) &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>做出改变后，<code>Switcher</code> 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Switcher</span><span class="params">(&#123; value, onChange &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt;</span><br><span class="line">      &#123; value ? 'lights on' : 'lights off' &#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;Switcher</span><br><span class="line">  value=&#123; Store.get() &#125;</span><br><span class="line">  onChange=&#123; Store.<span class="built_in">set</span>.bind(Store) &#125; /&gt;</span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这种模式的好处是组件只负责展示 <code>store</code> 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。</p>]]></content>
    
    <summary type="html">
    
      单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-展示型组件和容器型组件</title>
    <link href="https://duanruilong.github.io/2018/05/15/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6/"/>
    <id>https://duanruilong.github.io/2018/05/15/React开发常用设计模式-展示型组件和容器型组件/</id>
    <published>2018-05-15T15:34:58.000Z</published>
    <updated>2018-06-16T09:12:29.925Z</updated>
    
    <content type="html"><![CDATA[<p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="展示型组件和容器型组件"><a href="#展示型组件和容器型组件" class="headerlink" title="展示型组件和容器型组件"></a>展示型组件和容器型组件</h1><p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为<code>展示型组件</code>和<code>容器型组件</code>。</p><p>我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 <code>Clock</code> 组件，它接收 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date</a> 对象作为属性并显示实时时间。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; time: <span class="keyword">this</span>.props.time &#125;;</span><br><span class="line">    <span class="keyword">this</span>._update = <span class="keyword">this</span>._updateTime.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="keyword">this</span>._formatTime(<span class="keyword">this</span>.state.time);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._interval = setInterval(<span class="keyword">this</span>._update, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>._interval);</span><br><span class="line">  &#125;</span><br><span class="line">  _formatTime(time) &#123;</span><br><span class="line">    var [ hours, minutes, seconds ] = [</span><br><span class="line">      time.getHours(),</span><br><span class="line">      time.getMinutes(),</span><br><span class="line">      time.getSeconds()</span><br><span class="line">    ].<span class="built_in">map</span>(num =&gt; num &lt; <span class="number">10</span> ? <span class="string">'0'</span> + num : num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; hours, minutes, seconds &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      time: <span class="keyword">new</span> Date(<span class="keyword">this</span>.state.time.getTime() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Clock time=&#123; <span class="keyword">new</span> Date() &#125;/&gt;, ...);</span><br></pre></td></tr></table></figure></p><p>在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 <code>setInterval</code> ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: <code>_formatTime</code> 和<code>_updateTime</code> 。<code>_formatTime</code> 用来提取时分秒并确保它们是两位数的形式。<code>_updateTime</code> 用来将<code>time</code> 对象设置为当前时间加一秒。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这个组件中它做了好几件事，似乎承担了太多的职责。</p><ul><li>它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。</li><li><code>_formatTime</code> 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。</li></ul><h1 id="提取出容器型组件"><a href="#提取出容器型组件" class="headerlink" title="提取出容器型组件"></a>提取出容器型组件</h1><p>容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 <a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components" target="_blank" rel="noopener">高阶组件</a> 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。</p><p>下面是 <code>ClockContainer</code> 的代码:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/index.js</span></span><br><span class="line">import Clock from './Clock.jsx'; // &lt;-- 展示型组件</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockContainer</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; time: props.time &#125;;</span><br><span class="line">    <span class="keyword">this</span>._update = <span class="keyword">this</span>._updateTime.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Clock &#123; ...<span class="keyword">this</span>._extract(<span class="keyword">this</span>.state.time) &#125;/&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._interval = setInterval(<span class="keyword">this</span>._update, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>._interval);</span><br><span class="line">  &#125;</span><br><span class="line">  _extract(time) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      hours: time.getHours(),</span><br><span class="line">      minutes: time.getMinutes(),</span><br><span class="line">      seconds: time.getSeconds()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      time: <span class="keyword">new</span> Date(<span class="keyword">this</span>.state.time.getTime() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>它接收 <code>time</code> (date 对象) 属性，使用<code>setInterval</code> 循环并了解数据 (<code>getHours</code>、<code>getMinutes</code> 和 <code>getSeconds</code>) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。</p><h1 id="展示型组件"><a href="#展示型组件" class="headerlink" title="展示型组件"></a>展示型组件</h1><p>展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 <a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components" target="_blank" rel="noopener">无状态组件</a>，它们没有内部状态。</p><p>在本示例中，展示型组件只包含两位数的检查并返回 <code>&lt;h1&gt;</code> 标签:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/Clock.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Clock</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  var [ hours, minutes, seconds ] = [</span><br><span class="line">    props.hours,</span><br><span class="line">    props.minutes,</span><br><span class="line">    props.seconds</span><br><span class="line">  ].<span class="built_in">map</span>(num =&gt; num &lt; <span class="number">10</span> ? <span class="string">'0'</span> + num : num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。</p><p>容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 <code>render</code> 方法中的 ·<clock>· 组件。</clock></p><p>测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。</p>]]></content>
    
    <summary type="html">
    
      万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>小程序之旅——个人申请</title>
    <link href="https://duanruilong.github.io/2018/05/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%94%B3%E8%AF%B7/"/>
    <id>https://duanruilong.github.io/2018/05/15/小程序之旅——个人申请/</id>
    <published>2018-05-14T16:47:28.000Z</published>
    <updated>2018-06-16T09:22:00.337Z</updated>
    
    <content type="html"><![CDATA[<p>开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png" alt="微信小程序"></p><a id="more"></a><p><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">小程序开发注册传送门</a>，按照步骤完成注册认证就可以开始开发咯。</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx.png" alt="小程序之旅——个人申请"></p><p>注册完之后就登录进入开发<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_1.png" alt="小程序之旅——个人申请"></p><p>填写个人资料<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_4.png" alt="小程序之旅——个人申请"></p><p>填写个人资料<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_3.png" alt="小程序之旅——个人申请"></p><blockquote><p>注意事项：</p></blockquote><ul><li><p>1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。</p></li><li><p>2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。</p></li><li><p>3.每次登录都需要扫码认证，确认成功后就可以正常登录了。</p></li></ul><p>个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_2.png" alt="小程序之旅——个人申请"></p><p>我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目<br><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_5.png" alt="小程序之旅——个人申请"></p><p>新建一个项目文件，输入自己的APPID，确定</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_6.png" alt="小程序之旅——个人申请"></p><p>进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！</p><p><img src="/blog/2018/05/15/小程序之旅——个人申请/xcx_7.png" alt="小程序之旅——个人申请"></p><blockquote><p>注意事项：</p></blockquote><ul><li><p>1.每次登录都需要扫码登录</p></li><li><p>2.需要输入自己的APPID</p></li><li><p>3.每次修改完代码都要编译</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！<br>微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/wechat.png&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://duanruilong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="编程" scheme="https://duanruilong.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="小程序" scheme="https://duanruilong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-受控输入和非受控输入</title>
    <link href="https://duanruilong.github.io/2018/05/15/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5/"/>
    <id>https://duanruilong.github.io/2018/05/15/React开发常用设计模式-受控输入和非受控输入/</id>
    <published>2018-05-14T16:19:01.000Z</published>
    <updated>2018-06-16T09:12:25.472Z</updated>
    
    <content type="html"><![CDATA[<p>在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p><p><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="受控输入和非受控输入"><a href="#受控输入和非受控输入" class="headerlink" title="受控输入和非受控输入"></a>受控输入和非受控输入</h1><p>在 React 表单管理中有两个经常使用的术语: <code>受控输入</code>和<code>非受控输入</code>。</p><ul><li>受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个<code>&lt;input&gt;</code> 字段，它就是受控的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码的结果是我们可以操作<code>input</code> 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让<code>input</code>正常工作的话，需要为其添加<code>onChange</code> 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 <code>input</code>中输入的文字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">    this._change = this._handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        value=&#123; this.state.value &#125;</span><br><span class="line">        onChange=&#123; this._change &#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange(e) &#123;</span><br><span class="line">    this.setState(&#123; value: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 <code>defaultValue</code> 属性来提供初始值，此后浏览器将负责保存输入的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>&lt;input&gt;</code>元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用<a href="Refs"> Refs</a> 来获取 DOM 元素的实际引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class="line">    this._change = this._handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        defaultValue=&#123; this.state.value &#125;</span><br><span class="line">        onChange=&#123; this._change &#125;</span><br><span class="line">        ref=&#123; input =&gt; this.input = input &#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange() &#123;</span><br><span class="line">    this.setState(&#123; value: this.input.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>ref</code>属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量<code>input</code>中。之后当 <code>onChange</code>事件触发时，我们将 <code>input</code> 中的最新值保存到 <code>App</code> 组件的状态里。</p><p>大量使用<code>refs</code> 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>]]></content>
    
    <summary type="html">
    
      在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React开发常用设计模式-组合 (composition)</title>
    <link href="https://duanruilong.github.io/2018/05/14/React%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88-composition/"/>
    <id>https://duanruilong.github.io/2018/05/14/React开发常用设计模式-组合-composition/</id>
    <published>2018-05-14T15:52:47.000Z</published>
    <updated>2018-06-16T09:12:43.329Z</updated>
    
    <content type="html"><![CDATA[<p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。<br><img src="https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/react_d.png" alt="React"></p><a id="more"></a><h1 id="组合-composition"><a href="#组合-composition" class="headerlink" title="组合 ( composition )"></a>组合 ( composition )</h1><p>React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。</p><p>我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 <code>Reac</code>t 组件 <code>—App</code>、<code>Header</code> 和 <code>Navigation</code> 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt;</span><br></pre></td></tr></table></figure></p><p>组合这些组件的简单方法是在需要它们的时候引用即可。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line">import Header from './Header.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line">import Navigation from './Navigation.jsx';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigation.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Navigation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;nav&gt; ... &lt;/nav&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，这种方式会引入一些问题:</p><ul><li>我们可以把 App 看作是主要的组合场所。<code>Header</code> 可能还有其他元素，比如 <code>logo</code>、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 <code>Navigation</code> 的 <code>Header</code> 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。</li><li>代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 <code>Navigation</code> 组件出了问题，那么 <code>Header</code> 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: <a href="https://facebook.github.io/react/docs/test-utils.html#shallow-rendering" target="_blank" rel="noopener">浅层渲染 ( shallow rendering</a> ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)</li></ul><h1 id="使用-React-children-API"><a href="#使用-React-children-API" class="headerlink" title="使用 React children API"></a>使用 React children API</h1><p>React 提供了便利的 <a href="https://facebook.github.io/react/docs/multiple-components.html#children" target="_blank" rel="noopener">children</a> 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 <code>Header</code> 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> function <span class="title">Header</span><span class="params">(&#123; children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;header&gt;&#123; children &#125;&lt;/header&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，如果不在 <code>Heade</code>r 中使用 <code>{ children }</code>的话，那么 <code>Navigation</code> 组件永远不会渲染。</p><p>现在 Header 组件的测试变得更简单了，因为完全可以使用空 <code>&lt;div&gt;</code> 来渲染 <code>Header</code> 组件。这会使用组件更独立，并让我们专注于应用的一小部分。</p><h1 id="将-child-作为-prop-传入"><a href="#将-child-作为-prop-传入" class="headerlink" title="将 child 作为 prop 传入"></a>将 child 作为 prop 传入</h1><p>每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello there!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Header = function (&#123; title, children &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &#123; title &#125;</span><br><span class="line">      &#123; children &#125;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_5.png" alt="运行结果"></p><p>当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。</p><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 <a href="http://robdodson.me/javascript-design-patterns-decorator/" target="_blank" rel="noopener">装饰器模式</a> 十分相似，因为它是对组件的包装与增强。</p><p>从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component &#123;...<span class="keyword">this</span>.props&#125; /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;EnhancedTitle /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有<code>OriginalTitle</code>所需要的配置:<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var config = require('path/to/configuration');</span><br><span class="line"></span><br><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p><p><code>appTitle</code> 是封装在高阶组件内部的。<code>OriginalTitle</code> 只知道它所接收的 <code>title</code> 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建<code>mocks</code> 。</p><p>这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 <code>OriginalTitle</code> 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 <code>OriginalTitle</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = &#123; remoteTitle: null &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetchRemoteData('path/to/endpoint').then(data =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">          remoteTitle=&#123; <span class="keyword">this</span>.state.remoteTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class="line">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p><p>这次，<code>OriginalTitle</code> 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。</p><ul><li>关于高阶组件的创建问题<a href="https://github.com/gaearon" target="_blank" rel="noopener">，Dan Abramov</a> 提出了一个 <a href="https://github.com/krasimir/react-in-patterns/issues/12" target="_blank" rel="noopener">非常棒的观点</a>，像调用 <code>enhanceComponent</code> 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 </li></ul><h1 id="将函数作为-children-传入和-render-prop"><a href="#将函数作为-children-传入和-render-prop" class="headerlink" title="将函数作为 children 传入和 render prop"></a>将函数作为 children 传入和 render prop</h1><p>React 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 <code>children</code> 属性都是 <code>React</code> 组件。然而，有一种新的模式越来越受欢迎，<code>children</code> 属性是一个 <code>JSX</code> 表达式。我们先从传入一个简单对象开始。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">UserName</span><span class="params">(&#123; children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;,</span><br><span class="line">      &#123; children.firstName &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: 'Krasimir',</span><br><span class="line">    lastName: 'Tsonev'</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_6.png" alt="运行结果"></p><p>这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。<code>TodoList</code> 组件只是简单地封装了所需的 HTML 标记。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">TodoList</span><span class="params">(&#123; todos, children &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className='main-section'&gt;</span><br><span class="line">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class="line">        todos.<span class="built_in">map</span>((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; label: 'Write tests', status: 'done' &#125;,</span><br><span class="line">    &#123; label: 'Sent report', status: 'progress' &#125;,</span><br><span class="line">    &#123; label: 'Answer emails', status: 'done' &#125;</span><br><span class="line">  ];</span><br><span class="line">  const isCompleted = todo =&gt; todo.status === 'done';</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        todo =&gt; isCompleted(todo) ?</span><br><span class="line">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class="line">          todo.label</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/TodoList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_7.png" alt="运行结果"></p><p>注意观察 App 组件是如何不暴露数据结构的。<code>TodoList</code> 完全不知道 <code>label</code> 和 `status 属性。</p><p>名为 <code>render prop</code> 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 <code>render</code> 属性，而不是 <code>children</code> 。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">TodoList</span><span class="params">(&#123; todos, render &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className='main-section'&gt;</span><br><span class="line">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class="line">        todos.<span class="built_in">map</span>((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;TodoList</span><br><span class="line">    todos=&#123; todos &#125;</span><br><span class="line">    render=&#123;</span><br><span class="line">      todo =&gt; isCompleted(todo) ?</span><br><span class="line">        &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label</span><br><span class="line">    &#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/blog/2018/05/14/React开发常用设计模式-组合-composition/react_8.png" alt="运行结果"></p><p>这两种模式 将函数作为 <code>children</code> 传入 和 <code>render prop</code> 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; data: null &#125;;</span><br><span class="line">    setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.data === null) <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;section&gt;&#123; <span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state.data) &#125;&lt;/section&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DataProvider</code> 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个<code>&lt;section&gt;</code>，<code>&lt;section&gt;</code> 的内容是由 <code>render</code> 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>我们描述了我们想要做的事，而不是如何去做。细节都封装在了 <code>DataProvider</code> 中。最近，使用这种模式，某些界面限制只对具有 <code>read:products</code> 权限的用户开放。我们使用的是<code>render prop</code> 模式。<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Authorize</span><br><span class="line">  permissionsInclude=&#123;[ 'read:products' ]&#125;</span><br><span class="line">  render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>  这种声明式的方式相当不错，不言自明。<code>Authorize</code> 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 <code>ProductList</code>。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>]]></content>
    
    <summary type="html">
    
      对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。
    
    </summary>
    
      <category term="React" scheme="https://duanruilong.github.io/categories/React/"/>
    
    
      <category term="Javascript" scheme="https://duanruilong.github.io/tags/Javascript/"/>
    
      <category term="React" scheme="https://duanruilong.github.io/tags/React/"/>
    
  </entry>
  
</feed>
