{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/drlicon.ico","path":"images/drlicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/drlicon.icon.png","path":"images/drlicon.icon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/fireworks.js","path":"js/src/fireworks.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.png","path":"images/alipay.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/back.png","path":"images/back.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/drl.png","path":"images/drl.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1536324774000},{"_id":"themes/next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1536324774000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1536324774000},{"_id":"themes/next/_config.yml","hash":"889f242791ce6bdb0a0debe96e4f8d99d3f7dfdd","modified":1537238496000},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1536324774000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1536324774000},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1536324774000},{"_id":"source/_posts/Async-Functions-异步函数.md","hash":"19fb1e724df4b226c4ab743586f2abb0778048ad","modified":1537199912000},{"_id":"source/_posts/ES6攻略-一.md","hash":"a776bea2da97516ff0ff992abdaab3715c31bd26","modified":1537199912000},{"_id":"source/_posts/ES6攻略-三.md","hash":"6e15397532a265698be6cc751f05423f69885466","modified":1537199912000},{"_id":"source/_posts/ES6攻略-二.md","hash":"8a958da35dae19859b7dfd7fdac693e279a0a010","modified":1537199912000},{"_id":"source/_posts/ES6攻略-五.md","hash":"a236c6263a179904644c27caabaf85bfcb4da147","modified":1537199912000},{"_id":"source/_posts/ES6攻略-四.md","hash":"9ed6c2a178a8ad42843115c5009cce24aee3614c","modified":1537199912000},{"_id":"source/_posts/ES6攻略.md","hash":"cf97cbede45db46a84f642d1213c846e1a24363a","modified":1537199912000},{"_id":"source/_posts/ES6里-三种异步解决方案.md","hash":"7401e379971b0ba10864dc3dc6e8e06fb09acc65","modified":1537199912000},{"_id":"source/_posts/Gitment使用-GitHub-Issues-搭建评论系统.md","hash":"1b96a6fa86c1179785e205c49ad90820d3b9ea46","modified":1544170397000},{"_id":"source/_posts/JavaScript-什么是纯函数以及为什么要用纯函数.md","hash":"721aeae5238a3621f31bff412ac93186ecd99ed4","modified":1541930778000},{"_id":"source/_posts/Javascript正则速查表.md","hash":"75b332952435d83b367c34cec4434170fdfb5d4b","modified":1537199912000},{"_id":"source/_posts/React-开发常用设计模式-前言.md","hash":"dc84cd17f1b3f209b281421bd5a12df294fe9cff","modified":1537199912000},{"_id":"source/_posts/React16新特性来认识一波.md","hash":"a071cd6eb9d88e4b04180aefcefa63a15db9b923","modified":1544689965000},{"_id":"source/_posts/React一些路由.md","hash":"1947a6d40b691114cc659fdb496110040ad966dc","modified":1537279950000},{"_id":"source/_posts/React开发常用设计模式-Flux.md","hash":"a4b8de7437d2ba50401012bc627fa168ac4bf02a","modified":1537273397000},{"_id":"source/_posts/React开发常用设计模式-Redux.md","hash":"9ff08b8ca1021f6e71c82e93b4dadefc3c9805f8","modified":1537199912000},{"_id":"source/_posts/React开发常用设计模式-事件处理.md","hash":"6ebff75544cae9c71c5d4c236fd21e7de1608650","modified":1537273430000},{"_id":"source/_posts/React开发常用设计模式-依赖注入.md","hash":"a69080104a5dd4f7a3ce8fab6165118b2ac62ab2","modified":1537199912000},{"_id":"source/_posts/React开发常用设计模式-单向数据流.md","hash":"cc74f35192c06d53452582f9adbdf74d42ea7b6a","modified":1537273418000},{"_id":"source/_posts/React开发常用设计模式-受控输入和非受控输入.md","hash":"c9a37f48d69564665482e7f77630369870e25155","modified":1537273423000},{"_id":"source/_posts/React开发常用设计模式-展示型组件和容器型组件.md","hash":"b734ba5bc96e813d94a8f959a3fa43927f9b89e7","modified":1537273438000},{"_id":"source/_posts/React开发常用设计模式-组件样式.md","hash":"ef24afaa7aab20d0a52c8bad5db94f6b1a720f04","modified":1537199912000},{"_id":"source/_posts/React开发常用设计模式-组件通讯.md","hash":"037ee7b74749a6a2411a7f51f6daf185dbbe7a72","modified":1537273445000},{"_id":"source/_posts/React开发常用设计模式-组合-composition.md","hash":"bd1004a1ad729de3b8a4d44ad71363ce4debccef","modified":1537273450000},{"_id":"source/_posts/React开发常用设计模式-集成第三方库.md","hash":"398a6a0eda70a5ba2c0371aaceb7347266636f4e","modified":1537199912000},{"_id":"source/_posts/hello-world.md","hash":"2a53b6582e2ea2875ab3d259336aa2f009466fd9","modified":1537410474000},{"_id":"source/_posts/iTerm2-oh-my-zsh-agnoster-打造最强Mac终端.md","hash":"d1d95a5ef3c70be68387de6c12227f5d1b051d61","modified":1537199912000},{"_id":"source/_posts/mongodb数据库的使用.md","hash":"cd8bb40d33772434f4f3b4ca5b65b77c933677ee","modified":1537199912000},{"_id":"source/_posts/next主题模板一些配置.md","hash":"2bc7dee73971113fa05deb6180b4b81ddead26fb","modified":1537199912000},{"_id":"source/_posts/什么是-Rax，以及-Rax-的特点.md","hash":"d048f923f9c365d4197e4c5c8b96310a33ae92f6","modified":1537276060000},{"_id":"source/_posts/使用Hexo-Github搭建个人博客详细配置.md","hash":"c09e6c3fa0ed22f0e4695eeea3ae9d2c6531b1a8","modified":1537273511000},{"_id":"source/_posts/前端小笔记本.md","hash":"d17d38a59d25ac52064b980d9a72b1fe6897bd2c","modified":1537199912000},{"_id":"source/_posts/前端面试集锦.md","hash":"13b991f8a488fc443eceea8296ba63c533a8db54","modified":1537199912000},{"_id":"source/_posts/在PHP里很好的使用ImageMagick-convert篇.md","hash":"da40941663c90fbb413220df3c6a6f5958f01a37","modified":1537280176000},{"_id":"source/_posts/在PHP里很好的使用ImageMagick.md","hash":"907c45147b71366e618e33927c7c286abbfabce8","modified":1537199912000},{"_id":"source/_posts/小程序之旅-七.md","hash":"dfe14f6385df80b410aedc5a5ec0daef0f819dd1","modified":1537199912000},{"_id":"source/_posts/小程序之旅-三.md","hash":"7d711c1f50d28ce95d952cda0207a8ef3dbf5f82","modified":1537199912000},{"_id":"source/_posts/小程序之旅-二.md","hash":"a2bee5e43ad839046c9a4364e12d5d3db0733d10","modified":1537199912000},{"_id":"source/_posts/小程序之旅-五.md","hash":"5f8d04a758a33a7985f33718b177546c04660920","modified":1537199912000},{"_id":"source/_posts/小程序之旅-六.md","hash":"4a1b3d42bb17f0ab12b43568a47f8ce560352e4c","modified":1537273520000},{"_id":"source/_posts/小程序之旅-四.md","hash":"e5c97fc8762235ee9402071d2eeaebdbed62d1e0","modified":1537199912000},{"_id":"source/_posts/小程序之旅—-认识一下.md","hash":"92a749839e092397bb7b90cdb57ef8e76688c2b7","modified":1537199912000},{"_id":"source/_posts/小程序之旅——个人申请.md","hash":"0ade6d354b6f64ced842201e0526fc2b9b0abaa0","modified":1537199912000},{"_id":"source/_posts/开发小锦囊.md","hash":"abdb01f6c56a391e7f55ce1ba813060a8789bb60","modified":1537199912000},{"_id":"source/_posts/怎样在JS里尽量少写for循环.md","hash":"d7a34494f0bf401005ab7b5acd453c35c2fdaadc","modified":1537199912000},{"_id":"source/_posts/第一篇blog.md","hash":"3771c9a5883e1b83e62b29ffb3255ada20138814","modified":1544690455000},{"_id":"source/_posts/记一次Hexo文章里的图片不显示问题.md","hash":"8a94e4e49f8439e2f393205e1614cb76de52c4ec","modified":1539338613000},{"_id":"source/about/index.md","hash":"5584e33b5cc893e9f5fb21e4de0b7591b0e2fee1","modified":1536677126000},{"_id":"source/categories/index.md","hash":"a2035349188e7a8f01361ff322b19b6d2775e98b","modified":1536324774000},{"_id":"source/tags/index.md","hash":"0708e7c96162c8b40790c49802f60e5135797a2e","modified":1536324774000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1536324774000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1536324774000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1536324774000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1536324774000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1536324774000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1536324774000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1536324774000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1536324774000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1536324774000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1536324774000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"e3cf6f91fdfc7cd686310451cb9ede87d3d14ddc","modified":1536677126000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1536324774000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1536324774000},{"_id":"themes/next/layout/_layout.swig","hash":"c4ddb70dbe3407a001ae37fbbcb6ef1bb0ab75cb","modified":1536324774000},{"_id":"themes/next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1536324774000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1536324774000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1536324774000},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1536324774000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1536324774000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1536324774000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1536324774000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1536324774000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1536324774000},{"_id":"themes/next/source/404.html","hash":"4ce2875dc45198ab413e6c329c363d363b18a58f","modified":1536324774000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1536324774000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1536324774000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1536324774000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"source/_posts/ES6攻略/01.png","hash":"22c249d3547d34f2bff5c27a6df2bc4d26d5aa20","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-counter-app.png","hash":"3a1329f63c05bd18d550b3640bc5bcf8c78d44be","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-Redux/tag-it.png","hash":"3336aa9b305b6ebbf9ee6c0a2aaee8386f7f5687","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-单向数据流/react_store.jpg","hash":"490f1fdfee4b8fbaac94c04428e05a16a21d5d0b","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-组件通讯/reactput.png","hash":"3623c380ef63073bc776994d63cbdabdf7ff35b3","modified":1536324774000},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1-1.png","hash":"c740b6eaf51934cded1cf85b62d050146c94e34f","modified":1536677126000},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1-2.png","hash":"457890eb333e48282d67696a9b8bcad479eded43","modified":1536677126000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_5.png","hash":"e0fe8d76447245fecab1d12510ca07474ff7db35","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_6.png","hash":"40d6bf1bd0bff189d6f158a056324febcd8cc7fe","modified":1536324774000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1536324774000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1536324774000},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"4ac8e95c67bea1cd00fa1fd4b5db67a3cded85f5","modified":1536677126000},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"a80d55975e3444d24506b4e689de75d6dd6f1aa4","modified":1536324774000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1536324774000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1536324774000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f0b5cbf30d237f9158218fcb44b256d345754d19","modified":1536324774000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"e06314a3c7146c3144cd72cefacf5853f3145b39","modified":1536324774000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1536324774000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1536324774000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1536324774000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"99b46f07bb59c6713efb38a0f3f87c34e5172e4a","modified":1539338105000},{"_id":"themes/next/layout/_partials/head.swig","hash":"90840055f3e9313aa83ec49b449652617657212b","modified":1536324774000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1536324774000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1536324774000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1536324774000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1536324774000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1536324774000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1536324774000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1536324774000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1536324774000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1536324774000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1536324774000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1536324774000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1536324774000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1536324774000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1536324774000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1536324774000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1536324774000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1536324774000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1536324774000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1536324774000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1536324774000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1536324774000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1536324774000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1536324774000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1536324774000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1536324774000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1536324774000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1536324774000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1536324774000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1536324774000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1536324774000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1536324774000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1536324774000},{"_id":"themes/next/source/images/drlicon.ico","hash":"3a6d7dc6409a041e43613e0098932e21da663bbe","modified":1536324774000},{"_id":"themes/next/source/images/drlicon.icon.png","hash":"3a6d7dc6409a041e43613e0098932e21da663bbe","modified":1536324774000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536324774000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536324774000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1536324774000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1536324774000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-Redux/react.jpg","hash":"b934486efe3a31fe876d14e99200bd07b7148e32","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-architecture.jpg","hash":"57227993d05fc68064e0fac63e3316f67835b0aa","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-reallife.jpg","hash":"e940a281f9db5e97ad58d7fe692c7b660dd4fc27","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-事件处理/react_3.png","hash":"a9f1408d9ea58d091fa894b4dc98cce22aacc659","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-单向数据流/react_store1.jpg","hash":"474d69107ab2be5c2ee0a7f54ceca2d02a2e163f","modified":1536677126000},{"_id":"source/_posts/React开发常用设计模式-组件通讯/react_1.png","hash":"af49a53b2904b68a2d79ed5662f612fd51969489","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-组件通讯/react_2.png","hash":"5ae2a657c88c6edf966f80bd55b6228ae1f9d7fc","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_5.png","hash":"d012300fdc077224c8839bfa234ecff3f811ebf0","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_6.png","hash":"b45f92c20877af07e7a7d417203dbab2c4d75b9d","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx.png","hash":"838f281632be30cbfdc85ee76caf38fc65cf56d7","modified":1536324774000},{"_id":"source/_posts/记一次Hexo文章里的图片不显示问题/alipay.png","hash":"6e0e7bc4308d01858f440913da485d6ef4d306da","modified":1536324774000},{"_id":"source/_posts/记一次Hexo文章里的图片不显示问题/long.png","hash":"02ec46682d917dbb2ad8eca9d54f55a219254e4c","modified":1536324774000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-事件处理/react_4.png","hash":"b6c8431595feef016296cdf15d821c19751eda59","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_7.png","hash":"308124fabbe7918969962ab026fb6e044c05793e","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_8.png","hash":"1d4ee8c3f55b7f784dee8a4c08b79db814cfe048","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_3.png","hash":"cc2d1af886159d533b4c2589b5a54a4bb6039157","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_4.png","hash":"d6e4d62e80d079dfaa9f860510140b621c46824c","modified":1536324774000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1536324774000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1536324774000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1536324774000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1536324774000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1536324774000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1536324774000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"b5ebe6e3463bdc6df32a971dda1ad5cc1786717b","modified":1536324774000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1536324774000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1536324774000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1536324774000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1536324774000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"4aa55cd424389cf5626aa019c15ef6f3e4da09f2","modified":1539338430000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1536324774000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1536324774000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1536324774000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1536324774000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1536324774000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1536324774000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1536324774000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"2536cff2b5385ae86c9b9af9060469da421c5c0b","modified":1537199912000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1536324774000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1536324774000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1536324774000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1536324774000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1536324774000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1536324774000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1536324774000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1536324774000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1536324774000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1536324774000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1536324774000},{"_id":"themes/next/source/js/src/fireworks.js","hash":"ed2d0a5ad306a2745b7c8180b69e36b78d4b0698","modified":1536324774000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1536324774000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1536324774000},{"_id":"themes/next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1536324774000},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1536324774000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1536324774000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1536324774000},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1536324774000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1536324774000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1536324774000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1536324774000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1536324774000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1536324774000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1536324774000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1536324774000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1536324774000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1536324774000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1536324774000},{"_id":"source/_posts/React-开发常用设计模式-前言/cover1.png","hash":"31e11d18d777f28468015044197ec80cfacfc4b8","modified":1536324774000},{"_id":"source/_posts/React开发常用设计模式-Flux/flex.png","hash":"7fcc9c7236b6b94b5a7bb948cefdea63f030f024","modified":1536677126000},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1.png","hash":"c55fef2cacc9e1678755df7fe55a2faaff79ce80","modified":1536677126000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_2.png","hash":"56712ad07fa29fff27e15be571642dc788e8b84b","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_7.png","hash":"327fda1f59fd9558926e934daf3f65d123db4bc0","modified":1536324774000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1536324774000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"215bff67f795f36f00dd1418917bbab464ade4e4","modified":1537199912000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"8fde9fad5b69adbd51aa5cd275ab86d05f2874e7","modified":1536677126000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1536324774000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1536324774000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2c9d373dc1da2f9587446d4c028e1d2116962015","modified":1536677126000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1536324774000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1536324774000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1536324774000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1536324774000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"0fedfb99c7bfe99c014511d395af895bf664d12b","modified":1537199912000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1536324774000},{"_id":"themes/next/source/images/alipay.png","hash":"ce146b2aceb7bd44a4c9922c4821c89f860c76f8","modified":1536324774000},{"_id":"themes/next/source/images/wechatpay.png","hash":"becc2943ee257d7a66c5df496deb80377ad83668","modified":1536324774000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1536324774000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"361ead056530b8d39495a1fac07a54a566724898","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1536324774000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1536324774000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1536324774000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"0d0a238fc7edba39822d8ebd26b637ddeb8693b4","modified":1536677126000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"3496dc2ca5647bbf6a827f991d61849205a5955a","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"43cbed57aa58fca9f4732b95a6a07870dc64406e","modified":1536677126000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"0d390530c0c5e0e441c5f745044149aaa26517b6","modified":1536677126000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"a836b51d37c0d9d32604253fa4fe6094ea37c723","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"f7211326ebb10c3f604433a7c873ce125c7b8167","modified":1536677126000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8df15b9d9ca4170832411ea42ebf4dcaf6d14ca3","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"95120dd9db4d2511ebbf271ea271d311055362eb","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1536324774000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1536324774000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1536324774000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1536324774000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1536324774000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1536324774000},{"_id":"source/_posts/小程序之旅——个人申请/xcx_1.png","hash":"7eb6e5b52277254ac49ba2bc7ca46a3d975116c6","modified":1536324774000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1536324774000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1536324774000},{"_id":"themes/next/source/images/back.png","hash":"5ba30da4e34a6494924c480f4125276bec570d89","modified":1536677126000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1536324774000},{"_id":"themes/next/source/images/drl.png","hash":"43484a616b417d2539ae02c974e474bfd114db9c","modified":1536324774000},{"_id":"public/atom.xml","hash":"1fa9b6d932f16afb3c3156e0d48bead7464a1de3","modified":1544690494787},{"_id":"public/search.xml","hash":"68098a0b1f84f7395f3b17c2574df6bda4160651","modified":1544690494827},{"_id":"public/about/index.html","hash":"e1f73e53fdbc70b0260767e1edf8c1ea41f24ba3","modified":1544690494837},{"_id":"public/categories/index.html","hash":"df0621f7c1923ffa6dd354397fdd5907e525b630","modified":1544690494837},{"_id":"public/tags/index.html","hash":"2fed8a5b38a9f8ea3591de33eaed3b5894ccc73d","modified":1544690494838},{"_id":"public/2018/12/07/Gitment使用-GitHub-Issues-搭建评论系统/index.html","hash":"da26ff0365fdd55296f4871ef8caae86c9c32e25","modified":1544690494838},{"_id":"public/2018/11/29/React16新特性来认识一波/index.html","hash":"2c33511bbf7e647bd1c5789f8da3044da09b35f8","modified":1544690494838},{"_id":"public/2018/11/11/JavaScript-什么是纯函数以及为什么要用纯函数/index.html","hash":"cf7b4b4944a74c1b99829217fa7e9867f26d0d11","modified":1544690494838},{"_id":"public/2018/09/18/在PHP里很好的使用ImageMagick-convert篇/index.html","hash":"606b1303d6f5211d095f1981acd3c5d447d9c857","modified":1544690494838},{"_id":"public/2018/09/05/在PHP里很好的使用ImageMagick/index.html","hash":"ccd0f3cae71f3dfca4777dfcbfac5cfe7e5bd0cf","modified":1544690494838},{"_id":"public/2018/08/08/小程序之旅-七/index.html","hash":"d3103f42a011b5f7ad4877a447d9e84f50cfa1a2","modified":1544690494838},{"_id":"public/2018/08/01/前端小笔记本/index.html","hash":"80a3585507cc54109d2c9ee2a3bd935139005f7f","modified":1544690494838},{"_id":"public/2018/07/31/小程序之旅-六/index.html","hash":"3ad181dcf48b77fd01df78afd1494210509f6764","modified":1544690494838},{"_id":"public/2018/07/30/开发小锦囊/index.html","hash":"ca300311fbaa61783bb146f076863e4a802d3572","modified":1544690494838},{"_id":"public/2018/07/29/怎样在JS里尽量少写for循环/index.html","hash":"bacdbf1a9cbf76eee66684d428448e894141ffac","modified":1544690494838},{"_id":"public/2018/07/22/小程序之旅-五/index.html","hash":"d7e511f40d98e5d9018db6c608fa86110ec26bf7","modified":1544690494838},{"_id":"public/2018/07/22/iTerm2-oh-my-zsh-agnoster-打造最强Mac终端/index.html","hash":"bf82ee450333d8a50ab825124c80b85fd961796b","modified":1544690494838},{"_id":"public/2018/07/15/Async-Functions-异步函数/index.html","hash":"b4895ec7fda5da87127642acbf184a56b579c206","modified":1544690494838},{"_id":"public/2018/06/28/小程序之旅-四/index.html","hash":"cf86b15b60a96e18f1bb7705cbc56295f7632be7","modified":1544690494838},{"_id":"public/2018/06/27/ES6里-三种异步解决方案/index.html","hash":"8450707b53c129d4d26eeae05ace827d32d6bd80","modified":1544690494838},{"_id":"public/2018/06/19/小程序之旅-三/index.html","hash":"d9d2c89628a2f3e4f4ff093e32f1cbd9098f78b4","modified":1544690494839},{"_id":"public/2018/06/15/小程序之旅-二/index.html","hash":"b81664d6b882d2f7e023141a35d923f0b55725c0","modified":1544690494839},{"_id":"public/2018/06/14/React开发常用设计模式-集成第三方库/index.html","hash":"54ff93fa3093d9faa533dffb48c245b74e21c743","modified":1544690494839},{"_id":"public/2018/06/14/React开发常用设计模式-组件样式/index.html","hash":"0813cfd4f338e4bb257ccb32a3f182b20170179b","modified":1544690494839},{"_id":"public/2018/06/13/React开发常用设计模式-依赖注入/index.html","hash":"a4561bca31593e25499366166a2eafc8ed965958","modified":1544690494839},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/index.html","hash":"7a2fc262b0bfbf75e63723139a115d0cc07ebf2e","modified":1544690494839},{"_id":"public/2018/05/29/ES6攻略-五/index.html","hash":"159a7b24d7d6fc40196686245aa53c080442ca4c","modified":1544690494839},{"_id":"public/2018/05/29/ES6攻略-四/index.html","hash":"a00ecbe39f1421fe7d7bcbe796497b0f255dc2d7","modified":1544690494839},{"_id":"public/2018/05/28/ES6攻略-三/index.html","hash":"58b64b795d061dd3e4eb3efdadb6e4ebf537af0c","modified":1544690494839},{"_id":"public/2018/05/28/ES6攻略-二/index.html","hash":"9d61120d02359ae876b81ed9e8890cc2e9fd6ac3","modified":1544690494840},{"_id":"public/2018/05/27/ES6攻略-一/index.html","hash":"34714a58050fa050426181edf28d09b5ae7f9319","modified":1544690494840},{"_id":"public/2018/05/25/ES6攻略/index.html","hash":"7c91f0c8bb32a6f40ecd6bc4c6360fb778759628","modified":1544690494840},{"_id":"public/2018/05/24/前端面试集锦/index.html","hash":"a324addabedb2fe7ce6c698e29f9b72a82517aff","modified":1544690494840},{"_id":"public/2018/05/22/小程序之旅—-认识一下/index.html","hash":"1c048dd695fa38f9117be0a0708db4da21d2095b","modified":1544690494840},{"_id":"public/2018/05/21/mongodb数据库的使用/index.html","hash":"7aac22d93a15359e4527573b9e8f4c17c04f0eef","modified":1544690494840},{"_id":"public/2018/05/18/React开发常用设计模式-Flux/index.html","hash":"86b2e9dbfaa19e57a15da47f10e235511312f7ae","modified":1544690494840},{"_id":"public/2018/05/16/React开发常用设计模式-单向数据流/index.html","hash":"7ff69914deb1da33bd6184cf0374af0c850b5120","modified":1544690494840},{"_id":"public/2018/05/15/React开发常用设计模式-展示型组件和容器型组件/index.html","hash":"8cc1d78d7246b8f8c336a3b203f5d7170323795f","modified":1544690494840},{"_id":"public/2018/05/15/小程序之旅——个人申请/index.html","hash":"cc31f4f9e2215ffdd1870035b06e52a21bf57df2","modified":1544690494840},{"_id":"public/2018/05/15/React开发常用设计模式-受控输入和非受控输入/index.html","hash":"e88f66cfe1d8f3e7158fa1b1fb41ee0413a5b320","modified":1544690494840},{"_id":"public/2018/05/14/React开发常用设计模式-组合-composition/index.html","hash":"e377e00838db457d975c0593bbfa72ce9b8d7d23","modified":1544690494840},{"_id":"public/2018/05/14/React开发常用设计模式-事件处理/index.html","hash":"ebe55c79ace80bb15dcaa0e9e0515d6652aa036d","modified":1544690494840},{"_id":"public/2018/05/14/React开发常用设计模式-组件通讯/index.html","hash":"715d04fcdd6086903917621601caaf0f6b10d238","modified":1544690494840},{"_id":"public/2018/05/14/React-开发常用设计模式-前言/index.html","hash":"b3c987505e296063c7096aaf9538e2a2ce6f75ac","modified":1544690494840},{"_id":"public/2018/05/13/Javascript正则速查表/index.html","hash":"c897adbbe1d4833e5f38000c5a5f97d8991c840c","modified":1544690494841},{"_id":"public/2018/05/11/什么是-Rax，以及-Rax-的特点/index.html","hash":"af53a35e6969a298680d47e5b3da323e364e4d15","modified":1544690494841},{"_id":"public/2018/05/08/React一些路由/index.html","hash":"3d942b2332204ba0cf09f88e40f58f5df90623ea","modified":1544690494841},{"_id":"public/2018/05/06/记一次Hexo文章里的图片不显示问题/index.html","hash":"5a4b415c00b9d2dd073102a6edfd02b0cc4d2fff","modified":1544690494841},{"_id":"public/2018/05/05/next主题模板一些配置/index.html","hash":"94c36e64ca90fc1666b00ac7c03b38a05ff867e6","modified":1544690494841},{"_id":"public/2018/05/05/使用Hexo-Github搭建个人博客详细配置/index.html","hash":"0e20738e1fcb49bedcbdc324dcba88cb7b3a1846","modified":1544690494841},{"_id":"public/2018/05/04/第一篇blog/index.html","hash":"937bb133ef588c7015a97b9dcc8f14806e78fbcf","modified":1544690494841},{"_id":"public/2018/05/02/hello-world/index.html","hash":"5e814f8bafc0879dc1e781b61c9059214f94fb17","modified":1544690494841},{"_id":"public/archives/index.html","hash":"c6f4c27c5b801a8ad75fdaeb26d2ee88f7d5add2","modified":1544690494841},{"_id":"public/archives/page/2/index.html","hash":"0fc64c198809f2a38ce82a3860d1911b5c9a8826","modified":1544690494841},{"_id":"public/archives/page/3/index.html","hash":"b1866499636526249bb08290be61eefa2fddcbb5","modified":1544690494841},{"_id":"public/archives/page/4/index.html","hash":"22e7ccd6e83d18cf4cff92daa739a6005cce5803","modified":1544690494841},{"_id":"public/archives/page/5/index.html","hash":"95fe7fa3231803bd260d3a9d9f61f0703ebbda34","modified":1544690494841},{"_id":"public/archives/2018/index.html","hash":"8b42cb17c453c88eef66d0902f2670eca0ba09f8","modified":1544690494841},{"_id":"public/archives/2018/page/2/index.html","hash":"6a5742d056cf013f536e3abf433404d6802f6cf0","modified":1544690494841},{"_id":"public/archives/2018/page/3/index.html","hash":"16ff955fa3fc72a060d71108607b4e803364b33a","modified":1544690494841},{"_id":"public/archives/2018/page/4/index.html","hash":"adff57658c1958c15ac517075d5f75cd46b6ceb2","modified":1544690494841},{"_id":"public/archives/2018/page/5/index.html","hash":"841d83368a12f206de2775ca1c0bc7fc888709e1","modified":1544690494842},{"_id":"public/archives/2018/05/index.html","hash":"515b9db244619433a62674a46ab4490f2ddfd8a7","modified":1544690494842},{"_id":"public/archives/2018/05/page/2/index.html","hash":"fc3bb1cf97eb7c458456424d95db48c99413c3c2","modified":1544690494842},{"_id":"public/archives/2018/05/page/3/index.html","hash":"6fb6377e10d53cbc3dc63c3471fdd4ef1373f867","modified":1544690494842},{"_id":"public/archives/2018/06/index.html","hash":"2b85ebe2d4011225b7efb2ef9a804eeb02369a7b","modified":1544690494842},{"_id":"public/archives/2018/07/index.html","hash":"ef42328a084f8c4a3e394f4b65350ef209d0c797","modified":1544690494842},{"_id":"public/archives/2018/08/index.html","hash":"cdc640b9c1fc2d4434828902576f6380fa8ea63e","modified":1544690494842},{"_id":"public/archives/2018/09/index.html","hash":"0927774a5975628720fe2247d9b4e59cda7a9017","modified":1544690494842},{"_id":"public/archives/2018/11/index.html","hash":"66f9cc3443dc41f864c1eb210153d747af7fbd2b","modified":1544690494842},{"_id":"public/archives/2018/12/index.html","hash":"711c71f554f6cbaa6bcb0788061b9f0cb5e72ee3","modified":1544690494842},{"_id":"public/categories/Javascript/index.html","hash":"d576eca129d2c04140064ed51b687c31a7f28c55","modified":1544690494842},{"_id":"public/categories/ES6/index.html","hash":"7bb5bdceb8c934a629fa972ff2e16d02a03149bc","modified":1544690494842},{"_id":"public/categories/软件/index.html","hash":"695683d6488e3db01e6d9d9673c432d761385c5a","modified":1544690494842},{"_id":"public/categories/React/index.html","hash":"5518a53c342a3b11c6d6a85dd2f5b70767c5375c","modified":1544690494843},{"_id":"public/categories/React/page/2/index.html","hash":"179aa79b4ab108c05a040d09e35843683fbb60a0","modified":1544690494843},{"_id":"public/categories/Hexo/index.html","hash":"cffccb66901178f497961c5cf7b3cda3cc3647ea","modified":1544690494843},{"_id":"public/categories/mongoDB/index.html","hash":"1d7dadecddaf97b7a0dc8804aa2597942a56efdf","modified":1544690494843},{"_id":"public/categories/编程/index.html","hash":"598c547c900f9bb85152c0394bc334b4ced4f9b2","modified":1544690494843},{"_id":"public/categories/后端/index.html","hash":"15756e9351ef5664fd787141512f70dd82e9680d","modified":1544690494843},{"_id":"public/categories/小程序/index.html","hash":"42e6bd5338c868a7fb35ea9bf444155df3e40f85","modified":1544690494843},{"_id":"public/categories/随记/index.html","hash":"71d34954d65347a59dcd2a8684f4e23bd5133815","modified":1544690494843},{"_id":"public/index.html","hash":"2ea6736bb8b68da58daa15fefae16a883978f817","modified":1544690494843},{"_id":"public/page/2/index.html","hash":"4eedb886f080f756e9c938c391325bf2a3a88fde","modified":1544690494844},{"_id":"public/page/3/index.html","hash":"1154ec3444434f05adf4c6916ed5cecb6b64a584","modified":1544690494844},{"_id":"public/tags/Javascript/index.html","hash":"85cd67329c3cb7043307707ead9046035a82aef9","modified":1544690494844},{"_id":"public/tags/Javascript/page/2/index.html","hash":"592c3e7ae4f84ba7fbe192e70646a0e039861cb7","modified":1544690494844},{"_id":"public/tags/Javascript/page/3/index.html","hash":"d5528514da94f206e36111fd5f1163f9481d3d6a","modified":1544690494844},{"_id":"public/tags/Javascript/page/4/index.html","hash":"b7817cb229383c6959aa0b50128fc436f4a0e768","modified":1544690494844},{"_id":"public/tags/编程/index.html","hash":"10a76909ae2856beff702fdcdd6e0ae3009fefd6","modified":1544690494844},{"_id":"public/tags/编程/page/2/index.html","hash":"50dffc72bc514c9451282f9f6ab30def4803be6f","modified":1544690494844},{"_id":"public/tags/编程/page/3/index.html","hash":"fa321e28fa89bcc27cf3a4fb91e61b58c3e92002","modified":1544690494844},{"_id":"public/tags/编程/page/4/index.html","hash":"0f30288cd537358b8d73fe68902dec170a8d6118","modified":1544690494844},{"_id":"public/tags/ES6/index.html","hash":"a3c23ddae8de2ad373f8ce1da97d33b2f1209e7d","modified":1544690494844},{"_id":"public/tags/软件/index.html","hash":"c3f5ca7face269ba869504df6262a053ab009340","modified":1544690494844},{"_id":"public/tags/React/index.html","hash":"686bc2737ab69faafa77f7fd5a43f436aaa24eee","modified":1544690494845},{"_id":"public/tags/React/page/2/index.html","hash":"f18b8aa5455e11f560236520501a947c2e6bef3d","modified":1544690494845},{"_id":"public/tags/生活/index.html","hash":"f2eea8a0aa6f2ed0ff12dd1b250161d570b4cef8","modified":1544690494845},{"_id":"public/tags/mongoDB/index.html","hash":"e1cbb0f099cf8c5a8adf8f840030d7d056b36763","modified":1544690494845},{"_id":"public/tags/Node/index.html","hash":"c350cffe41e9f11d4d32dfbc193dceaf19c69f21","modified":1544690494845},{"_id":"public/tags/小程序/index.html","hash":"617bf9a8d441d1a7bf751228473db3a9e2eb3954","modified":1544690494845},{"_id":"public/tags/CSS/index.html","hash":"748f6059631d97fff560cfd6ed3343c4593494c7","modified":1544690494845},{"_id":"public/tags/PHP/index.html","hash":"3a6b153f370373b7ddbc483bdbaca75008ff1164","modified":1544690494845},{"_id":"public/tags/后端/index.html","hash":"fce64a0cb00bfb16c9b059300c52b52d49f2fc2f","modified":1544690494845},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1544690494902},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1544690494913},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1544690494913},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1544690494913},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1544690494914},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1544690494914},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1544690494914},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1544690494914},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1544690494914},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1544690494914},{"_id":"public/images/drlicon.ico","hash":"3a6d7dc6409a041e43613e0098932e21da663bbe","modified":1544690494914},{"_id":"public/images/drlicon.icon.png","hash":"3a6d7dc6409a041e43613e0098932e21da663bbe","modified":1544690494914},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1544690494914},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1544690494914},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1544690494914},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1544690494914},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1544690494914},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1544690494914},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1544690494915},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1544690494915},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1544690494915},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1544690494915},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1544690494915},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1544690494915},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1544690494915},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1544690494915},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1544690494915},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1544690494915},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1544690494915},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1544690494916},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1544690494916},{"_id":"public/2018/05/25/ES6攻略/01.png","hash":"22c249d3547d34f2bff5c27a6df2bc4d26d5aa20","modified":1544690494916},{"_id":"public/2018/05/16/React开发常用设计模式-单向数据流/react_store.jpg","hash":"490f1fdfee4b8fbaac94c04428e05a16a21d5d0b","modified":1544690494916},{"_id":"public/2018/05/14/React开发常用设计模式-组件通讯/reactput.png","hash":"3623c380ef63073bc776994d63cbdabdf7ff35b3","modified":1544690494916},{"_id":"public/2018/05/22/小程序之旅—-认识一下/xcx1-1.png","hash":"c740b6eaf51934cded1cf85b62d050146c94e34f","modified":1544690494916},{"_id":"public/2018/05/22/小程序之旅—-认识一下/xcx1-2.png","hash":"457890eb333e48282d67696a9b8bcad479eded43","modified":1544690494916},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/redux-counter-app.png","hash":"3a1329f63c05bd18d550b3640bc5bcf8c78d44be","modified":1544690494916},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/tag-it.png","hash":"3336aa9b305b6ebbf9ee6c0a2aaee8386f7f5687","modified":1544690494916},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_5.png","hash":"e0fe8d76447245fecab1d12510ca07474ff7db35","modified":1544690494916},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_6.png","hash":"40d6bf1bd0bff189d6f158a056324febcd8cc7fe","modified":1544690494916},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1544690495312},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1544690495318},{"_id":"public/2018/05/16/React开发常用设计模式-单向数据流/react_store1.jpg","hash":"474d69107ab2be5c2ee0a7f54ceca2d02a2e163f","modified":1544690495321},{"_id":"public/2018/05/06/记一次Hexo文章里的图片不显示问题/alipay.png","hash":"6e0e7bc4308d01858f440913da485d6ef4d306da","modified":1544690495321},{"_id":"public/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png","hash":"02ec46682d917dbb2ad8eca9d54f55a219254e4c","modified":1544690495321},{"_id":"public/2018/05/14/React开发常用设计模式-组件通讯/react_1.png","hash":"af49a53b2904b68a2d79ed5662f612fd51969489","modified":1544690495321},{"_id":"public/2018/05/14/React开发常用设计模式-事件处理/react_3.png","hash":"a9f1408d9ea58d091fa894b4dc98cce22aacc659","modified":1544690495321},{"_id":"public/2018/05/14/React开发常用设计模式-组件通讯/react_2.png","hash":"5ae2a657c88c6edf966f80bd55b6228ae1f9d7fc","modified":1544690495321},{"_id":"public/2018/05/14/React开发常用设计模式-组合-composition/react_5.png","hash":"d012300fdc077224c8839bfa234ecff3f811ebf0","modified":1544690495321},{"_id":"public/2018/05/14/React开发常用设计模式-组合-composition/react_6.png","hash":"b45f92c20877af07e7a7d417203dbab2c4d75b9d","modified":1544690495321},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/react.jpg","hash":"b934486efe3a31fe876d14e99200bd07b7148e32","modified":1544690495322},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/redux-architecture.jpg","hash":"57227993d05fc68064e0fac63e3316f67835b0aa","modified":1544690495322},{"_id":"public/2018/06/11/React开发常用设计模式-Redux/redux-reallife.jpg","hash":"e940a281f9db5e97ad58d7fe692c7b660dd4fc27","modified":1544690495322},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx.png","hash":"838f281632be30cbfdc85ee76caf38fc65cf56d7","modified":1544690495322},{"_id":"public/404.html","hash":"4ce2875dc45198ab413e6c329c363d363b18a58f","modified":1544690495332},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1544690495332},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1544690495332},{"_id":"public/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1544690495332},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1544690495332},{"_id":"public/js/src/fireworks.js","hash":"ed2d0a5ad306a2745b7c8180b69e36b78d4b0698","modified":1544690495332},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1544690495332},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1544690495332},{"_id":"public/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1544690495332},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1544690495332},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1544690495332},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1544690495332},{"_id":"public/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1544690495332},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1544690495332},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1544690495332},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1544690495332},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1544690495332},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1544690495332},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1544690495332},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1544690495332},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1544690495332},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1544690495332},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1544690495332},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1544690495333},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1544690495333},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1544690495333},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1544690495333},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1544690495333},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1544690495333},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1544690495333},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1544690495333},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1544690495333},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1544690495333},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1544690495334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1544690495334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1544690495334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1544690495334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1544690495334},{"_id":"public/css/main.css","hash":"e46ccdd14072af9f29b3bb2bf9efe00cf6c76b73","modified":1544690495334},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1544690495334},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1544690495334},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1544690495334},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1544690495334},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1544690495334},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1544690495334},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1544690495334},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1544690495334},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1544690495334},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1544690495334},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1544690495334},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1544690495334},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"361ead056530b8d39495a1fac07a54a566724898","modified":1544690495335},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1544690495335},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1544690495335},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1544690495335},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1544690495335},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1544690495335},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1544690495335},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1544690495335},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1544690495335},{"_id":"public/2018/05/14/React开发常用设计模式-事件处理/react_4.png","hash":"b6c8431595feef016296cdf15d821c19751eda59","modified":1544690495335},{"_id":"public/2018/05/14/React开发常用设计模式-组合-composition/react_8.png","hash":"1d4ee8c3f55b7f784dee8a4c08b79db814cfe048","modified":1544690495336},{"_id":"public/2018/05/14/React开发常用设计模式-组合-composition/react_7.png","hash":"308124fabbe7918969962ab026fb6e044c05793e","modified":1544690495336},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_3.png","hash":"cc2d1af886159d533b4c2589b5a54a4bb6039157","modified":1544690495336},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_4.png","hash":"d6e4d62e80d079dfaa9f860510140b621c46824c","modified":1544690495336},{"_id":"public/images/alipay.png","hash":"ce146b2aceb7bd44a4c9922c4821c89f860c76f8","modified":1544690495341},{"_id":"public/images/wechatpay.png","hash":"becc2943ee257d7a66c5df496deb80377ad83668","modified":1544690495341},{"_id":"public/2018/05/14/React-开发常用设计模式-前言/cover1.png","hash":"31e11d18d777f28468015044197ec80cfacfc4b8","modified":1544690495342},{"_id":"public/2018/05/18/React开发常用设计模式-Flux/flex.png","hash":"7fcc9c7236b6b94b5a7bb948cefdea63f030f024","modified":1544690495342},{"_id":"public/2018/05/22/小程序之旅—-认识一下/xcx1.png","hash":"c55fef2cacc9e1678755df7fe55a2faaff79ce80","modified":1544690495342},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_2.png","hash":"56712ad07fa29fff27e15be571642dc788e8b84b","modified":1544690495342},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_7.png","hash":"327fda1f59fd9558926e934daf3f65d123db4bc0","modified":1544690495343},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1544690495347},{"_id":"public/2018/05/15/小程序之旅——个人申请/xcx_1.png","hash":"7eb6e5b52277254ac49ba2bc7ca46a3d975116c6","modified":1544690495371},{"_id":"public/images/back.png","hash":"5ba30da4e34a6494924c480f4125276bec570d89","modified":1544690495372},{"_id":"public/images/drl.png","hash":"43484a616b417d2539ae02c974e474bfd114db9c","modified":1544690495373}],"Category":[{"name":"Javascript","_id":"cjpmctncy0003kt89hf5co7l2"},{"name":"ES6","_id":"cjpmctnd20008kt8975xi7wwx"},{"name":"软件","_id":"cjpmctndu000ykt89fxa8gt46"},{"name":"React","_id":"cjpmctne10016kt89bwrhjqxy"},{"name":"Hexo","_id":"cjpmctnei002ekt8926loc2cg"},{"name":"mongoDB","_id":"cjpmctnel002nkt890x4caiez"},{"name":"编程","_id":"cjpmctnet0031kt89ays0yr8h"},{"name":"后端","_id":"cjpmctney003hkt89rirlnm02"},{"name":"小程序","_id":"cjpmctnf3003xkt89i7xae341"},{"name":"随记","_id":"cjpmctnfj0056kt8980egdfbh"}],"Data":[],"Page":[{"title":"关于我自己","date":"2018-05-05T10:18:53.000Z","comments":0,"_content":"\n\n***\n{% asset_img drl.png images %}\n![你想输入的替代文字](/blog/images/drl.png)\n\n{% note danger %} 段瑞龙  {% endnote %}\n{% note danger %} 这里是一些干活的收集，和自己遇到的一些问题和新知识集合地。  {% endnote %}\n{% note warning %} 上海爱用宝科技有限公司  {% endnote %}\n{% note info %} 云南-曲靖人  {% endnote %}\n{% note danger %} 前端开发工程师  {% endnote %}\n{% note default %} 摄影剪辑  {% endnote %}\n{% note primary %} 运动打篮球  {% endnote %}\n{% note success %} 美食烹饪  {% endnote %}\n","source":"about/index.md","raw":"---\ntitle: 关于我自己\ndate: 2018-05-05 18:18:53\ncomments: false\n\n---\n\n\n***\n{% asset_img drl.png images %}\n![你想输入的替代文字](/blog/images/drl.png)\n\n{% note danger %} 段瑞龙  {% endnote %}\n{% note danger %} 这里是一些干活的收集，和自己遇到的一些问题和新知识集合地。  {% endnote %}\n{% note warning %} 上海爱用宝科技有限公司  {% endnote %}\n{% note info %} 云南-曲靖人  {% endnote %}\n{% note danger %} 前端开发工程师  {% endnote %}\n{% note default %} 摄影剪辑  {% endnote %}\n{% note primary %} 运动打篮球  {% endnote %}\n{% note success %} 美食烹饪  {% endnote %}\n","updated":"2018-09-11T14:45:26.000Z","path":"about/index.html","layout":"page","_id":"cjpmctnct0001kt89e2gy90pz","content":"<hr>\n\n<p><img src=\"/blog/images/drl.png\" alt=\"你想输入的替代文字\"></p>\n<div class=\"note danger\"><p>段瑞龙  </p></div>\n<div class=\"note danger\"><p>这里是一些干活的收集，和自己遇到的一些问题和新知识集合地。  </p></div>\n<div class=\"note warning\"><p>上海爱用宝科技有限公司  </p></div>\n<div class=\"note info\"><p>云南-曲靖人  </p></div>\n<div class=\"note danger\"><p>前端开发工程师  </p></div>\n<div class=\"note default\"><p>摄影剪辑  </p></div>\n<div class=\"note primary\"><p>运动打篮球  </p></div>\n<div class=\"note success\"><p>美食烹饪  </p></div>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n\n<p><img src=\"/blog/images/drl.png\" alt=\"你想输入的替代文字\"></p>\n<div class=\"note danger\"><p>段瑞龙  </p></div>\n<div class=\"note danger\"><p>这里是一些干活的收集，和自己遇到的一些问题和新知识集合地。  </p></div>\n<div class=\"note warning\"><p>上海爱用宝科技有限公司  </p></div>\n<div class=\"note info\"><p>云南-曲靖人  </p></div>\n<div class=\"note danger\"><p>前端开发工程师  </p></div>\n<div class=\"note default\"><p>摄影剪辑  </p></div>\n<div class=\"note primary\"><p>运动打篮球  </p></div>\n<div class=\"note success\"><p>美食烹饪  </p></div>\n"},{"title":"分类","date":"2018-05-05T10:40:54.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-05-05 18:40:54\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-09-07T12:52:54.000Z","path":"categories/index.html","layout":"page","_id":"cjpmctnkd007xkt893ow3anb7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"我的标签","date":"2018-05-05T10:39:24.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 我的标签\ndate: 2018-05-05 18:39:24\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-09-07T12:52:54.000Z","path":"tags/index.html","layout":"page","_id":"cjpmctnke007ykt89befsj0xe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Async Functions (异步函数)","date":"2018-07-15T13:43:58.000Z","description":null,"copyright":false,"top":null,"_content":" ECMAScript 2017 新特性 Async Functions(异步函数) 。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# async(异步) 函数变体\n\n以下是已经存在的异步函数变体。请注意无处不在的  async 关键字。\n\n- 异步函数声明： async function foo() {}\n- 异步函数表达式： const foo = async function () {};\n- 异步函数定义：let obj = { async foo() {} }\n- 异步箭头函数： const foo = async () => {};\n\n# async(异步) 函数总是返回 Promises\n\nasync(异步) 函数的 Promise 完成状态：\n\n```h\nasync function asyncFunc() {\n    return 123;\n}\n \nasyncFunc()\n.then(x => console.log(x));\n    // 123\n\n```\n\nasync(异步) 函数的 Promise 拒绝状态：\n\n```h\nasync function asyncFunc() {\n    throw new Error('Problem!');\n}\n \nasyncFunc()\n.catch(err => console.log(err));\n    // Error: Problem!\n```\n\n# 通过 await 处理 async(异步) 计算的结果和错误\nawait（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise\b 返回：\n\n- 如果 Promise 是完成状态，await 的结果是完成态的值。\n- 如果 Promise 是拒绝状态，await 会抛出拒绝值。\n\n处理单个 async(异步) 返回值：\n```h\nasync function asyncFunc() {\n    const result = await otherAsyncFunc();\n    console.log(result);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc()\n    .then(result => {\n        console.log(result);\n    });\n}\n```\n按顺序处理多个 async(异步) 返回值：\n\n```h\nasync function asyncFunc() {\n    const result1 = await otherAsyncFunc1();\n    console.log(result1);\n    const result2 = await otherAsyncFunc2();\n    console.log(result2);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc1()\n    .then(result1 => {\n        console.log(result1);\n        return otherAsyncFunc2();\n    })\n    .then(result2 => {\n        console.log(result2);\n    });\n}\n\n```\n\n并行处理多个 async(异步) 返回值：\n\n```h\nasync function asyncFunc() {\n    const [result1, result2] = await Promise.all([\n        otherAsyncFunc1(),\n        otherAsyncFunc2(),\n    ]);\n    console.log(result1, result2);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return Promise.all([\n        otherAsyncFunc1(),\n        otherAsyncFunc2(),\n    ])\n    .then([result1, result2] => {\n        console.log(result1, result2);\n    });\n}\n```\n\n错误处理：\n\n```h\nasync function asyncFunc() {\n    try {\n        await otherAsyncFunc();\n    } catch (err) {\n        console.error(err);\n    }\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc()\n    .catch(err => {\n        console.error(err);\n    });\n}\n```\n\n# 理解 async(异步) 函数\n\n解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。\n\n对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：\n\n```h\nfunction fetchJson(url) {\n    return fetch(url)\n    .then(request => request.text())\n    .then(text => {\n        return JSON.parse(text);\n    })\n    .catch(error => {\n        console.log(`ERROR: ${error.stack}`);\n    });\n}\nfetchJson('http://example.com/some_file.json')\n.then(obj => console.log(obj));\n\n```\n# 通过 generator 来编写异步代码\n\nco 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：\n\n```h\nconst fetchJson = co.wrap(function* (url) {\n    try {\n        let request = yield fetch(url);\n        let text = yield request.text();\n        return JSON.parse(text);\n    }\n    catch (error) {\n        console.log(`ERROR: ${error.stack}`);\n    }\n});\n```\n\n每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于  then() 所做的工作）。\n\n# 通过 async(异步) 函数来编写异步代码\n\nasync(异步) \b函数用的特定语法基本上和 co 类似：\n```h\nasync function fetchJson(url) {\n    try {\n        let request = await fetch(url);\n        let text = await request.text();\n        return JSON.parse(text);\n    }\n    catch (error) {\n        console.log(`ERROR: ${error.stack}`);\n    }\n}\n```\n\n在内部，异步函数写法更类似于 generators 。\n\n# 以同步开始，异步处理的 async(异步) \b函数\n以下是 async(异步)函数是如何工作的：\n\n- 1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。\n- 2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。\n- 3、返回 Promise 对象 p。\n\n\n当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和  catch() 的回调总是在当前代码完成后执行。\n\n以下是代码示例：\n\n```h\n\nasync function asyncFunc() {\n    console.log('asyncFunc()'); // (A)\n    return 'abc';\n}\nasyncFunc().\nthen(x => console.log(`Resolved: ${x}`)); // (B)\nconsole.log('main'); // (C)\n \n// Output:\n// asyncFunc()\n// main\n// Resolved: abc\n```\n\n您可以认为是以下的执行顺序：\n\n- 1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。\n- 2、行C：执行继续。\n- 3、行B：Promise\b\b 完成状态通知是异步发生的。\n\n# 返回不被包裹的 Promise 对象\nPromise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise  p 的。这意味着：\n\n- 1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。\n- 2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。\n因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：\n```h\nasync function asyncFunc() {\n    return Promise.resolve(123);\n}\nasyncFunc()\n.then(x => console.log(x)) // 123\n\n```\n\n有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）：\n\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return Promise.reject(new Error('Problem!'));\n}\nasyncFunc()\n.catch(err => console.error(err)); // Error: Problem!\n```\n\n这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return anotherAsyncFunc();\n}\n```\n上面的代码\b示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹  anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return await anotherAsyncFunc();\n}\n```\n\n# 使用 await 小贴士\n\n## 不要忘记使用 await\n在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const value = otherAsyncFunc(); // missing `await`!\n    ···\n}\n```\n在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。\n\nawait 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：\n```h\nJavaScript 代码:\nasync function foo() {\n    await step1(); // (A)\n    ···\n}\n```\n行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。\n\n## 不需要使用 await 的情况\n\n\n有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const writer = openFile('someFile.txt');\n    writer.write('hello'); // don’t wait\n    writer.write('world'); // don’t wait\n    await writer.close(); // wait for file to close\n}\n```\n在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。\n\nasyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。\n\n由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return\b 替换  await writer.close() ：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const writer = openFile('someFile.txt');\n    writer.write('hello');\n    writer.write('world');\n    return writer.close();\n}\n```\n这两个版本各有利弊，await 版本可能稍微更容易理解。\n\n## await 是顺序执行的，Promise.all() 是并行的\n\n下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。\n```h\nJavaScript 代码:\nasync function foo() {\n    const result1 = await asyncFunc1();\n    const result2 = await asyncFunc2();\n}\n```\n这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：\n\n```h\nJavaScript 代码:\nasync function foo() {\n    const [result1, result2] = await Promise.all([\n        asyncFunc1(),\n        asyncFunc2(),\n    ]);\n}\n```\n我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。\n\n# 异步函数和回调\n\nasync(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。\n\n# Array.prototype.map()\n\n我们从数组方法 map() 开始讲解。在\b下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    return urls.map(url => {\n        // 错误的语法!\n        const content = await httpGet(url);\n        return content;\n    });\n}\n```\n这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    return urls.map(async (url) => { // 注意这一行中的 async ;\n        const content = await httpGet(url);\n        return content;\n    });\n}\n```\n这段代码有两个问题：\n\n现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。\n一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待  downloadContent() 执行结束。\n我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(async (url) => {\n        const content = await httpGet(url);\n        return content;\n    });\n    return await Promise.all(promiseArray);\n}\n```\nmap() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(\n        url => httpGet(url));\n    return await Promise.all(promiseArray);\n}\n```\n我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开  Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(\n        url => httpGet(url));\n    return Promise.all(promiseArray);\n}\n```\n# Array.prototype.forEach()\n\n我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    urls.forEach(url => {\n        // Wrong syntax\n        const content = await httpGet(url);\n        console.log(content);\n    });\n}\n```\n同样的，这里的代码会产生一个语法错误，因为你不能在\b通常的箭头函数内部使用 await 。\n\n\b我们换作异步箭头函数：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    urls.forEach(async url => {\n        const content = await httpGet(url);\n        console.log(content);\n    });\n    // Not finished here\n}\n```\n这段代码起作用了，但是\b会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。\n\n如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    for (const url of urls) {\n        const content = await httpGet(url);\n        console.log(content);\n    }\n}\n```\n现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    await Promise.all(urls.map(\n        async url => {\n            const content = await httpGet(url);\n            console.log(content);\n        }));\n}\n```\nmap() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法\b执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。\n\n# 使用异步函数小贴士\n\n## 了解你的 Promises\n\nasync(异步) 函数的基础就是 [Promises](http://exploringjs.com/es6/ch_promises.html) 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来\b实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。\n\n举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：\n```h\nJavaScript 代码:\nfunction httpGet(url, responseType=\"\") {\n    return new Promise(\n        function (resolve, reject) {\n            const request = new XMLHttpRequest();\n            request.onload = function () {\n                if (this.status === 200) {\n                    // Success\n                    resolve(this.response);\n                } else {\n                    // Something went wrong (404 etc.)\n                    reject(new Error(this.statusText));\n                }\n            };\n            request.onerror = function () {\n                reject(new Error(\n                    'XMLHttpRequest Error: '+this.statusText));\n            };\n            request.open('GET', url);\n            xhr.responseType = responseType;\n            request.send();\n        });\n}\n```\n\bXMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者  throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。\n\n因此，异步函数的通用编码风格是：\n\n- 直接使用 Promise 对象来\b构建异步原语。\n- 用异步函数来使用这些原语。\n扩展阅读：“Exploring ES6” 中的 “[异步编程中的 Promises 对象](http://exploringjs.com/es6/ch_promises.html)” 章节\n\n# 立即调用异步函数表达式\n\n有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main() \b 并立即调用它：\n```h\nJavaScript 代码:\nasync function main() {\n    console.log(await asyncFunction());\n}\n```\nmain();\n或者您可以使用立即调用异步函数表达式：\n```h\nJavaScript 代码:\n(async function () {\n    console.log(await asyncFunction());\n})();\n```\n另一个选择是立即调用异步箭头函数：\n```h\nJavaScript 代码:\n(async () => {\n    console.log(await asyncFunction());\n})();\n```\n# 用异步函数进行单元测试\n\n以下代码使用 [测试框架 mocha](https://mochajs.org/) 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：\n\n```h\nimport assert from 'assert';\n \n// Bug: the following test always succeeds\ntest('Testing async code', function () {\n    asyncFunc1() // (A)\n    .then(result1 => {\n        assert.strictEqual(result1, 'a'); // (B)\n        return asyncFunc2();\n    })\n    .then(result2 => {\n        assert.strictEqual(result2, 'b'); // (C)\n    });\n});\n```\n然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。\n\n你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。\n```h\nJavaScript 代码:\nreturn asyncFunc1() // (A)\n\n```\n异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：\n```h\nJavaScript 代码:\nimport assert from 'assert';\ntest('Testing async code', async function () {\n    const result1 = await asyncFunc1();\n    assert.strictEqual(result1, 'a');\n    const result2 = await asyncFunc2();\n    assert.strictEqual(result2, 'b');\n});\n```\n在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。\n\n# 不要担心没有处理的拒绝拒态\n\n\n当前的 JavaScript 引擎可以在拒绝态未处理的情况下\b提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告\b：\n```h\nJavaScript 代码:\nasync function foo() {\n    throw new Error('Problem!');\n}\nfoo();\n```\n\n# 阅读延伸\n\n- [异步函数](https://github.com/tc39/ecmascript-asyncawait) （提出者Brian Terlson）\n- [通过generators来简化异步计算](http://exploringjs.com/es6/ch_generators.html#sec_co-library)（“\bExporing ES6”中的部分章节）\n原文地址：[http://exploringjs.com/es2016-es2017/ch_async-functions.html](http://exploringjs.com/es2016-es2017/ch_async-functions.html)\n\n\n","source":"_posts/Async-Functions-异步函数.md","raw":"---\ntitle: Async Functions (异步函数)\ndate: 2018-07-15 21:43:58\ntags: [Javascript,编程]\ndescription: \ncopyright: false\ncategories: Javascript\ntop:\n---\n ECMAScript 2017 新特性 Async Functions(异步函数) 。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# async(异步) 函数变体\n\n以下是已经存在的异步函数变体。请注意无处不在的  async 关键字。\n\n- 异步函数声明： async function foo() {}\n- 异步函数表达式： const foo = async function () {};\n- 异步函数定义：let obj = { async foo() {} }\n- 异步箭头函数： const foo = async () => {};\n\n# async(异步) 函数总是返回 Promises\n\nasync(异步) 函数的 Promise 完成状态：\n\n```h\nasync function asyncFunc() {\n    return 123;\n}\n \nasyncFunc()\n.then(x => console.log(x));\n    // 123\n\n```\n\nasync(异步) 函数的 Promise 拒绝状态：\n\n```h\nasync function asyncFunc() {\n    throw new Error('Problem!');\n}\n \nasyncFunc()\n.catch(err => console.log(err));\n    // Error: Problem!\n```\n\n# 通过 await 处理 async(异步) 计算的结果和错误\nawait（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise\b 返回：\n\n- 如果 Promise 是完成状态，await 的结果是完成态的值。\n- 如果 Promise 是拒绝状态，await 会抛出拒绝值。\n\n处理单个 async(异步) 返回值：\n```h\nasync function asyncFunc() {\n    const result = await otherAsyncFunc();\n    console.log(result);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc()\n    .then(result => {\n        console.log(result);\n    });\n}\n```\n按顺序处理多个 async(异步) 返回值：\n\n```h\nasync function asyncFunc() {\n    const result1 = await otherAsyncFunc1();\n    console.log(result1);\n    const result2 = await otherAsyncFunc2();\n    console.log(result2);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc1()\n    .then(result1 => {\n        console.log(result1);\n        return otherAsyncFunc2();\n    })\n    .then(result2 => {\n        console.log(result2);\n    });\n}\n\n```\n\n并行处理多个 async(异步) 返回值：\n\n```h\nasync function asyncFunc() {\n    const [result1, result2] = await Promise.all([\n        otherAsyncFunc1(),\n        otherAsyncFunc2(),\n    ]);\n    console.log(result1, result2);\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return Promise.all([\n        otherAsyncFunc1(),\n        otherAsyncFunc2(),\n    ])\n    .then([result1, result2] => {\n        console.log(result1, result2);\n    });\n}\n```\n\n错误处理：\n\n```h\nasync function asyncFunc() {\n    try {\n        await otherAsyncFunc();\n    } catch (err) {\n        console.error(err);\n    }\n}\n \n// 等价于:\nfunction asyncFunc() {\n    return otherAsyncFunc()\n    .catch(err => {\n        console.error(err);\n    });\n}\n```\n\n# 理解 async(异步) 函数\n\n解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。\n\n对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：\n\n```h\nfunction fetchJson(url) {\n    return fetch(url)\n    .then(request => request.text())\n    .then(text => {\n        return JSON.parse(text);\n    })\n    .catch(error => {\n        console.log(`ERROR: ${error.stack}`);\n    });\n}\nfetchJson('http://example.com/some_file.json')\n.then(obj => console.log(obj));\n\n```\n# 通过 generator 来编写异步代码\n\nco 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：\n\n```h\nconst fetchJson = co.wrap(function* (url) {\n    try {\n        let request = yield fetch(url);\n        let text = yield request.text();\n        return JSON.parse(text);\n    }\n    catch (error) {\n        console.log(`ERROR: ${error.stack}`);\n    }\n});\n```\n\n每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于  then() 所做的工作）。\n\n# 通过 async(异步) 函数来编写异步代码\n\nasync(异步) \b函数用的特定语法基本上和 co 类似：\n```h\nasync function fetchJson(url) {\n    try {\n        let request = await fetch(url);\n        let text = await request.text();\n        return JSON.parse(text);\n    }\n    catch (error) {\n        console.log(`ERROR: ${error.stack}`);\n    }\n}\n```\n\n在内部，异步函数写法更类似于 generators 。\n\n# 以同步开始，异步处理的 async(异步) \b函数\n以下是 async(异步)函数是如何工作的：\n\n- 1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。\n- 2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。\n- 3、返回 Promise 对象 p。\n\n\n当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和  catch() 的回调总是在当前代码完成后执行。\n\n以下是代码示例：\n\n```h\n\nasync function asyncFunc() {\n    console.log('asyncFunc()'); // (A)\n    return 'abc';\n}\nasyncFunc().\nthen(x => console.log(`Resolved: ${x}`)); // (B)\nconsole.log('main'); // (C)\n \n// Output:\n// asyncFunc()\n// main\n// Resolved: abc\n```\n\n您可以认为是以下的执行顺序：\n\n- 1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。\n- 2、行C：执行继续。\n- 3、行B：Promise\b\b 完成状态通知是异步发生的。\n\n# 返回不被包裹的 Promise 对象\nPromise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise  p 的。这意味着：\n\n- 1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。\n- 2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。\n因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：\n```h\nasync function asyncFunc() {\n    return Promise.resolve(123);\n}\nasyncFunc()\n.then(x => console.log(x)) // 123\n\n```\n\n有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）：\n\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return Promise.reject(new Error('Problem!'));\n}\nasyncFunc()\n.catch(err => console.error(err)); // Error: Problem!\n```\n\n这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return anotherAsyncFunc();\n}\n```\n上面的代码\b示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹  anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    return await anotherAsyncFunc();\n}\n```\n\n# 使用 await 小贴士\n\n## 不要忘记使用 await\n在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const value = otherAsyncFunc(); // missing `await`!\n    ···\n}\n```\n在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。\n\nawait 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：\n```h\nJavaScript 代码:\nasync function foo() {\n    await step1(); // (A)\n    ···\n}\n```\n行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。\n\n## 不需要使用 await 的情况\n\n\n有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const writer = openFile('someFile.txt');\n    writer.write('hello'); // don’t wait\n    writer.write('world'); // don’t wait\n    await writer.close(); // wait for file to close\n}\n```\n在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。\n\nasyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。\n\n由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return\b 替换  await writer.close() ：\n```h\nJavaScript 代码:\nasync function asyncFunc() {\n    const writer = openFile('someFile.txt');\n    writer.write('hello');\n    writer.write('world');\n    return writer.close();\n}\n```\n这两个版本各有利弊，await 版本可能稍微更容易理解。\n\n## await 是顺序执行的，Promise.all() 是并行的\n\n下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。\n```h\nJavaScript 代码:\nasync function foo() {\n    const result1 = await asyncFunc1();\n    const result2 = await asyncFunc2();\n}\n```\n这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：\n\n```h\nJavaScript 代码:\nasync function foo() {\n    const [result1, result2] = await Promise.all([\n        asyncFunc1(),\n        asyncFunc2(),\n    ]);\n}\n```\n我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。\n\n# 异步函数和回调\n\nasync(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。\n\n# Array.prototype.map()\n\n我们从数组方法 map() 开始讲解。在\b下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    return urls.map(url => {\n        // 错误的语法!\n        const content = await httpGet(url);\n        return content;\n    });\n}\n```\n这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    return urls.map(async (url) => { // 注意这一行中的 async ;\n        const content = await httpGet(url);\n        return content;\n    });\n}\n```\n这段代码有两个问题：\n\n现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。\n一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待  downloadContent() 执行结束。\n我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(async (url) => {\n        const content = await httpGet(url);\n        return content;\n    });\n    return await Promise.all(promiseArray);\n}\n```\nmap() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(\n        url => httpGet(url));\n    return await Promise.all(promiseArray);\n}\n```\n我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开  Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：\n```h\nJavaScript 代码:\nasync function downloadContent(urls) {\n    const promiseArray = urls.map(\n        url => httpGet(url));\n    return Promise.all(promiseArray);\n}\n```\n# Array.prototype.forEach()\n\n我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    urls.forEach(url => {\n        // Wrong syntax\n        const content = await httpGet(url);\n        console.log(content);\n    });\n}\n```\n同样的，这里的代码会产生一个语法错误，因为你不能在\b通常的箭头函数内部使用 await 。\n\n\b我们换作异步箭头函数：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    urls.forEach(async url => {\n        const content = await httpGet(url);\n        console.log(content);\n    });\n    // Not finished here\n}\n```\n这段代码起作用了，但是\b会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。\n\n如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    for (const url of urls) {\n        const content = await httpGet(url);\n        console.log(content);\n    }\n}\n```\n现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：\n```h\nJavaScript 代码:\nasync function logContent(urls) {\n    await Promise.all(urls.map(\n        async url => {\n            const content = await httpGet(url);\n            console.log(content);\n        }));\n}\n```\nmap() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法\b执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。\n\n# 使用异步函数小贴士\n\n## 了解你的 Promises\n\nasync(异步) 函数的基础就是 [Promises](http://exploringjs.com/es6/ch_promises.html) 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来\b实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。\n\n举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：\n```h\nJavaScript 代码:\nfunction httpGet(url, responseType=\"\") {\n    return new Promise(\n        function (resolve, reject) {\n            const request = new XMLHttpRequest();\n            request.onload = function () {\n                if (this.status === 200) {\n                    // Success\n                    resolve(this.response);\n                } else {\n                    // Something went wrong (404 etc.)\n                    reject(new Error(this.statusText));\n                }\n            };\n            request.onerror = function () {\n                reject(new Error(\n                    'XMLHttpRequest Error: '+this.statusText));\n            };\n            request.open('GET', url);\n            xhr.responseType = responseType;\n            request.send();\n        });\n}\n```\n\bXMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者  throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。\n\n因此，异步函数的通用编码风格是：\n\n- 直接使用 Promise 对象来\b构建异步原语。\n- 用异步函数来使用这些原语。\n扩展阅读：“Exploring ES6” 中的 “[异步编程中的 Promises 对象](http://exploringjs.com/es6/ch_promises.html)” 章节\n\n# 立即调用异步函数表达式\n\n有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main() \b 并立即调用它：\n```h\nJavaScript 代码:\nasync function main() {\n    console.log(await asyncFunction());\n}\n```\nmain();\n或者您可以使用立即调用异步函数表达式：\n```h\nJavaScript 代码:\n(async function () {\n    console.log(await asyncFunction());\n})();\n```\n另一个选择是立即调用异步箭头函数：\n```h\nJavaScript 代码:\n(async () => {\n    console.log(await asyncFunction());\n})();\n```\n# 用异步函数进行单元测试\n\n以下代码使用 [测试框架 mocha](https://mochajs.org/) 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：\n\n```h\nimport assert from 'assert';\n \n// Bug: the following test always succeeds\ntest('Testing async code', function () {\n    asyncFunc1() // (A)\n    .then(result1 => {\n        assert.strictEqual(result1, 'a'); // (B)\n        return asyncFunc2();\n    })\n    .then(result2 => {\n        assert.strictEqual(result2, 'b'); // (C)\n    });\n});\n```\n然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。\n\n你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。\n```h\nJavaScript 代码:\nreturn asyncFunc1() // (A)\n\n```\n异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：\n```h\nJavaScript 代码:\nimport assert from 'assert';\ntest('Testing async code', async function () {\n    const result1 = await asyncFunc1();\n    assert.strictEqual(result1, 'a');\n    const result2 = await asyncFunc2();\n    assert.strictEqual(result2, 'b');\n});\n```\n在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。\n\n# 不要担心没有处理的拒绝拒态\n\n\n当前的 JavaScript 引擎可以在拒绝态未处理的情况下\b提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告\b：\n```h\nJavaScript 代码:\nasync function foo() {\n    throw new Error('Problem!');\n}\nfoo();\n```\n\n# 阅读延伸\n\n- [异步函数](https://github.com/tc39/ecmascript-asyncawait) （提出者Brian Terlson）\n- [通过generators来简化异步计算](http://exploringjs.com/es6/ch_generators.html#sec_co-library)（“\bExporing ES6”中的部分章节）\n原文地址：[http://exploringjs.com/es2016-es2017/ch_async-functions.html](http://exploringjs.com/es2016-es2017/ch_async-functions.html)\n\n\n","slug":"Async-Functions-异步函数","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctncp0000kt89niw1niuk","content":"<p> ECMAScript 2017 新特性 Async Functions(异步函数) 。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"async-异步-函数变体\"><a href=\"#async-异步-函数变体\" class=\"headerlink\" title=\"async(异步) 函数变体\"></a>async(异步) 函数变体</h1><p>以下是已经存在的异步函数变体。请注意无处不在的  async 关键字。</p>\n<ul>\n<li>异步函数声明： async function foo() {}</li>\n<li>异步函数表达式： const foo = async function () {};</li>\n<li>异步函数定义：let obj = { async foo() {} }</li>\n<li>异步箭头函数： const foo = async () =&gt; {};</li>\n</ul>\n<h1 id=\"async-异步-函数总是返回-Promises\"><a href=\"#async-异步-函数总是返回-Promises\" class=\"headerlink\" title=\"async(异步) 函数总是返回 Promises\"></a>async(异步) 函数总是返回 Promises</h1><p>async(异步) 函数的 Promise 完成状态：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.then(x =&gt; console.<span class=\"built_in\">log</span>(x));</span><br><span class=\"line\">    <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>async(异步) 函数的 Promise 拒绝状态：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    throw new Error('Problem!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(err =&gt; console.<span class=\"built_in\">log</span>(err));</span><br><span class=\"line\">    <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-await-处理-async-异步-计算的结果和错误\"><a href=\"#通过-await-处理-async-异步-计算的结果和错误\" class=\"headerlink\" title=\"通过 await 处理 async(异步) 计算的结果和错误\"></a>通过 await 处理 async(异步) 计算的结果和错误</h1><p>await（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise\b 返回：</p>\n<ul>\n<li>如果 Promise 是完成状态，await 的结果是完成态的值。</li>\n<li>如果 Promise 是拒绝状态，await 会抛出拒绝值。</li>\n</ul>\n<p>处理单个 async(异步) 返回值：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = await otherAsyncFunc();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc()</span><br><span class=\"line\">    .then(result =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按顺序处理多个 async(异步) 返回值：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await otherAsyncFunc1();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await otherAsyncFunc2();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc1()</span><br><span class=\"line\">    .then(result1 =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result1);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> otherAsyncFunc2();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(result2 =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并行处理多个 async(异步) 返回值：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [result1, result2] = await Promise.all([</span><br><span class=\"line\">        otherAsyncFunc1(),</span><br><span class=\"line\">        otherAsyncFunc2(),</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result1, result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.all([</span><br><span class=\"line\">        otherAsyncFunc1(),</span><br><span class=\"line\">        otherAsyncFunc2(),</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    .then([result1, result2] =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result1, result2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>错误处理：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"function\">await <span class=\"title\">otherAsyncFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc()</span><br><span class=\"line\">    .<span class=\"keyword\">catch</span>(err =&gt; &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"理解-async-异步-函数\"><a href=\"#理解-async-异步-函数\" class=\"headerlink\" title=\"理解 async(异步) 函数\"></a>理解 async(异步) 函数</h1><p>解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p>\n<p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">fetchJson</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url)</span><br><span class=\"line\">    .then(request =&gt; request.text())</span><br><span class=\"line\">    .then(text =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"keyword\">catch</span>(error =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetchJson('http://example.com/some_file.json')</span><br><span class=\"line\">.then(obj =&gt; console.<span class=\"built_in\">log</span>(obj));</span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-generator-来编写异步代码\"><a href=\"#通过-generator-来编写异步代码\" class=\"headerlink\" title=\"通过 generator 来编写异步代码\"></a>通过 generator 来编写异步代码</h1><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetchJson = co.wrap(function* (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        let request = yield fetch(url);</span><br><span class=\"line\">        let text = yield request.text();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于  then() 所做的工作）。</p>\n<h1 id=\"通过-async-异步-函数来编写异步代码\"><a href=\"#通过-async-异步-函数来编写异步代码\" class=\"headerlink\" title=\"通过 async(异步) 函数来编写异步代码\"></a>通过 async(异步) 函数来编写异步代码</h1><p>async(异步) \b函数用的特定语法基本上和 co 类似：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">fetchJson</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        let request = await fetch(url);</span><br><span class=\"line\">        let text = await request.text();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在内部，异步函数写法更类似于 generators 。</p>\n<h1 id=\"以同步开始，异步处理的-async-异步-函数\"><a href=\"#以同步开始，异步处理的-async-异步-函数\" class=\"headerlink\" title=\"以同步开始，异步处理的 async(异步) \b函数\"></a>以同步开始，异步处理的 async(异步) \b函数</h1><p>以下是 async(异步)函数是如何工作的：</p>\n<ul>\n<li>1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。</li>\n<li>2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。</li>\n<li>3、返回 Promise 对象 p。</li>\n</ul>\n<p>当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和  catch() 的回调总是在当前代码完成后执行。</p>\n<p>以下是代码示例：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    console.log('asyncFunc()'); // (A)</span><br><span class=\"line\">    return 'abc';</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc().</span><br><span class=\"line\">then(x =&gt; console.<span class=\"built_in\">log</span>(`Resolved: $&#123;x&#125;`)); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">console.log('main'); // (C)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// asyncFunc()</span></span><br><span class=\"line\"><span class=\"comment\">// main</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved: abc</span></span><br></pre></td></tr></table></figure>\n<p>您可以认为是以下的执行顺序：</p>\n<ul>\n<li>1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。</li>\n<li>2、行C：执行继续。</li>\n<li>3、行B：Promise\b\b 完成状态通知是异步发生的。</li>\n</ul>\n<h1 id=\"返回不被包裹的-Promise-对象\"><a href=\"#返回不被包裹的-Promise-对象\" class=\"headerlink\" title=\"返回不被包裹的 Promise 对象\"></a>返回不被包裹的 Promise 对象</h1><p>Promise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise  p 的。这意味着：</p>\n<ul>\n<li>1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。</li>\n<li>2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。<br>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.resolve(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.then(x =&gt; console.<span class=\"built_in\">log</span>(x)) <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    return Promise.reject(new Error('Problem!'));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(err =&gt; console.error(err)); <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n<p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> anotherAsyncFunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码\b示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹  anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await anotherAsyncFunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用-await-小贴士\"><a href=\"#使用-await-小贴士\" class=\"headerlink\" title=\"使用 await 小贴士\"></a>使用 await 小贴士</h1><h2 id=\"不要忘记使用-await\"><a href=\"#不要忘记使用-await\" class=\"headerlink\" title=\"不要忘记使用 await\"></a>不要忘记使用 await</h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = otherAsyncFunc(); <span class=\"comment\">// missing `await`!</span></span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。</p>\n<p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">await <span class=\"title\">step1</span><span class=\"params\">()</span></span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。</p>\n<h2 id=\"不需要使用-await-的情况\"><a href=\"#不需要使用-await-的情况\" class=\"headerlink\" title=\"不需要使用 await 的情况\"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    const writer = openFile('someFile.txt');</span><br><span class=\"line\">    writer.write('hello'); // don’t wait</span><br><span class=\"line\">    writer.write('world'); // don’t wait</span><br><span class=\"line\">    await writer.close(); <span class=\"comment\">// wait for file to close</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p>\n<p>asyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。</p>\n<p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return\b 替换  await writer.close() ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    const writer = openFile('someFile.txt');</span><br><span class=\"line\">    writer.write('hello');</span><br><span class=\"line\">    writer.write('world');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> writer.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个版本各有利弊，await 版本可能稍微更容易理解。</p>\n<h2 id=\"await-是顺序执行的，Promise-all-是并行的\"><a href=\"#await-是顺序执行的，Promise-all-是并行的\" class=\"headerlink\" title=\"await 是顺序执行的，Promise.all() 是并行的\"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await asyncFunc1();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await asyncFunc2();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [result1, result2] = await Promise.all([</span><br><span class=\"line\">        asyncFunc1(),</span><br><span class=\"line\">        asyncFunc2(),</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p>\n<h1 id=\"异步函数和回调\"><a href=\"#异步函数和回调\" class=\"headerlink\" title=\"异步函数和回调\"></a>异步函数和回调</h1><p>async(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。</p>\n<h1 id=\"Array-prototype-map\"><a href=\"#Array-prototype-map\" class=\"headerlink\" title=\"Array.prototype.map()\"></a>Array.prototype.map()</h1><p>我们从数组方法 map() 开始讲解。在\b下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> urls.<span class=\"built_in\">map</span>(url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 错误的语法!</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> urls.<span class=\"built_in\">map</span>(async (url) =&gt; &#123; <span class=\"comment\">// 注意这一行中的 async ;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码有两个问题：</p>\n<p>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。<br>一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待  downloadContent() 执行结束。<br>我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(async (url) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        url =&gt; httpGet(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开  Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        url =&gt; httpGet(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Array-prototype-forEach\"><a href=\"#Array-prototype-forEach\" class=\"headerlink\" title=\"Array.prototype.forEach()\"></a>Array.prototype.forEach()</h1><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    urls.forEach(url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Wrong syntax</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，这里的代码会产生一个语法错误，因为你不能在\b通常的箭头函数内部使用 await 。</p>\n<p>\b我们换作异步箭头函数：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    urls.forEach(async url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// Not finished here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码起作用了，但是\b会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。</p>\n<p>如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url of urls) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    await Promise.all(urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        async url =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法\b执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p>\n<h1 id=\"使用异步函数小贴士\"><a href=\"#使用异步函数小贴士\" class=\"headerlink\" title=\"使用异步函数小贴士\"></a>使用异步函数小贴士</h1><h2 id=\"了解你的-Promises\"><a href=\"#了解你的-Promises\" class=\"headerlink\" title=\"了解你的 Promises\"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来\b实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p>\n<p>举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">httpGet</span><span class=\"params\">(url, responseType=<span class=\"string\">\"\"</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(</span><br><span class=\"line\">        function (resolve, reject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">            request.onload = function () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Success</span></span><br><span class=\"line\">                    resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Something went wrong (404 etc.)</span></span><br><span class=\"line\">                    reject(<span class=\"keyword\">new</span> Error(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            request.onerror = function () &#123;</span><br><span class=\"line\">                reject(<span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">                    'XMLHttpRequest Error: '+this.statusText));</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            request.open('GET', url);</span><br><span class=\"line\">            xhr.responseType = responseType;</span><br><span class=\"line\">            request.send();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>\bXMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者  throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。</p>\n<p>因此，异步函数的通用编码风格是：</p>\n<ul>\n<li>直接使用 Promise 对象来\b构建异步原语。</li>\n<li>用异步函数来使用这些原语。<br>扩展阅读：“Exploring ES6” 中的 “<a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">异步编程中的 Promises 对象</a>” 章节</li>\n</ul>\n<h1 id=\"立即调用异步函数表达式\"><a href=\"#立即调用异步函数表达式\" class=\"headerlink\" title=\"立即调用异步函数表达式\"></a>立即调用异步函数表达式</h1><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main() \b 并立即调用它：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main();<br>或者您可以使用立即调用异步函数表达式：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">(async function () &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>另一个选择是立即调用异步箭头函数：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">(async () =&gt; &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"用异步函数进行单元测试\"><a href=\"#用异步函数进行单元测试\" class=\"headerlink\" title=\"用异步函数进行单元测试\"></a>用异步函数进行单元测试</h1><p>以下代码使用 <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import assert from 'assert';</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Bug: the following test always succeeds</span></span><br><span class=\"line\">test('Testing async code', function () &#123;</span><br><span class=\"line\">    asyncFunc1() <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    .then(result1 =&gt; &#123;</span><br><span class=\"line\">        assert.strictEqual(result1, <span class=\"string\">'a'</span>); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> asyncFunc2();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(result2 =&gt; &#123;</span><br><span class=\"line\">        assert.strictEqual(result2, <span class=\"string\">'b'</span>); <span class=\"comment\">// (C)</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p>\n<p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"keyword\">return</span> asyncFunc1() <span class=\"comment\">// (A)</span></span><br></pre></td></tr></table></figure></p>\n<p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">import assert from 'assert';</span><br><span class=\"line\">test('Testing async code', async function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await asyncFunc1();</span><br><span class=\"line\">    assert.strictEqual(result1, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await asyncFunc2();</span><br><span class=\"line\">    assert.strictEqual(result2, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p>\n<h1 id=\"不要担心没有处理的拒绝拒态\"><a href=\"#不要担心没有处理的拒绝拒态\" class=\"headerlink\" title=\"不要担心没有处理的拒绝拒态\"></a>不要担心没有处理的拒绝拒态</h1><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下\b提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告\b：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    throw new Error('Problem!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"阅读延伸\"><a href=\"#阅读延伸\" class=\"headerlink\" title=\"阅读延伸\"></a>阅读延伸</h1><ul>\n<li><a href=\"https://github.com/tc39/ecmascript-asyncawait\" target=\"_blank\" rel=\"noopener\">异步函数</a> （提出者Brian Terlson）</li>\n<li><a href=\"http://exploringjs.com/es6/ch_generators.html#sec_co-library\" target=\"_blank\" rel=\"noopener\">通过generators来简化异步计算</a>（“\bExporing ES6”中的部分章节）<br>原文地址：<a href=\"http://exploringjs.com/es2016-es2017/ch_async-functions.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2016-es2017/ch_async-functions.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p> ECMAScript 2017 新特性 Async Functions(异步函数) 。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>","more":"<h1 id=\"async-异步-函数变体\"><a href=\"#async-异步-函数变体\" class=\"headerlink\" title=\"async(异步) 函数变体\"></a>async(异步) 函数变体</h1><p>以下是已经存在的异步函数变体。请注意无处不在的  async 关键字。</p>\n<ul>\n<li>异步函数声明： async function foo() {}</li>\n<li>异步函数表达式： const foo = async function () {};</li>\n<li>异步函数定义：let obj = { async foo() {} }</li>\n<li>异步箭头函数： const foo = async () =&gt; {};</li>\n</ul>\n<h1 id=\"async-异步-函数总是返回-Promises\"><a href=\"#async-异步-函数总是返回-Promises\" class=\"headerlink\" title=\"async(异步) 函数总是返回 Promises\"></a>async(异步) 函数总是返回 Promises</h1><p>async(异步) 函数的 Promise 完成状态：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.then(x =&gt; console.<span class=\"built_in\">log</span>(x));</span><br><span class=\"line\">    <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>async(异步) 函数的 Promise 拒绝状态：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    throw new Error('Problem!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(err =&gt; console.<span class=\"built_in\">log</span>(err));</span><br><span class=\"line\">    <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-await-处理-async-异步-计算的结果和错误\"><a href=\"#通过-await-处理-async-异步-计算的结果和错误\" class=\"headerlink\" title=\"通过 await 处理 async(异步) 计算的结果和错误\"></a>通过 await 处理 async(异步) 计算的结果和错误</h1><p>await（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise\b 返回：</p>\n<ul>\n<li>如果 Promise 是完成状态，await 的结果是完成态的值。</li>\n<li>如果 Promise 是拒绝状态，await 会抛出拒绝值。</li>\n</ul>\n<p>处理单个 async(异步) 返回值：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = await otherAsyncFunc();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc()</span><br><span class=\"line\">    .then(result =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按顺序处理多个 async(异步) 返回值：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await otherAsyncFunc1();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await otherAsyncFunc2();</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc1()</span><br><span class=\"line\">    .then(result1 =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result1);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> otherAsyncFunc2();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(result2 =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并行处理多个 async(异步) 返回值：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [result1, result2] = await Promise.all([</span><br><span class=\"line\">        otherAsyncFunc1(),</span><br><span class=\"line\">        otherAsyncFunc2(),</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(result1, result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.all([</span><br><span class=\"line\">        otherAsyncFunc1(),</span><br><span class=\"line\">        otherAsyncFunc2(),</span><br><span class=\"line\">    ])</span><br><span class=\"line\">    .then([result1, result2] =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(result1, result2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>错误处理：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"function\">await <span class=\"title\">otherAsyncFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otherAsyncFunc()</span><br><span class=\"line\">    .<span class=\"keyword\">catch</span>(err =&gt; &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"理解-async-异步-函数\"><a href=\"#理解-async-异步-函数\" class=\"headerlink\" title=\"理解 async(异步) 函数\"></a>理解 async(异步) 函数</h1><p>解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p>\n<p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">fetchJson</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url)</span><br><span class=\"line\">    .then(request =&gt; request.text())</span><br><span class=\"line\">    .then(text =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"keyword\">catch</span>(error =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetchJson('http://example.com/some_file.json')</span><br><span class=\"line\">.then(obj =&gt; console.<span class=\"built_in\">log</span>(obj));</span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-generator-来编写异步代码\"><a href=\"#通过-generator-来编写异步代码\" class=\"headerlink\" title=\"通过 generator 来编写异步代码\"></a>通过 generator 来编写异步代码</h1><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetchJson = co.wrap(function* (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        let request = yield fetch(url);</span><br><span class=\"line\">        let text = yield request.text();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于  then() 所做的工作）。</p>\n<h1 id=\"通过-async-异步-函数来编写异步代码\"><a href=\"#通过-async-异步-函数来编写异步代码\" class=\"headerlink\" title=\"通过 async(异步) 函数来编写异步代码\"></a>通过 async(异步) 函数来编写异步代码</h1><p>async(异步) \b函数用的特定语法基本上和 co 类似：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">fetchJson</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        let request = await fetch(url);</span><br><span class=\"line\">        let text = await request.text();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JSON.parse(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(`ERROR: $&#123;error.<span class=\"built_in\">stack</span>&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在内部，异步函数写法更类似于 generators 。</p>\n<h1 id=\"以同步开始，异步处理的-async-异步-函数\"><a href=\"#以同步开始，异步处理的-async-异步-函数\" class=\"headerlink\" title=\"以同步开始，异步处理的 async(异步) \b函数\"></a>以同步开始，异步处理的 async(异步) \b函数</h1><p>以下是 async(异步)函数是如何工作的：</p>\n<ul>\n<li>1、async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。</li>\n<li>2、函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。</li>\n<li>3、返回 Promise 对象 p。</li>\n</ul>\n<p>当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和  catch() 的回调总是在当前代码完成后执行。</p>\n<p>以下是代码示例：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    console.log('asyncFunc()'); // (A)</span><br><span class=\"line\">    return 'abc';</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc().</span><br><span class=\"line\">then(x =&gt; console.<span class=\"built_in\">log</span>(`Resolved: $&#123;x&#125;`)); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">console.log('main'); // (C)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// asyncFunc()</span></span><br><span class=\"line\"><span class=\"comment\">// main</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved: abc</span></span><br></pre></td></tr></table></figure>\n<p>您可以认为是以下的执行顺序：</p>\n<ul>\n<li>1、行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。</li>\n<li>2、行C：执行继续。</li>\n<li>3、行B：Promise\b\b 完成状态通知是异步发生的。</li>\n</ul>\n<h1 id=\"返回不被包裹的-Promise-对象\"><a href=\"#返回不被包裹的-Promise-对象\" class=\"headerlink\" title=\"返回不被包裹的 Promise 对象\"></a>返回不被包裹的 Promise 对象</h1><p>Promise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise  p 的。这意味着：</p>\n<ul>\n<li>1、返回一个非 Promise 值，该值将被处理成 p 的完成状态值。</li>\n<li>2、返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。<br>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.resolve(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.then(x =&gt; console.<span class=\"built_in\">log</span>(x)) <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    return Promise.reject(new Error('Problem!'));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncFunc()</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(err =&gt; console.error(err)); <span class=\"comment\">// Error: Problem!</span></span><br></pre></td></tr></table></figure>\n<p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> anotherAsyncFunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码\b示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹  anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await anotherAsyncFunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用-await-小贴士\"><a href=\"#使用-await-小贴士\" class=\"headerlink\" title=\"使用 await 小贴士\"></a>使用 await 小贴士</h1><h2 id=\"不要忘记使用-await\"><a href=\"#不要忘记使用-await\" class=\"headerlink\" title=\"不要忘记使用 await\"></a>不要忘记使用 await</h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = otherAsyncFunc(); <span class=\"comment\">// missing `await`!</span></span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。</p>\n<p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">await <span class=\"title\">step1</span><span class=\"params\">()</span></span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。</p>\n<h2 id=\"不需要使用-await-的情况\"><a href=\"#不需要使用-await-的情况\" class=\"headerlink\" title=\"不需要使用 await 的情况\"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    const writer = openFile('someFile.txt');</span><br><span class=\"line\">    writer.write('hello'); // don’t wait</span><br><span class=\"line\">    writer.write('world'); // don’t wait</span><br><span class=\"line\">    await writer.close(); <span class=\"comment\">// wait for file to close</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p>\n<p>asyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。</p>\n<p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return\b 替换  await writer.close() ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">asyncFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    const writer = openFile('someFile.txt');</span><br><span class=\"line\">    writer.write('hello');</span><br><span class=\"line\">    writer.write('world');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> writer.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个版本各有利弊，await 版本可能稍微更容易理解。</p>\n<h2 id=\"await-是顺序执行的，Promise-all-是并行的\"><a href=\"#await-是顺序执行的，Promise-all-是并行的\" class=\"headerlink\" title=\"await 是顺序执行的，Promise.all() 是并行的\"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await asyncFunc1();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await asyncFunc2();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [result1, result2] = await Promise.all([</span><br><span class=\"line\">        asyncFunc1(),</span><br><span class=\"line\">        asyncFunc2(),</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p>\n<h1 id=\"异步函数和回调\"><a href=\"#异步函数和回调\" class=\"headerlink\" title=\"异步函数和回调\"></a>异步函数和回调</h1><p>async(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach() 。</p>\n<h1 id=\"Array-prototype-map\"><a href=\"#Array-prototype-map\" class=\"headerlink\" title=\"Array.prototype.map()\"></a>Array.prototype.map()</h1><p>我们从数组方法 map() 开始讲解。在\b下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> urls.<span class=\"built_in\">map</span>(url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 错误的语法!</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> urls.<span class=\"built_in\">map</span>(async (url) =&gt; &#123; <span class=\"comment\">// 注意这一行中的 async ;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码有两个问题：</p>\n<p>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。<br>一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待  downloadContent() 执行结束。<br>我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(async (url) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        url =&gt; httpGet(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> await Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开  Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">downloadContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promiseArray = urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        url =&gt; httpGet(url));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Promise.all(promiseArray);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Array-prototype-forEach\"><a href=\"#Array-prototype-forEach\" class=\"headerlink\" title=\"Array.prototype.forEach()\"></a>Array.prototype.forEach()</h1><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    urls.forEach(url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Wrong syntax</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，这里的代码会产生一个语法错误，因为你不能在\b通常的箭头函数内部使用 await 。</p>\n<p>\b我们换作异步箭头函数：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    urls.forEach(async url =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// Not finished here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码起作用了，但是\b会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。</p>\n<p>如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url of urls) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">logContent</span><span class=\"params\">(urls)</span> </span>&#123;</span><br><span class=\"line\">    await Promise.all(urls.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        async url =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> content = await httpGet(url);</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(content);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法\b执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p>\n<h1 id=\"使用异步函数小贴士\"><a href=\"#使用异步函数小贴士\" class=\"headerlink\" title=\"使用异步函数小贴士\"></a>使用异步函数小贴士</h1><h2 id=\"了解你的-Promises\"><a href=\"#了解你的-Promises\" class=\"headerlink\" title=\"了解你的 Promises\"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来\b实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p>\n<p>举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">httpGet</span><span class=\"params\">(url, responseType=<span class=\"string\">\"\"</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(</span><br><span class=\"line\">        function (resolve, reject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">            request.onload = function () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Success</span></span><br><span class=\"line\">                    resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Something went wrong (404 etc.)</span></span><br><span class=\"line\">                    reject(<span class=\"keyword\">new</span> Error(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            request.onerror = function () &#123;</span><br><span class=\"line\">                reject(<span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">                    'XMLHttpRequest Error: '+this.statusText));</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            request.open('GET', url);</span><br><span class=\"line\">            xhr.responseType = responseType;</span><br><span class=\"line\">            request.send();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>\bXMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者  throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。</p>\n<p>因此，异步函数的通用编码风格是：</p>\n<ul>\n<li>直接使用 Promise 对象来\b构建异步原语。</li>\n<li>用异步函数来使用这些原语。<br>扩展阅读：“Exploring ES6” 中的 “<a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">异步编程中的 Promises 对象</a>” 章节</li>\n</ul>\n<h1 id=\"立即调用异步函数表达式\"><a href=\"#立即调用异步函数表达式\" class=\"headerlink\" title=\"立即调用异步函数表达式\"></a>立即调用异步函数表达式</h1><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main() \b 并立即调用它：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main();<br>或者您可以使用立即调用异步函数表达式：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">(async function () &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>另一个选择是立即调用异步箭头函数：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">(async () =&gt; &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(await asyncFunction());</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"用异步函数进行单元测试\"><a href=\"#用异步函数进行单元测试\" class=\"headerlink\" title=\"用异步函数进行单元测试\"></a>用异步函数进行单元测试</h1><p>以下代码使用 <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import assert from 'assert';</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Bug: the following test always succeeds</span></span><br><span class=\"line\">test('Testing async code', function () &#123;</span><br><span class=\"line\">    asyncFunc1() <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    .then(result1 =&gt; &#123;</span><br><span class=\"line\">        assert.strictEqual(result1, <span class=\"string\">'a'</span>); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> asyncFunc2();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(result2 =&gt; &#123;</span><br><span class=\"line\">        assert.strictEqual(result2, <span class=\"string\">'b'</span>); <span class=\"comment\">// (C)</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p>\n<p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"keyword\">return</span> asyncFunc1() <span class=\"comment\">// (A)</span></span><br></pre></td></tr></table></figure></p>\n<p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\">import assert from 'assert';</span><br><span class=\"line\">test('Testing async code', async function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result1 = await asyncFunc1();</span><br><span class=\"line\">    assert.strictEqual(result1, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result2 = await asyncFunc2();</span><br><span class=\"line\">    assert.strictEqual(result2, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p>\n<h1 id=\"不要担心没有处理的拒绝拒态\"><a href=\"#不要担心没有处理的拒绝拒态\" class=\"headerlink\" title=\"不要担心没有处理的拒绝拒态\"></a>不要担心没有处理的拒绝拒态</h1><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下\b提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告\b：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 代码:</span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    throw new Error('Problem!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"阅读延伸\"><a href=\"#阅读延伸\" class=\"headerlink\" title=\"阅读延伸\"></a>阅读延伸</h1><ul>\n<li><a href=\"https://github.com/tc39/ecmascript-asyncawait\" target=\"_blank\" rel=\"noopener\">异步函数</a> （提出者Brian Terlson）</li>\n<li><a href=\"http://exploringjs.com/es6/ch_generators.html#sec_co-library\" target=\"_blank\" rel=\"noopener\">通过generators来简化异步计算</a>（“\bExporing ES6”中的部分章节）<br>原文地址：<a href=\"http://exploringjs.com/es2016-es2017/ch_async-functions.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2016-es2017/ch_async-functions.html</a></li>\n</ul>"},{"title":"ES6攻略(一)","date":"2018-05-27T13:33:27.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n两个很有用的原生JS函数：`map`和`reduce`。\n\n- 1、map() 方法：\n\n它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。\n\n```h\nvar data = [1,2,3];\nvar callback = function(a){\n    // 这里的a就是数组每一项的值\n    return a+1;\n}\n\nvar demo = data.map(callback);\nconsloe.log(demo)\n//[2,3,4]\n```\n在这里需要注意的是`map`里面的回调函数，参数只有一个\n\n- 2、reduce()方法\n\n这个方法先从代码例子开始\n```h\nvar data = [1,2,3];\nvar callback = function(a,b){\n    console.log('初始值=',a);\n    return a+b;\n};\nvar demo = data.reduce(callback,100);\nconsole.log(demo);\n//初始值=100\n//初始值=101\n//初始值=103\n//106\n```\nreduce它有2个参数：\n- 第一个是`callback`回调函数，主要是针对数组的操作；\n- 第二个是传入的`初始值`\n\n工作原理：\n- 1、传入一个初始值；\n- 2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；\n- 3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；\n- .....\n\n依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。\n这和`ajax`的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个`并行`，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者\n`Q模块`是用来解决回调问题，与之类似的有`jQuery`的延迟对象，ES6的`promise`对象，ES7的`async`和`await`.\n可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。\n> 爬虫的工作原理：\n\n先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。\n\n先安装一个发送请求模块`request`和Q模块：\n> `npm install request --dev`\n> `npm install q --dev`\n\n然后开始写个脚本，先用`express`搭建一个服务：\n```h\nvar express = require('express')\nvar router = express.Router();\n\n// GET home page\nrouter.get('./',function(req,res,next){\nres.render('index',{title:'Express'});\n})\n\n// 请求1\nrouter.get('/list1',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求1完成了！')\n    }, 1000);\n})\n// 请求2\nrouter.get('/list2',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求2完成了！')\n    }, 2000);\n})\n// 请求3\nrouter.get('/list3',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求3完成了！')\n    }, 3000);\n})\n\nmodule.exports = router;\n\n```\n以上为数据接口。\n\n```h\nvar Q = require('q');\nvar request = require('request');\n\nfunction createPromise(url){\n    var deferred = Q.defer(); // 创建任务\n\n    request(url, function(err,response,body){\n        console.log('requested',url);\n        if (err) {\n            deferred.reject(err); // 错误返回\n        }else{\n            deferred.resolve(body) // 成功返回\n        }\n    })\n    return deferred.promise; // 返回一个承诺\n}\n\ncreatePromise('http://localhost:3000/list1').then(function(data){\n    console.log(data);\n},function(err){\n    console.error(err);\n})\n```\n> `resolve`就是继续执行，`reject`就是拒绝，`defer`就是布置任务。\n> Q把每一个请求都会布置成一个任务，然后返回一个`promise`对象，`promise`就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从`then()`方法里面拿到需要的数据。\n\n并行请求：\n```h\nvar Q = require('q');\nvar request = require('request');\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3',\n    'http//localhost:3000/hello_110' //这是个错误的地址\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer(); //创建任务\n    request(url, function (err, response, body) {\n        console.log(\"requested \" + url);\n        if (err) {\n            deferred.reject(err); //错误返回\n        } else {\n            deferred.resolve(body); //成功返回\n        }\n\n    });\n    return deferred.promise; //返回一个承诺\n}\n\nvar promises = urls.map(function (url) {\n    return createPromise(url);\n});\n\n\nQ.allSettled(promises).then(function (results) {\n    console.log(results);\n    results.forEach(function (result) {\n        if (result.state === \"fulfilled\") {\n            console.log(result.value);\n        } else {\n            console.error(result.reason);\n        }\n    });\n});\n```\n用`map()`方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）\n\n串行请求。先来个传统写法:\n```h\nvar Q = require('q');\nvar request = require('request');\n\nrequest('http://localhost:3000/hello1' , function(err1 , response1 , body1){\n console.log(body1);\n request('http://localhost:3000/hello2',function(err2 , response2 , body2){\n    console.log(body2);\n    request('http://localhost:3000/hello3',function(err3 , response3 , body3){\n      console.log(body3);\n\n   });\n  });\n\n});\n```\n这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。\nQ是如何解决回调地狱问题的呢？\n其实也简单，就是把发请求部分单独拆出去，做成子任务即可。\n前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：\n\n```h\nvar Q = require('q');\nvar request = require('request');\n\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3',\n    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer();\n    request(url, function (err, response, body) {\n        if (err)\n            deferred.reject(err);\n        else\n            deferred.resolve(body);\n    });\n    return deferred.promise;\n}\n\n//这里是亮点~~\nurls.reduce(function (promiseObj, url) {\n    //promiseObj第一次是Q(null)，也就是空的任务\n    return promiseObj.then(function (data) {\n        if (data) {\n            console.log(data);\n        }\n        //返回promise，层级传递，直到最后一个拿到结果\n        return createPromise(url);\n    }, function (err) {\n        console.error(err);\n        return createPromise(url);\n    })\n}, Q(null));\n```\n> 比较难理解的还是reduce。我们这里再来分析一遍他：\n> 第1步：给定一个初始值Q(null)。\n> 第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。\n> 第3步：把第2步的结果`Q('http://localhost:3000/hello1')`作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。\n\n现实中我们需求一般是这样的：\n> 请求1：拿到userid，传递给请求2。\n> 请求2：根据userid，查询ssoid，传递给请求3。\n> 请求3：根据ssoid，查到最终结果。\n我们根据这种情况，再来一次：\n改造下接口：\n```h\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function (req, res, next) {\n    res.render('index', {\n        title: 'Express'\n    });\n});\n//请求1\nrouter.get('/hello1', function (req, res, next) {\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: 123\n        });\n    }, 1000);\n});\n//请求2\nrouter.get('/hello2', function (req, res, next) {\n    var param = req.query || req.params;\n    var userid = param.userid;\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: userid,\n            ssoid: 456\n        });\n    }, 2000);\n});\n//请求3\nrouter.get('/hello3', function (req, res, next) {\n    var param = req.query || req.params;\n    var userid = param.userid;\n    var ssoid = param.ssoid;\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: userid,\n            ssoid: ssoid,\n            msg: '完成啦！'\n        });\n    }, 3000);\n});\nmodule.exports = router;\n```\n其次：\n```h\nvar Q = require('q');\nvar request = require('request');\n\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3'\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer();\n    request(url, function (err, response, body) {\n        if (err)\n            deferred.reject(err);\n        else\n            deferred.resolve(body);\n    });\n    return deferred.promise;\n}\n//第一个请求的回调\nvar callback_Request1 = function (data) {\n    data = JSON.parse(data);\n    console.log(data);\n    var userid = data.userid;\n    var url = urls[1] + '?userid=' + userid;\n    return createPromise(url);\n};\n//第二个请求的回调\nvar callback_Request2 = function (data) {\n    data = JSON.parse(data);\n    console.log(data);\n    var userid = data.userid;\n    var ssoid = data.ssoid;\n    var url = urls[2] + '?userid=' + userid + '&ssoid=' + ssoid;\n    return createPromise(url);\n};\n//业务逻辑被剥离出去咯~~\ncreatePromise(urls[0]).then(function (data) {\n    console.log('第一次请求');\n    return callback_Request1(data);\n}).then(function (data) {\n    console.log('第二次请求');\n    return callback_Request2(data);\n}).then(function (data) {\n    //打印最终结果\n    console.log('第三次请求');\n    console.log(data);\n});\n```\n就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。","source":"_posts/ES6攻略-一.md","raw":"---\ntitle: ES6攻略(一)\ndate: 2018-05-27 21:33:27\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n两个很有用的原生JS函数：`map`和`reduce`。\n\n- 1、map() 方法：\n\n它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。\n\n```h\nvar data = [1,2,3];\nvar callback = function(a){\n    // 这里的a就是数组每一项的值\n    return a+1;\n}\n\nvar demo = data.map(callback);\nconsloe.log(demo)\n//[2,3,4]\n```\n在这里需要注意的是`map`里面的回调函数，参数只有一个\n\n- 2、reduce()方法\n\n这个方法先从代码例子开始\n```h\nvar data = [1,2,3];\nvar callback = function(a,b){\n    console.log('初始值=',a);\n    return a+b;\n};\nvar demo = data.reduce(callback,100);\nconsole.log(demo);\n//初始值=100\n//初始值=101\n//初始值=103\n//106\n```\nreduce它有2个参数：\n- 第一个是`callback`回调函数，主要是针对数组的操作；\n- 第二个是传入的`初始值`\n\n工作原理：\n- 1、传入一个初始值；\n- 2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；\n- 3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；\n- .....\n\n依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。\n这和`ajax`的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个`并行`，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者\n`Q模块`是用来解决回调问题，与之类似的有`jQuery`的延迟对象，ES6的`promise`对象，ES7的`async`和`await`.\n可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。\n> 爬虫的工作原理：\n\n先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。\n\n先安装一个发送请求模块`request`和Q模块：\n> `npm install request --dev`\n> `npm install q --dev`\n\n然后开始写个脚本，先用`express`搭建一个服务：\n```h\nvar express = require('express')\nvar router = express.Router();\n\n// GET home page\nrouter.get('./',function(req,res,next){\nres.render('index',{title:'Express'});\n})\n\n// 请求1\nrouter.get('/list1',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求1完成了！')\n    }, 1000);\n})\n// 请求2\nrouter.get('/list2',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求2完成了！')\n    }, 2000);\n})\n// 请求3\nrouter.get('/list3',function(req,res,next){\n    setTimeout(() => {\n        res.send('请求3完成了！')\n    }, 3000);\n})\n\nmodule.exports = router;\n\n```\n以上为数据接口。\n\n```h\nvar Q = require('q');\nvar request = require('request');\n\nfunction createPromise(url){\n    var deferred = Q.defer(); // 创建任务\n\n    request(url, function(err,response,body){\n        console.log('requested',url);\n        if (err) {\n            deferred.reject(err); // 错误返回\n        }else{\n            deferred.resolve(body) // 成功返回\n        }\n    })\n    return deferred.promise; // 返回一个承诺\n}\n\ncreatePromise('http://localhost:3000/list1').then(function(data){\n    console.log(data);\n},function(err){\n    console.error(err);\n})\n```\n> `resolve`就是继续执行，`reject`就是拒绝，`defer`就是布置任务。\n> Q把每一个请求都会布置成一个任务，然后返回一个`promise`对象，`promise`就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从`then()`方法里面拿到需要的数据。\n\n并行请求：\n```h\nvar Q = require('q');\nvar request = require('request');\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3',\n    'http//localhost:3000/hello_110' //这是个错误的地址\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer(); //创建任务\n    request(url, function (err, response, body) {\n        console.log(\"requested \" + url);\n        if (err) {\n            deferred.reject(err); //错误返回\n        } else {\n            deferred.resolve(body); //成功返回\n        }\n\n    });\n    return deferred.promise; //返回一个承诺\n}\n\nvar promises = urls.map(function (url) {\n    return createPromise(url);\n});\n\n\nQ.allSettled(promises).then(function (results) {\n    console.log(results);\n    results.forEach(function (result) {\n        if (result.state === \"fulfilled\") {\n            console.log(result.value);\n        } else {\n            console.error(result.reason);\n        }\n    });\n});\n```\n用`map()`方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）\n\n串行请求。先来个传统写法:\n```h\nvar Q = require('q');\nvar request = require('request');\n\nrequest('http://localhost:3000/hello1' , function(err1 , response1 , body1){\n console.log(body1);\n request('http://localhost:3000/hello2',function(err2 , response2 , body2){\n    console.log(body2);\n    request('http://localhost:3000/hello3',function(err3 , response3 , body3){\n      console.log(body3);\n\n   });\n  });\n\n});\n```\n这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。\nQ是如何解决回调地狱问题的呢？\n其实也简单，就是把发请求部分单独拆出去，做成子任务即可。\n前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：\n\n```h\nvar Q = require('q');\nvar request = require('request');\n\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3',\n    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer();\n    request(url, function (err, response, body) {\n        if (err)\n            deferred.reject(err);\n        else\n            deferred.resolve(body);\n    });\n    return deferred.promise;\n}\n\n//这里是亮点~~\nurls.reduce(function (promiseObj, url) {\n    //promiseObj第一次是Q(null)，也就是空的任务\n    return promiseObj.then(function (data) {\n        if (data) {\n            console.log(data);\n        }\n        //返回promise，层级传递，直到最后一个拿到结果\n        return createPromise(url);\n    }, function (err) {\n        console.error(err);\n        return createPromise(url);\n    })\n}, Q(null));\n```\n> 比较难理解的还是reduce。我们这里再来分析一遍他：\n> 第1步：给定一个初始值Q(null)。\n> 第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。\n> 第3步：把第2步的结果`Q('http://localhost:3000/hello1')`作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。\n\n现实中我们需求一般是这样的：\n> 请求1：拿到userid，传递给请求2。\n> 请求2：根据userid，查询ssoid，传递给请求3。\n> 请求3：根据ssoid，查到最终结果。\n我们根据这种情况，再来一次：\n改造下接口：\n```h\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function (req, res, next) {\n    res.render('index', {\n        title: 'Express'\n    });\n});\n//请求1\nrouter.get('/hello1', function (req, res, next) {\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: 123\n        });\n    }, 1000);\n});\n//请求2\nrouter.get('/hello2', function (req, res, next) {\n    var param = req.query || req.params;\n    var userid = param.userid;\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: userid,\n            ssoid: 456\n        });\n    }, 2000);\n});\n//请求3\nrouter.get('/hello3', function (req, res, next) {\n    var param = req.query || req.params;\n    var userid = param.userid;\n    var ssoid = param.ssoid;\n    setTimeout(function () {\n        res.json({\n            code: 200,\n            userid: userid,\n            ssoid: ssoid,\n            msg: '完成啦！'\n        });\n    }, 3000);\n});\nmodule.exports = router;\n```\n其次：\n```h\nvar Q = require('q');\nvar request = require('request');\n\nvar urls = [\n    'http://localhost:3000/hello1',\n    'http://localhost:3000/hello2',\n    'http://localhost:3000/hello3'\n];\n\nfunction createPromise(url) {\n    var deferred = Q.defer();\n    request(url, function (err, response, body) {\n        if (err)\n            deferred.reject(err);\n        else\n            deferred.resolve(body);\n    });\n    return deferred.promise;\n}\n//第一个请求的回调\nvar callback_Request1 = function (data) {\n    data = JSON.parse(data);\n    console.log(data);\n    var userid = data.userid;\n    var url = urls[1] + '?userid=' + userid;\n    return createPromise(url);\n};\n//第二个请求的回调\nvar callback_Request2 = function (data) {\n    data = JSON.parse(data);\n    console.log(data);\n    var userid = data.userid;\n    var ssoid = data.ssoid;\n    var url = urls[2] + '?userid=' + userid + '&ssoid=' + ssoid;\n    return createPromise(url);\n};\n//业务逻辑被剥离出去咯~~\ncreatePromise(urls[0]).then(function (data) {\n    console.log('第一次请求');\n    return callback_Request1(data);\n}).then(function (data) {\n    console.log('第二次请求');\n    return callback_Request2(data);\n}).then(function (data) {\n    //打印最终结果\n    console.log('第三次请求');\n    console.log(data);\n});\n```\n就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。","slug":"ES6攻略-一","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctncv0002kt892kpj20if","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p>两个很有用的原生JS函数：<code>map</code>和<code>reduce</code>。</p>\n<ul>\n<li>1、map() 方法：</li>\n</ul>\n<p>它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">var callback = function(a)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的a就是数组每一项的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var demo = data.<span class=\"built_in\">map</span>(callback);</span><br><span class=\"line\">consloe.<span class=\"built_in\">log</span>(demo)</span><br><span class=\"line\"><span class=\"comment\">//[2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>在这里需要注意的是<code>map</code>里面的回调函数，参数只有一个</p>\n<ul>\n<li>2、reduce()方法</li>\n</ul>\n<p>这个方法先从代码例子开始<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">var callback = function(a,b)&#123;</span><br><span class=\"line\">    console.log('初始值=',a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var demo = data.reduce(callback,<span class=\"number\">100</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(demo);</span><br><span class=\"line\"><span class=\"comment\">//初始值=100</span></span><br><span class=\"line\"><span class=\"comment\">//初始值=101</span></span><br><span class=\"line\"><span class=\"comment\">//初始值=103</span></span><br><span class=\"line\"><span class=\"comment\">//106</span></span><br></pre></td></tr></table></figure></p>\n<p>reduce它有2个参数：</p>\n<ul>\n<li>第一个是<code>callback</code>回调函数，主要是针对数组的操作；</li>\n<li>第二个是传入的<code>初始值</code></li>\n</ul>\n<p>工作原理：</p>\n<ul>\n<li>1、传入一个初始值；</li>\n<li>2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；</li>\n<li>3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；</li>\n<li>…..</li>\n</ul>\n<p>依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。<br>这和<code>ajax</code>的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个<code>并行</code>，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者<br><code>Q模块</code>是用来解决回调问题，与之类似的有<code>jQuery</code>的延迟对象，ES6的<code>promise</code>对象，ES7的<code>async</code>和<code>await</code>.<br>可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。</p>\n<blockquote>\n<p>爬虫的工作原理：</p>\n</blockquote>\n<p>先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。</p>\n<p>先安装一个发送请求模块<code>request</code>和Q模块：</p>\n<blockquote>\n<p><code>npm install request --dev</code><br><code>npm install q --dev</code></p>\n</blockquote>\n<p>然后开始写个脚本，先用<code>express</code>搭建一个服务：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express')</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET home page</span></span><br><span class=\"line\">router.get('./',function(req,res,next)&#123;</span><br><span class=\"line\">res.render('index',&#123;title:'Express'&#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求1</span></span><br><span class=\"line\">router.get('/list1',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求1完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 请求2</span></span><br><span class=\"line\">router.get('/list2',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求2完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 请求3</span></span><br><span class=\"line\">router.get('/list3',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求3完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>以上为数据接口。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer(); <span class=\"comment\">// 创建任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">    request(url, function(err,response,body)&#123;</span><br><span class=\"line\">        console.log('requested',url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            deferred.reject(err); <span class=\"comment\">// 错误返回</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            deferred.resolve(body) <span class=\"comment\">// 成功返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise; <span class=\"comment\">// 返回一个承诺</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createPromise('http://localhost:3000/list1').then(function(data)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;,function(err)&#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>resolve</code>就是继续执行，<code>reject</code>就是拒绝，<code>defer</code>就是布置任务。<br>Q把每一个请求都会布置成一个任务，然后返回一个<code>promise</code>对象，<code>promise</code>就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从<code>then()</code>方法里面拿到需要的数据。</p>\n</blockquote>\n<p>并行请求：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3',</span><br><span class=\"line\">    'http//localhost:3000/hello_110' //这是个错误的地址</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer(); <span class=\"comment\">//创建任务</span></span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(<span class=\"string\">\"requested \"</span> + url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            deferred.reject(err); <span class=\"comment\">//错误返回</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deferred.resolve(body); <span class=\"comment\">//成功返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise; <span class=\"comment\">//返回一个承诺</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var promises = urls.<span class=\"built_in\">map</span>(function (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Q.allSettled(promises).then(function (results) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(results);</span><br><span class=\"line\">    results.forEach(function (result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.state === <span class=\"string\">\"fulfilled\"</span>) &#123;</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(result.value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            console.error(result.reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>用<code>map()</code>方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）</p>\n<p>串行请求。先来个传统写法:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">request('http://localhost:3000/hello1' , function(err1 , response1 , body1)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(body1);</span><br><span class=\"line\"> request('http://localhost:3000/hello2',function(err2 , response2 , body2)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(body2);</span><br><span class=\"line\">    request('http://localhost:3000/hello3',function(err3 , response3 , body3)&#123;</span><br><span class=\"line\">      console.<span class=\"built_in\">log</span>(body3);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。<br>Q是如何解决回调地狱问题的呢？<br>其实也简单，就是把发请求部分单独拆出去，做成子任务即可。<br>前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3',</span><br><span class=\"line\">    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer();</span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">            deferred.reject(err);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            deferred.resolve(body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是亮点~~</span></span><br><span class=\"line\">urls.reduce(function (promiseObj, url) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//promiseObj第一次是Q(null)，也就是空的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promiseObj.then(function (data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//返回promise，层级传递，直到最后一个拿到结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">    &#125;, function (err) &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, Q(null));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>比较难理解的还是reduce。我们这里再来分析一遍他：<br>第1步：给定一个初始值Q(null)。<br>第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。<br>第3步：把第2步的结果<code>Q(&#39;http://localhost:3000/hello1&#39;)</code>作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。</p>\n</blockquote>\n<p>现实中我们需求一般是这样的：</p>\n<blockquote>\n<p>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。<br>我们根据这种情况，再来一次：<br>改造下接口：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function (req, res, next) &#123;</span><br><span class=\"line\">    res.render('index', &#123;</span><br><span class=\"line\">        title: 'Express'</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求1</span></span><br><span class=\"line\">router.get('/hello1', function (req, res, next) &#123;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: <span class=\"number\">123</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求2</span></span><br><span class=\"line\">router.get('/hello2', function (req, res, next) &#123;</span><br><span class=\"line\">    var param = req.query || req.params;</span><br><span class=\"line\">    var userid = param.userid;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: userid,</span><br><span class=\"line\">            ssoid: <span class=\"number\">456</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求3</span></span><br><span class=\"line\">router.get('/hello3', function (req, res, next) &#123;</span><br><span class=\"line\">    var param = req.query || req.params;</span><br><span class=\"line\">    var userid = param.userid;</span><br><span class=\"line\">    var ssoid = param.ssoid;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: userid,</span><br><span class=\"line\">            ssoid: ssoid,</span><br><span class=\"line\">            msg: '完成啦！'</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其次：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer();</span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">            deferred.reject(err);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            deferred.resolve(body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第一个请求的回调</span></span><br><span class=\"line\">var callback_Request1 = function (data) &#123;</span><br><span class=\"line\">    data = JSON.parse(data);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">    var userid = data.userid;</span><br><span class=\"line\">    var url = urls[1] + '?userid=' + userid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//第二个请求的回调</span></span><br><span class=\"line\">var callback_Request2 = function (data) &#123;</span><br><span class=\"line\">    data = JSON.parse(data);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">    var userid = data.userid;</span><br><span class=\"line\">    var ssoid = data.ssoid;</span><br><span class=\"line\">    var url = urls[2] + '?userid=' + userid + '&amp;ssoid=' + ssoid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//业务逻辑被剥离出去咯~~</span></span><br><span class=\"line\">createPromise(urls[<span class=\"number\">0</span>]).then(function (data) &#123;</span><br><span class=\"line\">    console.log('第一次请求');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback_Request1(data);</span><br><span class=\"line\">&#125;).then(function (data) &#123;</span><br><span class=\"line\">    console.log('第二次请求');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback_Request2(data);</span><br><span class=\"line\">&#125;).then(function (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">    console.log('第三次请求');</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。</p>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是es6的Q模块。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p>两个很有用的原生JS函数：<code>map</code>和<code>reduce</code>。</p>\n<ul>\n<li>1、map() 方法：</li>\n</ul>\n<p>它返回一个由原数组中的每个元素调用一个指定方法之后的返回值组成新的数组。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">var callback = function(a)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的a就是数组每一项的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var demo = data.<span class=\"built_in\">map</span>(callback);</span><br><span class=\"line\">consloe.<span class=\"built_in\">log</span>(demo)</span><br><span class=\"line\"><span class=\"comment\">//[2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>在这里需要注意的是<code>map</code>里面的回调函数，参数只有一个</p>\n<ul>\n<li>2、reduce()方法</li>\n</ul>\n<p>这个方法先从代码例子开始<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">var callback = function(a,b)&#123;</span><br><span class=\"line\">    console.log('初始值=',a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var demo = data.reduce(callback,<span class=\"number\">100</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(demo);</span><br><span class=\"line\"><span class=\"comment\">//初始值=100</span></span><br><span class=\"line\"><span class=\"comment\">//初始值=101</span></span><br><span class=\"line\"><span class=\"comment\">//初始值=103</span></span><br><span class=\"line\"><span class=\"comment\">//106</span></span><br></pre></td></tr></table></figure></p>\n<p>reduce它有2个参数：</p>\n<ul>\n<li>第一个是<code>callback</code>回调函数，主要是针对数组的操作；</li>\n<li>第二个是传入的<code>初始值</code></li>\n</ul>\n<p>工作原理：</p>\n<ul>\n<li>1、传入一个初始值；</li>\n<li>2、第一次传入的结果（初始值）作为回调函数的第一个参数，数组的第一个值则作为第二个参数传入，执行完回调函数之后，返回一个结果；</li>\n<li>3、再把第二步的结果作为这一次第一个参数的入参，数组的第二个数值作为第二个参数传入，执行回调函数，返回一个结果；</li>\n<li>…..</li>\n</ul>\n<p>依次类推，遍历完数组则停止，也就是一层一层的回调，最终得到结果。<br>这和<code>ajax</code>的串行请求很类似，就是请求1，请求2，请求3等，是按照顺序排队执行，他们彼此有所依赖；同时还有一个<code>并行</code>，就是请求1，请求2，请求3等同时执行请求，他们彼此互不影响。并行请求时间取最大者<br><code>Q模块</code>是用来解决回调问题，与之类似的有<code>jQuery</code>的延迟对象，ES6的<code>promise</code>对象，ES7的<code>async</code>和<code>await</code>.<br>可以把Q理解为node版本的延迟对象，那么什么情况下要在Node下发送请求，其实爬虫程序就是这样的逻辑。</p>\n<blockquote>\n<p>爬虫的工作原理：</p>\n</blockquote>\n<p>先请求首页的连接，然后在首页的基础下对各个超链接不断的爬取，直到遍历完所有的页面。</p>\n<p>先安装一个发送请求模块<code>request</code>和Q模块：</p>\n<blockquote>\n<p><code>npm install request --dev</code><br><code>npm install q --dev</code></p>\n</blockquote>\n<p>然后开始写个脚本，先用<code>express</code>搭建一个服务：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express')</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET home page</span></span><br><span class=\"line\">router.get('./',function(req,res,next)&#123;</span><br><span class=\"line\">res.render('index',&#123;title:'Express'&#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求1</span></span><br><span class=\"line\">router.get('/list1',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求1完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 请求2</span></span><br><span class=\"line\">router.get('/list2',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求2完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 请求3</span></span><br><span class=\"line\">router.get('/list3',function(req,res,next)&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        res.send('请求3完成了！')</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>以上为数据接口。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer(); <span class=\"comment\">// 创建任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">    request(url, function(err,response,body)&#123;</span><br><span class=\"line\">        console.log('requested',url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            deferred.reject(err); <span class=\"comment\">// 错误返回</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            deferred.resolve(body) <span class=\"comment\">// 成功返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise; <span class=\"comment\">// 返回一个承诺</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createPromise('http://localhost:3000/list1').then(function(data)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;,function(err)&#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>resolve</code>就是继续执行，<code>reject</code>就是拒绝，<code>defer</code>就是布置任务。<br>Q把每一个请求都会布置成一个任务，然后返回一个<code>promise</code>对象，<code>promise</code>就是继承的意思，也就是这个任务就是一个承诺，承诺任务成功之后返回成功的结果，而失败就返回一个失败的结果，然后就可以从<code>then()</code>方法里面拿到需要的数据。</p>\n</blockquote>\n<p>并行请求：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3',</span><br><span class=\"line\">    'http//localhost:3000/hello_110' //这是个错误的地址</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer(); <span class=\"comment\">//创建任务</span></span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(<span class=\"string\">\"requested \"</span> + url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            deferred.reject(err); <span class=\"comment\">//错误返回</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deferred.resolve(body); <span class=\"comment\">//成功返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise; <span class=\"comment\">//返回一个承诺</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var promises = urls.<span class=\"built_in\">map</span>(function (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Q.allSettled(promises).then(function (results) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(results);</span><br><span class=\"line\">    results.forEach(function (result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.state === <span class=\"string\">\"fulfilled\"</span>) &#123;</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(result.value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            console.error(result.reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>用<code>map()</code>方法，在回调函数中批量创建任务，然后等待结果都执行完，一次性的拿到所有结果数据（以数组的形式返回）</p>\n<p>串行请求。先来个传统写法:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">request('http://localhost:3000/hello1' , function(err1 , response1 , body1)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(body1);</span><br><span class=\"line\"> request('http://localhost:3000/hello2',function(err2 , response2 , body2)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(body2);</span><br><span class=\"line\">    request('http://localhost:3000/hello3',function(err3 , response3 , body3)&#123;</span><br><span class=\"line\">      console.<span class=\"built_in\">log</span>(body3);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这种写法也叫回调地狱，实在太难维护了，代码一层摞一层，如果要改个东西那简直是要了命了，所以地狱二字用的灰常贴切。<br>Q是如何解决回调地狱问题的呢？<br>其实也简单，就是把发请求部分单独拆出去，做成子任务即可。<br>前面的reduce就是这样，在有一些场景下（比如微信api），我们可以结合这个函数写出漂亮的代码：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3',</span><br><span class=\"line\">    'http//localhost:3000/hello_110' //瞪大眼睛瞅好咯，这是个错误的地址</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer();</span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">            deferred.reject(err);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            deferred.resolve(body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是亮点~~</span></span><br><span class=\"line\">urls.reduce(function (promiseObj, url) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//promiseObj第一次是Q(null)，也就是空的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promiseObj.then(function (data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//返回promise，层级传递，直到最后一个拿到结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">    &#125;, function (err) &#123;</span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, Q(null));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>比较难理解的还是reduce。我们这里再来分析一遍他：<br>第1步：给定一个初始值Q(null)。<br>第2步：把上次的结果Q(null)作为回调的第一个参数，数组的第1个url作为第二个参数，执行回调函数，拿到上次的结果，然后返回一个promise对象（因为我们这里拿到的是null，所以在if条件判断时没有打印出来）。<br>第3步：把第2步的结果<code>Q(&#39;http://localhost:3000/hello1&#39;)</code>作为回调的第一个参数，数组的第2个url作为第二个参数，执行回调函数，这时打印的data就是hello1的结果，然后再次返回一个promise对象。以此类推，最终走到最后一个url，拿完所有的数据。</p>\n</blockquote>\n<p>现实中我们需求一般是这样的：</p>\n<blockquote>\n<p>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。<br>我们根据这种情况，再来一次：<br>改造下接口：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function (req, res, next) &#123;</span><br><span class=\"line\">    res.render('index', &#123;</span><br><span class=\"line\">        title: 'Express'</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求1</span></span><br><span class=\"line\">router.get('/hello1', function (req, res, next) &#123;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: <span class=\"number\">123</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求2</span></span><br><span class=\"line\">router.get('/hello2', function (req, res, next) &#123;</span><br><span class=\"line\">    var param = req.query || req.params;</span><br><span class=\"line\">    var userid = param.userid;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: userid,</span><br><span class=\"line\">            ssoid: <span class=\"number\">456</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//请求3</span></span><br><span class=\"line\">router.get('/hello3', function (req, res, next) &#123;</span><br><span class=\"line\">    var param = req.query || req.params;</span><br><span class=\"line\">    var userid = param.userid;</span><br><span class=\"line\">    var ssoid = param.ssoid;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            userid: userid,</span><br><span class=\"line\">            ssoid: ssoid,</span><br><span class=\"line\">            msg: '完成啦！'</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其次：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Q = require(<span class=\"string\">'q'</span>);</span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">    'http://localhost:3000/hello1',</span><br><span class=\"line\">    'http://localhost:3000/hello2',</span><br><span class=\"line\">    'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">    var deferred = Q.defer();</span><br><span class=\"line\">    request(url, function (err, response, body) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">            deferred.reject(err);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            deferred.resolve(body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deferred.promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第一个请求的回调</span></span><br><span class=\"line\">var callback_Request1 = function (data) &#123;</span><br><span class=\"line\">    data = JSON.parse(data);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">    var userid = data.userid;</span><br><span class=\"line\">    var url = urls[1] + '?userid=' + userid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//第二个请求的回调</span></span><br><span class=\"line\">var callback_Request2 = function (data) &#123;</span><br><span class=\"line\">    data = JSON.parse(data);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">    var userid = data.userid;</span><br><span class=\"line\">    var ssoid = data.ssoid;</span><br><span class=\"line\">    var url = urls[2] + '?userid=' + userid + '&amp;ssoid=' + ssoid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//业务逻辑被剥离出去咯~~</span></span><br><span class=\"line\">createPromise(urls[<span class=\"number\">0</span>]).then(function (data) &#123;</span><br><span class=\"line\">    console.log('第一次请求');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback_Request1(data);</span><br><span class=\"line\">&#125;).then(function (data) &#123;</span><br><span class=\"line\">    console.log('第二次请求');</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback_Request2(data);</span><br><span class=\"line\">&#125;).then(function (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">    console.log('第三次请求');</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>就可以把再怎么复杂的逻辑都可以单独封装到一个回调函数里面，整体代码干干净净。</p>"},{"title":"ES6攻略(二)","date":"2018-05-28T15:36:57.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n`回调`使我们时常需要面对的问题，现在`node`已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于`babel`去编译。\n\n关于es6的pormise他就是一个对象，看下面：\n\n```h\n<!-- 对比一下他们的差异 -->\n\n\n//布置一项任务\nvar promise = new Promise(function(resolve, reject) {\n// ... some code\n//resolve和reject是对象提供的两个回调函数\n if(/* 异步操作成功 */){\n   resolve(value);\n  } \n  else{\n   reject(error);\n  }\n});\n//执行任务\npromise.then(function(data) {\n// success\n console.log(data);\n}).catch(function(err){\n console.log(err);\n});\n```\n从中可以看出，他和`Q`模块有点类似，比如：\n`var deferred = Q.defer()`\n\n```h\nvar request = require('request');\n//回调函数\nvar callback = function(resolve, reject){\n var url = 'http://localhost:3000/hello1';\n request(url , function(err , response , body){\n  if(err){\n    reject(err);//错误返回\n  }else{\n    resolve(body);//成功返回\n  }\n });\n};\n//布置一项任务\nvar promise = new Promise(callback);\n//执行任务\npromise.then(function(data){\n//正确响应\n console.log(data);\n}).catch(function(err){\n//捕获错误信息\n console.log('error info:',err);\n});\n```\n![结果](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n将url地址http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：\n\n![结果](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n再一次修改一下：\n\n```h\n\nvar request = require('request');\n\nvar urls = [\n'http://localhost:3000/hello1',\n'http://localhost:3000/hello2',\n'http://localhost:3000/hello3'\n];\n//这里需要改写一下~~\nfunction createPromise(url){\n//回调函数\n var callback = function(resolve, reject){\n\n request(url , function(err , response , body){\n\n  if(err){\n   reject(err);//错误返回\n  }else{\n   resolve(body);//成功返回\n  }\n\n });\n };\n//布置任务\n var promise = new Promise(callback);\n//返回promise承诺\n return promise;\n}\n//第一个请求的回调\nvar callback_Request1 = function(data){\ndata = JSON.parse(data);\nconsole.log(data);\nvar userid = data.userid;\nvar url = urls[1]+'?userid='+userid;\nreturn createPromise(url);\n};\n//第二个请求的回调\nvar callback_Request2 = function(data){\ndata = JSON.parse(data);\nconsole.log(data);\nvar userid = data.userid;\nvar ssoid = data.ssoid;\nvar url = urls[2]+'?userid='+userid+'&ssoid='+ssoid;\nreturn createPromise(url);\n};\n//业务逻辑被剥离出去咯~~\ncreatePromise(urls[0]).then(function(data){\nconsole.log('第一次请求');\nreturn callback_Request1(data);\n}).then(function(data){\nconsole.log('第二次请求');\nreturn callback_Request2(data);\n}).then(function(data){\n//打印最终结果\nconsole.log('第三次请求');\nconsole.log(data);\n});\n```\n\n![结果：](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n","source":"_posts/ES6攻略-二.md","raw":"---\ntitle: ES6攻略(二)\ndate: 2018-05-28 23:36:57\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n`回调`使我们时常需要面对的问题，现在`node`已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于`babel`去编译。\n\n关于es6的pormise他就是一个对象，看下面：\n\n```h\n<!-- 对比一下他们的差异 -->\n\n\n//布置一项任务\nvar promise = new Promise(function(resolve, reject) {\n// ... some code\n//resolve和reject是对象提供的两个回调函数\n if(/* 异步操作成功 */){\n   resolve(value);\n  } \n  else{\n   reject(error);\n  }\n});\n//执行任务\npromise.then(function(data) {\n// success\n console.log(data);\n}).catch(function(err){\n console.log(err);\n});\n```\n从中可以看出，他和`Q`模块有点类似，比如：\n`var deferred = Q.defer()`\n\n```h\nvar request = require('request');\n//回调函数\nvar callback = function(resolve, reject){\n var url = 'http://localhost:3000/hello1';\n request(url , function(err , response , body){\n  if(err){\n    reject(err);//错误返回\n  }else{\n    resolve(body);//成功返回\n  }\n });\n};\n//布置一项任务\nvar promise = new Promise(callback);\n//执行任务\npromise.then(function(data){\n//正确响应\n console.log(data);\n}).catch(function(err){\n//捕获错误信息\n console.log('error info:',err);\n});\n```\n![结果](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n将url地址http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：\n\n![结果](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n再一次修改一下：\n\n```h\n\nvar request = require('request');\n\nvar urls = [\n'http://localhost:3000/hello1',\n'http://localhost:3000/hello2',\n'http://localhost:3000/hello3'\n];\n//这里需要改写一下~~\nfunction createPromise(url){\n//回调函数\n var callback = function(resolve, reject){\n\n request(url , function(err , response , body){\n\n  if(err){\n   reject(err);//错误返回\n  }else{\n   resolve(body);//成功返回\n  }\n\n });\n };\n//布置任务\n var promise = new Promise(callback);\n//返回promise承诺\n return promise;\n}\n//第一个请求的回调\nvar callback_Request1 = function(data){\ndata = JSON.parse(data);\nconsole.log(data);\nvar userid = data.userid;\nvar url = urls[1]+'?userid='+userid;\nreturn createPromise(url);\n};\n//第二个请求的回调\nvar callback_Request2 = function(data){\ndata = JSON.parse(data);\nconsole.log(data);\nvar userid = data.userid;\nvar ssoid = data.ssoid;\nvar url = urls[2]+'?userid='+userid+'&ssoid='+ssoid;\nreturn createPromise(url);\n};\n//业务逻辑被剥离出去咯~~\ncreatePromise(urls[0]).then(function(data){\nconsole.log('第一次请求');\nreturn callback_Request1(data);\n}).then(function(data){\nconsole.log('第二次请求');\nreturn callback_Request2(data);\n}).then(function(data){\n//打印最终结果\nconsole.log('第三次请求');\nconsole.log(data);\n});\n```\n\n![结果：](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n","slug":"ES6攻略-二","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd00005kt89wmgbwhzc","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p><code>回调</code>使我们时常需要面对的问题，现在<code>node</code>已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于<code>babel</code>去编译。</p>\n<p>关于es6的pormise他就是一个对象，看下面：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 对比一下他们的差异 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//布置一项任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ... some code</span></span><br><span class=\"line\"><span class=\"comment\">//resolve和reject是对象提供的两个回调函数</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">   resolve(value);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//执行任务</span></span><br><span class=\"line\">promise.then(function(data) &#123;</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从中可以看出，他和<code>Q</code>模块有点类似，比如：<br><code>var deferred = Q.defer()</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = require('request');</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\">var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"> var url = 'http://localhost:3000/hello1';</span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置一项任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//执行任务</span></span><br><span class=\"line\">promise.then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//正确响应</span></span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获错误信息</span></span><br><span class=\"line\"> console.log('error info:',err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果\"></p>\n<p>将url地址<a href=\"http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：</a></p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果\"></p>\n<p>再一次修改一下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">'http://localhost:3000/hello1',</span><br><span class=\"line\">'http://localhost:3000/hello2',</span><br><span class=\"line\">'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//这里需要改写一下~~</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\"> var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置任务</span></span><br><span class=\"line\"> var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//返回promise承诺</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第一个请求的回调</span></span><br><span class=\"line\">var callback_Request1 = function(data)&#123;</span><br><span class=\"line\">data = JSON.parse(data);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">var userid = data.userid;</span><br><span class=\"line\">var url = urls[1]+'?userid='+userid;</span><br><span class=\"line\"><span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//第二个请求的回调</span></span><br><span class=\"line\">var callback_Request2 = function(data)&#123;</span><br><span class=\"line\">data = JSON.parse(data);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">var userid = data.userid;</span><br><span class=\"line\">var ssoid = data.ssoid;</span><br><span class=\"line\">var url = urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid;</span><br><span class=\"line\"><span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//业务逻辑被剥离出去咯~~</span></span><br><span class=\"line\">createPromise(urls[<span class=\"number\">0</span>]).then(function(data)&#123;</span><br><span class=\"line\">console.log('第一次请求');</span><br><span class=\"line\"><span class=\"keyword\">return</span> callback_Request1(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">console.log('第二次请求');</span><br><span class=\"line\"><span class=\"keyword\">return</span> callback_Request2(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">console.log('第三次请求');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于promise对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p><code>回调</code>使我们时常需要面对的问题，现在<code>node</code>已经很全面的支持了es6和es7,在Node环境下就可以直接运行调试，不再依赖于<code>babel</code>去编译。</p>\n<p>关于es6的pormise他就是一个对象，看下面：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 对比一下他们的差异 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//布置一项任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ... some code</span></span><br><span class=\"line\"><span class=\"comment\">//resolve和reject是对象提供的两个回调函数</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">   resolve(value);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//执行任务</span></span><br><span class=\"line\">promise.then(function(data) &#123;</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从中可以看出，他和<code>Q</code>模块有点类似，比如：<br><code>var deferred = Q.defer()</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = require('request');</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\">var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"> var url = 'http://localhost:3000/hello1';</span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置一项任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//执行任务</span></span><br><span class=\"line\">promise.then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//正确响应</span></span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获错误信息</span></span><br><span class=\"line\"> console.log('error info:',err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VoxJJcJPvue0o3SdaAqnj9pDKzFPH7iaGAf0rWBicGrQaYibm6emNI2lA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果\"></p>\n<p>将url地址<a href=\"http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/hello1,故意改错成：http//localhost:3000/hello1，然后再测试一下：</a></p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8VTiamYTBttHLZhTzcWxMErJIzSzwVzJ9DFtfic7TibPX94NZZLjupFFbQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果\"></p>\n<p>再一次修改一下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var request = require('request');</span><br><span class=\"line\"></span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">'http://localhost:3000/hello1',</span><br><span class=\"line\">'http://localhost:3000/hello2',</span><br><span class=\"line\">'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//这里需要改写一下~~</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\"> var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置任务</span></span><br><span class=\"line\"> var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//返回promise承诺</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第一个请求的回调</span></span><br><span class=\"line\">var callback_Request1 = function(data)&#123;</span><br><span class=\"line\">data = JSON.parse(data);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">var userid = data.userid;</span><br><span class=\"line\">var url = urls[1]+'?userid='+userid;</span><br><span class=\"line\"><span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//第二个请求的回调</span></span><br><span class=\"line\">var callback_Request2 = function(data)&#123;</span><br><span class=\"line\">data = JSON.parse(data);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">var userid = data.userid;</span><br><span class=\"line\">var ssoid = data.ssoid;</span><br><span class=\"line\">var url = urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid;</span><br><span class=\"line\"><span class=\"keyword\">return</span> createPromise(url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//业务逻辑被剥离出去咯~~</span></span><br><span class=\"line\">createPromise(urls[<span class=\"number\">0</span>]).then(function(data)&#123;</span><br><span class=\"line\">console.log('第一次请求');</span><br><span class=\"line\"><span class=\"keyword\">return</span> callback_Request1(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">console.log('第二次请求');</span><br><span class=\"line\"><span class=\"keyword\">return</span> callback_Request2(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">console.log('第三次请求');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8byeTYa8DOqXKaf3fSHzdvRFbsQXqZicYOXn4tLticA8WjejA993FBqTA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>"},{"title":"ES6攻略(三)","date":"2018-05-28T15:54:45.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n\n`es6`的`promise`写法还是不够优雅，因为后面会跟很多`then()`。应该说，`async/await`是目前解决回调问题最好的方案了。\n\n\n> a:`async `函数是什么？\n> b:一句话，它就是 `Generator` 函数的语法糖。\n> a:而`Generator`又是神马？\n> b:是`es6`的一个语法。\n> a:这个语法干嘛的？\n> b:不用管它，只需要把async搞明白。\n\n要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是`10.*`，稳定版出到`8.*`，所以安装好就可以使用了。\n\n使用`async/await`的目的就是去除掉`Promise`后面的`then()`,在并行下也没有`then()`的，主要是串行，就是互相依靠的请求方式。\n- 假设有三个请求：\n  请求1：拿到userid，传递给请求2。\n  请求2：根据userid，查询ssoid，传递给请求3。\n  请求3：根据ssoid，查到最终结果。\n\n那么，如果可以这么写就好了：\n\n```h\nvar userid = getRequest1();\nvar ssoid = getRequest2(userid);\nvar res = getRequest3(userid,ssoid);\n//打印最终结果\nres.then(function(data){console.log(data);});\n\n```\n把之前es6的写法改一下：\n\n```h\nvar request = require('request');\nvar urls = [\n'http://localhost:3000/hello1',\n'http://localhost:3000/hello2',\n'http://localhost:3000/hello3'\n];\n//创建任务函数不变\nfunction createPromise(url){\n//回调函数\n var callback = function(resolve, reject){\n\n request(url , function(err , response , body){\n\n  if(err){\n   reject(err);//错误返回\n  }else{\n   resolve(body);//成功返回\n  }\n\n });\n};\n//布置任务\nvar promise = new Promise(callback);\n//返回promise承诺\n return promise;\n}\n//声明async函数，返回的一定是promise对象\nasync function doIt(){\n var data_userid = await createPromise(urls[0]);//第一个请求任务\n data_userid = JSON.parse(data_userid);//解析成对象\n var userid = data_userid.userid;//获取userid\n var data_ssoid = await createPromise(urls[1]+\"?userid=\"+userid);//第二个请求任务\n data_ssoid = JSON.parse(data_ssoid);//解析成对象\n var ssoid = data_ssoid.ssoid;//获取ssoid\n var result = await createPromise(urls[2]+'?userid='+userid+'&ssoid='+ssoid);//第三个请求任务\n return result;//返回promise对象\n}\n//最终执行\ndoIt().then(function(data){\n//打印最终结果\nconsole.log(data);\n}).catch(function(err){\n//捕获异常\nconsole.log(err);\n});\n```\n![结果：](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n> 注意：\n``` h\n1.async需要放在函数声明前，表示这个函数返回的一定是promise对象。\n2.await后面也必须是promise对象，表示这个任务是需要等待的。\n3.最后用then()获取所有接口的信息，catch()捕获所有异常。\n4.这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！\n\n这样，简单整洁，只留一个then和catch。\n```\n","source":"_posts/ES6攻略-三.md","raw":"---\ntitle: ES6攻略(三)\ndate: 2018-05-28 23:54:45\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# ES6\n\n`es6`的`promise`写法还是不够优雅，因为后面会跟很多`then()`。应该说，`async/await`是目前解决回调问题最好的方案了。\n\n\n> a:`async `函数是什么？\n> b:一句话，它就是 `Generator` 函数的语法糖。\n> a:而`Generator`又是神马？\n> b:是`es6`的一个语法。\n> a:这个语法干嘛的？\n> b:不用管它，只需要把async搞明白。\n\n要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是`10.*`，稳定版出到`8.*`，所以安装好就可以使用了。\n\n使用`async/await`的目的就是去除掉`Promise`后面的`then()`,在并行下也没有`then()`的，主要是串行，就是互相依靠的请求方式。\n- 假设有三个请求：\n  请求1：拿到userid，传递给请求2。\n  请求2：根据userid，查询ssoid，传递给请求3。\n  请求3：根据ssoid，查到最终结果。\n\n那么，如果可以这么写就好了：\n\n```h\nvar userid = getRequest1();\nvar ssoid = getRequest2(userid);\nvar res = getRequest3(userid,ssoid);\n//打印最终结果\nres.then(function(data){console.log(data);});\n\n```\n把之前es6的写法改一下：\n\n```h\nvar request = require('request');\nvar urls = [\n'http://localhost:3000/hello1',\n'http://localhost:3000/hello2',\n'http://localhost:3000/hello3'\n];\n//创建任务函数不变\nfunction createPromise(url){\n//回调函数\n var callback = function(resolve, reject){\n\n request(url , function(err , response , body){\n\n  if(err){\n   reject(err);//错误返回\n  }else{\n   resolve(body);//成功返回\n  }\n\n });\n};\n//布置任务\nvar promise = new Promise(callback);\n//返回promise承诺\n return promise;\n}\n//声明async函数，返回的一定是promise对象\nasync function doIt(){\n var data_userid = await createPromise(urls[0]);//第一个请求任务\n data_userid = JSON.parse(data_userid);//解析成对象\n var userid = data_userid.userid;//获取userid\n var data_ssoid = await createPromise(urls[1]+\"?userid=\"+userid);//第二个请求任务\n data_ssoid = JSON.parse(data_ssoid);//解析成对象\n var ssoid = data_ssoid.ssoid;//获取ssoid\n var result = await createPromise(urls[2]+'?userid='+userid+'&ssoid='+ssoid);//第三个请求任务\n return result;//返回promise对象\n}\n//最终执行\ndoIt().then(function(data){\n//打印最终结果\nconsole.log(data);\n}).catch(function(err){\n//捕获异常\nconsole.log(err);\n});\n```\n![结果：](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n> 注意：\n``` h\n1.async需要放在函数声明前，表示这个函数返回的一定是promise对象。\n2.await后面也必须是promise对象，表示这个任务是需要等待的。\n3.最后用then()获取所有接口的信息，catch()捕获所有异常。\n4.这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！\n\n这样，简单整洁，只留一个then和catch。\n```\n","slug":"ES6攻略-三","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd10006kt896it1x44i","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p><code>es6</code>的<code>promise</code>写法还是不够优雅，因为后面会跟很多<code>then()</code>。应该说，<code>async/await</code>是目前解决回调问题最好的方案了。</p>\n<blockquote>\n<p>a:<code>async</code>函数是什么？<br>b:一句话，它就是 <code>Generator</code> 函数的语法糖。<br>a:而<code>Generator</code>又是神马？<br>b:是<code>es6</code>的一个语法。<br>a:这个语法干嘛的？<br>b:不用管它，只需要把async搞明白。</p>\n</blockquote>\n<p>要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是<code>10.*</code>，稳定版出到<code>8.*</code>，所以安装好就可以使用了。</p>\n<p>使用<code>async/await</code>的目的就是去除掉<code>Promise</code>后面的<code>then()</code>,在并行下也没有<code>then()</code>的，主要是串行，就是互相依靠的请求方式。</p>\n<ul>\n<li>假设有三个请求：<br>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。</li>\n</ul>\n<p>那么，如果可以这么写就好了：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var userid = getRequest1();</span><br><span class=\"line\">var ssoid = getRequest2(userid);</span><br><span class=\"line\">var res = getRequest3(userid,ssoid);</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">res.then(function(data)&#123;console.<span class=\"built_in\">log</span>(data);&#125;);</span><br></pre></td></tr></table></figure>\n<p>把之前es6的写法改一下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = require('request');</span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">'http://localhost:3000/hello1',</span><br><span class=\"line\">'http://localhost:3000/hello2',</span><br><span class=\"line\">'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//创建任务函数不变</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\"> var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//返回promise承诺</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//声明async函数，返回的一定是promise对象</span></span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">doIt</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> var data_userid = await createPromise(urls[<span class=\"number\">0</span>]);<span class=\"comment\">//第一个请求任务</span></span><br><span class=\"line\"> data_userid = JSON.parse(data_userid);<span class=\"comment\">//解析成对象</span></span><br><span class=\"line\"> var userid = data_userid.userid;<span class=\"comment\">//获取userid</span></span><br><span class=\"line\"> var data_ssoid = await createPromise(urls[<span class=\"number\">1</span>]+<span class=\"string\">\"?userid=\"</span>+userid);<span class=\"comment\">//第二个请求任务</span></span><br><span class=\"line\"> data_ssoid = JSON.parse(data_ssoid);<span class=\"comment\">//解析成对象</span></span><br><span class=\"line\"> var ssoid = data_ssoid.ssoid;<span class=\"comment\">//获取ssoid</span></span><br><span class=\"line\"> var result = await createPromise(urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid);//第三个请求任务</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;<span class=\"comment\">//返回promise对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//最终执行</span></span><br><span class=\"line\">doIt().then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>\n<blockquote>\n<p>注意：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>async需要放在函数声明前，表示这个函数返回的一定是promise对象。</span><br><span class=\"line\"><span class=\"number\">2.</span>await后面也必须是promise对象，表示这个任务是需要等待的。</span><br><span class=\"line\"><span class=\"number\">3.</span>最后用then()获取所有接口的信息，<span class=\"keyword\">catch</span>()捕获所有异常。</span><br><span class=\"line\"><span class=\"number\">4.</span>这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！</span><br><span class=\"line\"></span><br><span class=\"line\">这样，简单整洁，只留一个then和<span class=\"keyword\">catch</span>。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于es7的async/await。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p><code>es6</code>的<code>promise</code>写法还是不够优雅，因为后面会跟很多<code>then()</code>。应该说，<code>async/await</code>是目前解决回调问题最好的方案了。</p>\n<blockquote>\n<p>a:<code>async</code>函数是什么？<br>b:一句话，它就是 <code>Generator</code> 函数的语法糖。<br>a:而<code>Generator</code>又是神马？<br>b:是<code>es6</code>的一个语法。<br>a:这个语法干嘛的？<br>b:不用管它，只需要把async搞明白。</p>\n</blockquote>\n<p>要在node7下面才能玩es7，低版本是玩不了的哈。目前官网最新测试版本是<code>10.*</code>，稳定版出到<code>8.*</code>，所以安装好就可以使用了。</p>\n<p>使用<code>async/await</code>的目的就是去除掉<code>Promise</code>后面的<code>then()</code>,在并行下也没有<code>then()</code>的，主要是串行，就是互相依靠的请求方式。</p>\n<ul>\n<li>假设有三个请求：<br>请求1：拿到userid，传递给请求2。<br>请求2：根据userid，查询ssoid，传递给请求3。<br>请求3：根据ssoid，查到最终结果。</li>\n</ul>\n<p>那么，如果可以这么写就好了：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var userid = getRequest1();</span><br><span class=\"line\">var ssoid = getRequest2(userid);</span><br><span class=\"line\">var res = getRequest3(userid,ssoid);</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">res.then(function(data)&#123;console.<span class=\"built_in\">log</span>(data);&#125;);</span><br></pre></td></tr></table></figure>\n<p>把之前es6的写法改一下：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = require('request');</span><br><span class=\"line\">var urls = [</span><br><span class=\"line\">'http://localhost:3000/hello1',</span><br><span class=\"line\">'http://localhost:3000/hello2',</span><br><span class=\"line\">'http://localhost:3000/hello3'</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//创建任务函数不变</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createPromise</span><span class=\"params\">(url)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\"> var callback = function(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> request(url , function(err , response , body)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   reject(err);<span class=\"comment\">//错误返回</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   resolve(body);<span class=\"comment\">//成功返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//布置任务</span></span><br><span class=\"line\">var promise = <span class=\"keyword\">new</span> Promise(callback);</span><br><span class=\"line\"><span class=\"comment\">//返回promise承诺</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//声明async函数，返回的一定是promise对象</span></span><br><span class=\"line\"><span class=\"function\">async function <span class=\"title\">doIt</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> var data_userid = await createPromise(urls[<span class=\"number\">0</span>]);<span class=\"comment\">//第一个请求任务</span></span><br><span class=\"line\"> data_userid = JSON.parse(data_userid);<span class=\"comment\">//解析成对象</span></span><br><span class=\"line\"> var userid = data_userid.userid;<span class=\"comment\">//获取userid</span></span><br><span class=\"line\"> var data_ssoid = await createPromise(urls[<span class=\"number\">1</span>]+<span class=\"string\">\"?userid=\"</span>+userid);<span class=\"comment\">//第二个请求任务</span></span><br><span class=\"line\"> data_ssoid = JSON.parse(data_ssoid);<span class=\"comment\">//解析成对象</span></span><br><span class=\"line\"> var ssoid = data_ssoid.ssoid;<span class=\"comment\">//获取ssoid</span></span><br><span class=\"line\"> var result = await createPromise(urls[2]+'?userid='+userid+'&amp;ssoid='+ssoid);//第三个请求任务</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;<span class=\"comment\">//返回promise对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//最终执行</span></span><br><span class=\"line\">doIt().then(function(data)&#123;</span><br><span class=\"line\"><span class=\"comment\">//打印最终结果</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(data);</span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(function(err)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1l8pHWF6CaJsuviaIjujRicK8ttrnjYQERA7C47wkJUtibIickCS8UwynqvOjETy7Yyz97syziaPcqDjXQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>\n<blockquote>\n<p>注意：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>async需要放在函数声明前，表示这个函数返回的一定是promise对象。</span><br><span class=\"line\"><span class=\"number\">2.</span>await后面也必须是promise对象，表示这个任务是需要等待的。</span><br><span class=\"line\"><span class=\"number\">3.</span>最后用then()获取所有接口的信息，<span class=\"keyword\">catch</span>()捕获所有异常。</span><br><span class=\"line\"><span class=\"number\">4.</span>这种写法虽然类似同步，但实际是promise的简化写法，不可混为一谈！</span><br><span class=\"line\"></span><br><span class=\"line\">这样，简单整洁，只留一个then和<span class=\"keyword\">catch</span>。</span><br></pre></td></tr></table></figure></p>\n</blockquote>"},{"title":"ES6攻略(五)","date":"2018-05-29T14:50:35.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 数组扩展\n\n## forEach()方法\n这个方法其实是`es5`的，还是很好用的。\n```h\nvar arr = ['a', 'b', 'c', 'd'];\n//遍历数组\narr.forEach(function(val){\n console.log(val);\n});\n```\n## Array.from()方法\n\n它是将两类对象装换为真的数组：`类数组对象arguments`、`可遍历对象`（可数Object、Set、Map).\n\n```h\nlet myObj = {length:2,'0':'hello','1':'world'};\nconsole.log(Array.from(myObj));\n//[ 'hello', 'world' ]\n\n<!-- Set -->\n\nlet mySet = new Set([1,1,2,3]);\nmySet.add('hello');\nmySet.add('hello');\nmySet.add(NaN);\nmySet.add(NaN);\nmySet.add(undefined);\nmySet.add(undefined);\nconsole.log(Array.from(mySet));\n//[ 1, 2, 3, 'hello', NaN, undefined ]\n\n<!-- Map -->\nlet myMap = new Map();\nmyMap.set(0,'hello');\nmyMap.set(true,'world');\nmyMap.set(1,'haha');\nconsole.log(Array.from(myMap));\n//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]\n\n<!-- arguments -->\nfunction foo(){\nconsole.log(Array.from(arguments));\n}\nfoo(1,3,5);\n//[ 1, 3, 5 ]\n\n```\n\n## find()和findindex()\n\n`find()`查找数组里符合条件的`第一个值`\n`findindex()`是查找数组里符合条件的第一个索引的`下标`\n\n```h\n\n<!-- find() -->\nconsole.log([-1, 4, -5, 10].find((n) => n < 2));\n// -1\n\n<!-- findindex() -->\nconsole.log([1, 5, 10, 15].findIndex(function(value, index, arr) {\n return value > 4;\n //5这个值的索引下标是1\n}));\n\n// 1\n\n```\n\n## fill()填充方法\n\n将`空数组`填充固定的某一个值。\n\n```h\nconsole.log(new Array(4));\n//[ , , , ]\nconsole.log(new Array(4).fill(2));\n//[2, 2, 2, 2]\n```\n\n## lterator 遍历器\n\n使用最多的遍历器是：`for...in`和`for`\n前者是循环遍历`Object`对象，后者是遍历数组\n在`ES6`里又新增加了2种数据结构：`Set`和`Map`。这里就用到了`lterator`，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用`for....of`循环。\n\n```h\nlet myMap = new Map();\nmyMap.set(0,'hello');\nmyMap.set(1,'world');\nmyMap.set('hi','jack');\n\nfor(let v of myMap){\n console.log(v);\n console.log(v[0]+'--'+v[1]);\n}\n\n/*\n    [0, \"hello\"]\n    0--hello\n    [1, \"world\"]\n    1--world\n    [\"hi\", \"jack\"]\n    hi--jack\n*/\n\nlet mySet = new Set([1,3,5]);\n\nfor(let v of mySet){\n console.log(v);\n}\n/*\n    1\n    3\n    5\n*/\n\n```\n\n## Module \n\n`Module`它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。\n\n这里需要注意：\n`Node`环境下使用`export`和`require`\n`前端JS`环境下使用`export`和`import`(需要babel等工具来解析)\n\n```h\n<!-- foo.js -->\n\n//导出方法\nmodule.exports.sayHi = function(){\n console.log('hello,world');\n};\n\n\n//导出对象\nmodule.exports.obj = {'a':1,'b':2};\n\nclass Person {\n constructor( name){\n  this.name = name;\n }\n eat() {\n  console.log(this.name+' eat');\n }\n}\n\n//导出一个类\nmodule.exports.Person = Person;\n\n```\n\n```h\n<!-- text.js -->\n\n//引入模块\nvar text = require('./foo.js');\n//使用模块\ntext.sayHi();\nconsole.log(text.obj.a);\n\nvar p = new text.Person('jack');\np.eat();\n\n```\n\n在se6的语法下，需要babel 的支持。\n1、安装\n\n`npm install   babel-preset-es2015`\n`npminstall --global  babel-cli`\n\n2、配置.babelrc文件\n\n`{\"presets\":[\"es2015\"]}`\n\n3、测试一下\n\n\n```h\n<!-- export.js -->\n\nvar yourname = 'Jack';\nvar age = 18;\nexport {yourname, age};\n```\n\n```h\n<!-- import.js -->\n\nimport {yourname, age} from './export.js';\nfunction say() {\n console.log(yourname,age);\n}\n```\n\n4、运行\n\n`babel export.js --out-file export_out.js`\n`babel import.js --out-file import_out.js`\n\n运行结束之后，目录下增加了2个输出文件，`export_out.js`和`import_out.js`\n\n```h\n<!--  export_out.js-->\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\nvalue: true\n});\nvar yourname = 'Jack';\nvar age = 18;\n\nexports.yourname = yourname;\nexports.age = age;\n```\n\n```h\n<!-- import_out.js -->\n\n'use strict';\n\nvar _export = require('./export.js');\n\nfunction say() {\n console.log(_export.yourname, _export.age);\n}\n```\n其实翻译过来后，仍旧是`exports`和`require`！\n\n5、在前端测试text.html\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>测试一下</title>\n<script src=\"./import_out.js\"></script>\n\n</head>\n<body>\n<div></div>　　　\n</body>\n</html>\n<script>\n    say();\n</script>\n```\n这样是运行不了的，他们环境都不一样，怎么可能运行。\n`babel`只是一个编译工具，这里只是把es6编译为`common.js`规范的语法，`require`这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。\n> common、cmd、amd:\n> `cmd`是seajs遵循的规范\n> `amd`是requirejs遵循的规范\n> `commomJS`是node遵循的规范\n\n就需要加入`webpack`.\n\n## webpack\n\n1、安装\n`npm install webpack -g (全局安装)`\n`npm install webpack (本地安装)`\n\n2、运行编译\n`webpack import_out.js bundle.js`\n\n因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。\n\n3、 再一次测试test.html\n> 会有错误抛出：say is not defined\n\n这个其实是模块化的问题，`say()`方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有\n` (function(modules) { ....... })();  ` 这就是一个自执行的封闭空间。\n如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。\nwebpack有个`expose-loader`这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:\n```h\n'use strict';\n\nvar _export = require('./export.js');\n\nfunction say() {\nconsole.log(_export.yourname, _export.age);\n}\n<!-- 把say()方法挂到window下面 -->\nwindow.say = say;\n\n```\n\n然后再运行一下webpack命令：\n`webpack import_out.js bundle.js`\n好啦，你再运行下test.html，发现终于成功啦！\n\n# 总结\n其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。\n\n> 参考原文：[ES6攻略](https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&hid=13&sn=7b07c59cafcf19e4805a803bf9f34347&scene=1&devicetype=android-26&version=26060637&lang=zh_CN&nettype=WIFI&ascene=7&session_us=gh_be748ba8c36a&wx_header=1)\n\n\n\n\n\n\n\n\n\n","source":"_posts/ES6攻略-五.md","raw":"---\ntitle: ES6攻略(五)\ndate: 2018-05-29 22:50:35\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 数组扩展\n\n## forEach()方法\n这个方法其实是`es5`的，还是很好用的。\n```h\nvar arr = ['a', 'b', 'c', 'd'];\n//遍历数组\narr.forEach(function(val){\n console.log(val);\n});\n```\n## Array.from()方法\n\n它是将两类对象装换为真的数组：`类数组对象arguments`、`可遍历对象`（可数Object、Set、Map).\n\n```h\nlet myObj = {length:2,'0':'hello','1':'world'};\nconsole.log(Array.from(myObj));\n//[ 'hello', 'world' ]\n\n<!-- Set -->\n\nlet mySet = new Set([1,1,2,3]);\nmySet.add('hello');\nmySet.add('hello');\nmySet.add(NaN);\nmySet.add(NaN);\nmySet.add(undefined);\nmySet.add(undefined);\nconsole.log(Array.from(mySet));\n//[ 1, 2, 3, 'hello', NaN, undefined ]\n\n<!-- Map -->\nlet myMap = new Map();\nmyMap.set(0,'hello');\nmyMap.set(true,'world');\nmyMap.set(1,'haha');\nconsole.log(Array.from(myMap));\n//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]\n\n<!-- arguments -->\nfunction foo(){\nconsole.log(Array.from(arguments));\n}\nfoo(1,3,5);\n//[ 1, 3, 5 ]\n\n```\n\n## find()和findindex()\n\n`find()`查找数组里符合条件的`第一个值`\n`findindex()`是查找数组里符合条件的第一个索引的`下标`\n\n```h\n\n<!-- find() -->\nconsole.log([-1, 4, -5, 10].find((n) => n < 2));\n// -1\n\n<!-- findindex() -->\nconsole.log([1, 5, 10, 15].findIndex(function(value, index, arr) {\n return value > 4;\n //5这个值的索引下标是1\n}));\n\n// 1\n\n```\n\n## fill()填充方法\n\n将`空数组`填充固定的某一个值。\n\n```h\nconsole.log(new Array(4));\n//[ , , , ]\nconsole.log(new Array(4).fill(2));\n//[2, 2, 2, 2]\n```\n\n## lterator 遍历器\n\n使用最多的遍历器是：`for...in`和`for`\n前者是循环遍历`Object`对象，后者是遍历数组\n在`ES6`里又新增加了2种数据结构：`Set`和`Map`。这里就用到了`lterator`，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用`for....of`循环。\n\n```h\nlet myMap = new Map();\nmyMap.set(0,'hello');\nmyMap.set(1,'world');\nmyMap.set('hi','jack');\n\nfor(let v of myMap){\n console.log(v);\n console.log(v[0]+'--'+v[1]);\n}\n\n/*\n    [0, \"hello\"]\n    0--hello\n    [1, \"world\"]\n    1--world\n    [\"hi\", \"jack\"]\n    hi--jack\n*/\n\nlet mySet = new Set([1,3,5]);\n\nfor(let v of mySet){\n console.log(v);\n}\n/*\n    1\n    3\n    5\n*/\n\n```\n\n## Module \n\n`Module`它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。\n\n这里需要注意：\n`Node`环境下使用`export`和`require`\n`前端JS`环境下使用`export`和`import`(需要babel等工具来解析)\n\n```h\n<!-- foo.js -->\n\n//导出方法\nmodule.exports.sayHi = function(){\n console.log('hello,world');\n};\n\n\n//导出对象\nmodule.exports.obj = {'a':1,'b':2};\n\nclass Person {\n constructor( name){\n  this.name = name;\n }\n eat() {\n  console.log(this.name+' eat');\n }\n}\n\n//导出一个类\nmodule.exports.Person = Person;\n\n```\n\n```h\n<!-- text.js -->\n\n//引入模块\nvar text = require('./foo.js');\n//使用模块\ntext.sayHi();\nconsole.log(text.obj.a);\n\nvar p = new text.Person('jack');\np.eat();\n\n```\n\n在se6的语法下，需要babel 的支持。\n1、安装\n\n`npm install   babel-preset-es2015`\n`npminstall --global  babel-cli`\n\n2、配置.babelrc文件\n\n`{\"presets\":[\"es2015\"]}`\n\n3、测试一下\n\n\n```h\n<!-- export.js -->\n\nvar yourname = 'Jack';\nvar age = 18;\nexport {yourname, age};\n```\n\n```h\n<!-- import.js -->\n\nimport {yourname, age} from './export.js';\nfunction say() {\n console.log(yourname,age);\n}\n```\n\n4、运行\n\n`babel export.js --out-file export_out.js`\n`babel import.js --out-file import_out.js`\n\n运行结束之后，目录下增加了2个输出文件，`export_out.js`和`import_out.js`\n\n```h\n<!--  export_out.js-->\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\nvalue: true\n});\nvar yourname = 'Jack';\nvar age = 18;\n\nexports.yourname = yourname;\nexports.age = age;\n```\n\n```h\n<!-- import_out.js -->\n\n'use strict';\n\nvar _export = require('./export.js');\n\nfunction say() {\n console.log(_export.yourname, _export.age);\n}\n```\n其实翻译过来后，仍旧是`exports`和`require`！\n\n5、在前端测试text.html\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>测试一下</title>\n<script src=\"./import_out.js\"></script>\n\n</head>\n<body>\n<div></div>　　　\n</body>\n</html>\n<script>\n    say();\n</script>\n```\n这样是运行不了的，他们环境都不一样，怎么可能运行。\n`babel`只是一个编译工具，这里只是把es6编译为`common.js`规范的语法，`require`这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。\n> common、cmd、amd:\n> `cmd`是seajs遵循的规范\n> `amd`是requirejs遵循的规范\n> `commomJS`是node遵循的规范\n\n就需要加入`webpack`.\n\n## webpack\n\n1、安装\n`npm install webpack -g (全局安装)`\n`npm install webpack (本地安装)`\n\n2、运行编译\n`webpack import_out.js bundle.js`\n\n因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。\n\n3、 再一次测试test.html\n> 会有错误抛出：say is not defined\n\n这个其实是模块化的问题，`say()`方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有\n` (function(modules) { ....... })();  ` 这就是一个自执行的封闭空间。\n如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。\nwebpack有个`expose-loader`这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:\n```h\n'use strict';\n\nvar _export = require('./export.js');\n\nfunction say() {\nconsole.log(_export.yourname, _export.age);\n}\n<!-- 把say()方法挂到window下面 -->\nwindow.say = say;\n\n```\n\n然后再运行一下webpack命令：\n`webpack import_out.js bundle.js`\n好啦，你再运行下test.html，发现终于成功啦！\n\n# 总结\n其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。\n\n> 参考原文：[ES6攻略](https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&hid=13&sn=7b07c59cafcf19e4805a803bf9f34347&scene=1&devicetype=android-26&version=26060637&lang=zh_CN&nettype=WIFI&ascene=7&session_us=gh_be748ba8c36a&wx_header=1)\n\n\n\n\n\n\n\n\n\n","slug":"ES6攻略-五","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd20007kt89tu4qjt90","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach()方法\"></a>forEach()方法</h2><p>这个方法其实是<code>es5</code>的，还是很好用的。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">arr.forEach(function(val)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(val);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Array-from-方法\"><a href=\"#Array-from-方法\" class=\"headerlink\" title=\"Array.from()方法\"></a>Array.from()方法</h2><p>它是将两类对象装换为真的数组：<code>类数组对象arguments</code>、<code>可遍历对象</code>（可数Object、Set、Map).</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myObj = &#123;length:2,'0':'hello','1':'world'&#125;;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(myObj));</span><br><span class=\"line\"><span class=\"comment\">//[ 'hello', 'world' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Set --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">let mySet = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">mySet.add('hello');</span><br><span class=\"line\">mySet.add('hello');</span><br><span class=\"line\">mySet.add(NaN);</span><br><span class=\"line\">mySet.add(NaN);</span><br><span class=\"line\">mySet.add(undefined);</span><br><span class=\"line\">mySet.add(undefined);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(mySet));</span><br><span class=\"line\"><span class=\"comment\">//[ 1, 2, 3, 'hello', NaN, undefined ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Map --&gt;</span><br><span class=\"line\">let myMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">myMap.set(0,'hello');</span><br><span class=\"line\">myMap.set(true,'world');</span><br><span class=\"line\">myMap.set(1,'haha');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(myMap));</span><br><span class=\"line\"><span class=\"comment\">//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- arguments --&gt;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(arguments));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//[ 1, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"find-和findindex\"><a href=\"#find-和findindex\" class=\"headerlink\" title=\"find()和findindex()\"></a>find()和findindex()</h2><p><code>find()</code>查找数组里符合条件的<code>第一个值</code><br><code>findindex()</code>是查找数组里符合条件的第一个索引的<code>下标</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- find() --&gt;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([<span class=\"number\">-1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find((n) =&gt; n &lt; <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- findindex() --&gt;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(function(value, index, arr) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> value &gt; <span class=\"number\">4</span>;</span><br><span class=\"line\"> <span class=\"comment\">//5这个值的索引下标是1</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"fill-填充方法\"><a href=\"#fill-填充方法\" class=\"headerlink\" title=\"fill()填充方法\"></a>fill()填充方法</h2><p>将<code>空数组</code>填充固定的某一个值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">new</span> Array(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"comment\">//[ , , , ]</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">new</span> Array(<span class=\"number\">4</span>).fill(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">//[2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"lterator-遍历器\"><a href=\"#lterator-遍历器\" class=\"headerlink\" title=\"lterator 遍历器\"></a>lterator 遍历器</h2><p>使用最多的遍历器是：<code>for...in</code>和<code>for</code><br>前者是循环遍历<code>Object</code>对象，后者是遍历数组<br>在<code>ES6</code>里又新增加了2种数据结构：<code>Set</code>和<code>Map</code>。这里就用到了<code>lterator</code>，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用<code>for....of</code>循环。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">myMap.set(0,'hello');</span><br><span class=\"line\">myMap.set(1,'world');</span><br><span class=\"line\">myMap.set('hi','jack');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let v of myMap)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(v);</span><br><span class=\"line\"> console.log(v[0]+'--'+v[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    [0, \"hello\"]</span></span><br><span class=\"line\"><span class=\"comment\">    0--hello</span></span><br><span class=\"line\"><span class=\"comment\">    [1, \"world\"]</span></span><br><span class=\"line\"><span class=\"comment\">    1--world</span></span><br><span class=\"line\"><span class=\"comment\">    [\"hi\", \"jack\"]</span></span><br><span class=\"line\"><span class=\"comment\">    hi--jack</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">let mySet = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let v of mySet)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1</span></span><br><span class=\"line\"><span class=\"comment\">    3</span></span><br><span class=\"line\"><span class=\"comment\">    5</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h2><p><code>Module</code>它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。</p>\n<p>这里需要注意：<br><code>Node</code>环境下使用<code>export</code>和<code>require</code><br><code>前端JS</code>环境下使用<code>export</code>和<code>import</code>(需要babel等工具来解析)</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- foo.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出方法</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.sayHi = function()&#123;</span><br><span class=\"line\"> console.log('hello,world');</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出对象</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.obj = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>,<span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"> constructor( name)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> eat() &#123;</span><br><span class=\"line\">  console.log(this.name+' eat');</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出一个类</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.Person = Person;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- text.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引入模块</span></span><br><span class=\"line\">var text = require('./foo.js');</span><br><span class=\"line\"><span class=\"comment\">//使用模块</span></span><br><span class=\"line\">text.sayHi();</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(text.obj.a);</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new text.Person('jack');</span><br><span class=\"line\">p.eat();</span><br></pre></td></tr></table></figure>\n<p>在se6的语法下，需要babel 的支持。<br>1、安装</p>\n<p><code>npm install   babel-preset-es2015</code><br><code>npminstall --global  babel-cli</code></p>\n<p>2、配置.babelrc文件</p>\n<p><code>{&quot;presets&quot;:[&quot;es2015&quot;]}</code></p>\n<p>3、测试一下</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"keyword\">export</span>.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var yourname = 'Jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;yourname, age&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"keyword\">import</span>.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;yourname, age&#125; from './export.js';</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(yourname,age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、运行</p>\n<p><code>babel export.js --out-file export_out.js</code><br><code>babel import.js --out-file import_out.js</code></p>\n<p>运行结束之后，目录下增加了2个输出文件，<code>export_out.js</code>和<code>import_out.js</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--  export_out.js--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(exports, <span class=\"string\">\"__esModule\"</span>, &#123;</span><br><span class=\"line\">value: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var yourname = 'Jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.yourname = yourname;</span><br><span class=\"line\">exports.age = age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- import_out.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">var _export = require('./export.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(_export.yourname, _export.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实翻译过来后，仍旧是<code>exports</code>和<code>require</code>！</p>\n<p>5、在前端测试text.html</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;测试一下&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"./import_out.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    say();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样是运行不了的，他们环境都不一样，怎么可能运行。<br><code>babel</code>只是一个编译工具，这里只是把es6编译为<code>common.js</code>规范的语法，<code>require</code>这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。</p>\n<blockquote>\n<p>common、cmd、amd:<br><code>cmd</code>是seajs遵循的规范<br><code>amd</code>是requirejs遵循的规范<br><code>commomJS</code>是node遵循的规范</p>\n</blockquote>\n<p>就需要加入<code>webpack</code>.</p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p>1、安装<br><code>npm install webpack -g (全局安装)</code><br><code>npm install webpack (本地安装)</code></p>\n<p>2、运行编译<br><code>webpack import_out.js bundle.js</code></p>\n<p>因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。</p>\n<p>3、 再一次测试test.html</p>\n<blockquote>\n<p>会有错误抛出：say is not defined</p>\n</blockquote>\n<p>这个其实是模块化的问题，<code>say()</code>方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有<br><code>(function(modules) { ....... })();</code> 这就是一个自执行的封闭空间。<br>如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。<br>webpack有个<code>expose-loader</code>这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">var _export = require('./export.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(_export.yourname, _export.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!-- 把say()方法挂到window下面 --&gt;</span><br><span class=\"line\">window.say = say;</span><br></pre></td></tr></table></figure></p>\n<p>然后再运行一下webpack命令：<br><code>webpack import_out.js bundle.js</code><br>好啦，你再运行下test.html，发现终于成功啦！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。</p>\n<blockquote>\n<p>参考原文：<a href=\"https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&amp;hid=13&amp;sn=7b07c59cafcf19e4805a803bf9f34347&amp;scene=1&amp;devicetype=android-26&amp;version=26060637&amp;lang=zh_CN&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_be748ba8c36a&amp;wx_header=1\" target=\"_blank\" rel=\"noopener\">ES6攻略</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于一些导出模块。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach()方法\"></a>forEach()方法</h2><p>这个方法其实是<code>es5</code>的，还是很好用的。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">arr.forEach(function(val)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(val);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Array-from-方法\"><a href=\"#Array-from-方法\" class=\"headerlink\" title=\"Array.from()方法\"></a>Array.from()方法</h2><p>它是将两类对象装换为真的数组：<code>类数组对象arguments</code>、<code>可遍历对象</code>（可数Object、Set、Map).</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myObj = &#123;length:2,'0':'hello','1':'world'&#125;;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(myObj));</span><br><span class=\"line\"><span class=\"comment\">//[ 'hello', 'world' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Set --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">let mySet = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">mySet.add('hello');</span><br><span class=\"line\">mySet.add('hello');</span><br><span class=\"line\">mySet.add(NaN);</span><br><span class=\"line\">mySet.add(NaN);</span><br><span class=\"line\">mySet.add(undefined);</span><br><span class=\"line\">mySet.add(undefined);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(mySet));</span><br><span class=\"line\"><span class=\"comment\">//[ 1, 2, 3, 'hello', NaN, undefined ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Map --&gt;</span><br><span class=\"line\">let myMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">myMap.set(0,'hello');</span><br><span class=\"line\">myMap.set(true,'world');</span><br><span class=\"line\">myMap.set(1,'haha');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(myMap));</span><br><span class=\"line\"><span class=\"comment\">//[ [ 0, 'hello' ], [ true, 'world' ], [ 1, 'haha' ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- arguments --&gt;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Array.from(arguments));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//[ 1, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"find-和findindex\"><a href=\"#find-和findindex\" class=\"headerlink\" title=\"find()和findindex()\"></a>find()和findindex()</h2><p><code>find()</code>查找数组里符合条件的<code>第一个值</code><br><code>findindex()</code>是查找数组里符合条件的第一个索引的<code>下标</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- find() --&gt;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([<span class=\"number\">-1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find((n) =&gt; n &lt; <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- findindex() --&gt;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(function(value, index, arr) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> value &gt; <span class=\"number\">4</span>;</span><br><span class=\"line\"> <span class=\"comment\">//5这个值的索引下标是1</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"fill-填充方法\"><a href=\"#fill-填充方法\" class=\"headerlink\" title=\"fill()填充方法\"></a>fill()填充方法</h2><p>将<code>空数组</code>填充固定的某一个值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">new</span> Array(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"comment\">//[ , , , ]</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">new</span> Array(<span class=\"number\">4</span>).fill(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">//[2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"lterator-遍历器\"><a href=\"#lterator-遍历器\" class=\"headerlink\" title=\"lterator 遍历器\"></a>lterator 遍历器</h2><p>使用最多的遍历器是：<code>for...in</code>和<code>for</code><br>前者是循环遍历<code>Object</code>对象，后者是遍历数组<br>在<code>ES6</code>里又新增加了2种数据结构：<code>Set</code>和<code>Map</code>。这里就用到了<code>lterator</code>，他其实就是链表结构，每一个对象记录它下个对象的位置，一个一个连成串。他们二者的原理是利用<code>for....of</code>循环。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">myMap.set(0,'hello');</span><br><span class=\"line\">myMap.set(1,'world');</span><br><span class=\"line\">myMap.set('hi','jack');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let v of myMap)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(v);</span><br><span class=\"line\"> console.log(v[0]+'--'+v[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    [0, \"hello\"]</span></span><br><span class=\"line\"><span class=\"comment\">    0--hello</span></span><br><span class=\"line\"><span class=\"comment\">    [1, \"world\"]</span></span><br><span class=\"line\"><span class=\"comment\">    1--world</span></span><br><span class=\"line\"><span class=\"comment\">    [\"hi\", \"jack\"]</span></span><br><span class=\"line\"><span class=\"comment\">    hi--jack</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">let mySet = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let v of mySet)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1</span></span><br><span class=\"line\"><span class=\"comment\">    3</span></span><br><span class=\"line\"><span class=\"comment\">    5</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h2><p><code>Module</code>它可以让JS变成一个个可以拆分的先文件，然后通过简单的方拼接起来，极大的增大了灵活性。它的一些关键字是默认的，可以忽略。</p>\n<p>这里需要注意：<br><code>Node</code>环境下使用<code>export</code>和<code>require</code><br><code>前端JS</code>环境下使用<code>export</code>和<code>import</code>(需要babel等工具来解析)</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- foo.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出方法</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.sayHi = function()&#123;</span><br><span class=\"line\"> console.log('hello,world');</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出对象</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.obj = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>,<span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"> constructor( name)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> eat() &#123;</span><br><span class=\"line\">  console.log(this.name+' eat');</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//导出一个类</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports.Person = Person;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- text.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引入模块</span></span><br><span class=\"line\">var text = require('./foo.js');</span><br><span class=\"line\"><span class=\"comment\">//使用模块</span></span><br><span class=\"line\">text.sayHi();</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(text.obj.a);</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new text.Person('jack');</span><br><span class=\"line\">p.eat();</span><br></pre></td></tr></table></figure>\n<p>在se6的语法下，需要babel 的支持。<br>1、安装</p>\n<p><code>npm install   babel-preset-es2015</code><br><code>npminstall --global  babel-cli</code></p>\n<p>2、配置.babelrc文件</p>\n<p><code>{&quot;presets&quot;:[&quot;es2015&quot;]}</code></p>\n<p>3、测试一下</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"keyword\">export</span>.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var yourname = 'Jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;yourname, age&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"keyword\">import</span>.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;yourname, age&#125; from './export.js';</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(yourname,age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、运行</p>\n<p><code>babel export.js --out-file export_out.js</code><br><code>babel import.js --out-file import_out.js</code></p>\n<p>运行结束之后，目录下增加了2个输出文件，<code>export_out.js</code>和<code>import_out.js</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--  export_out.js--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(exports, <span class=\"string\">\"__esModule\"</span>, &#123;</span><br><span class=\"line\">value: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var yourname = 'Jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.yourname = yourname;</span><br><span class=\"line\">exports.age = age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- import_out.js --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">var _export = require('./export.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(_export.yourname, _export.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实翻译过来后，仍旧是<code>exports</code>和<code>require</code>！</p>\n<p>5、在前端测试text.html</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;测试一下&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"./import_out.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    say();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样是运行不了的，他们环境都不一样，怎么可能运行。<br><code>babel</code>只是一个编译工具，这里只是把es6编译为<code>common.js</code>规范的语法，<code>require</code>这个关键字属于commomJS范畴，并不是前端原生的JS,也就无法识别。</p>\n<blockquote>\n<p>common、cmd、amd:<br><code>cmd</code>是seajs遵循的规范<br><code>amd</code>是requirejs遵循的规范<br><code>commomJS</code>是node遵循的规范</p>\n</blockquote>\n<p>就需要加入<code>webpack</code>.</p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p>1、安装<br><code>npm install webpack -g (全局安装)</code><br><code>npm install webpack (本地安装)</code></p>\n<p>2、运行编译<br><code>webpack import_out.js bundle.js</code></p>\n<p>因为我们已经对import_out.js使用babel编译过了，所以只需要使用Webpack把commonJS规范这个文件，编译成浏览器识别的文件。</p>\n<p>3、 再一次测试test.html</p>\n<blockquote>\n<p>会有错误抛出：say is not defined</p>\n</blockquote>\n<p>这个其实是模块化的问题，<code>say()</code>方法的存活空间只存在模块内，也就是Webpack解析后的自执行函数里，这样的好处就是避免了全局变量的污染，在bundle.js文件下有<br><code>(function(modules) { ....... })();</code> 这就是一个自执行的封闭空间。<br>如果需要在外部调用say()这个方法，只需要把它暴露在全局就好了。<br>webpack有个<code>expose-loader</code>这个插件，可以将jquery的$暴露到全局，以此类推，把say()方法挂到window下面就ok了。我们直接修改babel翻译过的文件import_out.js:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'use strict';</span><br><span class=\"line\"></span><br><span class=\"line\">var _export = require('./export.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(_export.yourname, _export.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!-- 把say()方法挂到window下面 --&gt;</span><br><span class=\"line\">window.say = say;</span><br></pre></td></tr></table></figure></p>\n<p>然后再运行一下webpack命令：<br><code>webpack import_out.js bundle.js</code><br>好啦，你再运行下test.html，发现终于成功啦！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实webpack集成了babel翻译的相关工作，我们并不需要这么麻烦拆分出来。不过为了搞清楚他们各自的工作原理，还是需要这样的拆分。</p>\n<blockquote>\n<p>参考原文：<a href=\"https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTU4MzMzOQ==&amp;hid=13&amp;sn=7b07c59cafcf19e4805a803bf9f34347&amp;scene=1&amp;devicetype=android-26&amp;version=26060637&amp;lang=zh_CN&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_be748ba8c36a&amp;wx_header=1\" target=\"_blank\" rel=\"noopener\">ES6攻略</a></p>\n</blockquote>"},{"title":"ES6攻略(四)","date":"2018-05-28T16:09:06.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# Set\n之前的JS只提供了两种容器：`数组`和`对象`。es6又添加了另一种非常有用的数据结构：`Set`。他就是`集合`的意思，本身也是一种容器。\n既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？\n拿他跟数组比较的话，`Set`的最大的特点就是`每个值都是唯一的，不能有重复值`。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。\n\n```h\nlet container = new Set([1, 2, 2, 3, 4, 4]);//可以直接传入数组进行初始化\ncontainer.add(5);//添加元素\ncontainer.delete(5);//删除元素\nconsole.log(container.has(5));//false，5这个元素被删除了\nconsole.log(container);//Set { 1, 2, 3, 4 }\nconsole.log(container.size);//长度4\nlet unique_arr = [...container];//省略号语法\nconsole.log(unique_arr);//唯一值数组：[ 1, 2, 3, 4 ]\n```\nSet的构造方法可以直接传数组进行初始化，当然也可以这样声明：\n`let mySet = new Set();`\n\nSet跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。\n\n```h\n//简单去重方案\nvar arr = [1,1,2,3,3,3];\nconsole.log([...new Set(arr)]);//一句话搞定\n```\n\n这并不适用于含有`重复对象的数组`，因为对象是比较的是内存地址。\n```h\nconsole.log({}=={});//false,内存地址不同\nlet arr = [{},{},{}];\nconsole.log([...new Set(arr)]);//对象是无法去重的\n```\n\n对象数组到底如何去重呢？\n一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用`Set`的不重复特性，把对象先转成字符串存入`Set`，去掉重复值后，再转回来就好。\n\n```h\nfunction unique(arr){\n var container = new Set();\n//遍历\n arr.forEach(function(val){\n//将对象转换为字符串,存入set容器中，确保唯一性。\n  container.add(JSON.stringify(val));\n });\n\n var newarr = [...container].map(function(item){\n   return JSON.parse(item);//转换回去\n  });\n return newarr;\n}\n```\n\n# 新数据结构：Map\n这个是`Map`容器，而不是前面的`map()`方法，千万别弄混了（注意大小写）！`Map`就是键值对容器，跟`Object`非常类似。它有什么特别之处呢？\n其实`Object`有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。\n如果让键不限于字符串，而是各种数据类型呢？比如num？\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>map</title>\n</head>\n    <body>\n        <div>\n            <button id=\"btn1\">提交</button>\n            <button id=\"btn2\">关闭</button>\n        </div>　　　\n    </body>\n</html>\n<script>\n    var dom1 = document.getElementById('btn1');\n    var dom2 = document.getElementById('btn2');\n\n    var callback1 = function(){\n        alert('提交');\n    };\n    var callback2 = function(){\n        alert('关闭');\n    };\n    const m = new Map();\n    m.set(dom1,callback1); //键是dom\n    m.set(dom2,callback2);\n    console.log(m);\n</script>\n```\n\n![结果：](http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n\n一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了\n\n```h\n\nconst map = new Map();\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n```\n因为对象比较的是内存地址，所以`['a']`作为新开辟的空间，无法在`Map容器`中找到。\n\n再来看一下Map的增查改删，非常简单。\n\n```h\n//利用二维数组，可以构建Map\nconst myMap = new Map([\n ['name', '张三'],\n ['content', 'hello,world']\n]);\nconsole.log(myMap);//Map { 'name' => '张三', 'content' => 'hello,world' }\nconsole.log(myMap.size); // 长度\nmyMap.set('age',18);//增加属性\nconsole.log(myMap.get('name')); //获取属性\nmyMap.delete('content');//删除属性\nconsole.log(myMap.has('content')); // 判断是否有这个属性\nconsole.log(myMap.keys());//获取所有的键 MapIterator { 'name', 'age' }\nconsole.log(myMap.values());//获取所有的值 MapIterator { '张三', 18 }\n```\n\n获取的keys集合是`MapIterator`类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构\n\n# Reflect是面镜子\n\n`Reflect`就是反射的意思，那究竟反射啥呢？\n大家知道镜子可以反射吧？\n`Reflect`就是一面镜子。那是谁照镜子呢？就是`Object`。\n也就是说，`Object`把自己的属于语言内部的方法（比如Object.defineProperty）照到了`Reflect`上。\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>利用反射实现数据和视图联动</title>\n\n</head>\n<body>\n<div>\n<div>测试Object：<input type=\"text\" id='userName'/></div>\n<div>测试Reflect：<input type=\"text\" id='age'/></div>\n<div id=\"showName\"></div>\n<div id=\"showAge\"></div>\n</div>　　　\n</body>\n</html>\n<script>\nvar userInfo = {};\n//Object的方式\nObject.defineProperty(userInfo, \"userName\", {\nget: function(){\nreturn document.getElementById('showName').innerHTML;\n},\nset: function(name){\ndocument.getElementById('showName').innerHTML = name;\n}\n});\n\n//Reflect是一面大镜子，Object你有的我就有！\nReflect.defineProperty(userInfo, \"age\", {\nget: function(){\nreturn document.getElementById('showAge').innerHTML;\n},\nset: function(name){\ndocument.getElementById('showAge').innerHTML = name;\n}\n});\n\ndocument.getElementById('userName').onkeyup = function(e){\n\nuserInfo.userName = this.value;\n};\n\ndocument.getElementById('age').onkeyup = function(e){\n\nuserInfo.age = this.value;\n};\n</script>\n```\n\n> `Reflect`一共是13个静态方法，就是13种武器哈：\n```h\n\nReflect.apply(target,thisArg,args)\nReflect.construct(target,args)\nReflect.get(target,name,receiver)\nReflect.set(target,name,value,receiver)\nReflect.defineProperty(target,name,desc)\nReflect.deleteProperty(target,name)\nReflect.has(target,name)\nReflect.ownKeys(target)\nReflect.isExtensible(target)\nReflect.preventExtensions(target)\nReflect.getOwnPropertyDescriptor(target, name)\nReflect.getPrototypeOf(target)\nReflect.setPrototypeOf(target, prototype)\n```\n看下几个常用的方法。\n\n```h\n\nlet obj = {\nname:'jack',\nage:18\n};\n//简单set方法\nReflect.set(obj,'name','tom');\nconsole.log(obj.name);//tom\n//简单get方法\nlet age = Reflect.get(obj,'age');\nconsole.log(age);//18\n\n//带有接收者对象的set方法\nlet receiver = {\nname:'lily'\n};\n//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。\n//所以，obj的name属性还是tom，但接收者receiver的name被改变了。\n//这种机制的作用是，可以在对象A中操作对象B。\nReflect.set(obj,'name','bill',receiver);\n\nconsole.log(obj.name);//tom\nconsole.log(receiver.name);//bill\n//判断obj是否有name属性？\n//旧写法--in\nconsole.log('name' in obj);//true\n//新写法--has\nconsole.log(Reflect.has(obj,'name'));//true\n```\n\n他与`Proxy`结合使用更合理。\n\n# Proxy\n\n`Proxy`就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟`Reflect`是一一对应的。\n只要`Proxy`对象有的方法，`Reflect`对象上都有。当然咯，`Proxy`没有的，`Reflect`也有。\n\n拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：\n`var proxy = new Proxy(target, handler);`\n\n>1.target就是目标对象，我们要给哪个对象加拦截？\n> 2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。\n\n拿最简单的set方法为例:\n\n```h\n//形参说明：\n// target:待测试的Person实例\n// validator:验证规则personValidators\n\nfunction createValidator(target, validator) {\n//拦截器，拦截赋值操作，触发set函数\nreturn new Proxy(target, {\n\n set(target, key, value) {\n//如果待测试的Person对象中含有这个属性，就启用验证规则，\n// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。\n  if (target.hasOwnProperty(key)) {\n\n    let rules = validator[key];//rules拿到的是name方法的引用\n//相当于调用方法name('hello')\n    if (rules(value)) {\n//如果验证无误，target的name属性可以修改成功\n     return Reflect.set(target, key, value);\n    } else {\n//否则失败\n      return 'error';\n   }\n  } else {\n     return 'error';\n  } \n }\n});\n}\n//验证规则\nconst personRules = {\n name(val) {\n   return typeof val === 'string';\n },\n age(val) {\n   return typeof val === 'number' && val > 18;\n }\n};\n//测试类\nclass Person {\n constructor(name, age) {\n   this.name = name;\n   this.age = age;\n//开启验证，传入这个类的实例和验证规则personRules\n   return createValidator(this, personRules);\n }\n}\n\nconst bill = new Person('Bill', 25);\nbill.name = 'jack';//赋值成功\nbill.age = 10;//赋值失败\nconsole.log(bill.name);//jack\nconsole.log(bill.age);//25\n```\n\n`createValidator`这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。\n\n再来看下`Reflect.apply`的用法。这个方法的使用频率还是蛮高的\n\n```h\n//假如这个foo函数是同事张三写的\nvar obj = {};\nfunction foo(){\n\nconsole.log(this);\n}\n\n//李四引入并使用了这个函数\nfoo.apply(obj);\n//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。\n//可以在不依赖函数名的情况下改变函数的作用域么？\nFunction.prototype.apply.call(foo,obj);\n//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。\nReflect.apply(foo,obj,[]);//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错\n```\n\n## 结语\n`Proxy`是用于修改语言内部行为的机制，因为`Object`对象内部的方法大多属于这种情况，所以`handler`的配置，又跟`Reflect`紧密联系在一起（因为Reflect是Object的镜子嘛）。\n应该说，`Reflect`和`Proxy`之间的关系还是不太容易理顺的。\n","source":"_posts/ES6攻略-四.md","raw":"---\ntitle: ES6攻略(四)\ndate: 2018-05-29 00:09:06\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# Set\n之前的JS只提供了两种容器：`数组`和`对象`。es6又添加了另一种非常有用的数据结构：`Set`。他就是`集合`的意思，本身也是一种容器。\n既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？\n拿他跟数组比较的话，`Set`的最大的特点就是`每个值都是唯一的，不能有重复值`。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。\n\n```h\nlet container = new Set([1, 2, 2, 3, 4, 4]);//可以直接传入数组进行初始化\ncontainer.add(5);//添加元素\ncontainer.delete(5);//删除元素\nconsole.log(container.has(5));//false，5这个元素被删除了\nconsole.log(container);//Set { 1, 2, 3, 4 }\nconsole.log(container.size);//长度4\nlet unique_arr = [...container];//省略号语法\nconsole.log(unique_arr);//唯一值数组：[ 1, 2, 3, 4 ]\n```\nSet的构造方法可以直接传数组进行初始化，当然也可以这样声明：\n`let mySet = new Set();`\n\nSet跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。\n\n```h\n//简单去重方案\nvar arr = [1,1,2,3,3,3];\nconsole.log([...new Set(arr)]);//一句话搞定\n```\n\n这并不适用于含有`重复对象的数组`，因为对象是比较的是内存地址。\n```h\nconsole.log({}=={});//false,内存地址不同\nlet arr = [{},{},{}];\nconsole.log([...new Set(arr)]);//对象是无法去重的\n```\n\n对象数组到底如何去重呢？\n一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用`Set`的不重复特性，把对象先转成字符串存入`Set`，去掉重复值后，再转回来就好。\n\n```h\nfunction unique(arr){\n var container = new Set();\n//遍历\n arr.forEach(function(val){\n//将对象转换为字符串,存入set容器中，确保唯一性。\n  container.add(JSON.stringify(val));\n });\n\n var newarr = [...container].map(function(item){\n   return JSON.parse(item);//转换回去\n  });\n return newarr;\n}\n```\n\n# 新数据结构：Map\n这个是`Map`容器，而不是前面的`map()`方法，千万别弄混了（注意大小写）！`Map`就是键值对容器，跟`Object`非常类似。它有什么特别之处呢？\n其实`Object`有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。\n如果让键不限于字符串，而是各种数据类型呢？比如num？\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>map</title>\n</head>\n    <body>\n        <div>\n            <button id=\"btn1\">提交</button>\n            <button id=\"btn2\">关闭</button>\n        </div>　　　\n    </body>\n</html>\n<script>\n    var dom1 = document.getElementById('btn1');\n    var dom2 = document.getElementById('btn2');\n\n    var callback1 = function(){\n        alert('提交');\n    };\n    var callback2 = function(){\n        alert('关闭');\n    };\n    const m = new Map();\n    m.set(dom1,callback1); //键是dom\n    m.set(dom2,callback2);\n    console.log(m);\n</script>\n```\n\n![结果：](http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n\n一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了\n\n```h\n\nconst map = new Map();\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n```\n因为对象比较的是内存地址，所以`['a']`作为新开辟的空间，无法在`Map容器`中找到。\n\n再来看一下Map的增查改删，非常简单。\n\n```h\n//利用二维数组，可以构建Map\nconst myMap = new Map([\n ['name', '张三'],\n ['content', 'hello,world']\n]);\nconsole.log(myMap);//Map { 'name' => '张三', 'content' => 'hello,world' }\nconsole.log(myMap.size); // 长度\nmyMap.set('age',18);//增加属性\nconsole.log(myMap.get('name')); //获取属性\nmyMap.delete('content');//删除属性\nconsole.log(myMap.has('content')); // 判断是否有这个属性\nconsole.log(myMap.keys());//获取所有的键 MapIterator { 'name', 'age' }\nconsole.log(myMap.values());//获取所有的值 MapIterator { '张三', 18 }\n```\n\n获取的keys集合是`MapIterator`类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构\n\n# Reflect是面镜子\n\n`Reflect`就是反射的意思，那究竟反射啥呢？\n大家知道镜子可以反射吧？\n`Reflect`就是一面镜子。那是谁照镜子呢？就是`Object`。\n也就是说，`Object`把自己的属于语言内部的方法（比如Object.defineProperty）照到了`Reflect`上。\n\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>利用反射实现数据和视图联动</title>\n\n</head>\n<body>\n<div>\n<div>测试Object：<input type=\"text\" id='userName'/></div>\n<div>测试Reflect：<input type=\"text\" id='age'/></div>\n<div id=\"showName\"></div>\n<div id=\"showAge\"></div>\n</div>　　　\n</body>\n</html>\n<script>\nvar userInfo = {};\n//Object的方式\nObject.defineProperty(userInfo, \"userName\", {\nget: function(){\nreturn document.getElementById('showName').innerHTML;\n},\nset: function(name){\ndocument.getElementById('showName').innerHTML = name;\n}\n});\n\n//Reflect是一面大镜子，Object你有的我就有！\nReflect.defineProperty(userInfo, \"age\", {\nget: function(){\nreturn document.getElementById('showAge').innerHTML;\n},\nset: function(name){\ndocument.getElementById('showAge').innerHTML = name;\n}\n});\n\ndocument.getElementById('userName').onkeyup = function(e){\n\nuserInfo.userName = this.value;\n};\n\ndocument.getElementById('age').onkeyup = function(e){\n\nuserInfo.age = this.value;\n};\n</script>\n```\n\n> `Reflect`一共是13个静态方法，就是13种武器哈：\n```h\n\nReflect.apply(target,thisArg,args)\nReflect.construct(target,args)\nReflect.get(target,name,receiver)\nReflect.set(target,name,value,receiver)\nReflect.defineProperty(target,name,desc)\nReflect.deleteProperty(target,name)\nReflect.has(target,name)\nReflect.ownKeys(target)\nReflect.isExtensible(target)\nReflect.preventExtensions(target)\nReflect.getOwnPropertyDescriptor(target, name)\nReflect.getPrototypeOf(target)\nReflect.setPrototypeOf(target, prototype)\n```\n看下几个常用的方法。\n\n```h\n\nlet obj = {\nname:'jack',\nage:18\n};\n//简单set方法\nReflect.set(obj,'name','tom');\nconsole.log(obj.name);//tom\n//简单get方法\nlet age = Reflect.get(obj,'age');\nconsole.log(age);//18\n\n//带有接收者对象的set方法\nlet receiver = {\nname:'lily'\n};\n//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。\n//所以，obj的name属性还是tom，但接收者receiver的name被改变了。\n//这种机制的作用是，可以在对象A中操作对象B。\nReflect.set(obj,'name','bill',receiver);\n\nconsole.log(obj.name);//tom\nconsole.log(receiver.name);//bill\n//判断obj是否有name属性？\n//旧写法--in\nconsole.log('name' in obj);//true\n//新写法--has\nconsole.log(Reflect.has(obj,'name'));//true\n```\n\n他与`Proxy`结合使用更合理。\n\n# Proxy\n\n`Proxy`就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟`Reflect`是一一对应的。\n只要`Proxy`对象有的方法，`Reflect`对象上都有。当然咯，`Proxy`没有的，`Reflect`也有。\n\n拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：\n`var proxy = new Proxy(target, handler);`\n\n>1.target就是目标对象，我们要给哪个对象加拦截？\n> 2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。\n\n拿最简单的set方法为例:\n\n```h\n//形参说明：\n// target:待测试的Person实例\n// validator:验证规则personValidators\n\nfunction createValidator(target, validator) {\n//拦截器，拦截赋值操作，触发set函数\nreturn new Proxy(target, {\n\n set(target, key, value) {\n//如果待测试的Person对象中含有这个属性，就启用验证规则，\n// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。\n  if (target.hasOwnProperty(key)) {\n\n    let rules = validator[key];//rules拿到的是name方法的引用\n//相当于调用方法name('hello')\n    if (rules(value)) {\n//如果验证无误，target的name属性可以修改成功\n     return Reflect.set(target, key, value);\n    } else {\n//否则失败\n      return 'error';\n   }\n  } else {\n     return 'error';\n  } \n }\n});\n}\n//验证规则\nconst personRules = {\n name(val) {\n   return typeof val === 'string';\n },\n age(val) {\n   return typeof val === 'number' && val > 18;\n }\n};\n//测试类\nclass Person {\n constructor(name, age) {\n   this.name = name;\n   this.age = age;\n//开启验证，传入这个类的实例和验证规则personRules\n   return createValidator(this, personRules);\n }\n}\n\nconst bill = new Person('Bill', 25);\nbill.name = 'jack';//赋值成功\nbill.age = 10;//赋值失败\nconsole.log(bill.name);//jack\nconsole.log(bill.age);//25\n```\n\n`createValidator`这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。\n\n再来看下`Reflect.apply`的用法。这个方法的使用频率还是蛮高的\n\n```h\n//假如这个foo函数是同事张三写的\nvar obj = {};\nfunction foo(){\n\nconsole.log(this);\n}\n\n//李四引入并使用了这个函数\nfoo.apply(obj);\n//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。\n//可以在不依赖函数名的情况下改变函数的作用域么？\nFunction.prototype.apply.call(foo,obj);\n//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。\nReflect.apply(foo,obj,[]);//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错\n```\n\n## 结语\n`Proxy`是用于修改语言内部行为的机制，因为`Object`对象内部的方法大多属于这种情况，所以`handler`的配置，又跟`Reflect`紧密联系在一起（因为Reflect是Object的镜子嘛）。\n应该说，`Reflect`和`Proxy`之间的关系还是不太容易理顺的。\n","slug":"ES6攻略-四","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd3000akt893hlnzd63","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><p>之前的JS只提供了两种容器：<code>数组</code>和<code>对象</code>。es6又添加了另一种非常有用的数据结构：<code>Set</code>。他就是<code>集合</code>的意思，本身也是一种容器。<br>既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？<br>拿他跟数组比较的话，<code>Set</code>的最大的特点就是<code>每个值都是唯一的，不能有重复值</code>。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);<span class=\"comment\">//可以直接传入数组进行初始化</span></span><br><span class=\"line\">container.add(<span class=\"number\">5</span>);<span class=\"comment\">//添加元素</span></span><br><span class=\"line\">container.<span class=\"keyword\">delete</span>(<span class=\"number\">5</span>);<span class=\"comment\">//删除元素</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container.has(<span class=\"number\">5</span>));<span class=\"comment\">//false，5这个元素被删除了</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container);<span class=\"comment\">//Set &#123; 1, 2, 3, 4 &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container.size);<span class=\"comment\">//长度4</span></span><br><span class=\"line\">let unique_arr = [...container];<span class=\"comment\">//省略号语法</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(unique_arr);<span class=\"comment\">//唯一值数组：[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>Set的构造方法可以直接传数组进行初始化，当然也可以这样声明：<br><code>let mySet = new Set();</code></p>\n<p>Set跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单去重方案</span></span><br><span class=\"line\">var arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"keyword\">new</span> Set(arr)]);<span class=\"comment\">//一句话搞定</span></span><br></pre></td></tr></table></figure>\n<p>这并不适用于含有<code>重复对象的数组</code>，因为对象是比较的是内存地址。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.<span class=\"built_in\">log</span>(&#123;&#125;==&#123;&#125;);<span class=\"comment\">//false,内存地址不同</span></span><br><span class=\"line\">let arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"keyword\">new</span> Set(arr)]);<span class=\"comment\">//对象是无法去重的</span></span><br></pre></td></tr></table></figure></p>\n<p>对象数组到底如何去重呢？<br>一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用<code>Set</code>的不重复特性，把对象先转成字符串存入<code>Set</code>，去掉重复值后，再转回来就好。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">unique</span><span class=\"params\">(arr)</span></span>&#123;</span><br><span class=\"line\"> var container = <span class=\"keyword\">new</span> Set();</span><br><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"> arr.forEach(function(val)&#123;</span><br><span class=\"line\"><span class=\"comment\">//将对象转换为字符串,存入set容器中，确保唯一性。</span></span><br><span class=\"line\">  container.add(JSON.stringify(val));</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"> var newarr = [...container].<span class=\"built_in\">map</span>(function(item)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> JSON.parse(item);<span class=\"comment\">//转换回去</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> newarr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"新数据结构：Map\"><a href=\"#新数据结构：Map\" class=\"headerlink\" title=\"新数据结构：Map\"></a>新数据结构：Map</h1><p>这个是<code>Map</code>容器，而不是前面的<code>map()</code>方法，千万别弄混了（注意大小写）！<code>Map</code>就是键值对容器，跟<code>Object</code>非常类似。它有什么特别之处呢？<br>其实<code>Object</code>有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。<br>如果让键不限于字符串，而是各种数据类型呢？比如num？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;<span class=\"built_in\">map</span>&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button id=<span class=\"string\">\"btn1\"</span>&gt;提交&lt;/button&gt;</span><br><span class=\"line\">            &lt;button id=<span class=\"string\">\"btn2\"</span>&gt;关闭&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;　　　</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var dom1 = document.getElementById('btn1');</span><br><span class=\"line\">    var dom2 = document.getElementById('btn2');</span><br><span class=\"line\"></span><br><span class=\"line\">    var callback1 = function()&#123;</span><br><span class=\"line\">        alert('提交');</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var callback2 = function()&#123;</span><br><span class=\"line\">        alert('关闭');</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">    m.<span class=\"built_in\">set</span>(dom1,callback1); <span class=\"comment\">//键是dom</span></span><br><span class=\"line\">    m.<span class=\"built_in\">set</span>(dom2,callback2);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(m);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>\n<p>一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.get([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>因为对象比较的是内存地址，所以<code>[&#39;a&#39;]</code>作为新开辟的空间，无法在<code>Map容器</code>中找到。</p>\n<p>再来看一下Map的增查改删，非常简单。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用二维数组，可以构建Map</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> Map([</span><br><span class=\"line\"> ['name', '张三'],</span><br><span class=\"line\"> ['content', 'hello,world']</span><br><span class=\"line\">]);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap);<span class=\"comment\">//Map &#123; 'name' =&gt; '张三', 'content' =&gt; 'hello,world' &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.size); <span class=\"comment\">// 长度</span></span><br><span class=\"line\">myMap.set('age',18);//增加属性</span><br><span class=\"line\">console.log(myMap.get('name')); //获取属性</span><br><span class=\"line\">myMap.delete('content');//删除属性</span><br><span class=\"line\">console.log(myMap.has('content')); // 判断是否有这个属性</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.keys());<span class=\"comment\">//获取所有的键 MapIterator &#123; 'name', 'age' &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.values());<span class=\"comment\">//获取所有的值 MapIterator &#123; '张三', 18 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>获取的keys集合是<code>MapIterator</code>类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构</p>\n<h1 id=\"Reflect是面镜子\"><a href=\"#Reflect是面镜子\" class=\"headerlink\" title=\"Reflect是面镜子\"></a>Reflect是面镜子</h1><p><code>Reflect</code>就是反射的意思，那究竟反射啥呢？<br>大家知道镜子可以反射吧？<br><code>Reflect</code>就是一面镜子。那是谁照镜子呢？就是<code>Object</code>。<br>也就是说，<code>Object</code>把自己的属于语言内部的方法（比如Object.defineProperty）照到了<code>Reflect</code>上。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;利用反射实现数据和视图联动&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;div&gt;测试Object：&lt;input type=\"text\" id='userName'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;测试Reflect：&lt;input type=\"text\" id='age'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"showName\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"showAge\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var userInfo = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//Object的方式</span></span><br><span class=\"line\">Object.defineProperty(userInfo, <span class=\"string\">\"userName\"</span>, &#123;</span><br><span class=\"line\">get: function()&#123;</span><br><span class=\"line\">return document.getElementById('showName').innerHTML;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">document.getElementById('showName').innerHTML = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Reflect是一面大镜子，Object你有的我就有！</span></span><br><span class=\"line\">Reflect.defineProperty(userInfo, <span class=\"string\">\"age\"</span>, &#123;</span><br><span class=\"line\">get: function()&#123;</span><br><span class=\"line\">return document.getElementById('showAge').innerHTML;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">document.getElementById('showAge').innerHTML = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">userInfo.userName = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('age').onkeyup = function(e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">userInfo.age = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Reflect</code>一共是13个静态方法，就是13种武器哈：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Reflect.apply(target,thisArg,args)</span><br><span class=\"line\">Reflect.construct(target,args)</span><br><span class=\"line\">Reflect.get(target,name,receiver)</span><br><span class=\"line\">Reflect.<span class=\"built_in\">set</span>(target,name,value,receiver)</span><br><span class=\"line\">Reflect.defineProperty(target,name,desc)</span><br><span class=\"line\">Reflect.deleteProperty(target,name)</span><br><span class=\"line\">Reflect.has(target,name)</span><br><span class=\"line\">Reflect.ownKeys(target)</span><br><span class=\"line\">Reflect.isExtensible(target)</span><br><span class=\"line\">Reflect.preventExtensions(target)</span><br><span class=\"line\">Reflect.getOwnPropertyDescriptor(target, name)</span><br><span class=\"line\">Reflect.getPrototypeOf(target)</span><br><span class=\"line\">Reflect.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>看下几个常用的方法。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">name:'jack',</span><br><span class=\"line\">age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//简单set方法</span></span><br><span class=\"line\">Reflect.set(obj,'name','tom');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.name);<span class=\"comment\">//tom</span></span><br><span class=\"line\"><span class=\"comment\">//简单get方法</span></span><br><span class=\"line\">let age = Reflect.get(obj,'age');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(age);<span class=\"comment\">//18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//带有接收者对象的set方法</span></span><br><span class=\"line\">let receiver = &#123;</span><br><span class=\"line\">name:'lily'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。</span></span><br><span class=\"line\"><span class=\"comment\">//所以，obj的name属性还是tom，但接收者receiver的name被改变了。</span></span><br><span class=\"line\"><span class=\"comment\">//这种机制的作用是，可以在对象A中操作对象B。</span></span><br><span class=\"line\">Reflect.set(obj,'name','bill',receiver);</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.name);<span class=\"comment\">//tom</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(receiver.name);<span class=\"comment\">//bill</span></span><br><span class=\"line\"><span class=\"comment\">//判断obj是否有name属性？</span></span><br><span class=\"line\"><span class=\"comment\">//旧写法--in</span></span><br><span class=\"line\">console.log('name' in obj);//true</span><br><span class=\"line\"><span class=\"comment\">//新写法--has</span></span><br><span class=\"line\">console.log(Reflect.has(obj,'name'));//true</span><br></pre></td></tr></table></figure>\n<p>他与<code>Proxy</code>结合使用更合理。</p>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><p><code>Proxy</code>就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟<code>Reflect</code>是一一对应的。<br>只要<code>Proxy</code>对象有的方法，<code>Reflect</code>对象上都有。当然咯，<code>Proxy</code>没有的，<code>Reflect</code>也有。</p>\n<p>拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：<br><code>var proxy = new Proxy(target, handler);</code></p>\n<blockquote>\n<p>1.target就是目标对象，我们要给哪个对象加拦截？<br>2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。</p>\n</blockquote>\n<p>拿最简单的set方法为例:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//形参说明：</span></span><br><span class=\"line\"><span class=\"comment\">// target:待测试的Person实例</span></span><br><span class=\"line\"><span class=\"comment\">// validator:验证规则personValidators</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createValidator</span><span class=\"params\">(target, validator)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//拦截器，拦截赋值操作，触发set函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Proxy(target, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">set</span>(target, key, value) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果待测试的Person对象中含有这个属性，就启用验证规则，</span></span><br><span class=\"line\"><span class=\"comment\">// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let rules = validator[key];<span class=\"comment\">//rules拿到的是name方法的引用</span></span><br><span class=\"line\"><span class=\"comment\">//相当于调用方法name('hello')</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rules(value)) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果验证无误，target的name属性可以修改成功</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Reflect.<span class=\"built_in\">set</span>(target, key, value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//否则失败</span></span><br><span class=\"line\">      return 'error';</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     return 'error';</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//验证规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> personRules = &#123;</span><br><span class=\"line\"> name(val) &#123;</span><br><span class=\"line\">   return typeof val === 'string';</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> age(val) &#123;</span><br><span class=\"line\">   return typeof val === 'number' &amp;&amp; val &gt; 18;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"> constructor(name, age) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\"><span class=\"comment\">//开启验证，传入这个类的实例和验证规则personRules</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> createValidator(<span class=\"keyword\">this</span>, personRules);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bill = new Person('Bill', 25);</span><br><span class=\"line\">bill.name = 'jack';//赋值成功</span><br><span class=\"line\">bill.age = <span class=\"number\">10</span>;<span class=\"comment\">//赋值失败</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bill.name);<span class=\"comment\">//jack</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bill.age);<span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure>\n<p><code>createValidator</code>这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。</p>\n<p>再来看下<code>Reflect.apply</code>的用法。这个方法的使用频率还是蛮高的</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假如这个foo函数是同事张三写的</span></span><br><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//李四引入并使用了这个函数</span></span><br><span class=\"line\">foo.apply(obj);</span><br><span class=\"line\"><span class=\"comment\">//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。</span></span><br><span class=\"line\"><span class=\"comment\">//可以在不依赖函数名的情况下改变函数的作用域么？</span></span><br><span class=\"line\">Function.prototype.apply.call(foo,obj);</span><br><span class=\"line\"><span class=\"comment\">//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。</span></span><br><span class=\"line\">Reflect.apply(foo,obj,[]);<span class=\"comment\">//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p><code>Proxy</code>是用于修改语言内部行为的机制，因为<code>Object</code>对象内部的方法大多属于这种情况，所以<code>handler</code>的配置，又跟<code>Reflect</code>紧密联系在一起（因为Reflect是Object的镜子嘛）。<br>应该说，<code>Reflect</code>和<code>Proxy</code>之间的关系还是不太容易理顺的。</p>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。这里是关于Reflect和Proxy。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><p>之前的JS只提供了两种容器：<code>数组</code>和<code>对象</code>。es6又添加了另一种非常有用的数据结构：<code>Set</code>。他就是<code>集合</code>的意思，本身也是一种容器。<br>既然是容器，肯定有对应的增查改删的操作了。增查改删是容器必备的职能。那么这种新式容器，到底有什么特点呢？<br>拿他跟数组比较的话，<code>Set</code>的最大的特点就是<code>每个值都是唯一的，不能有重复值</code>。经常会遇到数组去重的问题吧？自从有了Set，就开始变得美好了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = <span class=\"keyword\">new</span> Set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);<span class=\"comment\">//可以直接传入数组进行初始化</span></span><br><span class=\"line\">container.add(<span class=\"number\">5</span>);<span class=\"comment\">//添加元素</span></span><br><span class=\"line\">container.<span class=\"keyword\">delete</span>(<span class=\"number\">5</span>);<span class=\"comment\">//删除元素</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container.has(<span class=\"number\">5</span>));<span class=\"comment\">//false，5这个元素被删除了</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container);<span class=\"comment\">//Set &#123; 1, 2, 3, 4 &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(container.size);<span class=\"comment\">//长度4</span></span><br><span class=\"line\">let unique_arr = [...container];<span class=\"comment\">//省略号语法</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(unique_arr);<span class=\"comment\">//唯一值数组：[ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>Set的构造方法可以直接传数组进行初始化，当然也可以这样声明：<br><code>let mySet = new Set();</code></p>\n<p>Set跟数组极为类似，二者可以互相转换着用。有了它，就可以轻松的解决数组去重问题了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单去重方案</span></span><br><span class=\"line\">var arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"keyword\">new</span> Set(arr)]);<span class=\"comment\">//一句话搞定</span></span><br></pre></td></tr></table></figure>\n<p>这并不适用于含有<code>重复对象的数组</code>，因为对象是比较的是内存地址。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.<span class=\"built_in\">log</span>(&#123;&#125;==&#123;&#125;);<span class=\"comment\">//false,内存地址不同</span></span><br><span class=\"line\">let arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"keyword\">new</span> Set(arr)]);<span class=\"comment\">//对象是无法去重的</span></span><br></pre></td></tr></table></figure></p>\n<p>对象数组到底如何去重呢？<br>一种办法是你需要递归比较，两个对象的每一个值是否相等，不等的放入一个新数组中，相等的跳过。但是这个方法很普通，可以利用<code>Set</code>的不重复特性，把对象先转成字符串存入<code>Set</code>，去掉重复值后，再转回来就好。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">unique</span><span class=\"params\">(arr)</span></span>&#123;</span><br><span class=\"line\"> var container = <span class=\"keyword\">new</span> Set();</span><br><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"> arr.forEach(function(val)&#123;</span><br><span class=\"line\"><span class=\"comment\">//将对象转换为字符串,存入set容器中，确保唯一性。</span></span><br><span class=\"line\">  container.add(JSON.stringify(val));</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"> var newarr = [...container].<span class=\"built_in\">map</span>(function(item)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> JSON.parse(item);<span class=\"comment\">//转换回去</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> newarr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"新数据结构：Map\"><a href=\"#新数据结构：Map\" class=\"headerlink\" title=\"新数据结构：Map\"></a>新数据结构：Map</h1><p>这个是<code>Map</code>容器，而不是前面的<code>map()</code>方法，千万别弄混了（注意大小写）！<code>Map</code>就是键值对容器，跟<code>Object</code>非常类似。它有什么特别之处呢？<br>其实<code>Object</code>有个很大的问题：就是键只能用字符串，而不能使用其他数据类型。<br>如果让键不限于字符串，而是各种数据类型呢？比如num？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;<span class=\"built_in\">map</span>&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button id=<span class=\"string\">\"btn1\"</span>&gt;提交&lt;/button&gt;</span><br><span class=\"line\">            &lt;button id=<span class=\"string\">\"btn2\"</span>&gt;关闭&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;　　　</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var dom1 = document.getElementById('btn1');</span><br><span class=\"line\">    var dom2 = document.getElementById('btn2');</span><br><span class=\"line\"></span><br><span class=\"line\">    var callback1 = function()&#123;</span><br><span class=\"line\">        alert('提交');</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var callback2 = function()&#123;</span><br><span class=\"line\">        alert('关闭');</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">    m.<span class=\"built_in\">set</span>(dom1,callback1); <span class=\"comment\">//键是dom</span></span><br><span class=\"line\">    m.<span class=\"built_in\">set</span>(dom2,callback2);</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(m);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nZRR0oA8QqZfcQGqUNYUJzkRiclCN5500iaJhsyUpyjt8bu7xM47zaUoDJibSN1iazVaKN9wQjLkctgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"结果：\"></p>\n<p>一般来说，对象的键应该是唯一的。Object的键因为是字符串，所以没啥问题，但Map既然放开了类型限制，这就得注意了</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.get([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>因为对象比较的是内存地址，所以<code>[&#39;a&#39;]</code>作为新开辟的空间，无法在<code>Map容器</code>中找到。</p>\n<p>再来看一下Map的增查改删，非常简单。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用二维数组，可以构建Map</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> Map([</span><br><span class=\"line\"> ['name', '张三'],</span><br><span class=\"line\"> ['content', 'hello,world']</span><br><span class=\"line\">]);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap);<span class=\"comment\">//Map &#123; 'name' =&gt; '张三', 'content' =&gt; 'hello,world' &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.size); <span class=\"comment\">// 长度</span></span><br><span class=\"line\">myMap.set('age',18);//增加属性</span><br><span class=\"line\">console.log(myMap.get('name')); //获取属性</span><br><span class=\"line\">myMap.delete('content');//删除属性</span><br><span class=\"line\">console.log(myMap.has('content')); // 判断是否有这个属性</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.keys());<span class=\"comment\">//获取所有的键 MapIterator &#123; 'name', 'age' &#125;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(myMap.values());<span class=\"comment\">//获取所有的值 MapIterator &#123; '张三', 18 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>获取的keys集合是<code>MapIterator</code>类型的，这叫遍历器。顾名思义，就是专供遍历用的一种数据结构</p>\n<h1 id=\"Reflect是面镜子\"><a href=\"#Reflect是面镜子\" class=\"headerlink\" title=\"Reflect是面镜子\"></a>Reflect是面镜子</h1><p><code>Reflect</code>就是反射的意思，那究竟反射啥呢？<br>大家知道镜子可以反射吧？<br><code>Reflect</code>就是一面镜子。那是谁照镜子呢？就是<code>Object</code>。<br>也就是说，<code>Object</code>把自己的属于语言内部的方法（比如Object.defineProperty）照到了<code>Reflect</code>上。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;利用反射实现数据和视图联动&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;div&gt;测试Object：&lt;input type=\"text\" id='userName'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;测试Reflect：&lt;input type=\"text\" id='age'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"showName\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"showAge\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var userInfo = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//Object的方式</span></span><br><span class=\"line\">Object.defineProperty(userInfo, <span class=\"string\">\"userName\"</span>, &#123;</span><br><span class=\"line\">get: function()&#123;</span><br><span class=\"line\">return document.getElementById('showName').innerHTML;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">document.getElementById('showName').innerHTML = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Reflect是一面大镜子，Object你有的我就有！</span></span><br><span class=\"line\">Reflect.defineProperty(userInfo, <span class=\"string\">\"age\"</span>, &#123;</span><br><span class=\"line\">get: function()&#123;</span><br><span class=\"line\">return document.getElementById('showAge').innerHTML;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">document.getElementById('showAge').innerHTML = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">userInfo.userName = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('age').onkeyup = function(e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">userInfo.age = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Reflect</code>一共是13个静态方法，就是13种武器哈：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Reflect.apply(target,thisArg,args)</span><br><span class=\"line\">Reflect.construct(target,args)</span><br><span class=\"line\">Reflect.get(target,name,receiver)</span><br><span class=\"line\">Reflect.<span class=\"built_in\">set</span>(target,name,value,receiver)</span><br><span class=\"line\">Reflect.defineProperty(target,name,desc)</span><br><span class=\"line\">Reflect.deleteProperty(target,name)</span><br><span class=\"line\">Reflect.has(target,name)</span><br><span class=\"line\">Reflect.ownKeys(target)</span><br><span class=\"line\">Reflect.isExtensible(target)</span><br><span class=\"line\">Reflect.preventExtensions(target)</span><br><span class=\"line\">Reflect.getOwnPropertyDescriptor(target, name)</span><br><span class=\"line\">Reflect.getPrototypeOf(target)</span><br><span class=\"line\">Reflect.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>看下几个常用的方法。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">name:'jack',</span><br><span class=\"line\">age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//简单set方法</span></span><br><span class=\"line\">Reflect.set(obj,'name','tom');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.name);<span class=\"comment\">//tom</span></span><br><span class=\"line\"><span class=\"comment\">//简单get方法</span></span><br><span class=\"line\">let age = Reflect.get(obj,'age');</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(age);<span class=\"comment\">//18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//带有接收者对象的set方法</span></span><br><span class=\"line\">let receiver = &#123;</span><br><span class=\"line\">name:'lily'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//意思就是：发起者是obj，把name属性改为bill，但这个动作的接收者是receiver。</span></span><br><span class=\"line\"><span class=\"comment\">//所以，obj的name属性还是tom，但接收者receiver的name被改变了。</span></span><br><span class=\"line\"><span class=\"comment\">//这种机制的作用是，可以在对象A中操作对象B。</span></span><br><span class=\"line\">Reflect.set(obj,'name','bill',receiver);</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.name);<span class=\"comment\">//tom</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(receiver.name);<span class=\"comment\">//bill</span></span><br><span class=\"line\"><span class=\"comment\">//判断obj是否有name属性？</span></span><br><span class=\"line\"><span class=\"comment\">//旧写法--in</span></span><br><span class=\"line\">console.log('name' in obj);//true</span><br><span class=\"line\"><span class=\"comment\">//新写法--has</span></span><br><span class=\"line\">console.log(Reflect.has(obj,'name'));//true</span><br></pre></td></tr></table></figure>\n<p>他与<code>Proxy</code>结合使用更合理。</p>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><p><code>Proxy</code>就是拦截器，也可以译为代理器，跟设计模式的代理模式差不多。他跟<code>Reflect</code>是一一对应的。<br>只要<code>Proxy</code>对象有的方法，<code>Reflect</code>对象上都有。当然咯，<code>Proxy</code>没有的，<code>Reflect</code>也有。</p>\n<p>拦截器本身也是对象，他的主要作用在于拦截。看一下语法定义：<br><code>var proxy = new Proxy(target, handler);</code></p>\n<blockquote>\n<p>1.target就是目标对象，我们要给哪个对象加拦截？<br>2.handler就是处理对象，他是一系列拦截操作的集合。这些拦截操作，就是对应的Reflect具有的十三种静态方法（所谓的一一对应其实就是说的这个）。注意，只有这十三种武器，不支持其他的。</p>\n</blockquote>\n<p>拿最简单的set方法为例:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//形参说明：</span></span><br><span class=\"line\"><span class=\"comment\">// target:待测试的Person实例</span></span><br><span class=\"line\"><span class=\"comment\">// validator:验证规则personValidators</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">createValidator</span><span class=\"params\">(target, validator)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//拦截器，拦截赋值操作，触发set函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Proxy(target, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">set</span>(target, key, value) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果待测试的Person对象中含有这个属性，就启用验证规则，</span></span><br><span class=\"line\"><span class=\"comment\">// 验证规则的方法：name(val)和age(val)，名称需要跟传入的属性key一致。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let rules = validator[key];<span class=\"comment\">//rules拿到的是name方法的引用</span></span><br><span class=\"line\"><span class=\"comment\">//相当于调用方法name('hello')</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rules(value)) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果验证无误，target的name属性可以修改成功</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Reflect.<span class=\"built_in\">set</span>(target, key, value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//否则失败</span></span><br><span class=\"line\">      return 'error';</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     return 'error';</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//验证规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> personRules = &#123;</span><br><span class=\"line\"> name(val) &#123;</span><br><span class=\"line\">   return typeof val === 'string';</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> age(val) &#123;</span><br><span class=\"line\">   return typeof val === 'number' &amp;&amp; val &gt; 18;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"> constructor(name, age) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\"><span class=\"comment\">//开启验证，传入这个类的实例和验证规则personRules</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> createValidator(<span class=\"keyword\">this</span>, personRules);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bill = new Person('Bill', 25);</span><br><span class=\"line\">bill.name = 'jack';//赋值成功</span><br><span class=\"line\">bill.age = <span class=\"number\">10</span>;<span class=\"comment\">//赋值失败</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bill.name);<span class=\"comment\">//jack</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bill.age);<span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure>\n<p><code>createValidator</code>这个函数，返回的是Proxy拦截器对象。这个拦截器对象，对原Person类的set操作做了修改，加入了一些验证方案，其实就是起到了包装增强的作用，让Person具有了可验证字段类型的功能。</p>\n<p>再来看下<code>Reflect.apply</code>的用法。这个方法的使用频率还是蛮高的</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假如这个foo函数是同事张三写的</span></span><br><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//李四引入并使用了这个函数</span></span><br><span class=\"line\">foo.apply(obj);</span><br><span class=\"line\"><span class=\"comment\">//这时，如果张三把函数名改成了bar,如果没及时通知到李四，那么李四的调用就会报错了。</span></span><br><span class=\"line\"><span class=\"comment\">//可以在不依赖函数名的情况下改变函数的作用域么？</span></span><br><span class=\"line\">Function.prototype.apply.call(foo,obj);</span><br><span class=\"line\"><span class=\"comment\">//这种写法太长了，可以使用反射Reflect给我们提供的简单方法。</span></span><br><span class=\"line\">Reflect.apply(foo,obj,[]);<span class=\"comment\">//要注意，apply最后一个参数要跟数组，这个没有的话也得传[]，否则报错</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p><code>Proxy</code>是用于修改语言内部行为的机制，因为<code>Object</code>对象内部的方法大多属于这种情况，所以<code>handler</code>的配置，又跟<code>Reflect</code>紧密联系在一起（因为Reflect是Object的镜子嘛）。<br>应该说，<code>Reflect</code>和<code>Proxy</code>之间的关系还是不太容易理顺的。</p>"},{"title":"ES6攻略","date":"2018-05-24T16:17:09.000Z","description":null,"copyright":false,"top":null,"_content":"ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 搞定变量作用域问题：let\nES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。\nes6引入了let这个关键字，问题得到了解决：\n```h\nlet i=100;\n//循环语句1\nfor(let i=0;i<10;i++){}\nconsole.log(i);//100\n//循环语句2\nwhile(true){\n    let i=11;\n    break;\n}\nconsole.log(i);//100\n//分支语句\nif(true){\n    let i=111;\n}\nelse{\n    let i=0;\n}\nconsole.log(i);//100\n```\nlet关键字让变量作用域变得清晰可控\n# 利用const，保证全局变量不被更改\n有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。\n```h\nconst username = \"jack\";\n//重新声明\nvar username = 'hello';\n//直接修改\nusername = 123;\nconsole.log(username);\n```\n# 类的声明与继承\n按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到`高内聚低耦合`的设计目的。\n其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。\n而es6引入了静态语言的`class`之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。\n```h\n\nclass Animal {\n//构造函数，注意函数之间不用加;\n constructor(){\n  this.type = 'animal';\n }\n says(say){\n  console.log(this.type + ' says ' + say);\n }\n}\n\nlet animal = new Animal();\nanimal.says('hello'); //animal says hello\n\nclass Cat extends Animal {\n constructor(){\n super();//继承了父类的属性和方法\n this.type = 'cat';\n }\n}\n\nlet cat = new Cat();\ncat.says('hello'); //cat says hello\n```\n# 箭头函数，解决this指向问题\nJS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：\n```h\n\nclass Animal {\n constructor(){\n this.type = 'animal';\n }\n says(say){\n  setTimeout(function(){\n   console.log(this.type + ' says ' + say);\n  }, 1000);\n }\n}\n\nvar animal = new Animal();\nanimal.says('hi'); //undefined says hi\n```\n这是一个比较经典的this被篡改的问题，因为这个该死的`setTimeout`函数，他的`this`指向的是window对象。\n我们可以利用一个变量保存住这个`this`指针，也或者使用`bind(this)`方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。\n```h\nclass Animal {\n constructor(){\n  this.type = 'animal';\n }\n says(say){\n  setTimeout( () => {\n   console.log(this.type + ' says ' + say);\n  }, 1000);\n }\n}\nvar animal = new Animal();\nanimal.says('hi'); //animal says hi\n```\n# 插入大段html文本\n这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟`html`拼接好，最后追加到某个div下。\n拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。\n如果能不改变html的结构就好了！于是es6引入了`模板字串`的概念。\n```h\n\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n<div id=\"container\"></div>\n</body>\n</html>\n<script>\nvar cont = document.getElementById('container');\n//一些变量\nvar name = 'jack';\nvar age = 18;\ncont.innerHTML =\n `<div style=\"color:red;\">\n   <span class=\"name\">${name}</span>\n   <b class=\"age\">${age}</b>\n  </div>`;\n```\n在`反引号`中随意使用各种引号，其中的变量都用`${}`来表示。这样代码就变得优雅了。\n# 默认值default\n有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。\n那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。\n```h\nfunction hello(name){\n name = name || 'jack';\n\n console.log(name+' say hello!');\n}\nhello();\n```\n但这样写不够直观，es6提供了默认值的写法。\n```h\nfunction hello(name ='jack'){\n console.log(name + ' say hello!');\n}\nhello();\n```\n# 省略号语法\n省略号是一种语法糖，在处理函数不定参时十分有用。\n像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。\n```h\nfunction hello(a,b,...others){\nconsole.log(others);//[ 'amily', 'mike', 'sam' ]\n}\nhello('jack','tom','amily','mike','sam');\n```\n# Object几个好用的扩展\n> Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。\n\n- 1.`assign()`方法：用于对象的合并或拷贝。\n```h\n//对象合并\nvar target = {a:1};\nvar source = {b:2};\nObject.assign(target,source);\nconsole.log(target);//{a: 1, b: 2}\n```\n> 注意，拷贝是浅拷贝，而不是深拷贝。\n\n```h\n//对象拷贝，是浅拷贝。\nlet target = { a: { b: 'hello'} };\nlet source = { c: { d: 'world' } };\nObject.assign(target, source);\nconsole.log(target);//{ a: { b: 'hello' }, c: { d: 'world' } }\ntarget.c.d = 'haha';\nconsole.log(source);//{ c: { d: 'haha' } }\n```\n如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。\n究竟是用哪种拷贝，得看实际应用场景。\n\n- 2.`defineProperty()`方法：双向绑定的秘密！\n\n在angular或vue等框架里，对双向绑定并不陌生。\n数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？\n我们可以通过这个es6新提供的方法轻松搞定它。\n先来看一下用法：\n```h\nObject.defineProperty(obj, prop, descriptor) \nobj：待修改的对象。\nprop：待修改的属性名称。\ndescriptor：待修改属性的相关描述，要求传入一个对象。\n{\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: '',\n    set: function(){},\n    get: function(){}\n}\n\n\n- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ delete ），是否可以修改属性的 writable 、 enumerable 属性。\n- enumerable：属性是否可遍历出来（可通过 for...in 遍历到）。\n- writable：属性是否可重写（是否可以对属性进行重新赋值？）\n- value：属性的默认值。\n- set：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。\n- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。\n```\n看个例子：\n```h\nvar obj = {};\n//给obj对象赋予了一个属性name，值为jack\nObject.defineProperty(obj, 'name', {\n value: 'jack'\n});\n//给obj对象赋予了一个属性age，值为100\nObject.defineProperty(obj, 'age', {\n value: 100,\n configurable: true,//可配置\n enumerable: true,//可遍历出来\n writable: true//可写\n});\n\nconsole.log(obj.age); // 100\n\nobj.age = 18;//重写\nconsole.log(obj.age); // 18. 因为age属性是可重写的\n//遍历obj\nfor(let key in obj){\n console.log(key+\":\"+obj[key]);//age:18，默认是不可配置的，所以name读不到\n}\n//给obj对象赋予了一个属性sex，值为male\nObject.defineProperty(obj, 'sex', {\n value: 'male',\n writable: false\n});\n\nobj.sex = 'female'; // 不可重写\nconsole.log(obj.sex); // 'male'\n\ndelete obj.sex; // 属性删除无效，默认是不可配置的\n\nconsole.log(obj.sex);// 'male'，依然可以读出\n\nObject.defineProperty(obj, 'weight', {\n//value: '75kg',//如果打开这个value就会报错\n set: function(str) {\nconsole.log('set weight',str);\n},\n get:function(){\nconsole.log('get weight');\n}\n});\n```\n需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。\n下面就来看一下如何实现一个数据和视图双向绑定效果。\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>数据和视图联动</title>\n\n</head>\n<body>\n<div>\n<div>测试用户名：<input type=\"text\" id='userName'/></div>\n<div id=\"show\"></div>\n</div>　　　\n</body>\n</html>\n<script>\nvar userInfo = {};\nObject.defineProperty(userInfo, \"userName\", {\n get: function(){\n  return document.getElementById('show').innerHTML;\n },\n set: function(name){\n  document.getElementById('show').innerHTML = name;\n }\n});\n\ndocument.getElementById('userName').onkeyup = function(e){\n//改变数据，触发set方法，从而改变了视图。\n userInfo.userName = this.value;\n};\n</script>\n```\n运行效果：\n![运行效果：](ES6攻略/01.png)\n\n- 3.对象简写\nes6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：\n```h\nvar obj = {\n name:'jack',\n age:18,\n method() {\n   return this.name+'--'+this.age;\n }\n};\nconsole.log(obj.method());\n```\n","source":"_posts/ES6攻略.md","raw":"---\ntitle: ES6攻略\ndate: 2018-05-25 00:17:09\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\nES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 搞定变量作用域问题：let\nES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。\nes6引入了let这个关键字，问题得到了解决：\n```h\nlet i=100;\n//循环语句1\nfor(let i=0;i<10;i++){}\nconsole.log(i);//100\n//循环语句2\nwhile(true){\n    let i=11;\n    break;\n}\nconsole.log(i);//100\n//分支语句\nif(true){\n    let i=111;\n}\nelse{\n    let i=0;\n}\nconsole.log(i);//100\n```\nlet关键字让变量作用域变得清晰可控\n# 利用const，保证全局变量不被更改\n有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。\n```h\nconst username = \"jack\";\n//重新声明\nvar username = 'hello';\n//直接修改\nusername = 123;\nconsole.log(username);\n```\n# 类的声明与继承\n按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到`高内聚低耦合`的设计目的。\n其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。\n而es6引入了静态语言的`class`之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。\n```h\n\nclass Animal {\n//构造函数，注意函数之间不用加;\n constructor(){\n  this.type = 'animal';\n }\n says(say){\n  console.log(this.type + ' says ' + say);\n }\n}\n\nlet animal = new Animal();\nanimal.says('hello'); //animal says hello\n\nclass Cat extends Animal {\n constructor(){\n super();//继承了父类的属性和方法\n this.type = 'cat';\n }\n}\n\nlet cat = new Cat();\ncat.says('hello'); //cat says hello\n```\n# 箭头函数，解决this指向问题\nJS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：\n```h\n\nclass Animal {\n constructor(){\n this.type = 'animal';\n }\n says(say){\n  setTimeout(function(){\n   console.log(this.type + ' says ' + say);\n  }, 1000);\n }\n}\n\nvar animal = new Animal();\nanimal.says('hi'); //undefined says hi\n```\n这是一个比较经典的this被篡改的问题，因为这个该死的`setTimeout`函数，他的`this`指向的是window对象。\n我们可以利用一个变量保存住这个`this`指针，也或者使用`bind(this)`方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。\n```h\nclass Animal {\n constructor(){\n  this.type = 'animal';\n }\n says(say){\n  setTimeout( () => {\n   console.log(this.type + ' says ' + say);\n  }, 1000);\n }\n}\nvar animal = new Animal();\nanimal.says('hi'); //animal says hi\n```\n# 插入大段html文本\n这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟`html`拼接好，最后追加到某个div下。\n拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。\n如果能不改变html的结构就好了！于是es6引入了`模板字串`的概念。\n```h\n\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n<div id=\"container\"></div>\n</body>\n</html>\n<script>\nvar cont = document.getElementById('container');\n//一些变量\nvar name = 'jack';\nvar age = 18;\ncont.innerHTML =\n `<div style=\"color:red;\">\n   <span class=\"name\">${name}</span>\n   <b class=\"age\">${age}</b>\n  </div>`;\n```\n在`反引号`中随意使用各种引号，其中的变量都用`${}`来表示。这样代码就变得优雅了。\n# 默认值default\n有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。\n那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。\n```h\nfunction hello(name){\n name = name || 'jack';\n\n console.log(name+' say hello!');\n}\nhello();\n```\n但这样写不够直观，es6提供了默认值的写法。\n```h\nfunction hello(name ='jack'){\n console.log(name + ' say hello!');\n}\nhello();\n```\n# 省略号语法\n省略号是一种语法糖，在处理函数不定参时十分有用。\n像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。\n```h\nfunction hello(a,b,...others){\nconsole.log(others);//[ 'amily', 'mike', 'sam' ]\n}\nhello('jack','tom','amily','mike','sam');\n```\n# Object几个好用的扩展\n> Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。\n\n- 1.`assign()`方法：用于对象的合并或拷贝。\n```h\n//对象合并\nvar target = {a:1};\nvar source = {b:2};\nObject.assign(target,source);\nconsole.log(target);//{a: 1, b: 2}\n```\n> 注意，拷贝是浅拷贝，而不是深拷贝。\n\n```h\n//对象拷贝，是浅拷贝。\nlet target = { a: { b: 'hello'} };\nlet source = { c: { d: 'world' } };\nObject.assign(target, source);\nconsole.log(target);//{ a: { b: 'hello' }, c: { d: 'world' } }\ntarget.c.d = 'haha';\nconsole.log(source);//{ c: { d: 'haha' } }\n```\n如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。\n究竟是用哪种拷贝，得看实际应用场景。\n\n- 2.`defineProperty()`方法：双向绑定的秘密！\n\n在angular或vue等框架里，对双向绑定并不陌生。\n数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？\n我们可以通过这个es6新提供的方法轻松搞定它。\n先来看一下用法：\n```h\nObject.defineProperty(obj, prop, descriptor) \nobj：待修改的对象。\nprop：待修改的属性名称。\ndescriptor：待修改属性的相关描述，要求传入一个对象。\n{\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: '',\n    set: function(){},\n    get: function(){}\n}\n\n\n- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ delete ），是否可以修改属性的 writable 、 enumerable 属性。\n- enumerable：属性是否可遍历出来（可通过 for...in 遍历到）。\n- writable：属性是否可重写（是否可以对属性进行重新赋值？）\n- value：属性的默认值。\n- set：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。\n- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。\n```\n看个例子：\n```h\nvar obj = {};\n//给obj对象赋予了一个属性name，值为jack\nObject.defineProperty(obj, 'name', {\n value: 'jack'\n});\n//给obj对象赋予了一个属性age，值为100\nObject.defineProperty(obj, 'age', {\n value: 100,\n configurable: true,//可配置\n enumerable: true,//可遍历出来\n writable: true//可写\n});\n\nconsole.log(obj.age); // 100\n\nobj.age = 18;//重写\nconsole.log(obj.age); // 18. 因为age属性是可重写的\n//遍历obj\nfor(let key in obj){\n console.log(key+\":\"+obj[key]);//age:18，默认是不可配置的，所以name读不到\n}\n//给obj对象赋予了一个属性sex，值为male\nObject.defineProperty(obj, 'sex', {\n value: 'male',\n writable: false\n});\n\nobj.sex = 'female'; // 不可重写\nconsole.log(obj.sex); // 'male'\n\ndelete obj.sex; // 属性删除无效，默认是不可配置的\n\nconsole.log(obj.sex);// 'male'，依然可以读出\n\nObject.defineProperty(obj, 'weight', {\n//value: '75kg',//如果打开这个value就会报错\n set: function(str) {\nconsole.log('set weight',str);\n},\n get:function(){\nconsole.log('get weight');\n}\n});\n```\n需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。\n下面就来看一下如何实现一个数据和视图双向绑定效果。\n```h\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n<meta charset=\"UTF-8\">\n<title>数据和视图联动</title>\n\n</head>\n<body>\n<div>\n<div>测试用户名：<input type=\"text\" id='userName'/></div>\n<div id=\"show\"></div>\n</div>　　　\n</body>\n</html>\n<script>\nvar userInfo = {};\nObject.defineProperty(userInfo, \"userName\", {\n get: function(){\n  return document.getElementById('show').innerHTML;\n },\n set: function(name){\n  document.getElementById('show').innerHTML = name;\n }\n});\n\ndocument.getElementById('userName').onkeyup = function(e){\n//改变数据，触发set方法，从而改变了视图。\n userInfo.userName = this.value;\n};\n</script>\n```\n运行效果：\n![运行效果：](ES6攻略/01.png)\n\n- 3.对象简写\nes6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：\n```h\nvar obj = {\n name:'jack',\n age:18,\n method() {\n   return this.name+'--'+this.age;\n }\n};\nconsole.log(obj.method());\n```\n","slug":"ES6攻略","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd5000bkt89ml6ilgpv","content":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"搞定变量作用域问题：let\"><a href=\"#搞定变量作用域问题：let\" class=\"headerlink\" title=\"搞定变量作用域问题：let\"></a>搞定变量作用域问题：let</h1><p>ES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。<br>es6引入了let这个关键字，问题得到了解决：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let i=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//循环语句1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br><span class=\"line\"><span class=\"comment\">//循环语句2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">11</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br><span class=\"line\"><span class=\"comment\">//分支语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">111</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure></p>\n<p>let关键字让变量作用域变得清晰可控</p>\n<h1 id=\"利用const，保证全局变量不被更改\"><a href=\"#利用const，保证全局变量不被更改\" class=\"headerlink\" title=\"利用const，保证全局变量不被更改\"></a>利用const，保证全局变量不被更改</h1><p>有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"string\">\"jack\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//重新声明</span></span><br><span class=\"line\">var username = 'hello';</span><br><span class=\"line\"><span class=\"comment\">//直接修改</span></span><br><span class=\"line\">username = <span class=\"number\">123</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(username);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"类的声明与继承\"><a href=\"#类的声明与继承\" class=\"headerlink\" title=\"类的声明与继承\"></a>类的声明与继承</h1><p>按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到<code>高内聚低耦合</code>的设计目的。<br>其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。<br>而es6引入了静态语言的<code>class</code>之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//构造函数，注意函数之间不用加;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\">  this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  console.log(this.type + ' says ' + say);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hello'); //animal says hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\"> super();<span class=\"comment\">//继承了父类的属性和方法</span></span><br><span class=\"line\"> this.type = 'cat';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.says('hello'); //cat says hello</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"箭头函数，解决this指向问题\"><a href=\"#箭头函数，解决this指向问题\" class=\"headerlink\" title=\"箭头函数，解决this指向问题\"></a>箭头函数，解决this指向问题</h1><p>JS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\"> this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  setTimeout(function()&#123;</span><br><span class=\"line\">   console.log(this.type + ' says ' + say);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hi'); //undefined says hi</span><br></pre></td></tr></table></figure></p>\n<p>这是一个比较经典的this被篡改的问题，因为这个该死的<code>setTimeout</code>函数，他的<code>this</code>指向的是window对象。<br>我们可以利用一个变量保存住这个<code>this</code>指针，也或者使用<code>bind(this)</code>方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\">  this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  setTimeout( () =&gt; &#123;</span><br><span class=\"line\">   console.log(this.type + ' says ' + say);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hi'); //animal says hi</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"插入大段html文本\"><a href=\"#插入大段html文本\" class=\"headerlink\" title=\"插入大段html文本\"></a>插入大段html文本</h1><p>这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟<code>html</code>拼接好，最后追加到某个div下。<br>拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。<br>如果能不改变html的结构就好了！于是es6引入了<code>模板字串</code>的概念。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"container\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var cont = document.getElementById('container');</span><br><span class=\"line\"><span class=\"comment\">//一些变量</span></span><br><span class=\"line\">var name = 'jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\">cont.innerHTML =</span><br><span class=\"line\"> `&lt;div style=<span class=\"string\">\"color:red;\"</span>&gt;</span><br><span class=\"line\">   &lt;span class=<span class=\"string\">\"name\"</span>&gt;$&#123;name&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;b class=<span class=\"string\">\"age\"</span>&gt;$&#123;age&#125;&lt;/b&gt;</span><br><span class=\"line\">  &lt;/div&gt;`;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>反引号</code>中随意使用各种引号，其中的变量都用<code>${}</code>来表示。这样代码就变得优雅了。</p>\n<h1 id=\"默认值default\"><a href=\"#默认值default\" class=\"headerlink\" title=\"默认值default\"></a>默认值default</h1><p>有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。<br>那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">hello</span><span class=\"params\">(name)</span></span>&#123;</span><br><span class=\"line\"> name = name || 'jack';</span><br><span class=\"line\"></span><br><span class=\"line\"> console.log(name+' say hello!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br></pre></td></tr></table></figure></p>\n<p>但这样写不够直观，es6提供了默认值的写法。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hello(name ='jack')&#123;</span><br><span class=\"line\"> console.log(name + ' say hello!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"省略号语法\"><a href=\"#省略号语法\" class=\"headerlink\" title=\"省略号语法\"></a>省略号语法</h1><p>省略号是一种语法糖，在处理函数不定参时十分有用。<br>像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">hello</span><span class=\"params\">(a,b,...others)</span></span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(others);<span class=\"comment\">//[ 'amily', 'mike', 'sam' ]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello('jack','tom','amily','mike','sam');</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Object几个好用的扩展\"><a href=\"#Object几个好用的扩展\" class=\"headerlink\" title=\"Object几个好用的扩展\"></a>Object几个好用的扩展</h1><blockquote>\n<p>Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。</p>\n</blockquote>\n<ul>\n<li>1.<code>assign()</code>方法：用于对象的合并或拷贝。<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象合并</span></span><br><span class=\"line\">var target = &#123;a:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">var source = &#123;b:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">Object.assign(target,source);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(target);<span class=\"comment\">//&#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意，拷贝是浅拷贝，而不是深拷贝。</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象拷贝，是浅拷贝。</span></span><br><span class=\"line\">let target = &#123; a: &#123; b: 'hello'&#125; &#125;;</span><br><span class=\"line\">let source = &#123; c: &#123; d: 'world' &#125; &#125;;</span><br><span class=\"line\">Object.assign(target, source);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(target);<span class=\"comment\">//&#123; a: &#123; b: 'hello' &#125;, c: &#123; d: 'world' &#125; &#125;</span></span><br><span class=\"line\">target.c.d = 'haha';</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source);<span class=\"comment\">//&#123; c: &#123; d: 'haha' &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。<br>究竟是用哪种拷贝，得看实际应用场景。</p>\n<ul>\n<li>2.<code>defineProperty()</code>方法：双向绑定的秘密！</li>\n</ul>\n<p>在angular或vue等框架里，对双向绑定并不陌生。<br>数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？<br>我们可以通过这个es6新提供的方法轻松搞定它。<br>先来看一下用法：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(obj, prop, descriptor) </span><br><span class=\"line\">obj：待修改的对象。</span><br><span class=\"line\">prop：待修改的属性名称。</span><br><span class=\"line\">descriptor：待修改属性的相关描述，要求传入一个对象。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    value: '',</span><br><span class=\"line\">    <span class=\"built_in\">set</span>: function()&#123;&#125;,</span><br><span class=\"line\">    get: function()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ <span class=\"keyword\">delete</span> ），是否可以修改属性的 writable 、 enumerable 属性。</span><br><span class=\"line\">- enumerable：属性是否可遍历出来（可通过 <span class=\"keyword\">for</span>...in 遍历到）。</span><br><span class=\"line\">- writable：属性是否可重写（是否可以对属性进行重新赋值？）</span><br><span class=\"line\">- value：属性的默认值。</span><br><span class=\"line\">- <span class=\"built_in\">set</span>：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。</span><br><span class=\"line\">- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。</span><br></pre></td></tr></table></figure></p>\n<p>看个例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性name，值为jack</span></span><br><span class=\"line\">Object.defineProperty(obj, 'name', &#123;</span><br><span class=\"line\"> value: 'jack'</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性age，值为100</span></span><br><span class=\"line\">Object.defineProperty(obj, 'age', &#123;</span><br><span class=\"line\"> value: <span class=\"number\">100</span>,</span><br><span class=\"line\"> configurable: <span class=\"literal\">true</span>,<span class=\"comment\">//可配置</span></span><br><span class=\"line\"> enumerable: <span class=\"literal\">true</span>,<span class=\"comment\">//可遍历出来</span></span><br><span class=\"line\"> writable: <span class=\"literal\">true</span><span class=\"comment\">//可写</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.age); <span class=\"comment\">// 100</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.age = <span class=\"number\">18</span>;<span class=\"comment\">//重写</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.age); <span class=\"comment\">// 18. 因为age属性是可重写的</span></span><br><span class=\"line\"><span class=\"comment\">//遍历obj</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let key in obj)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(key+<span class=\"string\">\":\"</span>+obj[key]);<span class=\"comment\">//age:18，默认是不可配置的，所以name读不到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性sex，值为male</span></span><br><span class=\"line\">Object.defineProperty(obj, 'sex', &#123;</span><br><span class=\"line\"> value: 'male',</span><br><span class=\"line\"> writable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sex = 'female'; // 不可重写</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.sex); <span class=\"comment\">// 'male'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.sex; <span class=\"comment\">// 属性删除无效，默认是不可配置的</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.sex);<span class=\"comment\">// 'male'，依然可以读出</span></span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(obj, 'weight', &#123;</span><br><span class=\"line\"><span class=\"comment\">//value: '75kg',//如果打开这个value就会报错</span></span><br><span class=\"line\"> <span class=\"built_in\">set</span>: function(str) &#123;</span><br><span class=\"line\">console.log('set weight',str);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"> get:function()&#123;</span><br><span class=\"line\">console.log('get weight');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。<br>下面就来看一下如何实现一个数据和视图双向绑定效果。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;数据和视图联动&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;div&gt;测试用户名：&lt;input type=\"text\" id='userName'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"show\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var userInfo = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(userInfo, <span class=\"string\">\"userName\"</span>, &#123;</span><br><span class=\"line\"> get: function()&#123;</span><br><span class=\"line\">  return document.getElementById('show').innerHTML;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">  document.getElementById('show').innerHTML = name;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class=\"line\"><span class=\"comment\">//改变数据，触发set方法，从而改变了视图。</span></span><br><span class=\"line\"> userInfo.userName = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行效果：<br><img src=\"/blog/2018/05/25/ES6攻略/01.png\" alt=\"运行效果：\"></p>\n<ul>\n<li>3.对象简写<br>es6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\"> name:'jack',</span><br><span class=\"line\"> age:<span class=\"number\">18</span>,</span><br><span class=\"line\"> method() &#123;</span><br><span class=\"line\">   return this.name+'--'+this.age;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.method());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>ES6的改版，主要是通过引入JAVA等静态语言的优秀思想来解决老版本的一些痼疾，如作用域，回调，继承和封装等问题。这些改革措施是非常成功的，ES6让JS真正变成了一种好用的语言。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"搞定变量作用域问题：let\"><a href=\"#搞定变量作用域问题：let\" class=\"headerlink\" title=\"搞定变量作用域问题：let\"></a>搞定变量作用域问题：let</h1><p>ES5时代的囧境就是把某个变量搞成了全局变量，加上文件之间的相互调用，我们不容易追踪到它到底是在哪里被修改掉的。<br>es6引入了let这个关键字，问题得到了解决：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let i=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//循环语句1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br><span class=\"line\"><span class=\"comment\">//循环语句2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">11</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br><span class=\"line\"><span class=\"comment\">//分支语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">111</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    let i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(i);<span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure></p>\n<p>let关键字让变量作用域变得清晰可控</p>\n<h1 id=\"利用const，保证全局变量不被更改\"><a href=\"#利用const，保证全局变量不被更改\" class=\"headerlink\" title=\"利用const，保证全局变量不被更改\"></a>利用const，保证全局变量不被更改</h1><p>有时，我们在某个全局文件下声明了某个变量，而在别人引入这个文件时，有时也会用同样的名字。为了保证这个变量不会被修改，我们就可以用常量来约束一下。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"string\">\"jack\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//重新声明</span></span><br><span class=\"line\">var username = 'hello';</span><br><span class=\"line\"><span class=\"comment\">//直接修改</span></span><br><span class=\"line\">username = <span class=\"number\">123</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(username);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"类的声明与继承\"><a href=\"#类的声明与继承\" class=\"headerlink\" title=\"类的声明与继承\"></a>类的声明与继承</h1><p>按照静态语有的面向对象思想，我们会把某个功能封装到一个类里面，然后暴露出一些外部访问的接口，以达到<code>高内聚低耦合</code>的设计目的。<br>其实我们在es5时代都是没有类的概念的。类可以声明为一个函数，也可以是个字面量（字面量就是实例化的类），这很容易把人弄迷糊。<br>而es6引入了静态语言的<code>class</code>之后，让类和函数划清了界限，代码整洁度和阅读舒适度都有了显著提升。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//构造函数，注意函数之间不用加;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\">  this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  console.log(this.type + ' says ' + say);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hello'); //animal says hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\"> super();<span class=\"comment\">//继承了父类的属性和方法</span></span><br><span class=\"line\"> this.type = 'cat';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.says('hello'); //cat says hello</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"箭头函数，解决this指向问题\"><a href=\"#箭头函数，解决this指向问题\" class=\"headerlink\" title=\"箭头函数，解决this指向问题\"></a>箭头函数，解决this指向问题</h1><p>JS的对象间的互相调用是非常繁杂的，一不小心就会遇到this被篡改的问题，导致后面的代码出错。比如这样的情况：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\"> this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  setTimeout(function()&#123;</span><br><span class=\"line\">   console.log(this.type + ' says ' + say);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hi'); //undefined says hi</span><br></pre></td></tr></table></figure></p>\n<p>这是一个比较经典的this被篡改的问题，因为这个该死的<code>setTimeout</code>函数，他的<code>this</code>指向的是window对象。<br>我们可以利用一个变量保存住这个<code>this</code>指针，也或者使用<code>bind(this)</code>方法，但有了箭头函数，等于函数本身集成了保存this指针的功能。这给我们提供了极大的便利，我们可以把精力放在业务逻辑的实现上，而不是处处提防this的陷阱。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"> constructor()&#123;</span><br><span class=\"line\">  this.type = 'animal';</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> says(say)&#123;</span><br><span class=\"line\">  setTimeout( () =&gt; &#123;</span><br><span class=\"line\">   console.log(this.type + ' says ' + say);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">animal.says('hi'); //animal says hi</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"插入大段html文本\"><a href=\"#插入大段html文本\" class=\"headerlink\" title=\"插入大段html文本\"></a>插入大段html文本</h1><p>这种使用场景非常高。比如我们从服务器请求一个数据过来，然后跟<code>html</code>拼接好，最后追加到某个div下。<br>拼接字符串无疑会打乱html节点本来的结构，各种双引号单引号满天飞，一不留神就会弄错，阅读和维护也很麻烦。<br>如果能不改变html的结构就好了！于是es6引入了<code>模板字串</code>的概念。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"container\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var cont = document.getElementById('container');</span><br><span class=\"line\"><span class=\"comment\">//一些变量</span></span><br><span class=\"line\">var name = 'jack';</span><br><span class=\"line\">var age = <span class=\"number\">18</span>;</span><br><span class=\"line\">cont.innerHTML =</span><br><span class=\"line\"> `&lt;div style=<span class=\"string\">\"color:red;\"</span>&gt;</span><br><span class=\"line\">   &lt;span class=<span class=\"string\">\"name\"</span>&gt;$&#123;name&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;b class=<span class=\"string\">\"age\"</span>&gt;$&#123;age&#125;&lt;/b&gt;</span><br><span class=\"line\">  &lt;/div&gt;`;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>反引号</code>中随意使用各种引号，其中的变量都用<code>${}</code>来表示。这样代码就变得优雅了。</p>\n<h1 id=\"默认值default\"><a href=\"#默认值default\" class=\"headerlink\" title=\"默认值default\"></a>默认值default</h1><p>有时我们声明了一个函数，可能里面的逻辑比较复杂，需要保证调用时一定传入形参值，否则后面的代码就会报错。<br>那如何防止其他开发人员就是传空呢？我们要给形参一个默认值。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">hello</span><span class=\"params\">(name)</span></span>&#123;</span><br><span class=\"line\"> name = name || 'jack';</span><br><span class=\"line\"></span><br><span class=\"line\"> console.log(name+' say hello!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br></pre></td></tr></table></figure></p>\n<p>但这样写不够直观，es6提供了默认值的写法。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hello(name ='jack')&#123;</span><br><span class=\"line\"> console.log(name + ' say hello!');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"省略号语法\"><a href=\"#省略号语法\" class=\"headerlink\" title=\"省略号语法\"></a>省略号语法</h1><p>省略号是一种语法糖，在处理函数不定参时十分有用。<br>像下面这个例子，无论传入几个参数，它都会将剩余的参数打成数组。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">hello</span><span class=\"params\">(a,b,...others)</span></span>&#123;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(others);<span class=\"comment\">//[ 'amily', 'mike', 'sam' ]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello('jack','tom','amily','mike','sam');</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Object几个好用的扩展\"><a href=\"#Object几个好用的扩展\" class=\"headerlink\" title=\"Object几个好用的扩展\"></a>Object几个好用的扩展</h1><blockquote>\n<p>Object是JS最根上的类。在JS中造的任何东西都脱胎于他。他相当于万物之本，是上帝。这个上帝类，在es6也得到了功能扩充。</p>\n</blockquote>\n<ul>\n<li>1.<code>assign()</code>方法：用于对象的合并或拷贝。<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象合并</span></span><br><span class=\"line\">var target = &#123;a:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">var source = &#123;b:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">Object.assign(target,source);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(target);<span class=\"comment\">//&#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意，拷贝是浅拷贝，而不是深拷贝。</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象拷贝，是浅拷贝。</span></span><br><span class=\"line\">let target = &#123; a: &#123; b: 'hello'&#125; &#125;;</span><br><span class=\"line\">let source = &#123; c: &#123; d: 'world' &#125; &#125;;</span><br><span class=\"line\">Object.assign(target, source);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(target);<span class=\"comment\">//&#123; a: &#123; b: 'hello' &#125;, c: &#123; d: 'world' &#125; &#125;</span></span><br><span class=\"line\">target.c.d = 'haha';</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source);<span class=\"comment\">//&#123; c: &#123; d: 'haha' &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果是深拷贝，target改变了，source不应跟着改变；浅拷贝相反。<br>究竟是用哪种拷贝，得看实际应用场景。</p>\n<ul>\n<li>2.<code>defineProperty()</code>方法：双向绑定的秘密！</li>\n</ul>\n<p>在angular或vue等框架里，对双向绑定并不陌生。<br>数据和视图的联动真的很酷，能解决很多现实问题，但这个究竟如何实现的呢？<br>我们可以通过这个es6新提供的方法轻松搞定它。<br>先来看一下用法：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(obj, prop, descriptor) </span><br><span class=\"line\">obj：待修改的对象。</span><br><span class=\"line\">prop：待修改的属性名称。</span><br><span class=\"line\">descriptor：待修改属性的相关描述，要求传入一个对象。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    value: '',</span><br><span class=\"line\">    <span class=\"built_in\">set</span>: function()&#123;&#125;,</span><br><span class=\"line\">    get: function()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- configurable：属性是否可配置。可配置的含义包括：是否可以删除属性（ <span class=\"keyword\">delete</span> ），是否可以修改属性的 writable 、 enumerable 属性。</span><br><span class=\"line\">- enumerable：属性是否可遍历出来（可通过 <span class=\"keyword\">for</span>...in 遍历到）。</span><br><span class=\"line\">- writable：属性是否可重写（是否可以对属性进行重新赋值？）</span><br><span class=\"line\">- value：属性的默认值。</span><br><span class=\"line\">- <span class=\"built_in\">set</span>：属性的重写方法。一旦属性被重新赋值，此方法被自动调用。</span><br><span class=\"line\">- get ：属性的读取方法。一旦属性被访问读取，此方法被自动调用。</span><br></pre></td></tr></table></figure></p>\n<p>看个例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性name，值为jack</span></span><br><span class=\"line\">Object.defineProperty(obj, 'name', &#123;</span><br><span class=\"line\"> value: 'jack'</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性age，值为100</span></span><br><span class=\"line\">Object.defineProperty(obj, 'age', &#123;</span><br><span class=\"line\"> value: <span class=\"number\">100</span>,</span><br><span class=\"line\"> configurable: <span class=\"literal\">true</span>,<span class=\"comment\">//可配置</span></span><br><span class=\"line\"> enumerable: <span class=\"literal\">true</span>,<span class=\"comment\">//可遍历出来</span></span><br><span class=\"line\"> writable: <span class=\"literal\">true</span><span class=\"comment\">//可写</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.age); <span class=\"comment\">// 100</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.age = <span class=\"number\">18</span>;<span class=\"comment\">//重写</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.age); <span class=\"comment\">// 18. 因为age属性是可重写的</span></span><br><span class=\"line\"><span class=\"comment\">//遍历obj</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(let key in obj)&#123;</span><br><span class=\"line\"> console.<span class=\"built_in\">log</span>(key+<span class=\"string\">\":\"</span>+obj[key]);<span class=\"comment\">//age:18，默认是不可配置的，所以name读不到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给obj对象赋予了一个属性sex，值为male</span></span><br><span class=\"line\">Object.defineProperty(obj, 'sex', &#123;</span><br><span class=\"line\"> value: 'male',</span><br><span class=\"line\"> writable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sex = 'female'; // 不可重写</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.sex); <span class=\"comment\">// 'male'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.sex; <span class=\"comment\">// 属性删除无效，默认是不可配置的</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.sex);<span class=\"comment\">// 'male'，依然可以读出</span></span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(obj, 'weight', &#123;</span><br><span class=\"line\"><span class=\"comment\">//value: '75kg',//如果打开这个value就会报错</span></span><br><span class=\"line\"> <span class=\"built_in\">set</span>: function(str) &#123;</span><br><span class=\"line\">console.log('set weight',str);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"> get:function()&#123;</span><br><span class=\"line\">console.log('get weight');</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，set和get方法跟value属性是互斥的，同时出现会报错。<br>下面就来看一下如何实现一个数据和视图双向绑定效果。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;title&gt;数据和视图联动&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;div&gt;测试用户名：&lt;input type=\"text\" id='userName'/&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"show\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;　　　</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var userInfo = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(userInfo, <span class=\"string\">\"userName\"</span>, &#123;</span><br><span class=\"line\"> get: function()&#123;</span><br><span class=\"line\">  return document.getElementById('show').innerHTML;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"built_in\">set</span>: function(name)&#123;</span><br><span class=\"line\">  document.getElementById('show').innerHTML = name;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById('userName').onkeyup = function(e)&#123;</span><br><span class=\"line\"><span class=\"comment\">//改变数据，触发set方法，从而改变了视图。</span></span><br><span class=\"line\"> userInfo.userName = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行效果：<br><img src=\"/blog/2018/05/25/ES6攻略/01.png\" alt=\"运行效果：\"></p>\n<ul>\n<li>3.对象简写<br>es6提供了对象的简洁写法。虽然属性和方法都可以简写，但我觉得属性还是规规矩矩写键值对就好，不过方法的简写倒是省事不少。我们看一下如何书写：<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\"> name:'jack',</span><br><span class=\"line\"> age:<span class=\"number\">18</span>,</span><br><span class=\"line\"> method() &#123;</span><br><span class=\"line\">   return this.name+'--'+this.age;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(obj.method());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"ES6里 三种异步解决方案","date":"2018-06-27T15:47:45.000Z","description":null,"copyright":false,"top":null,"_content":"\n介绍一下ES6里的三种异步方案。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 知识尝鲜\n\n> 1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用`next()`  方法；\n> 2、next() 方法，可以给他传入一个参数。调用`next()`方法，会返回一个对象`{value: res,done: false}` ,这里的done 表示迭代器。\n\n# 方法一： Generator + Promise \n\n```h\n\nconst fund = require('fund')\n\n// Promise 版的readFile\nconst readFile = function (fileName) {\n  return new Promise(function(resolve, reject) {\n    fund.readFile(fileName, function(err, data){\n      if (err) return reject(error);\n      resolve(data);\n    })\n  })\n}\n\nconst newgen = function * () {\n  let demo1 = yield readFile('a.txt');\n  let demo2 = yield readFile('b.txt');\n\n  console.log('demo1--->', demo1.toString());\n  console.log('demo2--->', demo2.toString());\n}\n\n\n// 基于 Generator 和 Promise 的自动执行器\nfunction run(gen) {\n\n  let g = gen();\n  \n  function next(data) {\n    \n    let result = g.next(data);\n\n    if (result.done) return result.value;\n\n    result.value.then(function(data) {\n      next(data);\n    });\n  }\n  next();\n}\n\nrun(gen);\n\n```\n\n执行器 中的 `result.value` 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样  ` let f1 = yield readFile('a.txt');  `就可以拿到值.\n\n# 方法二： Generator + Thunk函数\n\n```h\nconst fs = require('fs')\n\n// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数\nfunction thunkify(fn, obj = {}) {\n    return function () {\n        let args = Array.from(arguments);\n        return function (m) {\n            args.push(m)\n            return fn.apply(obj, args)\n        }\n    }\n}\n\nconst readFile = thunkify(fs.readFile, fs);\n\nconst gen = function* () {\n    let f1 = yield readFile('a.txt');\n    let f2 = yield readFile('b.txt');\n\n    console.log('F1-->', f1.toString());\n    console.log('F2-->', f2.toString());\n}\n\n\n// 基于 Generator 和 Thunk函数的自动执行器\nfunction run(fn) {\n    let gen = fn();\n\n    function next(err, data) {\n        let result = gen.next(data);\n        if (result.done) return 1;\n        result.value(next);\n    }\n\n    next();\n\n}\n\nrun(gen);\n```\n`Thunk `转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法\n\n# 方法三：async 函数 + await 的异步处理方式 \n\n```h\n\nconst fs = require('fs')\n\n// Promise 版的readFile\nconst readFile = function (fileName) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(fileName, function(err, data){\n      if (err) return reject(err);\n      resolve(data);\n    })\n  })\n}\n\nconst asyncReadFile = async function () {\n  const f1 = await readFile('a.txt');\n  const f2 = await readFile('b.txt');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nasyncReadFile();\n\n```\n\n`readFile `函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。","source":"_posts/ES6里-三种异步解决方案.md","raw":"---\ntitle: ES6里 三种异步解决方案\ndate: 2018-06-27 23:47:45\ntags: [编程,Javascript,ES6]\ndescription: \ncopyright: false\ncategories: ES6\ntop:\n---\n\n介绍一下ES6里的三种异步方案。\n\n![ES6攻略](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png)\n\n<!-- more -->\n\n# 知识尝鲜\n\n> 1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用`next()`  方法；\n> 2、next() 方法，可以给他传入一个参数。调用`next()`方法，会返回一个对象`{value: res,done: false}` ,这里的done 表示迭代器。\n\n# 方法一： Generator + Promise \n\n```h\n\nconst fund = require('fund')\n\n// Promise 版的readFile\nconst readFile = function (fileName) {\n  return new Promise(function(resolve, reject) {\n    fund.readFile(fileName, function(err, data){\n      if (err) return reject(error);\n      resolve(data);\n    })\n  })\n}\n\nconst newgen = function * () {\n  let demo1 = yield readFile('a.txt');\n  let demo2 = yield readFile('b.txt');\n\n  console.log('demo1--->', demo1.toString());\n  console.log('demo2--->', demo2.toString());\n}\n\n\n// 基于 Generator 和 Promise 的自动执行器\nfunction run(gen) {\n\n  let g = gen();\n  \n  function next(data) {\n    \n    let result = g.next(data);\n\n    if (result.done) return result.value;\n\n    result.value.then(function(data) {\n      next(data);\n    });\n  }\n  next();\n}\n\nrun(gen);\n\n```\n\n执行器 中的 `result.value` 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样  ` let f1 = yield readFile('a.txt');  `就可以拿到值.\n\n# 方法二： Generator + Thunk函数\n\n```h\nconst fs = require('fs')\n\n// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数\nfunction thunkify(fn, obj = {}) {\n    return function () {\n        let args = Array.from(arguments);\n        return function (m) {\n            args.push(m)\n            return fn.apply(obj, args)\n        }\n    }\n}\n\nconst readFile = thunkify(fs.readFile, fs);\n\nconst gen = function* () {\n    let f1 = yield readFile('a.txt');\n    let f2 = yield readFile('b.txt');\n\n    console.log('F1-->', f1.toString());\n    console.log('F2-->', f2.toString());\n}\n\n\n// 基于 Generator 和 Thunk函数的自动执行器\nfunction run(fn) {\n    let gen = fn();\n\n    function next(err, data) {\n        let result = gen.next(data);\n        if (result.done) return 1;\n        result.value(next);\n    }\n\n    next();\n\n}\n\nrun(gen);\n```\n`Thunk `转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法\n\n# 方法三：async 函数 + await 的异步处理方式 \n\n```h\n\nconst fs = require('fs')\n\n// Promise 版的readFile\nconst readFile = function (fileName) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(fileName, function(err, data){\n      if (err) return reject(err);\n      resolve(data);\n    })\n  })\n}\n\nconst asyncReadFile = async function () {\n  const f1 = await readFile('a.txt');\n  const f2 = await readFile('b.txt');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nasyncReadFile();\n\n```\n\n`readFile `函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。","slug":"ES6里-三种异步解决方案","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnd8000fkt89o0luwjwa","content":"<p>介绍一下ES6里的三种异步方案。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>\n<a id=\"more\"></a>\n<h1 id=\"知识尝鲜\"><a href=\"#知识尝鲜\" class=\"headerlink\" title=\"知识尝鲜\"></a>知识尝鲜</h1><blockquote>\n<p>1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用<code>next()</code>  方法；<br>2、next() 方法，可以给他传入一个参数。调用<code>next()</code>方法，会返回一个对象<code>{value: res,done: false}</code> ,这里的done 表示迭代器。</p>\n</blockquote>\n<h1 id=\"方法一：-Generator-Promise\"><a href=\"#方法一：-Generator-Promise\" class=\"headerlink\" title=\"方法一： Generator + Promise\"></a>方法一： Generator + Promise</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const fund = require('fund')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise 版的readFile</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = function (fileName) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    fund.readFile(fileName, function(err, data)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newgen = function * () &#123;</span><br><span class=\"line\">  let demo1 = yield readFile('a.txt');</span><br><span class=\"line\">  let demo2 = yield readFile('b.txt');</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log('demo1---&gt;', demo1.toString());</span><br><span class=\"line\">  console.log('demo2---&gt;', demo2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于 Generator 和 Promise 的自动执行器</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">run</span><span class=\"params\">(gen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let g = gen();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\">function <span class=\"title\">next</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    let result = g.next(data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    result.value.then(function(data) &#123;</span><br><span class=\"line\">      next(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(gen);</span><br></pre></td></tr></table></figure>\n<p>执行器 中的 <code>result.value</code> 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样  <code>let f1 = yield readFile(&#39;a.txt&#39;);</code>就可以拿到值.</p>\n<h1 id=\"方法二：-Generator-Thunk函数\"><a href=\"#方法二：-Generator-Thunk函数\" class=\"headerlink\" title=\"方法二： Generator + Thunk函数\"></a>方法二： Generator + Thunk函数</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require('fs')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">thunkify</span><span class=\"params\">(fn, obj = &#123;&#125;)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> function () &#123;</span><br><span class=\"line\">        let args = Array.from(arguments);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> function (m) &#123;</span><br><span class=\"line\">            args.push(m)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(obj, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = thunkify(fs.readFile, fs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = function* () &#123;</span><br><span class=\"line\">    let f1 = yield readFile('a.txt');</span><br><span class=\"line\">    let f2 = yield readFile('b.txt');</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log('F1--&gt;', f1.toString());</span><br><span class=\"line\">    console.log('F2--&gt;', f2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于 Generator 和 Thunk函数的自动执行器</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">run</span><span class=\"params\">(fn)</span> </span>&#123;</span><br><span class=\"line\">    let gen = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">function <span class=\"title\">next</span><span class=\"params\">(err, data)</span> </span>&#123;</span><br><span class=\"line\">        let result = gen.next(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        result.value(next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(gen);</span><br></pre></td></tr></table></figure>\n<p><code>Thunk</code>转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法</p>\n<h1 id=\"方法三：async-函数-await-的异步处理方式\"><a href=\"#方法三：async-函数-await-的异步处理方式\" class=\"headerlink\" title=\"方法三：async 函数 + await 的异步处理方式\"></a>方法三：async 函数 + await 的异步处理方式</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const fs = require('fs')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise 版的readFile</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = function (fileName) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    fs.readFile(fileName, function(err, data)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> reject(err);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = async function () &#123;</span><br><span class=\"line\">  const f1 = await readFile('a.txt');</span><br><span class=\"line\">  const f2 = await readFile('b.txt');</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(f1.toString());</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncReadFile();</span><br></pre></td></tr></table></figure>\n<p><code>readFile</code>函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。</p>\n","site":{"data":{}},"excerpt":"<p>介绍一下ES6里的三种异步方案。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/es6_d.png\" alt=\"ES6攻略\"></p>","more":"<h1 id=\"知识尝鲜\"><a href=\"#知识尝鲜\" class=\"headerlink\" title=\"知识尝鲜\"></a>知识尝鲜</h1><blockquote>\n<p>1、newGenerator 函数，它执行之后会返回一个迭代器，在这个迭代器上我们可以去调用<code>next()</code>  方法；<br>2、next() 方法，可以给他传入一个参数。调用<code>next()</code>方法，会返回一个对象<code>{value: res,done: false}</code> ,这里的done 表示迭代器。</p>\n</blockquote>\n<h1 id=\"方法一：-Generator-Promise\"><a href=\"#方法一：-Generator-Promise\" class=\"headerlink\" title=\"方法一： Generator + Promise\"></a>方法一： Generator + Promise</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const fund = require('fund')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise 版的readFile</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = function (fileName) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    fund.readFile(fileName, function(err, data)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newgen = function * () &#123;</span><br><span class=\"line\">  let demo1 = yield readFile('a.txt');</span><br><span class=\"line\">  let demo2 = yield readFile('b.txt');</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log('demo1---&gt;', demo1.toString());</span><br><span class=\"line\">  console.log('demo2---&gt;', demo2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于 Generator 和 Promise 的自动执行器</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">run</span><span class=\"params\">(gen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let g = gen();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\">function <span class=\"title\">next</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    let result = g.next(data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    result.value.then(function(data) &#123;</span><br><span class=\"line\">      next(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(gen);</span><br></pre></td></tr></table></figure>\n<p>执行器 中的 <code>result.value</code> 现在是一个Promise, 通过 then 方法拿到需要的结果，传下一次 next 方法，这样  <code>let f1 = yield readFile(&#39;a.txt&#39;);</code>就可以拿到值.</p>\n<h1 id=\"方法二：-Generator-Thunk函数\"><a href=\"#方法二：-Generator-Thunk函数\" class=\"headerlink\" title=\"方法二： Generator + Thunk函数\"></a>方法二： Generator + Thunk函数</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require('fs')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把一个单一执行的函数 ，变成需要再次调用的函数，固定一部分参数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">thunkify</span><span class=\"params\">(fn, obj = &#123;&#125;)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> function () &#123;</span><br><span class=\"line\">        let args = Array.from(arguments);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> function (m) &#123;</span><br><span class=\"line\">            args.push(m)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(obj, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = thunkify(fs.readFile, fs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = function* () &#123;</span><br><span class=\"line\">    let f1 = yield readFile('a.txt');</span><br><span class=\"line\">    let f2 = yield readFile('b.txt');</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log('F1--&gt;', f1.toString());</span><br><span class=\"line\">    console.log('F2--&gt;', f2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于 Generator 和 Thunk函数的自动执行器</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">run</span><span class=\"params\">(fn)</span> </span>&#123;</span><br><span class=\"line\">    let gen = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">function <span class=\"title\">next</span><span class=\"params\">(err, data)</span> </span>&#123;</span><br><span class=\"line\">        let result = gen.next(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        result.value(next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(gen);</span><br></pre></td></tr></table></figure>\n<p><code>Thunk</code>转换器，把原来的 fs.readFile 函数 转换成需要两次调用的函数 ，readFile 的执行结果，可以通过回调函数能参数传递出来，再传给 next 方法</p>\n<h1 id=\"方法三：async-函数-await-的异步处理方式\"><a href=\"#方法三：async-函数-await-的异步处理方式\" class=\"headerlink\" title=\"方法三：async 函数 + await 的异步处理方式\"></a>方法三：async 函数 + await 的异步处理方式</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const fs = require('fs')</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise 版的readFile</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = function (fileName) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    fs.readFile(fileName, function(err, data)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> reject(err);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = async function () &#123;</span><br><span class=\"line\">  const f1 = await readFile('a.txt');</span><br><span class=\"line\">  const f2 = await readFile('b.txt');</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(f1.toString());</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncReadFile();</span><br></pre></td></tr></table></figure>\n<p><code>readFile</code>函数 对比方法一没有大的变化 ，Generator 函数变成 了 async 函数，可见这处方式 只是一个语法糖，async 函数自带了执行器。</p>"},{"title":"Gitment使用 GitHub Issues 搭建评论系统","date":"2018-12-07T07:42:06.000Z","description":null,"copyright":true,"top":null,"_content":"Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。\n\n![Gitment](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png)\n\n<!-- more -->\n\n# 基础使用\n\n## 1. 注册 OAuth Application\n[点击此处](https://github.com/settings/applications/new) 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。\n\n你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。\n\n## 2. 引入 Gitment\n\n\n将下面的代码添加到你的页面：\n\n```h\n<div id=\"container\"></div>\n<link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\">\n<script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"></script>\n<script>\nvar gitment = new Gitment({\n  id: '页面 ID', // 可选。默认为 location.href\n  owner: '你的 GitHub ID',\n  repo: '存储评论的 repo',\n  oauth: {\n    client_id: '你的 client ID',\n    client_secret: '你的 client secret',\n  },\n})\ngitment.render('container')\n</script>\n\n```\n\n注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。\n\n如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。\n\n`$ npm install --save gitment`\n关于构造函数中的更多可用参数请查看 Gitment Options\n\n## 3. 初始化评论\n页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。\n\n之后其他用户即可在该页面发表评论。\n\n## 自定义\nGitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）\n\n比如你可以通过自定义主题将评论框放在评论列表前面：\n\n```h\nconst myTheme = {\n  render(state, instance) {\n    const container = document.createElement('div')\n    container.lang = \"en-US\"\n    container.className = 'gitment-container gitment-root-container'\n    container.appendChild(instance.renderHeader(state, instance))\n    container.appendChild(instance.renderEditor(state, instance))\n    container.appendChild(instance.renderComments(state, instance))\n    container.appendChild(instance.renderFooter(state, instance))\n    return container\n  },\n}\nconst gitment = new Gitment({\n  // ...\n  theme: myTheme,\n})\ngitment.render('container')\n```\n\n更多自定义内容请查看[文档](https://github.com/imsun/gitment#customize)。\n\n## 其他问题\n语言问题\n考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。\n","source":"_posts/Gitment使用-GitHub-Issues-搭建评论系统.md","raw":"---\ntitle: Gitment使用 GitHub Issues 搭建评论系统\ndate: 2018-12-07 15:42:06\ntags: [软件,编程]\ndescription:\ncopyright: true\ncategories: 软件\ntop:\n---\nGitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。\n\n![Gitment](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png)\n\n<!-- more -->\n\n# 基础使用\n\n## 1. 注册 OAuth Application\n[点击此处](https://github.com/settings/applications/new) 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。\n\n你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。\n\n## 2. 引入 Gitment\n\n\n将下面的代码添加到你的页面：\n\n```h\n<div id=\"container\"></div>\n<link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\">\n<script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"></script>\n<script>\nvar gitment = new Gitment({\n  id: '页面 ID', // 可选。默认为 location.href\n  owner: '你的 GitHub ID',\n  repo: '存储评论的 repo',\n  oauth: {\n    client_id: '你的 client ID',\n    client_secret: '你的 client secret',\n  },\n})\ngitment.render('container')\n</script>\n\n```\n\n注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。\n\n如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。\n\n`$ npm install --save gitment`\n关于构造函数中的更多可用参数请查看 Gitment Options\n\n## 3. 初始化评论\n页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。\n\n之后其他用户即可在该页面发表评论。\n\n## 自定义\nGitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）\n\n比如你可以通过自定义主题将评论框放在评论列表前面：\n\n```h\nconst myTheme = {\n  render(state, instance) {\n    const container = document.createElement('div')\n    container.lang = \"en-US\"\n    container.className = 'gitment-container gitment-root-container'\n    container.appendChild(instance.renderHeader(state, instance))\n    container.appendChild(instance.renderEditor(state, instance))\n    container.appendChild(instance.renderComments(state, instance))\n    container.appendChild(instance.renderFooter(state, instance))\n    return container\n  },\n}\nconst gitment = new Gitment({\n  // ...\n  theme: myTheme,\n})\ngitment.render('container')\n```\n\n更多自定义内容请查看[文档](https://github.com/imsun/gitment#customize)。\n\n## 其他问题\n语言问题\n考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。\n","slug":"Gitment使用-GitHub-Issues-搭建评论系统","published":1,"updated":"2018-12-07T08:13:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnde000hkt897y28h0kd","content":"<p>Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png\" alt=\"Gitment\"></p>\n<a id=\"more\"></a>\n<h1 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h1><h2 id=\"1-注册-OAuth-Application\"><a href=\"#1-注册-OAuth-Application\" class=\"headerlink\" title=\"1. 注册 OAuth Application\"></a>1. 注册 OAuth Application</h2><p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href=\"https://imsun.net）。\" target=\"_blank\" rel=\"noopener\">https://imsun.net）。</a></p>\n<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>\n<h2 id=\"2-引入-Gitment\"><a href=\"#2-引入-Gitment\" class=\"headerlink\" title=\"2. 引入 Gitment\"></a>2. 引入 Gitment</h2><p>将下面的代码添加到你的页面：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"container\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"https://imsun.github.io/gitment/style/default.css\"</span>&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://imsun.github.io/gitment/dist/gitment.browser.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var gitment = <span class=\"keyword\">new</span> Gitment(&#123;</span><br><span class=\"line\">  id: '页面 ID', // 可选。默认为 location.href</span><br><span class=\"line\">  owner: '你的 GitHub ID',</span><br><span class=\"line\">  repo: '存储评论的 repo',</span><br><span class=\"line\">  oauth: &#123;</span><br><span class=\"line\">    client_id: '你的 client ID',</span><br><span class=\"line\">    client_secret: '你的 client secret',</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gitment.render('container')</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>\n<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>\n<p><code>$ npm install --save gitment</code><br>关于构造函数中的更多可用参数请查看 Gitment Options</p>\n<h2 id=\"3-初始化评论\"><a href=\"#3-初始化评论\" class=\"headerlink\" title=\"3. 初始化评论\"></a>3. 初始化评论</h2><p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>\n<p>之后其他用户即可在该页面发表评论。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>\n<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myTheme = &#123;</span><br><span class=\"line\">  render(state, instance) &#123;</span><br><span class=\"line\">    const container = document.createElement('div')</span><br><span class=\"line\">    container.lang = <span class=\"string\">\"en-US\"</span></span><br><span class=\"line\">    container.className = 'gitment-container gitment-root-container'</span><br><span class=\"line\">    container.appendChild(instance.renderHeader(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderEditor(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderComments(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderFooter(state, instance))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> container</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gitment = <span class=\"keyword\">new</span> Gitment(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  theme: myTheme,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gitment.render('container')</span><br></pre></td></tr></table></figure>\n<p>更多自定义内容请查看<a href=\"https://github.com/imsun/gitment#customize\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p>语言问题<br>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>\n","site":{"data":{}},"excerpt":"<p>Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/gitment.png\" alt=\"Gitment\"></p>","more":"<h1 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h1><h2 id=\"1-注册-OAuth-Application\"><a href=\"#1-注册-OAuth-Application\" class=\"headerlink\" title=\"1. 注册 OAuth Application\"></a>1. 注册 OAuth Application</h2><p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href=\"https://imsun.net）。\" target=\"_blank\" rel=\"noopener\">https://imsun.net）。</a></p>\n<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>\n<h2 id=\"2-引入-Gitment\"><a href=\"#2-引入-Gitment\" class=\"headerlink\" title=\"2. 引入 Gitment\"></a>2. 引入 Gitment</h2><p>将下面的代码添加到你的页面：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"container\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"https://imsun.github.io/gitment/style/default.css\"</span>&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://imsun.github.io/gitment/dist/gitment.browser.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var gitment = <span class=\"keyword\">new</span> Gitment(&#123;</span><br><span class=\"line\">  id: '页面 ID', // 可选。默认为 location.href</span><br><span class=\"line\">  owner: '你的 GitHub ID',</span><br><span class=\"line\">  repo: '存储评论的 repo',</span><br><span class=\"line\">  oauth: &#123;</span><br><span class=\"line\">    client_id: '你的 client ID',</span><br><span class=\"line\">    client_secret: '你的 client secret',</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gitment.render('container')</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>\n<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>\n<p><code>$ npm install --save gitment</code><br>关于构造函数中的更多可用参数请查看 Gitment Options</p>\n<h2 id=\"3-初始化评论\"><a href=\"#3-初始化评论\" class=\"headerlink\" title=\"3. 初始化评论\"></a>3. 初始化评论</h2><p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>\n<p>之后其他用户即可在该页面发表评论。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>\n<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myTheme = &#123;</span><br><span class=\"line\">  render(state, instance) &#123;</span><br><span class=\"line\">    const container = document.createElement('div')</span><br><span class=\"line\">    container.lang = <span class=\"string\">\"en-US\"</span></span><br><span class=\"line\">    container.className = 'gitment-container gitment-root-container'</span><br><span class=\"line\">    container.appendChild(instance.renderHeader(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderEditor(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderComments(state, instance))</span><br><span class=\"line\">    container.appendChild(instance.renderFooter(state, instance))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> container</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gitment = <span class=\"keyword\">new</span> Gitment(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  theme: myTheme,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gitment.render('container')</span><br></pre></td></tr></table></figure>\n<p>更多自定义内容请查看<a href=\"https://github.com/imsun/gitment#customize\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p>语言问题<br>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>"},{"title":"JavaScript: 什么是纯函数以及为什么要用纯函数","date":"2018-11-11T09:57:25.000Z","description":null,"copyright":true,"top":null,"_content":"当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？\n\n除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# 什么函数是纯\n\n纯函数的定义是：\n\n- 1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。\n\n- 2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。\n\n这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。\n\n在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。\n\n\n# 什么是可观察的副作用\n\n一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。\n\n注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。\n\n副作用来自，但不限于：\n\n- 进行一个 HTTP 请求\n\n- Mutating data\n\n- 输出数据到屏幕或者控制台\n\n- DOM 查询/操作\n\n- Math.random()\n\n- 获取的当前时间\n\n副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。\n\n不过首先，让我们来看一些纯的和不纯的函数对比的例子......\n\n# 纯函数\n\n以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：\n```h\nfunction priceAfterTax(productPrice) { return (productPrice * 0.20) + productPrice;}\n\n```\n\n它符合我们所说的两条纯函数的定义。`不依赖于任何外部输入，不改变任何外部数据、没有副作用`。\n\n即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。\n\n\n# 非纯函数\n\n我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:\n```h\nvar tax = 20;\n\nfunction calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice;\n}\n```\n暂停片刻，看看你是否能看出为什么这个函数不纯。\n\n其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。\n\n\n# 为什么说纯函数在 JavaScript 很重要\n\n纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。\n\n不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。\n\n并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。\n\n# 可测试性和重构\n另一个使用纯函数的原因是测试以及重构。\n\n使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。\n\n同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）\n\n`正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。`\n\n此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 [Wiki](https://en.wikipedia.org/wiki/Pure_function)。同时也推荐阅读 [开发建议手册](https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html) 以及 [纯函数 vs. 非纯函数](https://toddmotto.com/pure-versus-impure-functions).\n\n\n原文链接： medium.com","source":"_posts/JavaScript-什么是纯函数以及为什么要用纯函数.md","raw":"---\ntitle: 'JavaScript: 什么是纯函数以及为什么要用纯函数'\ndate: 2018-11-11 17:57:25\ntags: [Javascript,编程]\ndescription: \ncopyright: true\ncategories: Javascript\ntop:\n---\n当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？\n\n除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# 什么函数是纯\n\n纯函数的定义是：\n\n- 1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。\n\n- 2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。\n\n这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。\n\n在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。\n\n\n# 什么是可观察的副作用\n\n一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。\n\n注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。\n\n副作用来自，但不限于：\n\n- 进行一个 HTTP 请求\n\n- Mutating data\n\n- 输出数据到屏幕或者控制台\n\n- DOM 查询/操作\n\n- Math.random()\n\n- 获取的当前时间\n\n副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。\n\n不过首先，让我们来看一些纯的和不纯的函数对比的例子......\n\n# 纯函数\n\n以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：\n```h\nfunction priceAfterTax(productPrice) { return (productPrice * 0.20) + productPrice;}\n\n```\n\n它符合我们所说的两条纯函数的定义。`不依赖于任何外部输入，不改变任何外部数据、没有副作用`。\n\n即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。\n\n\n# 非纯函数\n\n我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:\n```h\nvar tax = 20;\n\nfunction calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice;\n}\n```\n暂停片刻，看看你是否能看出为什么这个函数不纯。\n\n其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。\n\n\n# 为什么说纯函数在 JavaScript 很重要\n\n纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。\n\n不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。\n\n并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。\n\n# 可测试性和重构\n另一个使用纯函数的原因是测试以及重构。\n\n使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。\n\n同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）\n\n`正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。`\n\n此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 [Wiki](https://en.wikipedia.org/wiki/Pure_function)。同时也推荐阅读 [开发建议手册](https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html) 以及 [纯函数 vs. 非纯函数](https://toddmotto.com/pure-versus-impure-functions).\n\n\n原文链接： medium.com","slug":"JavaScript-什么是纯函数以及为什么要用纯函数","published":1,"updated":"2018-11-11T10:06:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctndf000mkt89yv8o8df0","content":"<p>当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？</p>\n<p>除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"什么函数是纯\"><a href=\"#什么函数是纯\" class=\"headerlink\" title=\"什么函数是纯\"></a>什么函数是纯</h1><p>纯函数的定义是：</p>\n<ul>\n<li><p>1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>\n</li>\n<li><p>2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</p>\n</li>\n</ul>\n<p>这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。</p>\n<p>在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。</p>\n<h1 id=\"什么是可观察的副作用\"><a href=\"#什么是可观察的副作用\" class=\"headerlink\" title=\"什么是可观察的副作用\"></a>什么是可观察的副作用</h1><p>一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。</p>\n<p>注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。</p>\n<p>副作用来自，但不限于：</p>\n<ul>\n<li><p>进行一个 HTTP 请求</p>\n</li>\n<li><p>Mutating data</p>\n</li>\n<li><p>输出数据到屏幕或者控制台</p>\n</li>\n<li><p>DOM 查询/操作</p>\n</li>\n<li><p>Math.random()</p>\n</li>\n<li><p>获取的当前时间</p>\n</li>\n</ul>\n<p>副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。</p>\n<p>不过首先，让我们来看一些纯的和不纯的函数对比的例子……</p>\n<h1 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h1><p>以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">priceAfterTax</span><span class=\"params\">(productPrice)</span> </span>&#123; <span class=\"keyword\">return</span> (productPrice * <span class=\"number\">0.20</span>) + productPrice;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它符合我们所说的两条纯函数的定义。<code>不依赖于任何外部输入，不改变任何外部数据、没有副作用</code>。</p>\n<p>即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。</p>\n<h1 id=\"非纯函数\"><a href=\"#非纯函数\" class=\"headerlink\" title=\"非纯函数\"></a>非纯函数</h1><p>我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tax = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">calculateTax</span><span class=\"params\">(productPrice)</span> </span>&#123; <span class=\"keyword\">return</span> (productPrice * (tax/<span class=\"number\">100</span>)) + productPrice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>暂停片刻，看看你是否能看出为什么这个函数不纯。</p>\n<p>其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。</p>\n<h1 id=\"为什么说纯函数在-JavaScript-很重要\"><a href=\"#为什么说纯函数在-JavaScript-很重要\" class=\"headerlink\" title=\"为什么说纯函数在 JavaScript 很重要\"></a>为什么说纯函数在 JavaScript 很重要</h1><p>纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。</p>\n<p>不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。</p>\n<p>并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。</p>\n<h1 id=\"可测试性和重构\"><a href=\"#可测试性和重构\" class=\"headerlink\" title=\"可测试性和重构\"></a>可测试性和重构</h1><p>另一个使用纯函数的原因是测试以及重构。</p>\n<p>使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。</p>\n<p>同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）</p>\n<p><code>正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。</code></p>\n<p>此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 <a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"noopener\">Wiki</a>。同时也推荐阅读 <a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html\" target=\"_blank\" rel=\"noopener\">开发建议手册</a> 以及 <a href=\"https://toddmotto.com/pure-versus-impure-functions\" target=\"_blank\" rel=\"noopener\">纯函数 vs. 非纯函数</a>.</p>\n<p>原文链接： medium.com</p>\n","site":{"data":{}},"excerpt":"<p>当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？</p>\n<p>除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。可以花点时间一起来看以下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>","more":"<h1 id=\"什么函数是纯\"><a href=\"#什么函数是纯\" class=\"headerlink\" title=\"什么函数是纯\"></a>什么函数是纯</h1><p>纯函数的定义是：</p>\n<ul>\n<li><p>1、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>\n</li>\n<li><p>2、该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</p>\n</li>\n</ul>\n<p>这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。</p>\n<p>在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。</p>\n<h1 id=\"什么是可观察的副作用\"><a href=\"#什么是可观察的副作用\" class=\"headerlink\" title=\"什么是可观察的副作用\"></a>什么是可观察的副作用</h1><p>一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。</p>\n<p>注: 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。</p>\n<p>副作用来自，但不限于：</p>\n<ul>\n<li><p>进行一个 HTTP 请求</p>\n</li>\n<li><p>Mutating data</p>\n</li>\n<li><p>输出数据到屏幕或者控制台</p>\n</li>\n<li><p>DOM 查询/操作</p>\n</li>\n<li><p>Math.random()</p>\n</li>\n<li><p>获取的当前时间</p>\n</li>\n</ul>\n<p>副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。</p>\n<p>不过首先，让我们来看一些纯的和不纯的函数对比的例子……</p>\n<h1 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h1><p>以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">priceAfterTax</span><span class=\"params\">(productPrice)</span> </span>&#123; <span class=\"keyword\">return</span> (productPrice * <span class=\"number\">0.20</span>) + productPrice;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它符合我们所说的两条纯函数的定义。<code>不依赖于任何外部输入，不改变任何外部数据、没有副作用</code>。</p>\n<p>即使你用同样的输入运行运行这个函数 100,000,000 次它依旧产生同样的结果。</p>\n<h1 id=\"非纯函数\"><a href=\"#非纯函数\" class=\"headerlink\" title=\"非纯函数\"></a>非纯函数</h1><p>我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tax = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">calculateTax</span><span class=\"params\">(productPrice)</span> </span>&#123; <span class=\"keyword\">return</span> (productPrice * (tax/<span class=\"number\">100</span>)) + productPrice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>暂停片刻，看看你是否能看出为什么这个函数不纯。</p>\n<p>其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。</p>\n<h1 id=\"为什么说纯函数在-JavaScript-很重要\"><a href=\"#为什么说纯函数在-JavaScript-很重要\" class=\"headerlink\" title=\"为什么说纯函数在 JavaScript 很重要\"></a>为什么说纯函数在 JavaScript 很重要</h1><p>纯函数在函数式编程中被大量使用。而且诸如 ReactJS 和 Redux 等优质的库都需要使用纯函数。</p>\n<p>不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。</p>\n<p>并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。</p>\n<h1 id=\"可测试性和重构\"><a href=\"#可测试性和重构\" class=\"headerlink\" title=\"可测试性和重构\"></a>可测试性和重构</h1><p>另一个使用纯函数的原因是测试以及重构。</p>\n<p>使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。</p>\n<p>同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）</p>\n<p><code>正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。</code></p>\n<p>此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 <a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"noopener\">Wiki</a>。同时也推荐阅读 <a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html\" target=\"_blank\" rel=\"noopener\">开发建议手册</a> 以及 <a href=\"https://toddmotto.com/pure-versus-impure-functions\" target=\"_blank\" rel=\"noopener\">纯函数 vs. 非纯函数</a>.</p>\n<p>原文链接： medium.com</p>"},{"title":"Javascript正则速查表","date":"2018-05-12T16:22:33.000Z","description":null,"copyright":true,"top":null,"_content":"针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# replace:\n``` hash\n// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.\nfunction getLen(str) {\n  return str.replace(/[^\\x00-\\xff]/g, 'xx').length;\n}\n```\n# test:\n```hash\n// 匹配是否符合邮件规则\nvar reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;\n\n// test返回一个布尔值, 表示是否匹配到制定字符串\nvar mail = reg.test('anran758@gmail.com')\n\nif (mail) {\n  // 如果邮件格式正确的话, 就可以做点啥了(雾\n}\n```\n# 表单验证\n```hash\n// 用户名正则，4到16位（字母，数字，下划线，减号）\nvar userNameReg = /^[a-zA-Z0-9_-]{4,16}$/;\n\n// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\nvar passwordReg = /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;\n\n// 匹配邮箱地址\nvar mailReg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;\n\n// 中国六位数的邮政编码\nvar postalCode = /^\\d{6}$/;\n\n// 匹配15~18位身份证\nvar IDCard = /(^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$)|(^[1-9]\\d{5}\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{2}$)/;\n\n// 匹配18位的新版身份证\nvar IDCard_18 = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n```\n# 网络相关\n```hash\n//ipv4地址正则\nvar IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n// Reg Hex颜色正则\nvar pattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\n\n// URL正则\nvar urlReg= /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\n\n// 匹配JSON格式\nvar reg = /^\\w+\\(({[^()]+})\\)$/\n```\n# 联系方式\n```hash\n// 5-11位的腾讯qq号\nvar qqReg = /^[1-9][0-9]{4,11}$/;\n\n// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线\nvar qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;\n\n// 国内常见\nvar phone = /^1[3|5|8|9]\\d{9}$/;\n\n// 固定电话\nvar telephone = /^(0[0-9]{2})\\d{8}$|^(0[0-9]{3}(\\d{7,8}))$/;\n```\n# 字符串相关\n```hash\n// 匹配由26个英文字母组成的字符串\nvar reg = /^[A-Za-z]+$/;\n\n// 匹配由26个英文字母的大写组成的字符串\nvar reg = /^[A-Z]+$/;\n\n// 匹配由26个英文字母的小写组成的字符串\nvar reg = /^[a-z]+$/;\n\n// 匹配由数字和26个英文字母组成的字符串\nvar reg = /^[A-Za-z0-9]+$/;\n\n// 匹配由数字、26个英文字母或者下;划线组成的字符串\nvar reg = /^\\w+$/;\n\n// 匹配空白行的正则表达式\nvar reg = /\\n\\s*\\r/;\n\n// 匹配首尾空白字符的正则表达式\nvar reg = /^\\s*|\\s*$/;\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)\nvar reg = /[^\\x00-\\xff]/g;\n```\n# 匹配特定数字\n```hash\n// 匹配正整数\nvar reg = /^[1-9]\\d*$/;\n\n// 匹配负整数\nvar reg = /^-[1-9]\\d*$/;\n\n// 匹配整数\nvar reg = /^-?[1-9]\\d*$/;\n\n// 匹配非负整数（正整数 + 0）\nvar reg = /^[1-9]\\d*|0$/;\n\n// 匹配非正整数（负整数 + 0）\nvar reg = /^-[1-9]\\d*|0$/;\n\n// 匹配正浮点数\nvar reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/;\n\n// 匹配负浮点数\nvar reg = /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/;\n\n// 匹配浮点数\nvar reg = /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/;\n\n// 匹配非负浮点数（正浮点数 + 0）\nvar reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/;\n\n// 匹配非正浮点数（负浮点数 + 0）\nvar reg = /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/;\n```\n\n","source":"_posts/Javascript正则速查表.md","raw":"---\ntitle: Javascript正则速查表\ndate: 2018-05-13 00:22:33\ntags: [Javascript,编程]\ndescription: \ncopyright: true\ncategories: Javascript\ntop:\n---\n针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# replace:\n``` hash\n// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.\nfunction getLen(str) {\n  return str.replace(/[^\\x00-\\xff]/g, 'xx').length;\n}\n```\n# test:\n```hash\n// 匹配是否符合邮件规则\nvar reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;\n\n// test返回一个布尔值, 表示是否匹配到制定字符串\nvar mail = reg.test('anran758@gmail.com')\n\nif (mail) {\n  // 如果邮件格式正确的话, 就可以做点啥了(雾\n}\n```\n# 表单验证\n```hash\n// 用户名正则，4到16位（字母，数字，下划线，减号）\nvar userNameReg = /^[a-zA-Z0-9_-]{4,16}$/;\n\n// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\nvar passwordReg = /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;\n\n// 匹配邮箱地址\nvar mailReg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;\n\n// 中国六位数的邮政编码\nvar postalCode = /^\\d{6}$/;\n\n// 匹配15~18位身份证\nvar IDCard = /(^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$)|(^[1-9]\\d{5}\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{2}$)/;\n\n// 匹配18位的新版身份证\nvar IDCard_18 = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n```\n# 网络相关\n```hash\n//ipv4地址正则\nvar IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n// Reg Hex颜色正则\nvar pattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\n\n// URL正则\nvar urlReg= /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\n\n// 匹配JSON格式\nvar reg = /^\\w+\\(({[^()]+})\\)$/\n```\n# 联系方式\n```hash\n// 5-11位的腾讯qq号\nvar qqReg = /^[1-9][0-9]{4,11}$/;\n\n// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线\nvar qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;\n\n// 国内常见\nvar phone = /^1[3|5|8|9]\\d{9}$/;\n\n// 固定电话\nvar telephone = /^(0[0-9]{2})\\d{8}$|^(0[0-9]{3}(\\d{7,8}))$/;\n```\n# 字符串相关\n```hash\n// 匹配由26个英文字母组成的字符串\nvar reg = /^[A-Za-z]+$/;\n\n// 匹配由26个英文字母的大写组成的字符串\nvar reg = /^[A-Z]+$/;\n\n// 匹配由26个英文字母的小写组成的字符串\nvar reg = /^[a-z]+$/;\n\n// 匹配由数字和26个英文字母组成的字符串\nvar reg = /^[A-Za-z0-9]+$/;\n\n// 匹配由数字、26个英文字母或者下;划线组成的字符串\nvar reg = /^\\w+$/;\n\n// 匹配空白行的正则表达式\nvar reg = /\\n\\s*\\r/;\n\n// 匹配首尾空白字符的正则表达式\nvar reg = /^\\s*|\\s*$/;\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)\nvar reg = /[^\\x00-\\xff]/g;\n```\n# 匹配特定数字\n```hash\n// 匹配正整数\nvar reg = /^[1-9]\\d*$/;\n\n// 匹配负整数\nvar reg = /^-[1-9]\\d*$/;\n\n// 匹配整数\nvar reg = /^-?[1-9]\\d*$/;\n\n// 匹配非负整数（正整数 + 0）\nvar reg = /^[1-9]\\d*|0$/;\n\n// 匹配非正整数（负整数 + 0）\nvar reg = /^-[1-9]\\d*|0$/;\n\n// 匹配正浮点数\nvar reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/;\n\n// 匹配负浮点数\nvar reg = /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/;\n\n// 匹配浮点数\nvar reg = /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/;\n\n// 匹配非负浮点数（正浮点数 + 0）\nvar reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/;\n\n// 匹配非正浮点数（负浮点数 + 0）\nvar reg = /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/;\n```\n\n","slug":"Javascript正则速查表","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctndi000okt89w7peutqw","content":"<p>针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace:\"></a>replace:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.</span><br><span class=\"line\">function getLen(str) &#123;</span><br><span class=\"line\">  return str.replace(/[^\\x00-\\xff]/g, &apos;xx&apos;).length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test:\"></a>test:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配是否符合邮件规则</span><br><span class=\"line\">var reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;</span><br><span class=\"line\"></span><br><span class=\"line\">// test返回一个布尔值, 表示是否匹配到制定字符串</span><br><span class=\"line\">var mail = reg.test(&apos;anran758@gmail.com&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (mail) &#123;</span><br><span class=\"line\">  // 如果邮件格式正确的话, 就可以做点啥了(雾</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class=\"line\">var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class=\"line\">var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配邮箱地址</span><br><span class=\"line\">var mailReg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中国六位数的邮政编码</span><br><span class=\"line\">var postalCode = /^\\d&#123;6&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配15~18位身份证</span><br><span class=\"line\">var IDCard = /(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;2&#125;$)/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配18位的新版身份证</span><br><span class=\"line\">var IDCard_18 = /^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/;</span><br></pre></td></tr></table></figure>\n<h1 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ipv4地址正则</span><br><span class=\"line\">var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// Reg Hex颜色正则</span><br><span class=\"line\">var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL正则</span><br><span class=\"line\">var urlReg= /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配JSON格式</span><br><span class=\"line\">var reg = /^\\w+\\((&#123;[^()]+&#125;)\\)$/</span><br></pre></td></tr></table></figure>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 5-11位的腾讯qq号</span><br><span class=\"line\">var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线</span><br><span class=\"line\">var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 国内常见</span><br><span class=\"line\">var phone = /^1[3|5|8|9]\\d&#123;9&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 固定电话</span><br><span class=\"line\">var telephone = /^(0[0-9]&#123;2&#125;)\\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\\d&#123;7,8&#125;))$/;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配由26个英文字母组成的字符串</span><br><span class=\"line\">var reg = /^[A-Za-z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由26个英文字母的大写组成的字符串</span><br><span class=\"line\">var reg = /^[A-Z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由26个英文字母的小写组成的字符串</span><br><span class=\"line\">var reg = /^[a-z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由数字和26个英文字母组成的字符串</span><br><span class=\"line\">var reg = /^[A-Za-z0-9]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由数字、26个英文字母或者下;划线组成的字符串</span><br><span class=\"line\">var reg = /^\\w+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配空白行的正则表达式</span><br><span class=\"line\">var reg = /\\n\\s*\\r/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配首尾空白字符的正则表达式</span><br><span class=\"line\">var reg = /^\\s*|\\s*$/;</span><br><span class=\"line\">var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)</span><br><span class=\"line\">var reg = /[^\\x00-\\xff]/g;</span><br></pre></td></tr></table></figure>\n<h1 id=\"匹配特定数字\"><a href=\"#匹配特定数字\" class=\"headerlink\" title=\"匹配特定数字\"></a>匹配特定数字</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配正整数</span><br><span class=\"line\">var reg = /^[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配负整数</span><br><span class=\"line\">var reg = /^-[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配整数</span><br><span class=\"line\">var reg = /^-?[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非负整数（正整数 + 0）</span><br><span class=\"line\">var reg = /^[1-9]\\d*|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非正整数（负整数 + 0）</span><br><span class=\"line\">var reg = /^-[1-9]\\d*|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配正浮点数</span><br><span class=\"line\">var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配负浮点数</span><br><span class=\"line\">var reg = /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配浮点数</span><br><span class=\"line\">var reg = /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非负浮点数（正浮点数 + 0）</span><br><span class=\"line\">var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非正浮点数（负浮点数 + 0）</span><br><span class=\"line\">var reg = /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>","more":"<h1 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace:\"></a>replace:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.</span><br><span class=\"line\">function getLen(str) &#123;</span><br><span class=\"line\">  return str.replace(/[^\\x00-\\xff]/g, &apos;xx&apos;).length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test:\"></a>test:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配是否符合邮件规则</span><br><span class=\"line\">var reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;</span><br><span class=\"line\"></span><br><span class=\"line\">// test返回一个布尔值, 表示是否匹配到制定字符串</span><br><span class=\"line\">var mail = reg.test(&apos;anran758@gmail.com&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (mail) &#123;</span><br><span class=\"line\">  // 如果邮件格式正确的话, 就可以做点啥了(雾</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class=\"line\">var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class=\"line\">var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配邮箱地址</span><br><span class=\"line\">var mailReg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中国六位数的邮政编码</span><br><span class=\"line\">var postalCode = /^\\d&#123;6&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配15~18位身份证</span><br><span class=\"line\">var IDCard = /(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;2&#125;$)/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配18位的新版身份证</span><br><span class=\"line\">var IDCard_18 = /^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/;</span><br></pre></td></tr></table></figure>\n<h1 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ipv4地址正则</span><br><span class=\"line\">var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// Reg Hex颜色正则</span><br><span class=\"line\">var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL正则</span><br><span class=\"line\">var urlReg= /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配JSON格式</span><br><span class=\"line\">var reg = /^\\w+\\((&#123;[^()]+&#125;)\\)$/</span><br></pre></td></tr></table></figure>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 5-11位的腾讯qq号</span><br><span class=\"line\">var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线</span><br><span class=\"line\">var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 国内常见</span><br><span class=\"line\">var phone = /^1[3|5|8|9]\\d&#123;9&#125;$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 固定电话</span><br><span class=\"line\">var telephone = /^(0[0-9]&#123;2&#125;)\\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\\d&#123;7,8&#125;))$/;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配由26个英文字母组成的字符串</span><br><span class=\"line\">var reg = /^[A-Za-z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由26个英文字母的大写组成的字符串</span><br><span class=\"line\">var reg = /^[A-Z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由26个英文字母的小写组成的字符串</span><br><span class=\"line\">var reg = /^[a-z]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由数字和26个英文字母组成的字符串</span><br><span class=\"line\">var reg = /^[A-Za-z0-9]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配由数字、26个英文字母或者下;划线组成的字符串</span><br><span class=\"line\">var reg = /^\\w+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配空白行的正则表达式</span><br><span class=\"line\">var reg = /\\n\\s*\\r/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配首尾空白字符的正则表达式</span><br><span class=\"line\">var reg = /^\\s*|\\s*$/;</span><br><span class=\"line\">var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)</span><br><span class=\"line\">var reg = /[^\\x00-\\xff]/g;</span><br></pre></td></tr></table></figure>\n<h1 id=\"匹配特定数字\"><a href=\"#匹配特定数字\" class=\"headerlink\" title=\"匹配特定数字\"></a>匹配特定数字</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配正整数</span><br><span class=\"line\">var reg = /^[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配负整数</span><br><span class=\"line\">var reg = /^-[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配整数</span><br><span class=\"line\">var reg = /^-?[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非负整数（正整数 + 0）</span><br><span class=\"line\">var reg = /^[1-9]\\d*|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非正整数（负整数 + 0）</span><br><span class=\"line\">var reg = /^-[1-9]\\d*|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配正浮点数</span><br><span class=\"line\">var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配负浮点数</span><br><span class=\"line\">var reg = /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配浮点数</span><br><span class=\"line\">var reg = /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非负浮点数（正浮点数 + 0）</span><br><span class=\"line\">var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配非正浮点数（负浮点数 + 0）</span><br><span class=\"line\">var reg = /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/;</span><br></pre></td></tr></table></figure>"},{"title":"React 开发常用设计模式-前言","date":"2018-05-14T14:48:42.000Z","description":"介绍使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。","copyright":true,"top":null,"_content":"# React 模式\n介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n* [Web https://sangka.github.io/react-in-patterns-cn/](https://sangka.github.io/react-in-patterns-cn/)\n\n* [GitHub https://github.com/SangKa/react-in-patterns-cn](GitHub (https://github.com/SangKa/react-in-patterns-cn)\n\n![设计模式](React 开发常用设计模式-前言/cover1.png)","source":"_posts/React-开发常用设计模式-前言.md","raw":"---\ntitle: React 开发常用设计模式-前言\ndate: 2018-05-14 22:48:42\ntags: [React,Javascript]\ndescription: 介绍使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。\ncopyright: true\ncategories: React\ntop:\n---\n# React 模式\n介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n* [Web https://sangka.github.io/react-in-patterns-cn/](https://sangka.github.io/react-in-patterns-cn/)\n\n* [GitHub https://github.com/SangKa/react-in-patterns-cn](GitHub (https://github.com/SangKa/react-in-patterns-cn)\n\n![设计模式](React 开发常用设计模式-前言/cover1.png)","slug":"React-开发常用设计模式-前言","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctndm000tkt89uhajn44m","content":"<h1 id=\"React-模式\"><a href=\"#React-模式\" class=\"headerlink\" title=\"React 模式\"></a>React 模式</h1><p>介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<ul>\n<li><p><a href=\"https://sangka.github.io/react-in-patterns-cn/\" target=\"_blank\" rel=\"noopener\">Web https://sangka.github.io/react-in-patterns-cn/</a></p>\n</li>\n<li><p><a href=\"GitHub (https://github.com/SangKa/react-in-patterns-cn\">GitHub https://github.com/SangKa/react-in-patterns-cn</a></p>\n</li>\n</ul>\n<p><img src=\"/blog/2018/05/14/React-开发常用设计模式-前言/cover1.png\" alt=\"设计模式\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"React-模式\"><a href=\"#React-模式\" class=\"headerlink\" title=\"React 模式\"></a>React 模式</h1><p>介绍了使用 React 开发时的一些常用设计模式，其中包括的技术有组合( composition )、数据流、依赖管理，等等。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<ul>\n<li><p><a href=\"https://sangka.github.io/react-in-patterns-cn/\" target=\"_blank\" rel=\"noopener\">Web https://sangka.github.io/react-in-patterns-cn/</a></p>\n</li>\n<li><p><a href=\"GitHub (https://github.com/SangKa/react-in-patterns-cn\">GitHub https://github.com/SangKa/react-in-patterns-cn</a></p>\n</li>\n</ul>\n<p><img src=\"/blog/2018/05/14/React-开发常用设计模式-前言/cover1.png\" alt=\"设计模式\"></p>"},{"title":"React16新特性来认识一波","date":"2018-11-29T10:34:52.000Z","description":null,"copyright":false,"top":null,"_content":"React的16版本，采用了MIT开源许可证,React16新特性来认识一波。\n- `Fragments`：render函数可以返回数组和字符串\n- `error boundaries`：错误处理\n- `portals` ：支持声明性地将子树渲染到另一个DOM节点\n- `custom DOM attributes` ：ReactDom允许传递非标准属性\n- `improved server-side rendering`:提升服务端渲染性能\n- 支持自定义DOM属性\n- setState传入null时不会再触发更新\n- 更好的服务器端渲染\n- 新的打包策略\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png)\n\n<!--more-->\n\n# 新特性\n\n# 1、render可以return数组 ，字符串\n\n React16新增加了render的返回格式，你可以return返回`string，number，boolean，null，portal，以及fragments(带有key属性的数组)`，且不需要外层包含div标签。不过需要添加对应的key值。\n\n```h\n    //string\n    render(){\n        return 'Hello,world'\n    }\n\n    //number\n    render(){\n        return 0123456789\n    }\n\n    //boolean\n    render(){\n        return isTrue ? true : false\n    }\n\n    //null\n    render(){\n        return null\n    }\n\n    //fragments，遇到控制台出现warning,是未加key标识符，\n    render(){\n        return [\n            <div>Hello</div>,\n            <span>world</span>,\n            <p>DRL</p>\n        ]\n    }\n\n```\n\n# 2、error boundaries错误处理\n\nReact16新增加了抛异常的生命周期函数`componentDidCatch`\n\n```h\n  componentDidCatch(err,info){\n        this.setState({isError:1});\n    }\n```\n \n 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为`try-catch`\n\n 在容易出错的组件外使用ErrorBoundary将它包裹起来:\n\n ```h\n//使用方式\n\nimport React, { Component } from 'react'\n\nexport default class ErrorBoundary extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { hasError: false }\n    }\n    componentDidCatch(err, info) {\n        this.setState({ hasError: true })\n    }\n    render(){\n        if(this.state.hasError){\n            return <div>Something wrong!</div>\n        }\n        return this.props.children\n    }\n}\n\n\nrender(){\n    return (\n        <div>\n            <ErrorBoundary>\n                <Listview user={this.state.data} />\n            </ErrorBoundary>\n            <button onClick={this.onClickChange}>toUpdate</button>\n        </div>\n    )\n}\n\n```\n\n如果Listview组件发生错误，将会使用ErrorBoundary提供的`<div>Something went wrong</div>`代替它，不会引起整个组件树的卸载。\n\n\n# 3、`portals`支持声明性地将子树渲染到另一个DOM节点\n\nPortals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。\n\n```h\n//实现一个简易蒙层效果，抽象出一个通用的Overlay组件\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nexport default class Overlay extends Component {\n    constructor(props) {\n        super(props);\n        this.container = document.createElement('div');\n        document.body.appendChild(this.container);\n    }\n    componentWillUnmount() {\n        document.body.removeChild(this.container);\n    }\n    render() {\n        return ReactDOM.createPortal(\n            <div className='overlay'>\n                <span className='overlay-close' onClick={this.props.onClose}>&times;</span>\n                {this.props.children}\n            </div>,\n            this.container\n        )\n    }\n}\n//该组件对应的样式如下\n.overlay{\n    box-sizing:border-box;\n    position: fixed;\n    top:50%;\n    left:50%;\n    width:260px;\n    height:200px;\n    margin-left:-130px;\n    margin-top:-100px;\n    padding:10px;\n    background-color: #fff;\n    outline: rgba(0,0,0,.5) solid 9999px;\n}\n.overlay-close{\n    position: absolute;\n    top:10px;\n    right:10px;\n    color:red;\n    cursor: pointer;\n}\n\n使用方式如下：\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      overlayActive: false\n    }\n    this.closeOverlay = this.closeOverlay.bind(this);\n    this.showOverlay = this.showOverlay.bind(this);\n  }\n  closeOverlay() {\n    this.setState({ overlayActive: false })\n  }\n  showOverlay() {\n    this.setState({ overlayActive: true })\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <div>hello world!</div>\n        {this.state.overlayActive &&\n          <Overlay onClose={this.closeOverlay}>overlay content</Overlay>}\n        <button onClick={this.showOverlay}>show</button>\n      </div>\n    );\n  }\n}\n \n```\n\n\n\n# 4、`custom DOM attributes` ：ReactDom允许传递非标准属性\n# 5、 `improved server-side rendering`:提升服务端渲染性能\n# 6、 支持自定义DOM属性\n# 7、 setState传入null时不会再触发更新\n# 8、 更好的服务器端渲染\n# 9、 新的打包策略\n\n\n\n\n","source":"_posts/React16新特性来认识一波.md","raw":"---\ntitle: React16新特性来认识一波\ndate: 2018-11-29 18:34:52\ntags: [React,编程]\ndescription: \ncopyright: false\ncategories: React\ntop:\n---\nReact的16版本，采用了MIT开源许可证,React16新特性来认识一波。\n- `Fragments`：render函数可以返回数组和字符串\n- `error boundaries`：错误处理\n- `portals` ：支持声明性地将子树渲染到另一个DOM节点\n- `custom DOM attributes` ：ReactDom允许传递非标准属性\n- `improved server-side rendering`:提升服务端渲染性能\n- 支持自定义DOM属性\n- setState传入null时不会再触发更新\n- 更好的服务器端渲染\n- 新的打包策略\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png)\n\n<!--more-->\n\n# 新特性\n\n# 1、render可以return数组 ，字符串\n\n React16新增加了render的返回格式，你可以return返回`string，number，boolean，null，portal，以及fragments(带有key属性的数组)`，且不需要外层包含div标签。不过需要添加对应的key值。\n\n```h\n    //string\n    render(){\n        return 'Hello,world'\n    }\n\n    //number\n    render(){\n        return 0123456789\n    }\n\n    //boolean\n    render(){\n        return isTrue ? true : false\n    }\n\n    //null\n    render(){\n        return null\n    }\n\n    //fragments，遇到控制台出现warning,是未加key标识符，\n    render(){\n        return [\n            <div>Hello</div>,\n            <span>world</span>,\n            <p>DRL</p>\n        ]\n    }\n\n```\n\n# 2、error boundaries错误处理\n\nReact16新增加了抛异常的生命周期函数`componentDidCatch`\n\n```h\n  componentDidCatch(err,info){\n        this.setState({isError:1});\n    }\n```\n \n 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为`try-catch`\n\n 在容易出错的组件外使用ErrorBoundary将它包裹起来:\n\n ```h\n//使用方式\n\nimport React, { Component } from 'react'\n\nexport default class ErrorBoundary extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { hasError: false }\n    }\n    componentDidCatch(err, info) {\n        this.setState({ hasError: true })\n    }\n    render(){\n        if(this.state.hasError){\n            return <div>Something wrong!</div>\n        }\n        return this.props.children\n    }\n}\n\n\nrender(){\n    return (\n        <div>\n            <ErrorBoundary>\n                <Listview user={this.state.data} />\n            </ErrorBoundary>\n            <button onClick={this.onClickChange}>toUpdate</button>\n        </div>\n    )\n}\n\n```\n\n如果Listview组件发生错误，将会使用ErrorBoundary提供的`<div>Something went wrong</div>`代替它，不会引起整个组件树的卸载。\n\n\n# 3、`portals`支持声明性地将子树渲染到另一个DOM节点\n\nPortals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。\n\n```h\n//实现一个简易蒙层效果，抽象出一个通用的Overlay组件\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nexport default class Overlay extends Component {\n    constructor(props) {\n        super(props);\n        this.container = document.createElement('div');\n        document.body.appendChild(this.container);\n    }\n    componentWillUnmount() {\n        document.body.removeChild(this.container);\n    }\n    render() {\n        return ReactDOM.createPortal(\n            <div className='overlay'>\n                <span className='overlay-close' onClick={this.props.onClose}>&times;</span>\n                {this.props.children}\n            </div>,\n            this.container\n        )\n    }\n}\n//该组件对应的样式如下\n.overlay{\n    box-sizing:border-box;\n    position: fixed;\n    top:50%;\n    left:50%;\n    width:260px;\n    height:200px;\n    margin-left:-130px;\n    margin-top:-100px;\n    padding:10px;\n    background-color: #fff;\n    outline: rgba(0,0,0,.5) solid 9999px;\n}\n.overlay-close{\n    position: absolute;\n    top:10px;\n    right:10px;\n    color:red;\n    cursor: pointer;\n}\n\n使用方式如下：\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      overlayActive: false\n    }\n    this.closeOverlay = this.closeOverlay.bind(this);\n    this.showOverlay = this.showOverlay.bind(this);\n  }\n  closeOverlay() {\n    this.setState({ overlayActive: false })\n  }\n  showOverlay() {\n    this.setState({ overlayActive: true })\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <div>hello world!</div>\n        {this.state.overlayActive &&\n          <Overlay onClose={this.closeOverlay}>overlay content</Overlay>}\n        <button onClick={this.showOverlay}>show</button>\n      </div>\n    );\n  }\n}\n \n```\n\n\n\n# 4、`custom DOM attributes` ：ReactDom允许传递非标准属性\n# 5、 `improved server-side rendering`:提升服务端渲染性能\n# 6、 支持自定义DOM属性\n# 7、 setState传入null时不会再触发更新\n# 8、 更好的服务器端渲染\n# 9、 新的打包策略\n\n\n\n\n","slug":"React16新特性来认识一波","published":1,"updated":"2018-12-13T08:32:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnds000wkt896s2zjpz1","content":"<p>React的16版本，采用了MIT开源许可证,React16新特性来认识一波。</p>\n<ul>\n<li><code>Fragments</code>：render函数可以返回数组和字符串</li>\n<li><code>error boundaries</code>：错误处理</li>\n<li><code>portals</code> ：支持声明性地将子树渲染到另一个DOM节点</li>\n<li><code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</li>\n<li><code>improved server-side rendering</code>:提升服务端渲染性能</li>\n<li>支持自定义DOM属性</li>\n<li>setState传入null时不会再触发更新</li>\n<li>更好的服务器端渲染</li>\n<li>新的打包策略</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h1><h1 id=\"1、render可以return数组-，字符串\"><a href=\"#1、render可以return数组-，字符串\" class=\"headerlink\" title=\"1、render可以return数组 ，字符串\"></a>1、render可以return数组 ，字符串</h1><p> React16新增加了render的返回格式，你可以return返回<code>string，number，boolean，null，portal，以及fragments(带有key属性的数组)</code>，且不需要外层包含div标签。不过需要添加对应的key值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//string</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return 'Hello,world'</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//number</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0123456789</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//boolean</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isTrue ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> null</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//fragments，遇到控制台出现warning,是未加key标识符，</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        &lt;div&gt;Hello&lt;/div&gt;,</span><br><span class=\"line\">        &lt;span&gt;world&lt;/span&gt;,</span><br><span class=\"line\">        &lt;p&gt;DRL&lt;/p&gt;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、error-boundaries错误处理\"><a href=\"#2、error-boundaries错误处理\" class=\"headerlink\" title=\"2、error boundaries错误处理\"></a>2、error boundaries错误处理</h1><p>React16新增加了抛异常的生命周期函数<code>componentDidCatch</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidCatch(err,info)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;isError:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p> 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为<code>try-catch</code></p>\n<p> 在容易出错的组件外使用ErrorBoundary将它包裹起来:</p>\n <figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用方式</span></span><br><span class=\"line\"></span><br><span class=\"line\">import React, &#123; Component &#125; from 'react'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorBoundary</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; hasError: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidCatch(err, info) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; hasError: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.hasError)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;div&gt;Something wrong!&lt;/div&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ErrorBoundary&gt;</span><br><span class=\"line\">                &lt;Listview user=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">            &lt;/ErrorBoundary&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;<span class=\"keyword\">this</span>.onClickChange&#125;&gt;toUpdate&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果Listview组件发生错误，将会使用ErrorBoundary提供的<code>&lt;div&gt;Something went wrong&lt;/div&gt;</code>代替它，不会引起整个组件树的卸载。</p>\n<h1 id=\"3、portals支持声明性地将子树渲染到另一个DOM节点\"><a href=\"#3、portals支持声明性地将子树渲染到另一个DOM节点\" class=\"headerlink\" title=\"3、portals支持声明性地将子树渲染到另一个DOM节点\"></a>3、<code>portals</code>支持声明性地将子树渲染到另一个DOM节点</h1><p>Portals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现一个简易蒙层效果，抽象出一个通用的Overlay组件</span></span><br><span class=\"line\">import React, &#123; Component &#125; from 'react';</span><br><span class=\"line\">import ReactDOM from 'react-dom';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Overlay</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.container = document.createElement('div');</span><br><span class=\"line\">        document.body.appendChild(<span class=\"keyword\">this</span>.container);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        document.body.removeChild(<span class=\"keyword\">this</span>.container);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ReactDOM.createPortal(</span><br><span class=\"line\">            &lt;div className='overlay'&gt;</span><br><span class=\"line\">                &lt;span className='overlay-close' onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt;</span><br><span class=\"line\">                &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">            &lt;/div&gt;,</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.container</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//该组件对应的样式如下</span></span><br><span class=\"line\">.overlay&#123;</span><br><span class=\"line\">    box-sizing:border-box;</span><br><span class=\"line\">    position: fixed;</span><br><span class=\"line\">    top:<span class=\"number\">50</span>%;</span><br><span class=\"line\">    left:<span class=\"number\">50</span>%;</span><br><span class=\"line\">    width:<span class=\"number\">260</span>px;</span><br><span class=\"line\">    height:<span class=\"number\">200</span>px;</span><br><span class=\"line\">    margin-left:<span class=\"number\">-130</span>px;</span><br><span class=\"line\">    margin-top:<span class=\"number\">-100</span>px;</span><br><span class=\"line\">    padding:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    background-color: <span class=\"meta\">#fff;</span></span><br><span class=\"line\">    outline: rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">.5</span>) solid <span class=\"number\">9999</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.overlay-close&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    right:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">    cursor: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">使用方式如下：</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      overlayActive: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.closeOverlay = <span class=\"keyword\">this</span>.closeOverlay.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.showOverlay = <span class=\"keyword\">this</span>.showOverlay.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  closeOverlay() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; overlayActive: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  showOverlay() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; overlayActive: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;hello world!&lt;/div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.overlayActive &amp;&amp;</span><br><span class=\"line\">          &lt;Overlay onClose=&#123;<span class=\"keyword\">this</span>.closeOverlay&#125;&gt;overlay content&lt;/Overlay&gt;&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.showOverlay&#125;&gt;show&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4、custom-DOM-attributes-：ReactDom允许传递非标准属性\"><a href=\"#4、custom-DOM-attributes-：ReactDom允许传递非标准属性\" class=\"headerlink\" title=\"4、custom DOM attributes ：ReactDom允许传递非标准属性\"></a>4、<code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</h1><h1 id=\"5、-improved-server-side-rendering-提升服务端渲染性能\"><a href=\"#5、-improved-server-side-rendering-提升服务端渲染性能\" class=\"headerlink\" title=\"5、 improved server-side rendering:提升服务端渲染性能\"></a>5、 <code>improved server-side rendering</code>:提升服务端渲染性能</h1><h1 id=\"6、-支持自定义DOM属性\"><a href=\"#6、-支持自定义DOM属性\" class=\"headerlink\" title=\"6、 支持自定义DOM属性\"></a>6、 支持自定义DOM属性</h1><h1 id=\"7、-setState传入null时不会再触发更新\"><a href=\"#7、-setState传入null时不会再触发更新\" class=\"headerlink\" title=\"7、 setState传入null时不会再触发更新\"></a>7、 setState传入null时不会再触发更新</h1><h1 id=\"8、-更好的服务器端渲染\"><a href=\"#8、-更好的服务器端渲染\" class=\"headerlink\" title=\"8、 更好的服务器端渲染\"></a>8、 更好的服务器端渲染</h1><h1 id=\"9、-新的打包策略\"><a href=\"#9、-新的打包策略\" class=\"headerlink\" title=\"9、 新的打包策略\"></a>9、 新的打包策略</h1>","site":{"data":{}},"excerpt":"<p>React的16版本，采用了MIT开源许可证,React16新特性来认识一波。</p>\n<ul>\n<li><code>Fragments</code>：render函数可以返回数组和字符串</li>\n<li><code>error boundaries</code>：错误处理</li>\n<li><code>portals</code> ：支持声明性地将子树渲染到另一个DOM节点</li>\n<li><code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</li>\n<li><code>improved server-side rendering</code>:提升服务端渲染性能</li>\n<li>支持自定义DOM属性</li>\n<li>setState传入null时不会再触发更新</li>\n<li>更好的服务器端渲染</li>\n<li>新的打包策略</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react16.png\" alt=\"React\"></p>","more":"<h1 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h1><h1 id=\"1、render可以return数组-，字符串\"><a href=\"#1、render可以return数组-，字符串\" class=\"headerlink\" title=\"1、render可以return数组 ，字符串\"></a>1、render可以return数组 ，字符串</h1><p> React16新增加了render的返回格式，你可以return返回<code>string，number，boolean，null，portal，以及fragments(带有key属性的数组)</code>，且不需要外层包含div标签。不过需要添加对应的key值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//string</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return 'Hello,world'</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//number</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0123456789</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//boolean</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isTrue ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> null</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//fragments，遇到控制台出现warning,是未加key标识符，</span></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        &lt;div&gt;Hello&lt;/div&gt;,</span><br><span class=\"line\">        &lt;span&gt;world&lt;/span&gt;,</span><br><span class=\"line\">        &lt;p&gt;DRL&lt;/p&gt;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、error-boundaries错误处理\"><a href=\"#2、error-boundaries错误处理\" class=\"headerlink\" title=\"2、error boundaries错误处理\"></a>2、error boundaries错误处理</h1><p>React16新增加了抛异常的生命周期函数<code>componentDidCatch</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidCatch(err,info)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;isError:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p> 运用这个寿命周期在遇到页面报错的时候就可以定义报错方式，给用户更好的体验。React 16之前页面内的组件如果发生错误，那么整个组件树就会从根节点被卸载，到了React 16 产生了一个“错误边界（error boundaries）”的概念,它会捕捉页面内的错误并且对这些错误进行处理。我们可以把它比喻为<code>try-catch</code></p>\n<p> 在容易出错的组件外使用ErrorBoundary将它包裹起来:</p>\n <figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用方式</span></span><br><span class=\"line\"></span><br><span class=\"line\">import React, &#123; Component &#125; from 'react'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorBoundary</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; hasError: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidCatch(err, info) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; hasError: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.hasError)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;div&gt;Something wrong!&lt;/div&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ErrorBoundary&gt;</span><br><span class=\"line\">                &lt;Listview user=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">            &lt;/ErrorBoundary&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;<span class=\"keyword\">this</span>.onClickChange&#125;&gt;toUpdate&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果Listview组件发生错误，将会使用ErrorBoundary提供的<code>&lt;div&gt;Something went wrong&lt;/div&gt;</code>代替它，不会引起整个组件树的卸载。</p>\n<h1 id=\"3、portals支持声明性地将子树渲染到另一个DOM节点\"><a href=\"#3、portals支持声明性地将子树渲染到另一个DOM节点\" class=\"headerlink\" title=\"3、portals支持声明性地将子树渲染到另一个DOM节点\"></a>3、<code>portals</code>支持声明性地将子树渲染到另一个DOM节点</h1><p>Portals机制提供了一种最直接的方式可以把一个子组件渲染到父组件渲染的DOM树之外。默认情况下，React组件树和DOM树是完全对应的，因此对于一些Modal,Overlay之类的组件，通常是将它们放在顶层，但逻辑上它们可能只是属于某个子组件，不利于组件的代码组织。通过使用createPortal，我们可以将组件渲染到我们想要的任意DOM节点中，但该组件依然处在React的父组件之内。带来的一个特性就是，在子组件产生的event依然可以被React父组件捕获，但在DOM结构中，它却不是你的父组件。对于组件组织，代码切割来说，这是一个很好的属性。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现一个简易蒙层效果，抽象出一个通用的Overlay组件</span></span><br><span class=\"line\">import React, &#123; Component &#125; from 'react';</span><br><span class=\"line\">import ReactDOM from 'react-dom';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Overlay</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.container = document.createElement('div');</span><br><span class=\"line\">        document.body.appendChild(<span class=\"keyword\">this</span>.container);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        document.body.removeChild(<span class=\"keyword\">this</span>.container);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ReactDOM.createPortal(</span><br><span class=\"line\">            &lt;div className='overlay'&gt;</span><br><span class=\"line\">                &lt;span className='overlay-close' onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt;</span><br><span class=\"line\">                &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">            &lt;/div&gt;,</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.container</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//该组件对应的样式如下</span></span><br><span class=\"line\">.overlay&#123;</span><br><span class=\"line\">    box-sizing:border-box;</span><br><span class=\"line\">    position: fixed;</span><br><span class=\"line\">    top:<span class=\"number\">50</span>%;</span><br><span class=\"line\">    left:<span class=\"number\">50</span>%;</span><br><span class=\"line\">    width:<span class=\"number\">260</span>px;</span><br><span class=\"line\">    height:<span class=\"number\">200</span>px;</span><br><span class=\"line\">    margin-left:<span class=\"number\">-130</span>px;</span><br><span class=\"line\">    margin-top:<span class=\"number\">-100</span>px;</span><br><span class=\"line\">    padding:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    background-color: <span class=\"meta\">#fff;</span></span><br><span class=\"line\">    outline: rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">.5</span>) solid <span class=\"number\">9999</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.overlay-close&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    right:<span class=\"number\">10</span>px;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">    cursor: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">使用方式如下：</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      overlayActive: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.closeOverlay = <span class=\"keyword\">this</span>.closeOverlay.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.showOverlay = <span class=\"keyword\">this</span>.showOverlay.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  closeOverlay() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; overlayActive: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  showOverlay() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; overlayActive: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;hello world!&lt;/div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.overlayActive &amp;&amp;</span><br><span class=\"line\">          &lt;Overlay onClose=&#123;<span class=\"keyword\">this</span>.closeOverlay&#125;&gt;overlay content&lt;/Overlay&gt;&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.showOverlay&#125;&gt;show&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4、custom-DOM-attributes-：ReactDom允许传递非标准属性\"><a href=\"#4、custom-DOM-attributes-：ReactDom允许传递非标准属性\" class=\"headerlink\" title=\"4、custom DOM attributes ：ReactDom允许传递非标准属性\"></a>4、<code>custom DOM attributes</code> ：ReactDom允许传递非标准属性</h1><h1 id=\"5、-improved-server-side-rendering-提升服务端渲染性能\"><a href=\"#5、-improved-server-side-rendering-提升服务端渲染性能\" class=\"headerlink\" title=\"5、 improved server-side rendering:提升服务端渲染性能\"></a>5、 <code>improved server-side rendering</code>:提升服务端渲染性能</h1><h1 id=\"6、-支持自定义DOM属性\"><a href=\"#6、-支持自定义DOM属性\" class=\"headerlink\" title=\"6、 支持自定义DOM属性\"></a>6、 支持自定义DOM属性</h1><h1 id=\"7、-setState传入null时不会再触发更新\"><a href=\"#7、-setState传入null时不会再触发更新\" class=\"headerlink\" title=\"7、 setState传入null时不会再触发更新\"></a>7、 setState传入null时不会再触发更新</h1><h1 id=\"8、-更好的服务器端渲染\"><a href=\"#8、-更好的服务器端渲染\" class=\"headerlink\" title=\"8、 更好的服务器端渲染\"></a>8、 更好的服务器端渲染</h1><h1 id=\"9、-新的打包策略\"><a href=\"#9、-新的打包策略\" class=\"headerlink\" title=\"9、 新的打包策略\"></a>9、 新的打包策略</h1>"},{"title":"React一些路由","date":"2018-05-08T15:44:22.000Z","description":null,"copyright":true,"top":null,"_content":"React路由Prompt、Redirect、match、Switch。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 1、Prompt组件 \n> 除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。\n\n它有一个必须的属性message，用于给用户提示信息。 \n基本使用：\n```hash\n<Prompt message=\"给用户提示信息\"/>\n```\n有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。 \n基本使用方式：\n```hash\n<Prompt when={true} message=\"给用户提示信息\"/>\n```\n***\n# 2、Redirect组件 \n> 在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。\n\nRedirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。\n基本使用：\n```hash\n<Redirect to='/new-path' />\n<Route path='/new-path' component={NewPage}/>\n```\n```hash\n<Route path=\"/index\" render={()=><Redirect to=\"/other\"/>}/>\n```\nRedirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它 \n基本使用方式：\n```hash\nimport React,{ Component } from \"react\";\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Prompt,Redirect } from \"react-router-dom\";\n\nclass Index extends Component{\n    render(){\n        return (\n            <div>this a Index page</div>\n        )\n    }\n}\nclass Other extends Component{\n    render(){\n        return (\n            <div>this a Other page</div>\n        )\n    }\n}\nclass Main extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            toast: false,\n        }\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/index\">这是首页</Link></li>\n                        <li><Link to=\"/other\">这是其他页</Link></li>\n                    </ul>\n                    <Route path=\"/index\" render={()=><Redirect to=\"/other\"/>}/>\n                    <Route path=\"/other\" component={Other}/>\n                </div>\n            </Router>\n        )\n    }\n}\n\n//因为重定向，所以每个路由展示界面都是other界面\n\nrender(<Main />,document.getElementById(\"root\"));\n```\n***\n# 3、Switch组件\n> 它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。\n\n基本使用方式：\n```hash\nimport { Switch } from \"react-router-dom\";\n\n<Switch>\n    <Route path=\"/\" component={Test1} />\n    <Route path=\"/Test\" component={Test2} />\n</Switch>\n```\n以下实例：\n```hash\nimport React,{ Component } from \"react\";\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Switch } from \"react-router-dom\";\n\nclass Home extends Component{\n    render(){\n        return (\n            <div>Home</div>\n        )\n    }\n}\nclass Other extends Component{\n    render(){\n        return (\n            <div>Other</div>\n        )\n    }\n}\nclass Switchs extends Component{\n    render(){\n        return (\n            <div>Switchs test</div>\n        )\n    }\n}\n\nclass Main extends Component{\n    constructor(props){\n        super(props);\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/home\">首页</Link></li>\n                        <li><Link to=\"/other\">其他页</Link></li>\n                    </ul>\n                    <Switch>\n                        <Route path=\"/:id\" component={Switchs}/>\n                        <Route path=\"/home\" component={Home}/>\n                        <Route path=\"/other\" component={Other}/>\n                    </Switch>\n                </div>\n            </Router>\n        )\n    }\n}\n\nrender(<Main />,document.getElementById(\"root\"));\n```\n***\n# 4、Match对象\n> match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。\n\n在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。\n\nMatch的获取方式： \n在Route component中，组件通过this.props.match获取。 \n在Route render 和Route children中，通过传递一个参数的方式获取。\n```\n以下实例：\n```hash\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Prompt,Redirect } from \"react-router-dom\";\n\nclass Match extends Component{\n    render(){\n        return (\n            <div>id:{this.props.match.params.id}</div>\n        )\n    }\n}\n\nclass Main extends Component{\n    constructor(props){\n        super(props);\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/home\">首页</Link></li>\n                        <li><Link to=\"/other\">其他页</Link></li>\n                    </ul>\n\n                    <Route path=\"/:id\" component={Match}/>\n                </div>\n            </Router>\n        )\n    }\n}\n//id是路径匹配参数。\nrender(<Main />,document.getElementById(\"root\"));\n```\n***","source":"_posts/React一些路由.md","raw":"---\ntitle: React一些路由\ndate: 2018-05-08 23:44:22\ntags: [React,编程]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\nReact路由Prompt、Redirect、match、Switch。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 1、Prompt组件 \n> 除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。\n\n它有一个必须的属性message，用于给用户提示信息。 \n基本使用：\n```hash\n<Prompt message=\"给用户提示信息\"/>\n```\n有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。 \n基本使用方式：\n```hash\n<Prompt when={true} message=\"给用户提示信息\"/>\n```\n***\n# 2、Redirect组件 \n> 在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。\n\nRedirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。\n基本使用：\n```hash\n<Redirect to='/new-path' />\n<Route path='/new-path' component={NewPage}/>\n```\n```hash\n<Route path=\"/index\" render={()=><Redirect to=\"/other\"/>}/>\n```\nRedirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它 \n基本使用方式：\n```hash\nimport React,{ Component } from \"react\";\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Prompt,Redirect } from \"react-router-dom\";\n\nclass Index extends Component{\n    render(){\n        return (\n            <div>this a Index page</div>\n        )\n    }\n}\nclass Other extends Component{\n    render(){\n        return (\n            <div>this a Other page</div>\n        )\n    }\n}\nclass Main extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            toast: false,\n        }\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/index\">这是首页</Link></li>\n                        <li><Link to=\"/other\">这是其他页</Link></li>\n                    </ul>\n                    <Route path=\"/index\" render={()=><Redirect to=\"/other\"/>}/>\n                    <Route path=\"/other\" component={Other}/>\n                </div>\n            </Router>\n        )\n    }\n}\n\n//因为重定向，所以每个路由展示界面都是other界面\n\nrender(<Main />,document.getElementById(\"root\"));\n```\n***\n# 3、Switch组件\n> 它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。\n\n基本使用方式：\n```hash\nimport { Switch } from \"react-router-dom\";\n\n<Switch>\n    <Route path=\"/\" component={Test1} />\n    <Route path=\"/Test\" component={Test2} />\n</Switch>\n```\n以下实例：\n```hash\nimport React,{ Component } from \"react\";\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Switch } from \"react-router-dom\";\n\nclass Home extends Component{\n    render(){\n        return (\n            <div>Home</div>\n        )\n    }\n}\nclass Other extends Component{\n    render(){\n        return (\n            <div>Other</div>\n        )\n    }\n}\nclass Switchs extends Component{\n    render(){\n        return (\n            <div>Switchs test</div>\n        )\n    }\n}\n\nclass Main extends Component{\n    constructor(props){\n        super(props);\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/home\">首页</Link></li>\n                        <li><Link to=\"/other\">其他页</Link></li>\n                    </ul>\n                    <Switch>\n                        <Route path=\"/:id\" component={Switchs}/>\n                        <Route path=\"/home\" component={Home}/>\n                        <Route path=\"/other\" component={Other}/>\n                    </Switch>\n                </div>\n            </Router>\n        )\n    }\n}\n\nrender(<Main />,document.getElementById(\"root\"));\n```\n***\n# 4、Match对象\n> match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。\n\n在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。\n\nMatch的获取方式： \n在Route component中，组件通过this.props.match获取。 \n在Route render 和Route children中，通过传递一个参数的方式获取。\n```\n以下实例：\n```hash\nimport { render } from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link, Prompt,Redirect } from \"react-router-dom\";\n\nclass Match extends Component{\n    render(){\n        return (\n            <div>id:{this.props.match.params.id}</div>\n        )\n    }\n}\n\nclass Main extends Component{\n    constructor(props){\n        super(props);\n    }\n    render(){\n        return (\n            <Router>\n                <div>\n                    <ul>\n                        <li><Link to=\"/home\">首页</Link></li>\n                        <li><Link to=\"/other\">其他页</Link></li>\n                    </ul>\n\n                    <Route path=\"/:id\" component={Match}/>\n                </div>\n            </Router>\n        )\n    }\n}\n//id是路径匹配参数。\nrender(<Main />,document.getElementById(\"root\"));\n```\n***","slug":"React一些路由","published":1,"updated":"2018-09-18T14:12:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctndx0011kt89bw27fknb","content":"<p>React路由Prompt、Redirect、match、Switch。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"1、Prompt组件\"><a href=\"#1、Prompt组件\" class=\"headerlink\" title=\"1、Prompt组件\"></a>1、Prompt组件</h1><blockquote>\n<p>除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。</p>\n</blockquote>\n<p>它有一个必须的属性message，用于给用户提示信息。<br>基本使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Prompt message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。<br>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Prompt when=&#123;true&#125; message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"2、Redirect组件\"><a href=\"#2、Redirect组件\" class=\"headerlink\" title=\"2、Redirect组件\"></a>2、Redirect组件</h1><blockquote>\n<p>在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。</p>\n</blockquote>\n<p>Redirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。<br>基本使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Redirect to=&apos;/new-path&apos; /&gt;</span><br><span class=\"line\">&lt;Route path=&apos;/new-path&apos; component=&#123;NewPage&#125;/&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它<br>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Index extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;this a Index page&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Other extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;this a Other page&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            toast: false,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/index&quot;&gt;这是首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;这是其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\">                    &lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br><span class=\"line\">                    &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//因为重定向，所以每个路由展示界面都是other界面</span><br><span class=\"line\"></span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"3、Switch组件\"><a href=\"#3、Switch组件\" class=\"headerlink\" title=\"3、Switch组件\"></a>3、Switch组件</h1><blockquote>\n<p>它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。</p>\n</blockquote>\n<p>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/&quot; component=&#123;Test1&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/Test&quot; component=&#123;Test2&#125; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以下实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Home extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Home&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Other extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Other&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Switchs extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Switchs test&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\">                    &lt;Switch&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/:id&quot; component=&#123;Switchs&#125;/&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class=\"line\">                    &lt;/Switch&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"4、Match对象\"><a href=\"#4、Match对象\" class=\"headerlink\" title=\"4、Match对象\"></a>4、Match对象</h1><blockquote>\n<p>match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。</p>\n</blockquote>\n<p>在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。</p>\n<p>Match的获取方式：<br>在Route component中，组件通过this.props.match获取。<br>在Route render 和Route children中，通过传递一个参数的方式获取。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下实例：</span><br><span class=\"line\">```hash</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Match extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;id:&#123;this.props.match.params.id&#125;&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &lt;Route path=&quot;/:id&quot; component=&#123;Match&#125;/&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//id是路径匹配参数。</span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>React路由Prompt、Redirect、match、Switch。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"1、Prompt组件\"><a href=\"#1、Prompt组件\" class=\"headerlink\" title=\"1、Prompt组件\"></a>1、Prompt组件</h1><blockquote>\n<p>除了Router、Route、Link这三个react路由的基础搭配使用，还有一些其他的比较重要的组件，比如我们在页面切换时，需要进行一些提示，我们就能使用Prompt组件。</p>\n</blockquote>\n<p>它有一个必须的属性message，用于给用户提示信息。<br>基本使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Prompt message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>有时候，我们希望提示消息，有时候我们不希望提示出现，这就用到它的另外一个属性-when。when有两种情况，当它的值是true时，会提示消息。当它的值为false时，不会提示消息。<br>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Prompt when=&#123;true&#125; message=&quot;给用户提示信息&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"2、Redirect组件\"><a href=\"#2、Redirect组件\" class=\"headerlink\" title=\"2、Redirect组件\"></a>2、Redirect组件</h1><blockquote>\n<p>在匹配一个路径时，但是可能这个路径，我们更希望它指向一个新的展示界面，而不是它原本的路径匹配界面。</p>\n</blockquote>\n<p>Redirect组件的必须属性是to属性，表示重定向的新地址。 因为重定向了一个新的地址，必须有一个对应的新的地址的Route，来指定重定向的界面。<br>基本使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Redirect to=&apos;/new-path&apos; /&gt;</span><br><span class=\"line\">&lt;Route path=&apos;/new-path&apos; component=&#123;NewPage&#125;/&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它<br>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Index extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;this a Index page&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Other extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;this a Other page&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            toast: false,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/index&quot;&gt;这是首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;这是其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\">                    &lt;Route path=&quot;/index&quot; render=&#123;()=&gt;&lt;Redirect to=&quot;/other&quot;/&gt;&#125;/&gt;</span><br><span class=\"line\">                    &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//因为重定向，所以每个路由展示界面都是other界面</span><br><span class=\"line\"></span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"3、Switch组件\"><a href=\"#3、Switch组件\" class=\"headerlink\" title=\"3、Switch组件\"></a>3、Switch组件</h1><blockquote>\n<p>它的特性是我们只渲染所匹配到的第一个路由组件，一般界面渲染的时候，会渲染所有匹配到的路由组件。它的孩子节点只能是Route组件或者Redirect组件。</p>\n</blockquote>\n<p>基本使用方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/&quot; component=&#123;Test1&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/Test&quot; component=&#123;Test2&#125; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以下实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Home extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Home&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Other extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Other&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Switchs extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;Switchs test&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\">                    &lt;Switch&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/:id&quot; component=&#123;Switchs&#125;/&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class=\"line\">                        &lt;Route path=&quot;/other&quot; component=&#123;Other&#125;/&gt;</span><br><span class=\"line\">                    &lt;/Switch&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"4、Match对象\"><a href=\"#4、Match对象\" class=\"headerlink\" title=\"4、Match对象\"></a>4、Match对象</h1><blockquote>\n<p>match是一个匹配路径参数的对象，它有一个属性params，里面的内容就是路径参数，除常用的params属性外，它还有url、path、isExact属性。</p>\n</blockquote>\n<p>在组件Match中，通过this.props.match.params.id获取了路径的匹配参数。首页参数home，其他页是other。</p>\n<p>Match的获取方式：<br>在Route component中，组件通过this.props.match获取。<br>在Route render 和Route children中，通过传递一个参数的方式获取。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下实例：</span><br><span class=\"line\">```hash</span><br><span class=\"line\">import &#123; render &#125; from &quot;react-dom&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route, Link, Prompt,Redirect &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Match extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;id:&#123;this.props.match.params.id&#125;&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;ul&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                        &lt;li&gt;&lt;Link to=&quot;/other&quot;&gt;其他页&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">                    &lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &lt;Route path=&quot;/:id&quot; component=&#123;Match&#125;/&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/Router&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//id是路径匹配参数。</span><br><span class=\"line\">render(&lt;Main /&gt;,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure></p>\n<hr>"},{"title":"React开发常用设计模式-Flux","date":"2018-05-17T16:37:45.000Z","description":null,"copyright":true,"top":null,"_content":"Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# Flux\n我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。\n\n[Flux](http://facebook.github.io/flux/) 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 [F8](https://youtu.be/nYkdrAPrdcw?t=568) 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 [React](http://facebook.github.io/react/) 搭配使用。React 是 Facebook 发布的另外一个库。在 [日常工作](http://antidote.me/) 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。\n# Flux 架构及其主要特点\n![Flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_basic_flux_architecture.jpg)\n\n这种模式的主角是` dispatcher` 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 `actions` (动作) 的通知并将其传给所有的 `stores` 。`store` 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 `views `(视图，这里指 React 组件) 的重新渲染。如果非要将 `Flux `和大名鼎鼎的` MVC` 相比较的话，`Flux` 中的` store` 类似于` MVC `中的 `model` 。它负责保存和修改数据。\n\n传给 `dispatcher` 的动作可以来自于视图，也可以来自于系统的其他部分，比如 `services` 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。\n# 实现 Flux 架构\n如其他流行的概念一样，Flux 也有一些 [变种](https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73) 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。\n# Dispatcher\n大多数场景下，我们只需要一个单个的` dispatcher` 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。`dispatcher` 需要知道两样东西: 动作和 `stores` 。动作只是简单地转发给 `stores`，所以没必要保存它们。然而，`stores` 应该在 `dispatcher` 中进行追踪，这样才可以遍历它们:\n![Flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_the_dispatcher.jpg)\n\n可以这样写：\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {  \n      this._stores.push({ store: store });\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action);\n        });\n      }\n    }\n  }\n};\n```\n首先需要注意的是我们期望传入的 `stores` 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error('You should provide a store that has an `update` method.');\n  } else {\n    this._stores.push({ store: store });\n  }\n}\n```\n# 将视图和 stores 进行绑定\n下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_change_view.jpg)\n\n### 使用辅助函数\n一些 flux 的实现会自带辅助函数来完成此工作。例如:\n```h\nFramework.attachToStore(view, store);\n```\n要让 `attachToStore `正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。\n### 使用 mixin\n那么如果使用 React 的 [mixins](https://facebook.github.io/react/docs/reusable-components.html#mixins) 呢？\n```h\nvar View = React.createClass({\n  mixins: [Framework.attachToStore(store)]\n  ...\n});\n```\n为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建` mixin` 来完成绑定工作。但说实话，并认为这是个好主意。[看起来](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750) 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。\n### 使用 context\n解决此问题的另一项技术便是 React 的 [context](https://facebook.github.io/react/docs/context.html) 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 `context `。\n> 偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 \"context\" 功能可以让你做到这一点。\n\n看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。\n\n\n### 高阶组件概念\n高阶组件模式是由 Sebastian Markbåge 所[提出](https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775)的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如:\n\n```h\nfunction attachToStore(Component, store, consumer) {\n  const Wrapper = React.createClass({\n    getInitialState() {\n      return consumer(this.props, store);\n    },\n    componentDidMount() {\n      store.onChangeEvent(this._handleStoreChange);\n    },\n    componentWillUnmount() {\n      store.offChangeEvent(this._handleStoreChange);\n    },\n    _handleStoreChange() {\n      if (this.isMounted()) {\n        this.setState(consumer(this.props, store));\n      }\n    },\n    render() {\n      return <Component {...this.props} {...this.state} />;\n    }\n  });\n  return Wrapper;\n};\n\n```\nComponent 是我们想要附加到 `store` 中的视图。`consumer` 函数说明应该提取` store` 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:\n```h\nclass MyView extends React.Component {\n  ...\n}\n\nProfilePage = connectToStores(MyView, store, (props, store) => ({\n  data: store.get('key')\n}));\n```\n这是个有趣的模式，因为它转移了职责。它是视图从 `store` 中拉取数据，而不是 `store` 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 `store` 变得简单。现在 `store` 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。\n # 最终的选择\n 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。\n\n目前为止，我们的实现中只有 `register` 方法与 store 进行交互。\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error('You should provide a store that has an `update` method.');\n  } else {\n    this._stores.push({ store: store });\n  }\n}\n```\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_view.jpg)\n\n将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。\n\n下面是更改后的 `register` 方法:\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error(\n      'You should provide a store that has an `update` method.'\n    );\n  } else {\n    var consumers = [];\n    var subscribe = function (consumer) {\n      consumers.push(consumer);\n    };\n\n    this._stores.push({ store: store });\n    return subscribe;\n  }\n  return false;\n}\n```\n最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 `consumer` 函数，但现在还没有任何代码来执行它们。\n\n根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 `action`，但我们还应该发出 change 函数。调用此函数来触发 `consumers` :\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error(\n      'You should provide a store that has an `update` method.'\n    );\n  } else {\n    var consumers = [];\n    var change = function () {\n      consumers.forEach(function (consumer) {\n        consumer(store);\n      });\n    };\n    var subscribe = function (consumer) {\n      consumers.push(consumer);\n    };\n\n    this._stores.push({ store: store, change: change });\n    return subscribe;\n  }\n  return false;\n},\ndispatch: function (action) {\n  if (this._stores.length > 0) {\n    this._stores.forEach(function (entry) {\n      entry.store.update(action, entry.change);\n    });\n  }\n}\n```\n注意如何在` _stores `数组中将 `change` 和` store` 一起推送出去。稍后，在` dispatch `方法中通过传入` action` 和 `change` 函数来调用` update`\n\n常见用法是使用` store` 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 `consumer` 函数一次。这可以在` subscribe` 方法中轻松完成:\n```h\nvar subscribe = function (consumer, noInit) {\n  consumers.push(consumer);\n  !noInit ? consumer(store) : null;\n};\n```\n当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {\n      if (!store || !store.update) {\n        throw new Error(\n          'You should provide a store that has an `update` method'\n        );\n      } else {\n        var consumers = [];\n        var change = function () {\n          consumers.forEach(function (consumer) {\n            consumer(store);\n          });\n        };\n        var subscribe = function (consumer, noInit) {\n          consumers.push(consumer);\n          !noInit ? consumer(store) : null;\n        };\n\n        this._stores.push({ store: store, change: change });\n        return subscribe;\n      }\n      return false;\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action, entry.change);\n        });\n      }\n    }\n  }\n};\n\n```\n# 动作 ( Actions )\n或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: `type `和` payload` ：\n```h\n{\n  type: 'USER_LOGIN_REQUEST',\n  payload: {\n    username: '...',\n    password: '...'\n  }\n}\n```\ntype 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。\n\n有趣的是` type `从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 `stores` 对哪些动作感兴趣。因此，我们可以应用 [partial application](http://krasimirtsonev.com/blog/article/a-story-about-currying-bind) 并避免传入动作对象。例如:\n```h\nvar createAction = function (type) {\n  if (!type) {\n    throw new Error('Please, provide action\\'s type.');\n  } else {\n    return function (payload) {\n      return dispatcher.dispatch({\n        type: type,\n        payload: payload\n      });\n    }\n  }\n}\n```\ncreateAction 具有以下优点:\n\n* 我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。\n* 我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。\n* 最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。\n\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_action_creator.jpg)\n\n这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。\n# 最终代码\n在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:\n```h\nvar createSubscriber = function (store) {\n  return dispatcher.register(store);\n}\n```\n我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {\n      if (!store || !store.update) {\n        throw new Error(\n          'You should provide a store that has an `update` method'\n        );\n      } else {\n        var consumers = [];\n        var change = function () {\n          consumers.forEach(function (consumer) {\n            consumer(store);\n          });\n        };\n        var subscribe = function (consumer, noInit) {\n          consumers.push(consumer);\n          !noInit ? consumer(store) : null;\n        };\n\n        this._stores.push({ store: store, change: change });\n        return subscribe;\n      }\n      return false;\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action, entry.change);\n        });\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  create: function () {\n    var dispatcher = Dispatcher();\n\n    return {\n      createAction: function (type) {\n        if (!type) {\n          throw new Error('Please, provide action\\'s type.');\n        } else {\n          return function (payload) {\n            return dispatcher.dispatch({\n              type: type,\n              payload: payload\n            });\n          }\n        }\n      },\n      createSubscriber: function (store) {\n        return dispatcher.register(store);\n      }\n    }\n  }\n};\n\n```\n如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。\n# 整合\n我们写好的模块提供两个辅助函数来构建 `Flux` 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。\n# HTML\n我们需要一些 UI 元素来进行互动:\n```h\n<div id=\"counter\">\n  <span></span>\n  <button>increase</button>\n  <button>decrease</button>\n</div>\n```\n`span` 用来显示计数器的当前值。点击按钮会改变计数器的值。\n# 视图\n```h\nconst View = function (subscribeToStore, increase, decrease) {\n  var value = null;\n  var el = document.querySelector('#counter');\n  var display = el.querySelector('span');\n  var [ increaseBtn, decreaseBtn ] =\n    Array.from(el.querySelectorAll('button'));\n\n  var render = () => display.innerHTML = value;\n  var updateState = (store) => value = store.getValue();\n\n  subscribeToStore([updateState, render]);\n\n  increaseBtn.addEventListener('click', increase);\n  decreaseBtn.addEventListener('click', decrease);\n};\n```\nView 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。\n\n之后我们定义了` render `函数，它负责将值渲染到 `spa`n 标签中。当 `store` 发生变化时会调用` updateState` 方法。我们将这两个函数传给` subscribeToStore` 是因为我们想要视图更新以及进行初首次渲染。还记得`consumers` 函数默认至少要调用一次吧？\n\n最后要做的是为按钮绑定点击事件。\n# Store\n每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。\n```h\nconst INCREASE = 'INCREASE';\nconst DECREASE = 'DECREASE';\n```\n通常每个 `store `只有一个实例。为了简单起见，我们将直接创建一个单例对象。\n\n```h\nconst CounterStore = {\n  _data: { value: 0 },\n  getValue: function () {\n    return this._data.value;\n  },\n  update: function (action, change) {\n    if (action.type === INCREASE) {\n      this._data.value += 1;\n    } else if (action.type === DECREASE) {\n      this._data.value -= 1;\n    }\n    change();\n  }\n};\n```\n`_data` 是 `store` 的内部状态。`update` 是` dispatcher` 所调用的方法，我们在 `update` 中处理动作，并在完成时调用` change() `方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。)\n\n# 整合各个部分\n\n这样，`store` 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 `store` 的订阅者、动作并让这一切运转起来。\n\n```h\nconst { createAction, createSubscriber } = Fluxiny.create();\nconst counterStoreSubscriber = createSubscriber(CounterStore);\nconst actions = {\n  increase: createAction(INCREASE),\n  decrease: createAction(DECREASE)\n};\n\nView(counterStoreSubscriber, actions.increase, actions.decrease);\n```\n\n这样就完成了。视图订阅` store `并进行渲染，因为我们的` consumers `实际上就是 render 方法。\n\n# 在线示例\n![flex](React开发常用设计模式-Flux/flex.png)\n\n这里有 JSBin 的 [在线示例](http://jsbin.com/koxidu/embed?js,output)。如果你觉得这个示例过于简单的话，请查阅 [Fluxiny 仓库中的示例](https://github.com/krasimir/fluxiny/tree/master/example)。它使用 React 作为视图层。\n\n在本章中所讨论的 Flux 实现可以在 [这里](https://github.com/krasimir/fluxiny) 找到。可以 [直接在浏览器中](https://github.com/krasimir/fluxiny/tree/master/lib) 使用，也可以通过[ npm 依赖 ](https://www.npmjs.com/package/fluxiny)进行安装。\n\n\n\n\n","source":"_posts/React开发常用设计模式-Flux.md","raw":"---\ntitle: React开发常用设计模式-Flux\ndate: 2018-05-18 00:37:45\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\nFlux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# Flux\n我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。\n\n[Flux](http://facebook.github.io/flux/) 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 [F8](https://youtu.be/nYkdrAPrdcw?t=568) 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 [React](http://facebook.github.io/react/) 搭配使用。React 是 Facebook 发布的另外一个库。在 [日常工作](http://antidote.me/) 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。\n# Flux 架构及其主要特点\n![Flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_basic_flux_architecture.jpg)\n\n这种模式的主角是` dispatcher` 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 `actions` (动作) 的通知并将其传给所有的 `stores` 。`store` 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 `views `(视图，这里指 React 组件) 的重新渲染。如果非要将 `Flux `和大名鼎鼎的` MVC` 相比较的话，`Flux` 中的` store` 类似于` MVC `中的 `model` 。它负责保存和修改数据。\n\n传给 `dispatcher` 的动作可以来自于视图，也可以来自于系统的其他部分，比如 `services` 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。\n# 实现 Flux 架构\n如其他流行的概念一样，Flux 也有一些 [变种](https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73) 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。\n# Dispatcher\n大多数场景下，我们只需要一个单个的` dispatcher` 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。`dispatcher` 需要知道两样东西: 动作和 `stores` 。动作只是简单地转发给 `stores`，所以没必要保存它们。然而，`stores` 应该在 `dispatcher` 中进行追踪，这样才可以遍历它们:\n![Flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_the_dispatcher.jpg)\n\n可以这样写：\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {  \n      this._stores.push({ store: store });\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action);\n        });\n      }\n    }\n  }\n};\n```\n首先需要注意的是我们期望传入的 `stores` 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error('You should provide a store that has an `update` method.');\n  } else {\n    this._stores.push({ store: store });\n  }\n}\n```\n# 将视图和 stores 进行绑定\n下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_change_view.jpg)\n\n### 使用辅助函数\n一些 flux 的实现会自带辅助函数来完成此工作。例如:\n```h\nFramework.attachToStore(view, store);\n```\n要让 `attachToStore `正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。\n### 使用 mixin\n那么如果使用 React 的 [mixins](https://facebook.github.io/react/docs/reusable-components.html#mixins) 呢？\n```h\nvar View = React.createClass({\n  mixins: [Framework.attachToStore(store)]\n  ...\n});\n```\n为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建` mixin` 来完成绑定工作。但说实话，并认为这是个好主意。[看起来](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750) 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。\n### 使用 context\n解决此问题的另一项技术便是 React 的 [context](https://facebook.github.io/react/docs/context.html) 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 `context `。\n> 偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 \"context\" 功能可以让你做到这一点。\n\n看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。\n\n\n### 高阶组件概念\n高阶组件模式是由 Sebastian Markbåge 所[提出](https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775)的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如:\n\n```h\nfunction attachToStore(Component, store, consumer) {\n  const Wrapper = React.createClass({\n    getInitialState() {\n      return consumer(this.props, store);\n    },\n    componentDidMount() {\n      store.onChangeEvent(this._handleStoreChange);\n    },\n    componentWillUnmount() {\n      store.offChangeEvent(this._handleStoreChange);\n    },\n    _handleStoreChange() {\n      if (this.isMounted()) {\n        this.setState(consumer(this.props, store));\n      }\n    },\n    render() {\n      return <Component {...this.props} {...this.state} />;\n    }\n  });\n  return Wrapper;\n};\n\n```\nComponent 是我们想要附加到 `store` 中的视图。`consumer` 函数说明应该提取` store` 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:\n```h\nclass MyView extends React.Component {\n  ...\n}\n\nProfilePage = connectToStores(MyView, store, (props, store) => ({\n  data: store.get('key')\n}));\n```\n这是个有趣的模式，因为它转移了职责。它是视图从 `store` 中拉取数据，而不是 `store` 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 `store` 变得简单。现在 `store` 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。\n # 最终的选择\n 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。\n\n目前为止，我们的实现中只有 `register` 方法与 store 进行交互。\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error('You should provide a store that has an `update` method.');\n  } else {\n    this._stores.push({ store: store });\n  }\n}\n```\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_view.jpg)\n\n将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。\n\n下面是更改后的 `register` 方法:\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error(\n      'You should provide a store that has an `update` method.'\n    );\n  } else {\n    var consumers = [];\n    var subscribe = function (consumer) {\n      consumers.push(consumer);\n    };\n\n    this._stores.push({ store: store });\n    return subscribe;\n  }\n  return false;\n}\n```\n最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 `consumer` 函数，但现在还没有任何代码来执行它们。\n\n根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 `action`，但我们还应该发出 change 函数。调用此函数来触发 `consumers` :\n```h\nregister: function (store) {\n  if (!store || !store.update) {\n    throw new Error(\n      'You should provide a store that has an `update` method.'\n    );\n  } else {\n    var consumers = [];\n    var change = function () {\n      consumers.forEach(function (consumer) {\n        consumer(store);\n      });\n    };\n    var subscribe = function (consumer) {\n      consumers.push(consumer);\n    };\n\n    this._stores.push({ store: store, change: change });\n    return subscribe;\n  }\n  return false;\n},\ndispatch: function (action) {\n  if (this._stores.length > 0) {\n    this._stores.forEach(function (entry) {\n      entry.store.update(action, entry.change);\n    });\n  }\n}\n```\n注意如何在` _stores `数组中将 `change` 和` store` 一起推送出去。稍后，在` dispatch `方法中通过传入` action` 和 `change` 函数来调用` update`\n\n常见用法是使用` store` 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 `consumer` 函数一次。这可以在` subscribe` 方法中轻松完成:\n```h\nvar subscribe = function (consumer, noInit) {\n  consumers.push(consumer);\n  !noInit ? consumer(store) : null;\n};\n```\n当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {\n      if (!store || !store.update) {\n        throw new Error(\n          'You should provide a store that has an `update` method'\n        );\n      } else {\n        var consumers = [];\n        var change = function () {\n          consumers.forEach(function (consumer) {\n            consumer(store);\n          });\n        };\n        var subscribe = function (consumer, noInit) {\n          consumers.push(consumer);\n          !noInit ? consumer(store) : null;\n        };\n\n        this._stores.push({ store: store, change: change });\n        return subscribe;\n      }\n      return false;\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action, entry.change);\n        });\n      }\n    }\n  }\n};\n\n```\n# 动作 ( Actions )\n或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: `type `和` payload` ：\n```h\n{\n  type: 'USER_LOGIN_REQUEST',\n  payload: {\n    username: '...',\n    password: '...'\n  }\n}\n```\ntype 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。\n\n有趣的是` type `从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 `stores` 对哪些动作感兴趣。因此，我们可以应用 [partial application](http://krasimirtsonev.com/blog/article/a-story-about-currying-bind) 并避免传入动作对象。例如:\n```h\nvar createAction = function (type) {\n  if (!type) {\n    throw new Error('Please, provide action\\'s type.');\n  } else {\n    return function (payload) {\n      return dispatcher.dispatch({\n        type: type,\n        payload: payload\n      });\n    }\n  }\n}\n```\ncreateAction 具有以下优点:\n\n* 我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。\n* 我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。\n* 最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。\n\n![flex](http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_action_creator.jpg)\n\n这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。\n# 最终代码\n在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:\n```h\nvar createSubscriber = function (store) {\n  return dispatcher.register(store);\n}\n```\n我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:\n```h\nvar Dispatcher = function () {\n  return {\n    _stores: [],\n    register: function (store) {\n      if (!store || !store.update) {\n        throw new Error(\n          'You should provide a store that has an `update` method'\n        );\n      } else {\n        var consumers = [];\n        var change = function () {\n          consumers.forEach(function (consumer) {\n            consumer(store);\n          });\n        };\n        var subscribe = function (consumer, noInit) {\n          consumers.push(consumer);\n          !noInit ? consumer(store) : null;\n        };\n\n        this._stores.push({ store: store, change: change });\n        return subscribe;\n      }\n      return false;\n    },\n    dispatch: function (action) {\n      if (this._stores.length > 0) {\n        this._stores.forEach(function (entry) {\n          entry.store.update(action, entry.change);\n        });\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  create: function () {\n    var dispatcher = Dispatcher();\n\n    return {\n      createAction: function (type) {\n        if (!type) {\n          throw new Error('Please, provide action\\'s type.');\n        } else {\n          return function (payload) {\n            return dispatcher.dispatch({\n              type: type,\n              payload: payload\n            });\n          }\n        }\n      },\n      createSubscriber: function (store) {\n        return dispatcher.register(store);\n      }\n    }\n  }\n};\n\n```\n如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。\n# 整合\n我们写好的模块提供两个辅助函数来构建 `Flux` 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。\n# HTML\n我们需要一些 UI 元素来进行互动:\n```h\n<div id=\"counter\">\n  <span></span>\n  <button>increase</button>\n  <button>decrease</button>\n</div>\n```\n`span` 用来显示计数器的当前值。点击按钮会改变计数器的值。\n# 视图\n```h\nconst View = function (subscribeToStore, increase, decrease) {\n  var value = null;\n  var el = document.querySelector('#counter');\n  var display = el.querySelector('span');\n  var [ increaseBtn, decreaseBtn ] =\n    Array.from(el.querySelectorAll('button'));\n\n  var render = () => display.innerHTML = value;\n  var updateState = (store) => value = store.getValue();\n\n  subscribeToStore([updateState, render]);\n\n  increaseBtn.addEventListener('click', increase);\n  decreaseBtn.addEventListener('click', decrease);\n};\n```\nView 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。\n\n之后我们定义了` render `函数，它负责将值渲染到 `spa`n 标签中。当 `store` 发生变化时会调用` updateState` 方法。我们将这两个函数传给` subscribeToStore` 是因为我们想要视图更新以及进行初首次渲染。还记得`consumers` 函数默认至少要调用一次吧？\n\n最后要做的是为按钮绑定点击事件。\n# Store\n每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。\n```h\nconst INCREASE = 'INCREASE';\nconst DECREASE = 'DECREASE';\n```\n通常每个 `store `只有一个实例。为了简单起见，我们将直接创建一个单例对象。\n\n```h\nconst CounterStore = {\n  _data: { value: 0 },\n  getValue: function () {\n    return this._data.value;\n  },\n  update: function (action, change) {\n    if (action.type === INCREASE) {\n      this._data.value += 1;\n    } else if (action.type === DECREASE) {\n      this._data.value -= 1;\n    }\n    change();\n  }\n};\n```\n`_data` 是 `store` 的内部状态。`update` 是` dispatcher` 所调用的方法，我们在 `update` 中处理动作，并在完成时调用` change() `方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。)\n\n# 整合各个部分\n\n这样，`store` 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 `store` 的订阅者、动作并让这一切运转起来。\n\n```h\nconst { createAction, createSubscriber } = Fluxiny.create();\nconst counterStoreSubscriber = createSubscriber(CounterStore);\nconst actions = {\n  increase: createAction(INCREASE),\n  decrease: createAction(DECREASE)\n};\n\nView(counterStoreSubscriber, actions.increase, actions.decrease);\n```\n\n这样就完成了。视图订阅` store `并进行渲染，因为我们的` consumers `实际上就是 render 方法。\n\n# 在线示例\n![flex](React开发常用设计模式-Flux/flex.png)\n\n这里有 JSBin 的 [在线示例](http://jsbin.com/koxidu/embed?js,output)。如果你觉得这个示例过于简单的话，请查阅 [Fluxiny 仓库中的示例](https://github.com/krasimir/fluxiny/tree/master/example)。它使用 React 作为视图层。\n\n在本章中所讨论的 Flux 实现可以在 [这里](https://github.com/krasimir/fluxiny) 找到。可以 [直接在浏览器中](https://github.com/krasimir/fluxiny/tree/master/lib) 使用，也可以通过[ npm 依赖 ](https://www.npmjs.com/package/fluxiny)进行安装。\n\n\n\n\n","slug":"React开发常用设计模式-Flux","published":1,"updated":"2018-09-18T12:23:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne00014kt89s0zcsbb5","content":"<p>Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h1><p>我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。</p>\n<p><a href=\"http://facebook.github.io/flux/\" target=\"_blank\" rel=\"noopener\">Flux</a> 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 <a href=\"https://youtu.be/nYkdrAPrdcw?t=568\" target=\"_blank\" rel=\"noopener\">F8</a> 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 <a href=\"http://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">React</a> 搭配使用。React 是 Facebook 发布的另外一个库。在 <a href=\"http://antidote.me/\" target=\"_blank\" rel=\"noopener\">日常工作</a> 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p>\n<h1 id=\"Flux-架构及其主要特点\"><a href=\"#Flux-架构及其主要特点\" class=\"headerlink\" title=\"Flux 架构及其主要特点\"></a>Flux 架构及其主要特点</h1><p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_basic_flux_architecture.jpg\" alt=\"Flex\"></p>\n<p>这种模式的主角是<code>dispatcher</code> 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 <code>actions</code> (动作) 的通知并将其传给所有的 <code>stores</code> 。<code>store</code> 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 <code>views</code>(视图，这里指 React 组件) 的重新渲染。如果非要将 <code>Flux</code>和大名鼎鼎的<code>MVC</code> 相比较的话，<code>Flux</code> 中的<code>store</code> 类似于<code>MVC</code>中的 <code>model</code> 。它负责保存和修改数据。</p>\n<p>传给 <code>dispatcher</code> 的动作可以来自于视图，也可以来自于系统的其他部分，比如 <code>services</code> 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。</p>\n<h1 id=\"实现-Flux-架构\"><a href=\"#实现-Flux-架构\" class=\"headerlink\" title=\"实现 Flux 架构\"></a>实现 Flux 架构</h1><p>如其他流行的概念一样，Flux 也有一些 <a href=\"https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73\" target=\"_blank\" rel=\"noopener\">变种</a> 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。</p>\n<h1 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h1><p>大多数场景下，我们只需要一个单个的<code>dispatcher</code> 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。<code>dispatcher</code> 需要知道两样东西: 动作和 <code>stores</code> 。动作只是简单地转发给 <code>stores</code>，所以没必要保存它们。然而，<code>stores</code> 应该在 <code>dispatcher</code> 中进行追踪，这样才可以遍历它们:<br><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_the_dispatcher.jpg\" alt=\"Flex\"></p>\n<p>可以这样写：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先需要注意的是我们期望传入的 <code>stores</code> 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"将视图和-stores-进行绑定\"><a href=\"#将视图和-stores-进行绑定\" class=\"headerlink\" title=\"将视图和 stores 进行绑定\"></a>将视图和 stores 进行绑定</h1><p>下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。<br><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_change_view.jpg\" alt=\"flex\"></p>\n<h3 id=\"使用辅助函数\"><a href=\"#使用辅助函数\" class=\"headerlink\" title=\"使用辅助函数\"></a>使用辅助函数</h3><p>一些 flux 的实现会自带辅助函数来完成此工作。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Framework.attachToStore(view, store);</span><br></pre></td></tr></table></figure></p>\n<p>要让 <code>attachToStore</code>正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。</p>\n<h3 id=\"使用-mixin\"><a href=\"#使用-mixin\" class=\"headerlink\" title=\"使用 mixin\"></a>使用 mixin</h3><p>那么如果使用 React 的 <a href=\"https://facebook.github.io/react/docs/reusable-components.html#mixins\" target=\"_blank\" rel=\"noopener\">mixins</a> 呢？<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var View = React.createClass(&#123;</span><br><span class=\"line\">  mixins: [Framework.attachToStore(store)]</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建<code>mixin</code> 来完成绑定工作。但说实话，并认为这是个好主意。<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\" target=\"_blank\" rel=\"noopener\">看起来</a> 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。</p>\n<h3 id=\"使用-context\"><a href=\"#使用-context\" class=\"headerlink\" title=\"使用 context\"></a>使用 context</h3><p>解决此问题的另一项技术便是 React 的 <a href=\"https://facebook.github.io/react/docs/context.html\" target=\"_blank\" rel=\"noopener\">context</a> 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 <code>context</code>。</p>\n<blockquote>\n<p>偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 “context” 功能可以让你做到这一点。</p>\n</blockquote>\n<p>看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。</p>\n<h3 id=\"高阶组件概念\"><a href=\"#高阶组件概念\" class=\"headerlink\" title=\"高阶组件概念\"></a>高阶组件概念</h3><p>高阶组件模式是由 Sebastian Markbåge 所<a href=\"https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775\" target=\"_blank\" rel=\"noopener\">提出</a>的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">attachToStore</span><span class=\"params\">(Component, store, consumer)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Wrapper = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> consumer(<span class=\"keyword\">this</span>.props, store);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      store.onChangeEvent(<span class=\"keyword\">this</span>._handleStoreChange);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      store.offChangeEvent(<span class=\"keyword\">this</span>._handleStoreChange);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    _handleStoreChange() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isMounted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(consumer(<span class=\"keyword\">this</span>.props, store));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;Component &#123;...<span class=\"keyword\">this</span>.props&#125; &#123;...<span class=\"keyword\">this</span>.state&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Wrapper;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Component 是我们想要附加到 <code>store</code> 中的视图。<code>consumer</code> 函数说明应该提取<code>store</code> 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ProfilePage = connectToStores(MyView, store, (props, store) =&gt; (&#123;</span><br><span class=\"line\">  data: store.get('key')</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>这是个有趣的模式，因为它转移了职责。它是视图从 <code>store</code> 中拉取数据，而不是 <code>store</code> 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 <code>store</code> 变得简单。现在 <code>store</code> 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。</p>\n<h1 id=\"最终的选择\"><a href=\"#最终的选择\" class=\"headerlink\" title=\"最终的选择\"></a>最终的选择</h1><p> 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。</p>\n<p>目前为止，我们的实现中只有 <code>register</code> 方法与 store 进行交互。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_view.jpg\" alt=\"flex\"></p>\n<p>将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。</p>\n<p>下面是更改后的 <code>register</code> 方法:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">      'You should provide a store that has an `update` method.'</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    var consumers = [];</span><br><span class=\"line\">    var subscribe = function (consumer) &#123;</span><br><span class=\"line\">      consumers.push(consumer);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 <code>consumer</code> 函数，但现在还没有任何代码来执行它们。</p>\n<p>根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 <code>action</code>，但我们还应该发出 change 函数。调用此函数来触发 <code>consumers</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">      'You should provide a store that has an `update` method.'</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    var consumers = [];</span><br><span class=\"line\">    var change = function () &#123;</span><br><span class=\"line\">      consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">        consumer(store);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var subscribe = function (consumer) &#123;</span><br><span class=\"line\">      consumers.push(consumer);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">dispatch: function (action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">      entry.store.update(action, entry.change);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意如何在<code>_stores</code>数组中将 <code>change</code> 和<code>store</code> 一起推送出去。稍后，在<code>dispatch</code>方法中通过传入<code>action</code> 和 <code>change</code> 函数来调用<code>update</code></p>\n<p>常见用法是使用<code>store</code> 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 <code>consumer</code> 函数一次。这可以在<code>subscribe</code> 方法中轻松完成:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">  consumers.push(consumer);</span><br><span class=\"line\">  !noInit ? consumer(store) : null;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">          'You should provide a store that has an `update` method'</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        var consumers = [];</span><br><span class=\"line\">        var change = function () &#123;</span><br><span class=\"line\">          consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">            consumer(store);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">          consumers.push(consumer);</span><br><span class=\"line\">          !noInit ? consumer(store) : null;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action, entry.change);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"动作-Actions\"><a href=\"#动作-Actions\" class=\"headerlink\" title=\"动作 ( Actions )\"></a>动作 ( Actions )</h1><p>或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: <code>type</code>和<code>payload</code> ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: 'USER_LOGIN_REQUEST',</span><br><span class=\"line\">  payload: &#123;</span><br><span class=\"line\">    username: '...',</span><br><span class=\"line\">    password: '...'</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>type 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。</p>\n<p>有趣的是<code>type</code>从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 <code>stores</code> 对哪些动作感兴趣。因此，我们可以应用 <a href=\"http://krasimirtsonev.com/blog/article/a-story-about-currying-bind\" target=\"_blank\" rel=\"noopener\">partial application</a> 并避免传入动作对象。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var createAction = function (type) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">    throw new Error('Please, provide action\\'s type.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> function (payload) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatcher.dispatch(&#123;</span><br><span class=\"line\">        type: type,</span><br><span class=\"line\">        payload: payload</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>createAction 具有以下优点:</p>\n<ul>\n<li>我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。</li>\n<li>我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。</li>\n<li>最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。</li>\n</ul>\n<p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_action_creator.jpg\" alt=\"flex\"></p>\n<p>这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。</p>\n<h1 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h1><p>在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var createSubscriber = function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatcher.<span class=\"keyword\">register</span>(store);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">          'You should provide a store that has an `update` method'</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        var consumers = [];</span><br><span class=\"line\">        var change = function () &#123;</span><br><span class=\"line\">          consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">            consumer(store);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">          consumers.push(consumer);</span><br><span class=\"line\">          !noInit ? consumer(store) : null;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action, entry.change);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = &#123;</span><br><span class=\"line\">  create: function () &#123;</span><br><span class=\"line\">    var dispatcher = Dispatcher();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      createAction: function (type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">          throw new Error('Please, provide action\\'s type.');</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> function (payload) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatcher.dispatch(&#123;</span><br><span class=\"line\">              type: type,</span><br><span class=\"line\">              payload: payload</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      createSubscriber: function (store) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dispatcher.<span class=\"keyword\">register</span>(store);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。</p>\n<h1 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h1><p>我们写好的模块提供两个辅助函数来构建 <code>Flux</code> 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。</p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><p>我们需要一些 UI 元素来进行互动:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"counter\"</span>&gt;</span><br><span class=\"line\">  &lt;span&gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;button&gt;increase&lt;/button&gt;</span><br><span class=\"line\">  &lt;button&gt;decrease&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>span</code> 用来显示计数器的当前值。点击按钮会改变计数器的值。</p>\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> View = function (subscribeToStore, increase, decrease) &#123;</span><br><span class=\"line\">  var value = null;</span><br><span class=\"line\">  var el = document.querySelector('#counter');</span><br><span class=\"line\">  var display = el.querySelector('span');</span><br><span class=\"line\">  var [ increaseBtn, decreaseBtn ] =</span><br><span class=\"line\">    Array.from(el.querySelectorAll('button'));</span><br><span class=\"line\"></span><br><span class=\"line\">  var render = () =&gt; display.innerHTML = value;</span><br><span class=\"line\">  var updateState = (store) =&gt; value = store.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">  subscribeToStore([updateState, render]);</span><br><span class=\"line\"></span><br><span class=\"line\">  increaseBtn.addEventListener('click', increase);</span><br><span class=\"line\">  decreaseBtn.addEventListener('click', decrease);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>View 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。</p>\n<p>之后我们定义了<code>render</code>函数，它负责将值渲染到 <code>spa</code>n 标签中。当 <code>store</code> 发生变化时会调用<code>updateState</code> 方法。我们将这两个函数传给<code>subscribeToStore</code> 是因为我们想要视图更新以及进行初首次渲染。还记得<code>consumers</code> 函数默认至少要调用一次吧？</p>\n<p>最后要做的是为按钮绑定点击事件。</p>\n<h1 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h1><p>每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const INCREASE = 'INCREASE';</span><br><span class=\"line\">const DECREASE = 'DECREASE';</span><br></pre></td></tr></table></figure></p>\n<p>通常每个 <code>store</code>只有一个实例。为了简单起见，我们将直接创建一个单例对象。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CounterStore = &#123;</span><br><span class=\"line\">  _data: &#123; value: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  getValue: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data.value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  update: function (action, change) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action.type === INCREASE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._data.value += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === DECREASE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._data.value -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    change();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>_data</code> 是 <code>store</code> 的内部状态。<code>update</code> 是<code>dispatcher</code> 所调用的方法，我们在 <code>update</code> 中处理动作，并在完成时调用<code>change()</code>方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。)</p>\n<h1 id=\"整合各个部分\"><a href=\"#整合各个部分\" class=\"headerlink\" title=\"整合各个部分\"></a>整合各个部分</h1><p>这样，<code>store</code> 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 <code>store</code> 的订阅者、动作并让这一切运转起来。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; createAction, createSubscriber &#125; = Fluxiny.create();</span><br><span class=\"line\"><span class=\"keyword\">const</span> counterStoreSubscriber = createSubscriber(CounterStore);</span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  increase: createAction(INCREASE),</span><br><span class=\"line\">  decrease: createAction(DECREASE)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">View(counterStoreSubscriber, actions.increase, actions.decrease);</span><br></pre></td></tr></table></figure>\n<p>这样就完成了。视图订阅<code>store</code>并进行渲染，因为我们的<code>consumers</code>实际上就是 render 方法。</p>\n<h1 id=\"在线示例\"><a href=\"#在线示例\" class=\"headerlink\" title=\"在线示例\"></a>在线示例</h1><p><img src=\"/blog/2018/05/18/React开发常用设计模式-Flux/flex.png\" alt=\"flex\"></p>\n<p>这里有 JSBin 的 <a href=\"http://jsbin.com/koxidu/embed?js,output\" target=\"_blank\" rel=\"noopener\">在线示例</a>。如果你觉得这个示例过于简单的话，请查阅 <a href=\"https://github.com/krasimir/fluxiny/tree/master/example\" target=\"_blank\" rel=\"noopener\">Fluxiny 仓库中的示例</a>。它使用 React 作为视图层。</p>\n<p>在本章中所讨论的 Flux 实现可以在 <a href=\"https://github.com/krasimir/fluxiny\" target=\"_blank\" rel=\"noopener\">这里</a> 找到。可以 <a href=\"https://github.com/krasimir/fluxiny/tree/master/lib\" target=\"_blank\" rel=\"noopener\">直接在浏览器中</a> 使用，也可以通过<a href=\"https://www.npmjs.com/package/fluxiny\" target=\"_blank\" rel=\"noopener\"> npm 依赖 </a>进行安装。</p>\n","site":{"data":{}},"excerpt":"<p>Flux 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 F8 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 React 搭配使用。React 是 Facebook 发布的另外一个库。在 日常工作 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h1><p>我痴迷于将代码变得简单。注意，我说的不是代码量更少，而是简单。因为代码量更少并不一定意味着简单。我相信软件行业中大部分问题都源自不必要的复杂度。复杂度是我们进行抽象的结果。你也知道，我们 (程序员) 都喜欢进行抽象。我们喜欢将抽象的东西放入黑盒中，并希望这些黑盒能够在一起工作。</p>\n<p><a href=\"http://facebook.github.io/flux/\" target=\"_blank\" rel=\"noopener\">Flux</a> 是一种构建用户界面的架构设计模式。它是由 Facebook 在它们的 <a href=\"https://youtu.be/nYkdrAPrdcw?t=568\" target=\"_blank\" rel=\"noopener\">F8</a> 开发者大会上推出的。在此之后，许多公司都采纳了这个想法，这种模式用来构建前端应用似乎非常不错。Flux 通常和 <a href=\"http://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">React</a> 搭配使用。React 是 Facebook 发布的另外一个库。在 <a href=\"http://antidote.me/\" target=\"_blank\" rel=\"noopener\">日常工作</a> 中使用的是 React+Flux/Redux ，敢说这种架构真的非常简单和灵活。该模式有助于更快地创建应用，同时使代码保持良好的组织结构。</p>\n<h1 id=\"Flux-架构及其主要特点\"><a href=\"#Flux-架构及其主要特点\" class=\"headerlink\" title=\"Flux 架构及其主要特点\"></a>Flux 架构及其主要特点</h1><p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_basic_flux_architecture.jpg\" alt=\"Flex\"></p>\n<p>这种模式的主角是<code>dispatcher</code> 。它担当系统中所有事件的枢纽。它的工作就是接收我们称之为 <code>actions</code> (动作) 的通知并将其传给所有的 <code>stores</code> 。<code>store</code> 决定了是否对传入的动作感兴趣，如果感兴趣则通过改变自己的内部状态/数据来进行响应。改变会触发 <code>views</code>(视图，这里指 React 组件) 的重新渲染。如果非要将 <code>Flux</code>和大名鼎鼎的<code>MVC</code> 相比较的话，<code>Flux</code> 中的<code>store</code> 类似于<code>MVC</code>中的 <code>model</code> 。它负责保存和修改数据。</p>\n<p>传给 <code>dispatcher</code> 的动作可以来自于视图，也可以来自于系统的其他部分，比如 <code>services</code> 。举个例子，一个执行 HTTP 请求的模块，当它接收到结果数据时，它可以触发动作以通知系统请求成功。</p>\n<h1 id=\"实现-Flux-架构\"><a href=\"#实现-Flux-架构\" class=\"headerlink\" title=\"实现 Flux 架构\"></a>实现 Flux 架构</h1><p>如其他流行的概念一样，Flux 也有一些 <a href=\"https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73\" target=\"_blank\" rel=\"noopener\">变种</a> 。通常，要理解某种技术的最好途径就是去实现它。在下面的几节中，我们将创建一个库，它提供辅助函数来构建 Flux 模式。</p>\n<h1 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h1><p>大多数场景下，我们只需要一个单个的<code>dispatcher</code> 。因为它扮演胶水的角色，用来粘合其他部分，所以有一个就够了。<code>dispatcher</code> 需要知道两样东西: 动作和 <code>stores</code> 。动作只是简单地转发给 <code>stores</code>，所以没必要保存它们。然而，<code>stores</code> 应该在 <code>dispatcher</code> 中进行追踪，这样才可以遍历它们:<br><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_the_dispatcher.jpg\" alt=\"Flex\"></p>\n<p>可以这样写：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先需要注意的是我们期望传入的 <code>stores</code> 上存在 update 方法。如果此方法不存在的话，抛出错误会更好些:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"将视图和-stores-进行绑定\"><a href=\"#将视图和-stores-进行绑定\" class=\"headerlink\" title=\"将视图和 stores 进行绑定\"></a>将视图和 stores 进行绑定</h1><p>下一步是将视图与 stores 链接，这样当 stores 的状态发生改变时，我们才能进行重新渲染。<br><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_change_view.jpg\" alt=\"flex\"></p>\n<h3 id=\"使用辅助函数\"><a href=\"#使用辅助函数\" class=\"headerlink\" title=\"使用辅助函数\"></a>使用辅助函数</h3><p>一些 flux 的实现会自带辅助函数来完成此工作。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Framework.attachToStore(view, store);</span><br></pre></td></tr></table></figure></p>\n<p>要让 <code>attachToStore</code>正常运行，需要视图和 store 中有一个特殊的 API ，因此我们需要严格定义这个新的公有方法。或者换句话说，Framework 对你说道: “你的视图和 store 应该具备这样的 API ，这样我才能能够将它们连接起来”。如果我们沿着这个方向前进的话，那么我们可能会定义可扩展的基类，这样我们就不会让 Flux 的细节去困扰开发人员。然后，Framework 又对你说到: “你所有的类都应该继承我们的类”。这听上去也并非好主意，因为开发人员可能会切换成另一个 Flux 提供者，这种切换势必会修改所有内容。</p>\n<h3 id=\"使用-mixin\"><a href=\"#使用-mixin\" class=\"headerlink\" title=\"使用 mixin\"></a>使用 mixin</h3><p>那么如果使用 React 的 <a href=\"https://facebook.github.io/react/docs/reusable-components.html#mixins\" target=\"_blank\" rel=\"noopener\">mixins</a> 呢？<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var View = React.createClass(&#123;</span><br><span class=\"line\">  mixins: [Framework.attachToStore(store)]</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>为已存在的 React 组件定义行为的话，这是一种“更好的”方式。所以，从理论上来说，我们可能会创建<code>mixin</code> 来完成绑定工作。但说实话，并认为这是个好主意。<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\" target=\"_blank\" rel=\"noopener\">看起来</a> 不止有不喜欢他的想法。不喜欢 mixins 的原因是它们修改组件的方式是不可预见的。完全不知道幕后发生了什么。所以放弃这个选项。</p>\n<h3 id=\"使用-context\"><a href=\"#使用-context\" class=\"headerlink\" title=\"使用 context\"></a>使用 context</h3><p>解决此问题的另一项技术便是 React 的 <a href=\"https://facebook.github.io/react/docs/context.html\" target=\"_blank\" rel=\"noopener\">context</a> 。使用 context 可以将 props 传递给子组件而无需在组件树中进行层层传递。Facebook 建议在数据必须到达嵌套层级非常深的组件的情况下使用 <code>context</code>。</p>\n<blockquote>\n<p>偶尔，你希望通过组件树传递数据，而不必在每个级别手动传递这些 props 。React 的 “context” 功能可以让你做到这一点。</p>\n</blockquote>\n<p>看到了与 mixins 的相似之处。context 是在组件树的顶层定义的，并魔法般的为组件树中的所有的子组件提供 props 。至于数据从而何来，尚不可知。</p>\n<h3 id=\"高阶组件概念\"><a href=\"#高阶组件概念\" class=\"headerlink\" title=\"高阶组件概念\"></a>高阶组件概念</h3><p>高阶组件模式是由 Sebastian Markbåge 所<a href=\"https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775\" target=\"_blank\" rel=\"noopener\">提出</a>的。它创建一个包装组件并返回原始的输入组件。使用高阶组件的话，就有机会来传递属性或应用附加逻辑。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">attachToStore</span><span class=\"params\">(Component, store, consumer)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Wrapper = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> consumer(<span class=\"keyword\">this</span>.props, store);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      store.onChangeEvent(<span class=\"keyword\">this</span>._handleStoreChange);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      store.offChangeEvent(<span class=\"keyword\">this</span>._handleStoreChange);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    _handleStoreChange() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isMounted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(consumer(<span class=\"keyword\">this</span>.props, store));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;Component &#123;...<span class=\"keyword\">this</span>.props&#125; &#123;...<span class=\"keyword\">this</span>.state&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Wrapper;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Component 是我们想要附加到 <code>store</code> 中的视图。<code>consumer</code> 函数说明应该提取<code>store</code> 的哪部分状态并发送给到视图。上面函数的简单用法如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ProfilePage = connectToStores(MyView, store, (props, store) =&gt; (&#123;</span><br><span class=\"line\">  data: store.get('key')</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>这是个有趣的模式，因为它转移了职责。它是视图从 <code>store</code> 中拉取数据，而不是 <code>store</code> 将数据推送给视图。当然它也有自己的优势和劣势。优势在于它使得 <code>store</code> 变得简单。现在 <code>store</code> 只修改数据即可，并告诉大家: “嗨，我的状态发生改变了”。它不再负责将数据发送给别人。这种方法的缺点可能是我们将有不止一个组件 (包装组件) 参与其中。我们还需要视图、store 和 consumer 函数三者在同一个地方，这样我们才可以建立连接。</p>\n<h1 id=\"最终的选择\"><a href=\"#最终的选择\" class=\"headerlink\" title=\"最终的选择\"></a>最终的选择</h1><p> 最终的选择是最后一个选项 - 高阶组件，它已经非常接近于我想要的。我喜欢由视图来决定它所需要什么的这点。无论如何，数据都存在于组件中，所以将它保留在那里是有道理的。这也正是为什么生成高阶组件的函数通常与视图保持在同一个文件中的原因。如果我们使用类似的方法而压根不传入 store 呢？或者换句话说，函数只接收 consumer 。每当 store 发生变化时，都会调用此函数。</p>\n<p>目前为止，我们的实现中只有 <code>register</code> 方法与 store 进行交互。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    throw new Error('You should provide a store that has an `update` method.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_store_view.jpg\" alt=\"flex\"></p>\n<p>将整个 store 发送给 consumer 函数，而不是 store 中的保存的数据。就像在高阶组件模式中一样，视图应该使用 store 的 getter 来说明它需要什么。这使得 store 变得相当简单并且不包含任何表现层相关的逻辑。</p>\n<p>下面是更改后的 <code>register</code> 方法:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">      'You should provide a store that has an `update` method.'</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    var consumers = [];</span><br><span class=\"line\">    var subscribe = function (consumer) &#123;</span><br><span class=\"line\">      consumers.push(consumer);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后要完成是 store 如何通知别人它内部的状态发生了改变。我们已经收集了 <code>consumer</code> 函数，但现在还没有任何代码来执行它们。</p>\n<p>根据 flux 架构的基本原则，stores 改变自身状态以响应动作。在 update 方法中，我们发送了 <code>action</code>，但我们还应该发出 change 函数。调用此函数来触发 <code>consumers</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">      'You should provide a store that has an `update` method.'</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    var consumers = [];</span><br><span class=\"line\">    var change = function () &#123;</span><br><span class=\"line\">      consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">        consumer(store);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var subscribe = function (consumer) &#123;</span><br><span class=\"line\">      consumers.push(consumer);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">dispatch: function (action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">      entry.store.update(action, entry.change);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意如何在<code>_stores</code>数组中将 <code>change</code> 和<code>store</code> 一起推送出去。稍后，在<code>dispatch</code>方法中通过传入<code>action</code> 和 <code>change</code> 函数来调用<code>update</code></p>\n<p>常见用法是使用<code>store</code> 的初始状态来渲染视图。在我们实现中，这意味着当库被使用时至少触发所有 <code>consumer</code> 函数一次。这可以在<code>subscribe</code> 方法中轻松完成:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">  consumers.push(consumer);</span><br><span class=\"line\">  !noInit ? consumer(store) : null;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当然，有时候并不需要，所以我们添加了一个标识，它的默认值是假值。下面是 dispatcher 的最终版本:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">          'You should provide a store that has an `update` method'</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        var consumers = [];</span><br><span class=\"line\">        var change = function () &#123;</span><br><span class=\"line\">          consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">            consumer(store);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">          consumers.push(consumer);</span><br><span class=\"line\">          !noInit ? consumer(store) : null;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action, entry.change);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"动作-Actions\"><a href=\"#动作-Actions\" class=\"headerlink\" title=\"动作 ( Actions )\"></a>动作 ( Actions )</h1><p>或许已经注意到了，我们还没讨论过动作。什么是动作？约定是它们应该是具有两个属性的简单对象: <code>type</code>和<code>payload</code> ：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: 'USER_LOGIN_REQUEST',</span><br><span class=\"line\">  payload: &#123;</span><br><span class=\"line\">    username: '...',</span><br><span class=\"line\">    password: '...'</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>type 表明了这个动作具体是做什么的，payload 包含事件的相关信息，而且它并非是必需的。</p>\n<p>有趣的是<code>type</code>从一开始就广为人知。我们知道什么类型的动作应该进入应用，谁来分发它们，已经 <code>stores</code> 对哪些动作感兴趣。因此，我们可以应用 <a href=\"http://krasimirtsonev.com/blog/article/a-story-about-currying-bind\" target=\"_blank\" rel=\"noopener\">partial application</a> 并避免传入动作对象。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var createAction = function (type) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">    throw new Error('Please, provide action\\'s type.');</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> function (payload) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatcher.dispatch(&#123;</span><br><span class=\"line\">        type: type,</span><br><span class=\"line\">        payload: payload</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>createAction 具有以下优点:</p>\n<ul>\n<li>我们不再需要记住动作的具体类型是什么。现在只需传入 payload 来调用此函数即可。</li>\n<li>我们不再需要访问 dispatcher 了，这是个巨大的优势。否则，还需要考虑如何将它传递给每个需要分发动作的地方。</li>\n<li>最后，我们不用再去处理对象，只是调用函数，这种方式要好得多。对象是静态的，而函数描述的是过程。</li>\n</ul>\n<p><img src=\"http://sangka-z.com/react-in-patterns-cn/chapter-8/fluxiny_action_creator.jpg\" alt=\"flex\"></p>\n<p>这种创建动作的方式非常流行，像上面这样的函数称之为 “action creators” 。</p>\n<h1 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h1><p>在上一节中，在我们发出动作的同时隐藏了 dispatcher 。在 store 的注册过程中我们也可以这样做:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var createSubscriber = function (store) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatcher.<span class=\"keyword\">register</span>(store);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以不暴露 dispaatcher，而只暴露 createAction 和 createSubscriber 这两个函数。下面是最终代码:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Dispatcher = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    _stores: [],</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: function (store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!store || !store.update) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(</span><br><span class=\"line\">          'You should provide a store that has an `update` method'</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        var consumers = [];</span><br><span class=\"line\">        var change = function () &#123;</span><br><span class=\"line\">          consumers.forEach(function (consumer) &#123;</span><br><span class=\"line\">            consumer(store);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var subscribe = function (consumer, noInit) &#123;</span><br><span class=\"line\">          consumers.push(consumer);</span><br><span class=\"line\">          !noInit ? consumer(store) : null;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.push(&#123; store: store, change: change &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subscribe;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dispatch: function (action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._stores.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stores.forEach(function (entry) &#123;</span><br><span class=\"line\">          entry.store.update(action, entry.change);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = &#123;</span><br><span class=\"line\">  create: function () &#123;</span><br><span class=\"line\">    var dispatcher = Dispatcher();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      createAction: function (type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">          throw new Error('Please, provide action\\'s type.');</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> function (payload) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatcher.dispatch(&#123;</span><br><span class=\"line\">              type: type,</span><br><span class=\"line\">              payload: payload</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      createSubscriber: function (store) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dispatcher.<span class=\"keyword\">register</span>(store);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果添加对 AMD、CommonJS 和全局引用的支持的话，那么最终的 JavaScript 文件共 66 行代码，文件大小为 1.7KB，压缩后 795 字节。</p>\n<h1 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h1><p>我们写好的模块提供两个辅助函数来构建 <code>Flux</code> 项目。我们来写个简单的计数器应用，此应用不使用 React ，只为了解 Flux 模式的实际使用情况。</p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><p>我们需要一些 UI 元素来进行互动:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"counter\"</span>&gt;</span><br><span class=\"line\">  &lt;span&gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;button&gt;increase&lt;/button&gt;</span><br><span class=\"line\">  &lt;button&gt;decrease&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>span</code> 用来显示计数器的当前值。点击按钮会改变计数器的值。</p>\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> View = function (subscribeToStore, increase, decrease) &#123;</span><br><span class=\"line\">  var value = null;</span><br><span class=\"line\">  var el = document.querySelector('#counter');</span><br><span class=\"line\">  var display = el.querySelector('span');</span><br><span class=\"line\">  var [ increaseBtn, decreaseBtn ] =</span><br><span class=\"line\">    Array.from(el.querySelectorAll('button'));</span><br><span class=\"line\"></span><br><span class=\"line\">  var render = () =&gt; display.innerHTML = value;</span><br><span class=\"line\">  var updateState = (store) =&gt; value = store.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">  subscribeToStore([updateState, render]);</span><br><span class=\"line\"></span><br><span class=\"line\">  increaseBtn.addEventListener('click', increase);</span><br><span class=\"line\">  decreaseBtn.addEventListener('click', decrease);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>View 接收 store 的订阅者函数和增加/减少值的两个动作函数。View 中开始的几行代码只是用来获取 DOM 元素。</p>\n<p>之后我们定义了<code>render</code>函数，它负责将值渲染到 <code>spa</code>n 标签中。当 <code>store</code> 发生变化时会调用<code>updateState</code> 方法。我们将这两个函数传给<code>subscribeToStore</code> 是因为我们想要视图更新以及进行初首次渲染。还记得<code>consumers</code> 函数默认至少要调用一次吧？</p>\n<p>最后要做的是为按钮绑定点击事件。</p>\n<h1 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h1><p>每个动作都有类型。为这些类型创建常量是一种最佳实践，因为我们不想处理原始字符串。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const INCREASE = 'INCREASE';</span><br><span class=\"line\">const DECREASE = 'DECREASE';</span><br></pre></td></tr></table></figure></p>\n<p>通常每个 <code>store</code>只有一个实例。为了简单起见，我们将直接创建一个单例对象。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CounterStore = &#123;</span><br><span class=\"line\">  _data: &#123; value: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  getValue: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data.value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  update: function (action, change) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action.type === INCREASE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._data.value += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === DECREASE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._data.value -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    change();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>_data</code> 是 <code>store</code> 的内部状态。<code>update</code> 是<code>dispatcher</code> 所调用的方法，我们在 <code>update</code> 中处理动作，并在完成时调用<code>change()</code>方法来通知发生了变化。getValue 是公共方法，视图会使用它来获取所需数据。(在这个案例中，就是计数器的值。)</p>\n<h1 id=\"整合各个部分\"><a href=\"#整合各个部分\" class=\"headerlink\" title=\"整合各个部分\"></a>整合各个部分</h1><p>这样，<code>store</code> 就完成了，它等待 dispatcher 发出的动作。视图我们也定义完了。现在来创建 <code>store</code> 的订阅者、动作并让这一切运转起来。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; createAction, createSubscriber &#125; = Fluxiny.create();</span><br><span class=\"line\"><span class=\"keyword\">const</span> counterStoreSubscriber = createSubscriber(CounterStore);</span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  increase: createAction(INCREASE),</span><br><span class=\"line\">  decrease: createAction(DECREASE)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">View(counterStoreSubscriber, actions.increase, actions.decrease);</span><br></pre></td></tr></table></figure>\n<p>这样就完成了。视图订阅<code>store</code>并进行渲染，因为我们的<code>consumers</code>实际上就是 render 方法。</p>\n<h1 id=\"在线示例\"><a href=\"#在线示例\" class=\"headerlink\" title=\"在线示例\"></a>在线示例</h1><p><img src=\"/blog/2018/05/18/React开发常用设计模式-Flux/flex.png\" alt=\"flex\"></p>\n<p>这里有 JSBin 的 <a href=\"http://jsbin.com/koxidu/embed?js,output\" target=\"_blank\" rel=\"noopener\">在线示例</a>。如果你觉得这个示例过于简单的话，请查阅 <a href=\"https://github.com/krasimir/fluxiny/tree/master/example\" target=\"_blank\" rel=\"noopener\">Fluxiny 仓库中的示例</a>。它使用 React 作为视图层。</p>\n<p>在本章中所讨论的 Flux 实现可以在 <a href=\"https://github.com/krasimir/fluxiny\" target=\"_blank\" rel=\"noopener\">这里</a> 找到。可以 <a href=\"https://github.com/krasimir/fluxiny/tree/master/lib\" target=\"_blank\" rel=\"noopener\">直接在浏览器中</a> 使用，也可以通过<a href=\"https://www.npmjs.com/package/fluxiny\" target=\"_blank\" rel=\"noopener\"> npm 依赖 </a>进行安装。</p>"},{"title":"React开发常用设计模式-Redux","date":"2018-06-11T15:52:51.000Z","description":null,"copyright":true,"top":null,"_content":"[Redux](https://redux.js.org/) 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 ([视频](https://www.youtube.com/watch?v=xsSnOQynTHs))。它类似于 [Flux 架构](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics) 并有很多共同点。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# Redux\n\n## Redux 架构及其主要特点\n![redux](React开发常用设计模式-Redux/redux-architecture.jpg)\n\n类似于 [Flux](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md) 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 `store `中。注意，我们说的是 `store`，而不是 `stores` ，这是因为在 `Redux` 中只有一个 `store` ，这是 `Redux` 与 `Flux` 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 `reducers` 。一旦 `store `接收到动作，它会将当前状态和给定动作发送给` reducer `并要求其返回一个新的状态。然后，在数据不可变的方式下， `reducer `需要返回新的状态。再然后， `store `更新自身的内部状态。最后，与 `store `连接的 `React `组件会重新渲染。\n\n概念相当清晰并再次遵循了 [单向数据流](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md) 。我们来讨论每一个部分并引入一些支持 `Redux` 模式工作的新术语。\n\n## 动作 ( Actions )\n\n`Redux` 中的动作和 `Flux `一样，也只是有 `type `属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:\n\n```h\nconst CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';\nconst action = {\n  type: CHANGE_VISIBILITY,\n  visible: false\n}\n```\n使用像 `CHANGE_VISIBILITY` 这样的常量作为动作的类型是一种最佳实践。有很多支持 `Redux `的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。\n\n`visible` 属性是我们所提到过的元数据。它与 `Redux `本身无关，它表示应用中某处需要使用的数据。\n\n每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 `action creators` 诞生的原因。`action creator` 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:\n```h\nconst changeVisibility = visible => ({\n  type: CHANGE_VISIBILITY,\n  visible\n});\n\nchangeVisibility(false);\n// { type: CHANGE_VISIBILITY, visible: false }\n```\n注意，将 `visible` 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。\n\n## Store\n\n`Redux` 提供辅助函数 `createStore` 来创建 `store` 。它的函数签名如下:\n```h\nimport { createStore } from 'redux';\n\ncreateStore([reducer], [initial state], [enhancer]);\n```\n正如之前所提到的，`reducer` 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 `store` 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数` enhancer `提供 API 来使用第三方的中间件来扩展` Redux `，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。\n\n创建好的` store` 具有四个方法:` getState、dispatch、subscribe `和 `replaceReducer` 。其中最重要的或许就是` dispatch `:\n```h\nstore.dispatch(changeVisibility(false));\n```\n这里我们使用的是 `action creator `。我们将其结果 (即 action 对象) 传给 `dispatch `方法。然后，它会传播给应用中的 `reducers `。\n\n在典型的` React `应用中，我们通常不会直接使用` getState 和 subscribe `，因为有辅助函数  可以将`组件`和 `store `联系起来并有效地订阅 `store` 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用` getState `。`replaceReducer `是一个高级 API ，它用来交互 `store `所使用的当前 `reducer` 。\n\n## Reducer\n\n`reducer `函数大概是` Redux `中最精华的部分。`reducer `还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。\n\n{% note danger %} (1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 {% endnote %}\n{% note danger %} (2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 {% endnote %}\n\n下面是个很简单的计数器 reducer :\n\n```h\nconst counterReducer = function (state, action) {\n  if (action.type === ADD) {\n    return { value: state.value + 1 };\n  } else if (action.type === SUBTRACT) {\n    return { value: state.value - 1 };\n  }\n  return { value: 0 };\n};\n```\n它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。\n\n## 连接 React 组件\n\n如果是在 `React `上下文中讨论` Redux `的话，那基本离不开 [react-redux](https://github.com/reactjs/react-redux) 模块。它提供两样东西来进行 `Redux` 到组件的连接。\n\n> (1) `<Provider> 组件` - 它是一个组件，它接收 `store `并使得所有的子组件都可以通过 React 的 context API 来访问 `store `。\n\n例如:\n```h\n<Provider store={ myStore }>\n  <MyApp />\n</Provider>\n```\n通常，我们只在应用中的单个地方使用它。\n\n> (2) `connect 函数` - 它是一个函数，它负责订阅 `store `的更新和重新渲染组件。它是通过 [高阶组件](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component) 实现的。\n\n这是它的函数签名:\n```h\nconnect(\n  [mapStateToProps],\n  [mapDispatchToProps],\n  [mergeProps],\n  [options]\n)\n```\n`mapDispatchToProps `也是类似的，只是它接收的是 `dispatch `函数，而不是` state` 。这里是我们将派发动作定义成属性的地方。\n```h\nconst mapDispatchToProps = dispatch => ({\n  changeVisibility: value => dispatch(changeVisibility(value))\n});\n```\n`mergeProps `将 `mapStateToProps、 mapDispatchToProps `和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。`options` 接收一组如何控制连接的设置。\n\n## 使用 Redux 的简单计数器应用\n\n使用上面所有的 API 来创建一个简单的计数器应用。\n![react](React开发常用设计模式-Redux/redux-counter-app.png)\n\n\"Add\" 和 \"Subtract\" 按钮只是改变 `store` 的值。\"Visible\" 和 \"Hidden\" 按钮用来控制计数器是否显示。\n### 创建动作\n每个 `Redux` 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:`增加、减少和管理可见性`。所有动作代码如下所示:\n```h\nconst ADD = 'ADD';\nconst SUBTRACT = 'SUBTRACT';\nconst CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';\n\nconst add = () => ({ type: ADD });\nconst subtract = () => ({ type: SUBTRACT });\nconst changeVisibility = visible => ({\n  type: CHANGE_VISIBILITY,\n  visible\n});\n```\n### Store 及其 reducers\n在解释 `store` 和 `reudcers `时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。`store` 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:\n```h\nconst initialState = {\n  counter: {\n    value: 0\n  },\n  visible: true\n};\n```\n需要为这两部分分别定义 `reducer `。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 `reducer` 函数来进行维护，这样管理起来将会非常困难。\n\n`Redux `提供辅助函数来让我们能够锁定` state `的某个特定部分并为其分配一个 `reducer `。它就是 `combineReducers` :\n```h\nimport { createStore, combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n  counter: function A() { ... },\n  visible: function B() { ... }\n});\nconst store = createStore(rootReducer);\n```\n函数 A 只接收 `counter` 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。\n\n`counter` 切片的` reducer` 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 `counter` 状态。\n```h\nconst counterReducer = function (state, action) {\n  if (action.type === ADD) {\n    return { value: state.value + 1 };\n  } else if (action.type === SUBTRACT) {\n    return { value: state.value - 1 };\n  }\n  return state || { value: 0 };\n};\n```\n当 `store` 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 `{ type: \"@@redux/INIT\"}` 。在这个实例中，reducer 应该返回数据的初始值 `{ value: 0 }` 。\n\nvisible 的 reducer 相当简单，它只处理动作 `CHANGE_VISIBILITY` :\n```h\nconst visibilityReducer = function (state, action) {\n  if (action.type === CHANGE_VISIBILITY) {\n    return action.visible;\n  }\n  return true;\n};\n```\n最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。\n\n```h\nconst rootReducer = combineReducers({\n  counter: counterReducer,\n  visible: visibilityReducer\n});\n```\n### 选择器 ( Selectors )\n我们知道状态通常都是细化成多个状态切片。我们有专门的 `reducer `来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:\n```h\nconst getCounterValue = state => state.counter.value;\nconst getVisibility = state => state.visible;\n```\n这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。\n\n### React 组件\n\n先来处理管理计数器可见性的 UI 部分。\n```h\nfunction Visibility({ changeVisibility }) {\n  return (\n    <div>\n      <button onClick={ () => changeVisibility(true) }>\n        Visible\n      </button>\n      <button onClick={ () => changeVisibility(false) }>\n        Hidden\n      </button>\n    </div>\n  );\n}\n\nconst VisibilityConnected = connect(\n  null,\n  dispatch => ({\n    changeVisibility: value => dispatch(changeVisibility(value))\n  })\n)(Visibility);\n```\n第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。\n\n```h\nfunction Counter({ value, add, subtract }) {\n  return (\n    <div>\n      <p>Value: { value }</p>\n      <button onClick={ add }>Add</button>\n      <button onClick={ subtract }>Subtract</button>\n    </div>\n  );\n}\n\nconst CounterConnected = connect(\n  state => ({\n    value: getCounterValue(state)\n  }),\n  dispatch => ({\n    add: () => dispatch(add()),\n    subtract: () => dispatch(subtract())\n  })\n)(Counter);\n\n```\n这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: `value、add 和 subtract `。\n\n最后要完成的就是 App 组件，我们在这里进行应用的组装。\n\n```h\nfunction App({ visible }) {\n  return (\n    <div>\n      <VisibilityConnected />\n      { visible && <CounterConnected /> }\n    </div>\n  );\n}\nconst AppConnected = connect(\n  state => ({\n    visible: getVisibility(state)\n  })\n)(App);\n```\n再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。\n\n## 结语\n\nRedux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:\n\n![react](React开发常用设计模式-Redux/redux-reallife.jpg)\n\n顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。\n\n我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。\n","source":"_posts/React开发常用设计模式-Redux.md","raw":"---\ntitle: React开发常用设计模式-Redux\ndate: 2018-06-11 23:52:51\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n[Redux](https://redux.js.org/) 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 ([视频](https://www.youtube.com/watch?v=xsSnOQynTHs))。它类似于 [Flux 架构](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics) 并有很多共同点。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# Redux\n\n## Redux 架构及其主要特点\n![redux](React开发常用设计模式-Redux/redux-architecture.jpg)\n\n类似于 [Flux](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md) 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 `store `中。注意，我们说的是 `store`，而不是 `stores` ，这是因为在 `Redux` 中只有一个 `store` ，这是 `Redux` 与 `Flux` 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 `reducers` 。一旦 `store `接收到动作，它会将当前状态和给定动作发送给` reducer `并要求其返回一个新的状态。然后，在数据不可变的方式下， `reducer `需要返回新的状态。再然后， `store `更新自身的内部状态。最后，与 `store `连接的 `React `组件会重新渲染。\n\n概念相当清晰并再次遵循了 [单向数据流](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md) 。我们来讨论每一个部分并引入一些支持 `Redux` 模式工作的新术语。\n\n## 动作 ( Actions )\n\n`Redux` 中的动作和 `Flux `一样，也只是有 `type `属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:\n\n```h\nconst CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';\nconst action = {\n  type: CHANGE_VISIBILITY,\n  visible: false\n}\n```\n使用像 `CHANGE_VISIBILITY` 这样的常量作为动作的类型是一种最佳实践。有很多支持 `Redux `的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。\n\n`visible` 属性是我们所提到过的元数据。它与 `Redux `本身无关，它表示应用中某处需要使用的数据。\n\n每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 `action creators` 诞生的原因。`action creator` 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:\n```h\nconst changeVisibility = visible => ({\n  type: CHANGE_VISIBILITY,\n  visible\n});\n\nchangeVisibility(false);\n// { type: CHANGE_VISIBILITY, visible: false }\n```\n注意，将 `visible` 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。\n\n## Store\n\n`Redux` 提供辅助函数 `createStore` 来创建 `store` 。它的函数签名如下:\n```h\nimport { createStore } from 'redux';\n\ncreateStore([reducer], [initial state], [enhancer]);\n```\n正如之前所提到的，`reducer` 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 `store` 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数` enhancer `提供 API 来使用第三方的中间件来扩展` Redux `，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。\n\n创建好的` store` 具有四个方法:` getState、dispatch、subscribe `和 `replaceReducer` 。其中最重要的或许就是` dispatch `:\n```h\nstore.dispatch(changeVisibility(false));\n```\n这里我们使用的是 `action creator `。我们将其结果 (即 action 对象) 传给 `dispatch `方法。然后，它会传播给应用中的 `reducers `。\n\n在典型的` React `应用中，我们通常不会直接使用` getState 和 subscribe `，因为有辅助函数  可以将`组件`和 `store `联系起来并有效地订阅 `store` 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用` getState `。`replaceReducer `是一个高级 API ，它用来交互 `store `所使用的当前 `reducer` 。\n\n## Reducer\n\n`reducer `函数大概是` Redux `中最精华的部分。`reducer `还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。\n\n{% note danger %} (1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 {% endnote %}\n{% note danger %} (2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 {% endnote %}\n\n下面是个很简单的计数器 reducer :\n\n```h\nconst counterReducer = function (state, action) {\n  if (action.type === ADD) {\n    return { value: state.value + 1 };\n  } else if (action.type === SUBTRACT) {\n    return { value: state.value - 1 };\n  }\n  return { value: 0 };\n};\n```\n它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。\n\n## 连接 React 组件\n\n如果是在 `React `上下文中讨论` Redux `的话，那基本离不开 [react-redux](https://github.com/reactjs/react-redux) 模块。它提供两样东西来进行 `Redux` 到组件的连接。\n\n> (1) `<Provider> 组件` - 它是一个组件，它接收 `store `并使得所有的子组件都可以通过 React 的 context API 来访问 `store `。\n\n例如:\n```h\n<Provider store={ myStore }>\n  <MyApp />\n</Provider>\n```\n通常，我们只在应用中的单个地方使用它。\n\n> (2) `connect 函数` - 它是一个函数，它负责订阅 `store `的更新和重新渲染组件。它是通过 [高阶组件](https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component) 实现的。\n\n这是它的函数签名:\n```h\nconnect(\n  [mapStateToProps],\n  [mapDispatchToProps],\n  [mergeProps],\n  [options]\n)\n```\n`mapDispatchToProps `也是类似的，只是它接收的是 `dispatch `函数，而不是` state` 。这里是我们将派发动作定义成属性的地方。\n```h\nconst mapDispatchToProps = dispatch => ({\n  changeVisibility: value => dispatch(changeVisibility(value))\n});\n```\n`mergeProps `将 `mapStateToProps、 mapDispatchToProps `和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。`options` 接收一组如何控制连接的设置。\n\n## 使用 Redux 的简单计数器应用\n\n使用上面所有的 API 来创建一个简单的计数器应用。\n![react](React开发常用设计模式-Redux/redux-counter-app.png)\n\n\"Add\" 和 \"Subtract\" 按钮只是改变 `store` 的值。\"Visible\" 和 \"Hidden\" 按钮用来控制计数器是否显示。\n### 创建动作\n每个 `Redux` 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:`增加、减少和管理可见性`。所有动作代码如下所示:\n```h\nconst ADD = 'ADD';\nconst SUBTRACT = 'SUBTRACT';\nconst CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';\n\nconst add = () => ({ type: ADD });\nconst subtract = () => ({ type: SUBTRACT });\nconst changeVisibility = visible => ({\n  type: CHANGE_VISIBILITY,\n  visible\n});\n```\n### Store 及其 reducers\n在解释 `store` 和 `reudcers `时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。`store` 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:\n```h\nconst initialState = {\n  counter: {\n    value: 0\n  },\n  visible: true\n};\n```\n需要为这两部分分别定义 `reducer `。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 `reducer` 函数来进行维护，这样管理起来将会非常困难。\n\n`Redux `提供辅助函数来让我们能够锁定` state `的某个特定部分并为其分配一个 `reducer `。它就是 `combineReducers` :\n```h\nimport { createStore, combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n  counter: function A() { ... },\n  visible: function B() { ... }\n});\nconst store = createStore(rootReducer);\n```\n函数 A 只接收 `counter` 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。\n\n`counter` 切片的` reducer` 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 `counter` 状态。\n```h\nconst counterReducer = function (state, action) {\n  if (action.type === ADD) {\n    return { value: state.value + 1 };\n  } else if (action.type === SUBTRACT) {\n    return { value: state.value - 1 };\n  }\n  return state || { value: 0 };\n};\n```\n当 `store` 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 `{ type: \"@@redux/INIT\"}` 。在这个实例中，reducer 应该返回数据的初始值 `{ value: 0 }` 。\n\nvisible 的 reducer 相当简单，它只处理动作 `CHANGE_VISIBILITY` :\n```h\nconst visibilityReducer = function (state, action) {\n  if (action.type === CHANGE_VISIBILITY) {\n    return action.visible;\n  }\n  return true;\n};\n```\n最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。\n\n```h\nconst rootReducer = combineReducers({\n  counter: counterReducer,\n  visible: visibilityReducer\n});\n```\n### 选择器 ( Selectors )\n我们知道状态通常都是细化成多个状态切片。我们有专门的 `reducer `来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:\n```h\nconst getCounterValue = state => state.counter.value;\nconst getVisibility = state => state.visible;\n```\n这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。\n\n### React 组件\n\n先来处理管理计数器可见性的 UI 部分。\n```h\nfunction Visibility({ changeVisibility }) {\n  return (\n    <div>\n      <button onClick={ () => changeVisibility(true) }>\n        Visible\n      </button>\n      <button onClick={ () => changeVisibility(false) }>\n        Hidden\n      </button>\n    </div>\n  );\n}\n\nconst VisibilityConnected = connect(\n  null,\n  dispatch => ({\n    changeVisibility: value => dispatch(changeVisibility(value))\n  })\n)(Visibility);\n```\n第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。\n\n```h\nfunction Counter({ value, add, subtract }) {\n  return (\n    <div>\n      <p>Value: { value }</p>\n      <button onClick={ add }>Add</button>\n      <button onClick={ subtract }>Subtract</button>\n    </div>\n  );\n}\n\nconst CounterConnected = connect(\n  state => ({\n    value: getCounterValue(state)\n  }),\n  dispatch => ({\n    add: () => dispatch(add()),\n    subtract: () => dispatch(subtract())\n  })\n)(Counter);\n\n```\n这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: `value、add 和 subtract `。\n\n最后要完成的就是 App 组件，我们在这里进行应用的组装。\n\n```h\nfunction App({ visible }) {\n  return (\n    <div>\n      <VisibilityConnected />\n      { visible && <CounterConnected /> }\n    </div>\n  );\n}\nconst AppConnected = connect(\n  state => ({\n    visible: getVisibility(state)\n  })\n)(App);\n```\n再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。\n\n## 结语\n\nRedux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:\n\n![react](React开发常用设计模式-Redux/redux-reallife.jpg)\n\n顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。\n\n我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。\n","slug":"React开发常用设计模式-Redux","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne10019kt89w3i17dlt","content":"<p><a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener\">Redux</a> 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (<a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\" rel=\"noopener\">视频</a>)。它类似于 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics\" target=\"_blank\" rel=\"noopener\">Flux 架构</a> 并有很多共同点。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><h2 id=\"Redux-架构及其主要特点\"><a href=\"#Redux-架构及其主要特点\" class=\"headerlink\" title=\"Redux 架构及其主要特点\"></a>Redux 架构及其主要特点</h2><p><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-architecture.jpg\" alt=\"redux\"></p>\n<p>类似于 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md\" target=\"_blank\" rel=\"noopener\">Flux</a> 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 <code>store</code>中。注意，我们说的是 <code>store</code>，而不是 <code>stores</code> ，这是因为在 <code>Redux</code> 中只有一个 <code>store</code> ，这是 <code>Redux</code> 与 <code>Flux</code> 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 <code>reducers</code> 。一旦 <code>store</code>接收到动作，它会将当前状态和给定动作发送给<code>reducer</code>并要求其返回一个新的状态。然后，在数据不可变的方式下， <code>reducer</code>需要返回新的状态。再然后， <code>store</code>更新自身的内部状态。最后，与 <code>store</code>连接的 <code>React</code>组件会重新渲染。</p>\n<p>概念相当清晰并再次遵循了 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md\" target=\"_blank\" rel=\"noopener\">单向数据流</a> 。我们来讨论每一个部分并引入一些支持 <code>Redux</code> 模式工作的新术语。</p>\n<h2 id=\"动作-Actions\"><a href=\"#动作-Actions\" class=\"headerlink\" title=\"动作 ( Actions )\"></a>动作 ( Actions )</h2><p><code>Redux</code> 中的动作和 <code>Flux</code>一样，也只是有 <code>type</code>属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class=\"line\"><span class=\"keyword\">const</span> action = &#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用像 <code>CHANGE_VISIBILITY</code> 这样的常量作为动作的类型是一种最佳实践。有很多支持 <code>Redux</code>的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。</p>\n<p><code>visible</code> 属性是我们所提到过的元数据。它与 <code>Redux</code>本身无关，它表示应用中某处需要使用的数据。</p>\n<p>每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 <code>action creators</code> 诞生的原因。<code>action creator</code> 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">changeVisibility(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: CHANGE_VISIBILITY, visible: false &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，将 <code>visible</code> 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。</p>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p><code>Redux</code> 提供辅助函数 <code>createStore</code> 来创建 <code>store</code> 。它的函数签名如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from 'redux';</span><br><span class=\"line\"></span><br><span class=\"line\">createStore([reducer], [initial state], [enhancer]);</span><br></pre></td></tr></table></figure></p>\n<p>正如之前所提到的，<code>reducer</code> 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 <code>store</code> 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数<code>enhancer</code>提供 API 来使用第三方的中间件来扩展<code>Redux</code>，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。</p>\n<p>创建好的<code>store</code> 具有四个方法:<code>getState、dispatch、subscribe</code>和 <code>replaceReducer</code> 。其中最重要的或许就是<code>dispatch</code>:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(changeVisibility(<span class=\"literal\">false</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这里我们使用的是 <code>action creator</code>。我们将其结果 (即 action 对象) 传给 <code>dispatch</code>方法。然后，它会传播给应用中的 <code>reducers</code>。</p>\n<p>在典型的<code>React</code>应用中，我们通常不会直接使用<code>getState 和 subscribe</code>，因为有辅助函数  可以将<code>组件</code>和 <code>store</code>联系起来并有效地订阅 <code>store</code> 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用<code>getState</code>。<code>replaceReducer</code>是一个高级 API ，它用来交互 <code>store</code>所使用的当前 <code>reducer</code> 。</p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p><code>reducer</code>函数大概是<code>Redux</code>中最精华的部分。<code>reducer</code>还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。</p>\n<div class=\"note danger\"><p>(1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 </p></div>\n<div class=\"note danger\"><p>(2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 </p></div>\n<p>下面是个很简单的计数器 reducer :</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === ADD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === SUBTRACT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; value: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。</p>\n<h2 id=\"连接-React-组件\"><a href=\"#连接-React-组件\" class=\"headerlink\" title=\"连接 React 组件\"></a>连接 React 组件</h2><p>如果是在 <code>React</code>上下文中讨论<code>Redux</code>的话，那基本离不开 <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\" rel=\"noopener\">react-redux</a> 模块。它提供两样东西来进行 <code>Redux</code> 到组件的连接。</p>\n<blockquote>\n<p>(1) <code>&lt;Provider&gt; 组件</code> - 它是一个组件，它接收 <code>store</code>并使得所有的子组件都可以通过 React 的 context API 来访问 <code>store</code>。</p>\n</blockquote>\n<p>例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123; myStore &#125;&gt;</span><br><span class=\"line\">  &lt;MyApp /&gt;</span><br><span class=\"line\">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure></p>\n<p>通常，我们只在应用中的单个地方使用它。</p>\n<blockquote>\n<p>(2) <code>connect 函数</code> - 它是一个函数，它负责订阅 <code>store</code>的更新和重新渲染组件。它是通过 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component\" target=\"_blank\" rel=\"noopener\">高阶组件</a> 实现的。</p>\n</blockquote>\n<p>这是它的函数签名:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(</span><br><span class=\"line\">  [mapStateToProps],</span><br><span class=\"line\">  [mapDispatchToProps],</span><br><span class=\"line\">  [mergeProps],</span><br><span class=\"line\">  [options]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>mapDispatchToProps</code>也是类似的，只是它接收的是 <code>dispatch</code>函数，而不是<code>state</code> 。这里是我们将派发动作定义成属性的地方。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class=\"line\">  changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>mergeProps</code>将 <code>mapStateToProps、 mapDispatchToProps</code>和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。<code>options</code> 接收一组如何控制连接的设置。</p>\n<h2 id=\"使用-Redux-的简单计数器应用\"><a href=\"#使用-Redux-的简单计数器应用\" class=\"headerlink\" title=\"使用 Redux 的简单计数器应用\"></a>使用 Redux 的简单计数器应用</h2><p>使用上面所有的 API 来创建一个简单的计数器应用。<br><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-counter-app.png\" alt=\"react\"></p>\n<p>“Add” 和 “Subtract” 按钮只是改变 <code>store</code> 的值。”Visible” 和 “Hidden” 按钮用来控制计数器是否显示。</p>\n<h3 id=\"创建动作\"><a href=\"#创建动作\" class=\"headerlink\" title=\"创建动作\"></a>创建动作</h3><p>每个 <code>Redux</code> 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:<code>增加、减少和管理可见性</code>。所有动作代码如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ADD = 'ADD';</span><br><span class=\"line\">const SUBTRACT = 'SUBTRACT';</span><br><span class=\"line\">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = () =&gt; (&#123; type: ADD &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subtract = () =&gt; (&#123; type: SUBTRACT &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Store-及其-reducers\"><a href=\"#Store-及其-reducers\" class=\"headerlink\" title=\"Store 及其 reducers\"></a>Store 及其 reducers</h3><p>在解释 <code>store</code> 和 <code>reudcers</code>时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。<code>store</code> 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  counter: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>需要为这两部分分别定义 <code>reducer</code>。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 <code>reducer</code> 函数来进行维护，这样管理起来将会非常困难。</p>\n<p><code>Redux</code>提供辅助函数来让我们能够锁定<code>state</code>的某个特定部分并为其分配一个 <code>reducer</code>。它就是 <code>combineReducers</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore, combineReducers &#125; from 'redux';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: function A() &#123; ... &#125;,</span><br><span class=\"line\">  visible: function B() &#123; ... &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure></p>\n<p>函数 A 只接收 <code>counter</code> 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。</p>\n<p><code>counter</code> 切片的<code>reducer</code> 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 <code>counter</code> 状态。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === ADD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === SUBTRACT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state || &#123; value: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当 <code>store</code> 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 <code>{ type: &quot;@@redux/INIT&quot;}</code> 。在这个实例中，reducer 应该返回数据的初始值 <code>{ value: 0 }</code> 。</p>\n<p>visible 的 reducer 相当简单，它只处理动作 <code>CHANGE_VISIBILITY</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> visibilityReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === CHANGE_VISIBILITY) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action.visible;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: counterReducer,</span><br><span class=\"line\">  visible: visibilityReducer</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择器-Selectors\"><a href=\"#选择器-Selectors\" class=\"headerlink\" title=\"选择器 ( Selectors )\"></a>选择器 ( Selectors )</h3><p>我们知道状态通常都是细化成多个状态切片。我们有专门的 <code>reducer</code>来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCounterValue = state =&gt; state.counter.value;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibility = state =&gt; state.visible;</span><br></pre></td></tr></table></figure></p>\n<p>这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。</p>\n<h3 id=\"React-组件\"><a href=\"#React-组件\" class=\"headerlink\" title=\"React 组件\"></a>React 组件</h3><p>先来处理管理计数器可见性的 UI 部分。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Visibility</span><span class=\"params\">(&#123; changeVisibility &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class=\"literal\">true</span>) &#125;&gt;</span><br><span class=\"line\">        Visible</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class=\"literal\">false</span>) &#125;&gt;</span><br><span class=\"line\">        Hidden</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibilityConnected = connect(</span><br><span class=\"line\">  null,</span><br><span class=\"line\">  dispatch =&gt; (&#123;</span><br><span class=\"line\">    changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(Visibility);</span><br></pre></td></tr></table></figure></p>\n<p>第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Counter</span><span class=\"params\">(&#123; value, add, subtract &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;Value: &#123; value &#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; add &#125;&gt;Add&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; subtract &#125;&gt;Subtract&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> CounterConnected = connect(</span><br><span class=\"line\">  state =&gt; (&#123;</span><br><span class=\"line\">    value: getCounterValue(state)</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  dispatch =&gt; (&#123;</span><br><span class=\"line\">    add: () =&gt; dispatch(add()),</span><br><span class=\"line\">    subtract: () =&gt; dispatch(subtract())</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(Counter);</span><br></pre></td></tr></table></figure>\n<p>这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: <code>value、add 和 subtract</code>。</p>\n<p>最后要完成的就是 App 组件，我们在这里进行应用的组装。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">(&#123; visible &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VisibilityConnected /&gt;</span><br><span class=\"line\">      &#123; visible &amp;&amp; &lt;CounterConnected /&gt; &#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> AppConnected = connect(</span><br><span class=\"line\">  state =&gt; (&#123;</span><br><span class=\"line\">    visible: getVisibility(state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(App);</span><br></pre></td></tr></table></figure>\n<p>再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>Redux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:</p>\n<p><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-reallife.jpg\" alt=\"react\"></p>\n<p>顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。</p>\n<p>我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener\">Redux</a> 是一个库，它扮演着状态容器的角色，并负责管理应用的数据流。它是 Dan Abramov 在 2015 年的 ReactEurope 开发者大会上推出的 (<a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\" rel=\"noopener\">视频</a>)。它类似于 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md#flux-architecture-and-its-main-characteristics\" target=\"_blank\" rel=\"noopener\">Flux 架构</a> 并有很多共同点。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><h2 id=\"Redux-架构及其主要特点\"><a href=\"#Redux-架构及其主要特点\" class=\"headerlink\" title=\"Redux 架构及其主要特点\"></a>Redux 架构及其主要特点</h2><p><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-architecture.jpg\" alt=\"redux\"></p>\n<p>类似于 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-8/README.md\" target=\"_blank\" rel=\"noopener\">Flux</a> 架构，由视图组件 (React) 来派发动作。同一个动作也可能是由系统的其他部分派发的，例如引导逻辑。动作不是派发到中心枢纽中，而是直接派发到 <code>store</code>中。注意，我们说的是 <code>store</code>，而不是 <code>stores</code> ，这是因为在 <code>Redux</code> 中只有一个 <code>store</code> ，这是 <code>Redux</code> 与 <code>Flux</code> 的最重要的区别之一。决定数据如何改变的逻辑以纯函数 ( pure functions ) 的形式存在，我们称之为 <code>reducers</code> 。一旦 <code>store</code>接收到动作，它会将当前状态和给定动作发送给<code>reducer</code>并要求其返回一个新的状态。然后，在数据不可变的方式下， <code>reducer</code>需要返回新的状态。再然后， <code>store</code>更新自身的内部状态。最后，与 <code>store</code>连接的 <code>React</code>组件会重新渲染。</p>\n<p>概念相当清晰并再次遵循了 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-7/README.md\" target=\"_blank\" rel=\"noopener\">单向数据流</a> 。我们来讨论每一个部分并引入一些支持 <code>Redux</code> 模式工作的新术语。</p>\n<h2 id=\"动作-Actions\"><a href=\"#动作-Actions\" class=\"headerlink\" title=\"动作 ( Actions )\"></a>动作 ( Actions )</h2><p><code>Redux</code> 中的动作和 <code>Flux</code>一样，也只是有 <code>type</code>属性的对象而已。该对象中的其他所有内容都被视为特定于上下文的数据，并且与模式无关，而与应用的逻辑相关。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class=\"line\"><span class=\"keyword\">const</span> action = &#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用像 <code>CHANGE_VISIBILITY</code> 这样的常量作为动作的类型是一种最佳实践。有很多支持 <code>Redux</code>的工具和库，它们用来解决不用的问题，并且都只需要动作的类型即可。所以说，动作只是传递信息的一种便捷方式。</p>\n<p><code>visible</code> 属性是我们所提到过的元数据。它与 <code>Redux</code>本身无关，它表示应用中某处需要使用的数据。</p>\n<p>每次我们想要派发动作时都需要使用这样的对象。但是，一遍又一遍地写确实是让太人烦躁了。这也正是概念 <code>action creators</code> 诞生的原因。<code>action creator</code> 是返回动作对象的函数，它可选项性地接收与动作相关联的属性。例如，如果将上面的 action 写成 action creator 会是这样:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">changeVisibility(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: CHANGE_VISIBILITY, visible: false &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，将 <code>visible</code> 的值作为参数传入，这样我们不必去记住 (或导入) 动作的确切类型。使用这种辅助函数可以让代码更紧凑，更易于阅读。</p>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p><code>Redux</code> 提供辅助函数 <code>createStore</code> 来创建 <code>store</code> 。它的函数签名如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from 'redux';</span><br><span class=\"line\"></span><br><span class=\"line\">createStore([reducer], [initial state], [enhancer]);</span><br></pre></td></tr></table></figure></p>\n<p>正如之前所提到的，<code>reducer</code> 是一个函数，它接收当前状态和动作，然后返回一个新的状态。第二个参数是 <code>store</code> 的初始状态。这是一种便捷的手段，可以用已有的数据来初始化我们的应用。这个功能是像服务器端渲染或持久体验这样的过程的本质。第三个参数<code>enhancer</code>提供 API 来使用第三方的中间件来扩展<code>Redux</code>，基本上是插入一些自身没有提供的功能，例如处理异步流程的工具。</p>\n<p>创建好的<code>store</code> 具有四个方法:<code>getState、dispatch、subscribe</code>和 <code>replaceReducer</code> 。其中最重要的或许就是<code>dispatch</code>:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(changeVisibility(<span class=\"literal\">false</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这里我们使用的是 <code>action creator</code>。我们将其结果 (即 action 对象) 传给 <code>dispatch</code>方法。然后，它会传播给应用中的 <code>reducers</code>。</p>\n<p>在典型的<code>React</code>应用中，我们通常不会直接使用<code>getState 和 subscribe</code>，因为有辅助函数  可以将<code>组件</code>和 <code>store</code>联系起来并有效地订阅 <code>store</code> 的变化。作为订阅的一部分，我们自然可以收到当前的状态，所以不必自己去调用<code>getState</code>。<code>replaceReducer</code>是一个高级 API ，它用来交互 <code>store</code>所使用的当前 <code>reducer</code> 。</p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p><code>reducer</code>函数大概是<code>Redux</code>中最精华的部分。<code>reducer</code>还有两个特点非常重要，没有它们的话基本上这种模式也不复存在。</p>\n<div class=\"note danger\"><p>(1) 它必须是纯函数 - 这意味着在输入不变的情况下，永远应该返回相同的结果。 </p></div>\n<div class=\"note danger\"><p>(2) 它应该没有副作用 - 像访问全局变量、发起异步请求或等待 promise 解析这样的操作都不应该用在此处。 </p></div>\n<p>下面是个很简单的计数器 reducer :</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === ADD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === SUBTRACT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; value: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>它没有任何副作用，每次都是返回一个全新的对象。我们根据之前的状态和传入的动作类型来累加出新的值。</p>\n<h2 id=\"连接-React-组件\"><a href=\"#连接-React-组件\" class=\"headerlink\" title=\"连接 React 组件\"></a>连接 React 组件</h2><p>如果是在 <code>React</code>上下文中讨论<code>Redux</code>的话，那基本离不开 <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\" rel=\"noopener\">react-redux</a> 模块。它提供两样东西来进行 <code>Redux</code> 到组件的连接。</p>\n<blockquote>\n<p>(1) <code>&lt;Provider&gt; 组件</code> - 它是一个组件，它接收 <code>store</code>并使得所有的子组件都可以通过 React 的 context API 来访问 <code>store</code>。</p>\n</blockquote>\n<p>例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123; myStore &#125;&gt;</span><br><span class=\"line\">  &lt;MyApp /&gt;</span><br><span class=\"line\">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure></p>\n<p>通常，我们只在应用中的单个地方使用它。</p>\n<blockquote>\n<p>(2) <code>connect 函数</code> - 它是一个函数，它负责订阅 <code>store</code>的更新和重新渲染组件。它是通过 <a href=\"https://github.com/krasimir/react-in-patterns/blob/master/book/chapter-4/README.md#higher-order-component\" target=\"_blank\" rel=\"noopener\">高阶组件</a> 实现的。</p>\n</blockquote>\n<p>这是它的函数签名:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(</span><br><span class=\"line\">  [mapStateToProps],</span><br><span class=\"line\">  [mapDispatchToProps],</span><br><span class=\"line\">  [mergeProps],</span><br><span class=\"line\">  [options]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>mapDispatchToProps</code>也是类似的，只是它接收的是 <code>dispatch</code>函数，而不是<code>state</code> 。这里是我们将派发动作定义成属性的地方。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class=\"line\">  changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>mergeProps</code>将 <code>mapStateToProps、 mapDispatchToProps</code>和发送给组件的属性进行合并，它赋予我们机会去累加出更适合的属性。例如，如果我们需要触发两个动作，我们可以将它们组合成一个单独的属性并将其发送给 React 。<code>options</code> 接收一组如何控制连接的设置。</p>\n<h2 id=\"使用-Redux-的简单计数器应用\"><a href=\"#使用-Redux-的简单计数器应用\" class=\"headerlink\" title=\"使用 Redux 的简单计数器应用\"></a>使用 Redux 的简单计数器应用</h2><p>使用上面所有的 API 来创建一个简单的计数器应用。<br><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-counter-app.png\" alt=\"react\"></p>\n<p>“Add” 和 “Subtract” 按钮只是改变 <code>store</code> 的值。”Visible” 和 “Hidden” 按钮用来控制计数器是否显示。</p>\n<h3 id=\"创建动作\"><a href=\"#创建动作\" class=\"headerlink\" title=\"创建动作\"></a>创建动作</h3><p>每个 <code>Redux</code> 的开始都是对动作类型建模及定义我们所要保存的状态。在这个示例中，会有三个操作:<code>增加、减少和管理可见性</code>。所有动作代码如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ADD = 'ADD';</span><br><span class=\"line\">const SUBTRACT = 'SUBTRACT';</span><br><span class=\"line\">const CHANGE_VISIBILITY = 'CHANGE_VISIBILITY';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = () =&gt; (&#123; type: ADD &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subtract = () =&gt; (&#123; type: SUBTRACT &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> changeVisibility = visible =&gt; (&#123;</span><br><span class=\"line\">  type: CHANGE_VISIBILITY,</span><br><span class=\"line\">  visible</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Store-及其-reducers\"><a href=\"#Store-及其-reducers\" class=\"headerlink\" title=\"Store 及其 reducers\"></a>Store 及其 reducers</h3><p>在解释 <code>store</code> 和 <code>reudcers</code>时，有些技术点是没有讨论到的。通常，我们会有多个 reducer ，因为要管理多种状态。<code>store</code> 只有一个，所以理论上只有一个状态对象。但是大多数生产环境的应用的状态都是状态切片的组合。每个切片代表应用的一部分。这个小示例拥有计数和可见性两个切片。所以初始状态应该是这样的:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  counter: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>需要为这两部分分别定义 <code>reducer</code>。这样会带来灵活性并提升代码的可读性。想象一下，如果我们有一个拥有十个或更多状态切片的巨型应用，并且我们只使用单个 <code>reducer</code> 函数来进行维护，这样管理起来将会非常困难。</p>\n<p><code>Redux</code>提供辅助函数来让我们能够锁定<code>state</code>的某个特定部分并为其分配一个 <code>reducer</code>。它就是 <code>combineReducers</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore, combineReducers &#125; from 'redux';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: function A() &#123; ... &#125;,</span><br><span class=\"line\">  visible: function B() &#123; ... &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure></p>\n<p>函数 A 只接收 <code>counter</code> 切片作为状态，并且只返回切片这部分的状态。函数 B 也是同样的，它接收布尔值 (visible 的值) 并且必须返回布尔值。</p>\n<p><code>counter</code> 切片的<code>reducer</code> 应该考虑到 ADD 和 SUBTRACT 两个动作，并基于动作来计算出新的 <code>counter</code> 状态。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === ADD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === SUBTRACT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; value: state.value - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state || &#123; value: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当 <code>store</code> 初始化时，每个 reducer 至少触发一次。最初运行的这一次，state 为 undefined ，action 为 <code>{ type: &quot;@@redux/INIT&quot;}</code> 。在这个实例中，reducer 应该返回数据的初始值 <code>{ value: 0 }</code> 。</p>\n<p>visible 的 reducer 相当简单，它只处理动作 <code>CHANGE_VISIBILITY</code> :<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> visibilityReducer = function (state, action) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === CHANGE_VISIBILITY) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action.visible;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>最后，我们需要将这两个 reducers 传给 combineReducers 来创建 rootReducer 。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: counterReducer,</span><br><span class=\"line\">  visible: visibilityReducer</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择器-Selectors\"><a href=\"#选择器-Selectors\" class=\"headerlink\" title=\"选择器 ( Selectors )\"></a>选择器 ( Selectors )</h3><p>我们知道状态通常都是细化成多个状态切片。我们有专门的 <code>reducer</code>来负责更新数据，但是当涉及到获取状态数据时，我们仍然只是有一个对象。这里就是选择器 ( Selectors )派上用场的地方。选择器就是一个函数，它接收整个状态对象并提取出我们所需要的数据。例如，在这个小示例应用中我们需要两个数据:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCounterValue = state =&gt; state.counter.value;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibility = state =&gt; state.visible;</span><br></pre></td></tr></table></figure></p>\n<p>这个计数器应用实在是太小了，完全体现不出选择器的威力。但是，在一个大项目中便截然不同。选择器的存在并不是为了少些几行代码，也不是为了可读性。选择器附带了这些内容，但它们也是上下文相关的，可能包含逻辑。由于它们可以访问整个状态，所以它们能够回答业务逻辑相关的问题。例如，“在 Y 页面用户是否有权限可以做 X 这件事”。这样的事通过一个选择器就可以完成。</p>\n<h3 id=\"React-组件\"><a href=\"#React-组件\" class=\"headerlink\" title=\"React 组件\"></a>React 组件</h3><p>先来处理管理计数器可见性的 UI 部分。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Visibility</span><span class=\"params\">(&#123; changeVisibility &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class=\"literal\">true</span>) &#125;&gt;</span><br><span class=\"line\">        Visible</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; () =&gt; changeVisibility(<span class=\"literal\">false</span>) &#125;&gt;</span><br><span class=\"line\">        Hidden</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibilityConnected = connect(</span><br><span class=\"line\">  null,</span><br><span class=\"line\">  dispatch =&gt; (&#123;</span><br><span class=\"line\">    changeVisibility: value =&gt; dispatch(changeVisibility(value))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(Visibility);</span><br></pre></td></tr></table></figure></p>\n<p>第二个组件略微有些复杂。将它命名为 Counter ，它渲染两个按钮和计数值。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Counter</span><span class=\"params\">(&#123; value, add, subtract &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;Value: &#123; value &#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; add &#125;&gt;Add&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123; subtract &#125;&gt;Subtract&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> CounterConnected = connect(</span><br><span class=\"line\">  state =&gt; (&#123;</span><br><span class=\"line\">    value: getCounterValue(state)</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  dispatch =&gt; (&#123;</span><br><span class=\"line\">    add: () =&gt; dispatch(add()),</span><br><span class=\"line\">    subtract: () =&gt; dispatch(subtract())</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(Counter);</span><br></pre></td></tr></table></figure>\n<p>这里 mapStateToProps 和 mapDispatchToProps 都需要，因为我们想读取 store 中的数据，同时还要派发动作。这个组件要接收三个属性: <code>value、add 和 subtract</code>。</p>\n<p>最后要完成的就是 App 组件，我们在这里进行应用的组装。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">(&#123; visible &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VisibilityConnected /&gt;</span><br><span class=\"line\">      &#123; visible &amp;&amp; &lt;CounterConnected /&gt; &#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> AppConnected = connect(</span><br><span class=\"line\">  state =&gt; (&#123;</span><br><span class=\"line\">    visible: getVisibility(state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)(App);</span><br></pre></td></tr></table></figure>\n<p>再一次需要对组件进行 connect 操作，因为我们想要控制计数器的显示。getVisibility 选择器返回布尔值，它表示是否渲染 CounterConnected 组件。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>Redux 是一种很棒的模式。JavaScript 社区将这种理念发扬下去，并使用一些新术语对其进行了增强。我认为一个典型的 Redux 应用应该是下面这样的:</p>\n<p><img src=\"/blog/2018/06/11/React开发常用设计模式-Redux/redux-reallife.jpg\" alt=\"react\"></p>\n<p>顺便一提，还没有介绍过副作用管理。那将是另外的新篇章了，它有自己的理念和解决方案。</p>\n<p>我们可以得出结论，Redux 本身是一种非常简单的模式。它传授了非常有用的技术，但不幸的是光靠它自身往往是不够的。我们迟早要引入更多的概念或模式。当然这没有那么糟糕，我们只是先提起计划一下。</p>"},{"title":"React开发常用设计模式-事件处理","date":"2018-05-14T15:43:54.000Z","description":null,"copyright":true,"top":null,"_content":"对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n\n<!--more-->\n\n# 事件处理\n\n```h\nconst theLogoIsClicked = () => alert('Clicked');\n\n<Logo onClick={ theLogoIsClicked } />\n<input\n  type='text'\n  onChange={event => theInputIsChanged(event.target.value) } />\n  ```\n  通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法:\n  ```\n  class Switcher extends React.Component {\n  render() {\n    return (\n      <button onClick={ this._handleButtonClick }>\n        click me\n      </button>\n    );\n  }\n  _handleButtonClick() {\n    console.log('Button is clicked');\n  }\n};\n```\n\n\n这样使用完全可以，因为 `_handleButtonClick` 是一个函数，而我们也确实将这个函数传给了 `onClick`  属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 `_handleButtonClick` 函数中使用 `this` 来获取 `Switcher` 组件的引用时将会报错。\n通常，我们使用 bind 来解决:\n```h\n<button onClick={ this._handleButtonClick.bind(this) }>\n  click me\n</button>\n```\n但是，这样做的话 `bind` 函数会一次又一次地被调用，这是因为 `button` 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:\n```h\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: 'React in patterns' };\n    this._buttonClick = this._handleButtonClick.bind(this);\n  }\n  render() {\n    return (\n      <button onClick={ this._buttonClick }>\n        click me\n      </button>\n    );\n  }\n  _handleButtonClick() {\n    console.log(`Button is clicked inside ${ this.state.name }`);\n  }\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-事件处理/react_3.png)\n\n附带一提，在处理函数需要和组件的上下文保持统一时，Facebook [推荐](https://facebook.github.io/react/docs/reusable-components.html#no-autobinding) 的也是此技巧。\n\n构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。\n```h\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this._onNameChanged = this._onFieldChange.bind(this, 'name');\n    this._onPasswordChanged =\n      this._onFieldChange.bind(this, 'password');\n  }\n  render() {\n    return (\n      <form>\n        <input onChange={ this._onNameChanged } />\n        <input onChange={ this._onPasswordChanged } />\n      </form>\n    );\n  }\n  _onFieldChange(field, event) {\n    console.log(`${ field } changed to ${ event.target.value }`);\n  }\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-事件处理/react_4.png)\n\n\n# 结语\n对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。\n\n\n","source":"_posts/React开发常用设计模式-事件处理.md","raw":"---\ntitle: React开发常用设计模式-事件处理\ndate: 2018-05-14 23:43:54\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n\n<!--more-->\n\n# 事件处理\n\n```h\nconst theLogoIsClicked = () => alert('Clicked');\n\n<Logo onClick={ theLogoIsClicked } />\n<input\n  type='text'\n  onChange={event => theInputIsChanged(event.target.value) } />\n  ```\n  通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法:\n  ```\n  class Switcher extends React.Component {\n  render() {\n    return (\n      <button onClick={ this._handleButtonClick }>\n        click me\n      </button>\n    );\n  }\n  _handleButtonClick() {\n    console.log('Button is clicked');\n  }\n};\n```\n\n\n这样使用完全可以，因为 `_handleButtonClick` 是一个函数，而我们也确实将这个函数传给了 `onClick`  属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 `_handleButtonClick` 函数中使用 `this` 来获取 `Switcher` 组件的引用时将会报错。\n通常，我们使用 bind 来解决:\n```h\n<button onClick={ this._handleButtonClick.bind(this) }>\n  click me\n</button>\n```\n但是，这样做的话 `bind` 函数会一次又一次地被调用，这是因为 `button` 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:\n```h\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: 'React in patterns' };\n    this._buttonClick = this._handleButtonClick.bind(this);\n  }\n  render() {\n    return (\n      <button onClick={ this._buttonClick }>\n        click me\n      </button>\n    );\n  }\n  _handleButtonClick() {\n    console.log(`Button is clicked inside ${ this.state.name }`);\n  }\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-事件处理/react_3.png)\n\n附带一提，在处理函数需要和组件的上下文保持统一时，Facebook [推荐](https://facebook.github.io/react/docs/reusable-components.html#no-autobinding) 的也是此技巧。\n\n构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。\n```h\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this._onNameChanged = this._onFieldChange.bind(this, 'name');\n    this._onPasswordChanged =\n      this._onFieldChange.bind(this, 'password');\n  }\n  render() {\n    return (\n      <form>\n        <input onChange={ this._onNameChanged } />\n        <input onChange={ this._onPasswordChanged } />\n      </form>\n    );\n  }\n  _onFieldChange(field, event) {\n    console.log(`${ field } changed to ${ event.target.value }`);\n  }\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-事件处理/react_4.png)\n\n\n# 结语\n对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。\n\n\n","slug":"React开发常用设计模式-事件处理","published":1,"updated":"2018-09-18T12:23:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne2001ckt89nm0clzop","content":"<p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const theLogoIsClicked = () =&gt; alert('Clicked');</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;</span><br><span class=\"line\">&lt;input</span><br><span class=\"line\">  type='text'</span><br><span class=\"line\">  onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>  通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  class Switcher extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button onClick=&#123; this._handleButtonClick &#125;&gt;</span><br><span class=\"line\">        click me</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleButtonClick() &#123;</span><br><span class=\"line\">    console.log(&apos;Button is clicked&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样使用完全可以，因为 <code>_handleButtonClick</code> 是一个函数，而我们也确实将这个函数传给了 <code>onClick</code>  属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 <code>_handleButtonClick</code> 函数中使用 <code>this</code> 来获取 <code>Switcher</code> 组件的引用时将会报错。<br>通常，我们使用 bind 来解决:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123; <span class=\"keyword\">this</span>._handleButtonClick.bind(<span class=\"keyword\">this</span>) &#125;&gt;</span><br><span class=\"line\">  click me</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>但是，这样做的话 <code>bind</code> 函数会一次又一次地被调用，这是因为 <code>button</code> 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; name: 'React in patterns' &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._buttonClick = <span class=\"keyword\">this</span>._handleButtonClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._buttonClick &#125;&gt;</span><br><span class=\"line\">        click me</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleButtonClick() &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(`Button is clicked inside $&#123; <span class=\"keyword\">this</span>.state.name &#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-事件处理/react_3.png\" alt=\"运行结果\"></p>\n<p>附带一提，在处理函数需要和组件的上下文保持统一时，Facebook <a href=\"https://facebook.github.io/react/docs/reusable-components.html#no-autobinding\" target=\"_blank\" rel=\"noopener\">推荐</a> 的也是此技巧。</p>\n<p>构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this._onNameChanged = this._onFieldChange.bind(this, 'name');</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onPasswordChanged =</span><br><span class=\"line\">      this._onFieldChange.bind(this, 'password');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form&gt;</span><br><span class=\"line\">        &lt;input onChange=&#123; <span class=\"keyword\">this</span>._onNameChanged &#125; /&gt;</span><br><span class=\"line\">        &lt;input onChange=&#123; <span class=\"keyword\">this</span>._onPasswordChanged &#125; /&gt;</span><br><span class=\"line\">      &lt;/form&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _onFieldChange(field, event) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-事件处理/react_4.png\" alt=\"运行结果\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。</p>\n","site":{"data":{}},"excerpt":"<p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h1><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const theLogoIsClicked = () =&gt; alert('Clicked');</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;</span><br><span class=\"line\">&lt;input</span><br><span class=\"line\">  type='text'</span><br><span class=\"line\">  onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>  通常，我们在包含派发事件的元素的组件中处理事件。比如在下面的示例中，我们有一个事件处理函数，我们想要在同一个组件中运行函数或方法:<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  class Switcher extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button onClick=&#123; this._handleButtonClick &#125;&gt;</span><br><span class=\"line\">        click me</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleButtonClick() &#123;</span><br><span class=\"line\">    console.log(&apos;Button is clicked&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样使用完全可以，因为 <code>_handleButtonClick</code> 是一个函数，而我们也确实将这个函数传给了 <code>onClick</code>  属性。问题是这段代码中并没有保持同一个上下文。所以，如果我们在 <code>_handleButtonClick</code> 函数中使用 <code>this</code> 来获取 <code>Switcher</code> 组件的引用时将会报错。<br>通常，我们使用 bind 来解决:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123; <span class=\"keyword\">this</span>._handleButtonClick.bind(<span class=\"keyword\">this</span>) &#125;&gt;</span><br><span class=\"line\">  click me</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>但是，这样做的话 <code>bind</code> 函数会一次又一次地被调用，这是因为 <code>button</code> 可能会渲染多次。一种更好的方式是在组件的构造函数中来创建绑定:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; name: 'React in patterns' &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._buttonClick = <span class=\"keyword\">this</span>._handleButtonClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._buttonClick &#125;&gt;</span><br><span class=\"line\">        click me</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleButtonClick() &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(`Button is clicked inside $&#123; <span class=\"keyword\">this</span>.state.name &#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-事件处理/react_3.png\" alt=\"运行结果\"></p>\n<p>附带一提，在处理函数需要和组件的上下文保持统一时，Facebook <a href=\"https://facebook.github.io/react/docs/reusable-components.html#no-autobinding\" target=\"_blank\" rel=\"noopener\">推荐</a> 的也是此技巧。</p>\n<p>构造函数还是部分执行处理函数的好地方。例如，我们有一个表单，但是不想为每个 input 提供一个单独的处理函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this._onNameChanged = this._onFieldChange.bind(this, 'name');</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onPasswordChanged =</span><br><span class=\"line\">      this._onFieldChange.bind(this, 'password');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form&gt;</span><br><span class=\"line\">        &lt;input onChange=&#123; <span class=\"keyword\">this</span>._onNameChanged &#125; /&gt;</span><br><span class=\"line\">        &lt;input onChange=&#123; <span class=\"keyword\">this</span>._onPasswordChanged &#125; /&gt;</span><br><span class=\"line\">      &lt;/form&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _onFieldChange(field, event) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-事件处理/react_4.png\" alt=\"运行结果\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>对于 React 中的事件处理，其实没有太多需要学习的。React 的作者们在保留开发者的使用习惯上做的十分出色。因为 JSX 使用的是类似 HTML 的语法，所以使用类似 DOM 的事件处理意义重大。</p>"},{"title":"React开发常用设计模式-依赖注入","date":"2018-06-12T16:13:53.000Z","description":null,"copyright":true,"top":null,"_content":"写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 [依赖注入](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript) 的技术 (大多数人认为它是一种模式) 用来解决这种问题。\n\n在 React 中，对依赖注入的需要是显而易见的。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 依赖注入\n\n来考虑下面的应用的组件树:\n```h\n// Title.jsx\nexport default function Title(props) {\n  return <h1>{ props.title }</h1>;\n}\n\n// Header.jsx\nimport Title from './Title.jsx';\n\nexport default function Header() {\n  return (\n    <header>\n      <Title />\n    </header>\n  );\n}\n\n// App.jsx\nimport Header from './Header.jsx';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { title: 'React in patterns' };\n  }\n  render() {\n    return <Header />;\n  }\n};\n```\n字符串 \"React in patterns\" 应该以某种方式到达 `Title` 组件。最直接的方式就从 `App` 传到 `Header `，再从 `Header` 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。\n\n已经了解过 [高阶组件](http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6) ，它可以用来注入数据。来使用同样的技术来注入 title 变量:\n\n```h\n// inject.jsx\nconst title = 'React in patterns';\n\nexport default function inject(Component) {\n  return class Injector extends React.Component {\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ title }\n        />\n      )\n    }\n  };\n}\n\n// -----------------------------------\n// Header.jsx\nimport inject from './inject.jsx';\nimport Title from './Title.jsx';\n\nvar EnhancedTitle = inject(Title);\nexport default function Header() {\n  return (\n    <header>\n      <EnhancedTitle />\n    </header>\n  );\n}\n\n```\n`title `隐藏在了中间层 (高阶组件) ，在中间层将` title `属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。\n\n## 使用 React context (16.3 之前的版本)\n\n> 在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。\n\nReact 有 `context` 的概念。每个 React 组件都可以访问 `context `。它有些类似于 [事件总线](https://github.com/krasimir/EventBus) ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 `store` 。\n```h\n// 定义 context 的地方\nvar context = { title: 'React in patterns' };\n\nclass App extends React.Component {\n  getChildContext() {\n    return context;\n  }\n  ...\n};\nApp.childContextTypes = {\n  title: React.PropTypes.string\n};\n\n// 使用 context 的地方\nclass Inject extends React.Component {\n  render() {\n    var title = this.context.title;\n    ...\n  }\n}\nInject.contextTypes = {\n  title: React.PropTypes.string\n};\n```\n注意，需要使用` childContextTypes `和 `contextTypes` 来指定 `context `对象的具体签名。如果不指定的话，那么 `context` 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 `context `写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:\n\n```h\n// dependencies.js\nexport default {\n  data: {},\n  get(key) {\n    return this.data[key];\n  },\n  register(key, value) {\n    this.data[key] = value;\n  }\n}\n```\n然后，回到示例中，App 组件应该是这样的:\n```h\nimport dependencies from './dependencies';\n\ndependencies.register('title', 'React in patterns');\n\nclass App extends React.Component {\n  getChildContext() {\n    return dependencies;\n  }\n  render() {\n    return <Header />;\n  }\n};\nApp.childContextTypes = {\n  data: React.PropTypes.object,\n  get: React.PropTypes.func,\n  register: React.PropTypes.func\n};\n```\nTitle 组件通过 context 来获取数据:\n```h\n\n// Title.jsx\nexport default class Title extends React.Component {\n  render() {\n    return <h1>{ this.context.get('title') }</h1>\n  }\n}\nTitle.contextTypes = {\n  data: React.PropTypes.object,\n  get: React.PropTypes.func,\n  register: React.PropTypes.func\n};\n```\n理想情况下，不想每次需要访问 `context`时都指定`contextTypes`。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用`this.context.get('title')` 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:\n```h\n\n// Title.jsx\nimport wire from './wire';\n\nfunction Title(props) {\n  return <h1>{ props.title }</h1>;\n}\n\nexport default wire(Title, ['title'], function resolve(title) {\n  return { title };\n});\n```\n`wire `函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 `mapper `的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。\n\n`wire` 函数的代码如下所示:\n```h\nexport default function wire(Component, dependencies, mapper) {\n  class Inject extends React.Component {\n    render() {\n      var resolved = dependencies.map(\n        this.context.get.bind(this.context)\n      );\n      var props = mapper(...resolved);\n\n      return React.createElement(Component, props);\n    }\n  }\n  Inject.contextTypes = {\n    data: React.PropTypes.object,\n    get: React.PropTypes.func,\n    register: React.PropTypes.func\n  };\n  return Inject;\n};\n```\n`Inject` 是高阶组件，它可以访问 `context `并获取 `dependencies `数组中的所有项。`mapper` 函数接收 context 数据并将其转换成我们组建所需要的属性。\n\n## 使用 React context (16.3 及之后的版本)\n\nFackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。\n\n还是使用同一个示例，让字符串抵达` <Title> `组件。\n\n先来定义包含 `context `初始化的文件:\n```h\n// context.js\nimport { createContext } from 'react';\n\nconst Context = createContext({});\n\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n```\n`createContext `返回的对象具有 `Provider 和 Consumer `属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。\n\n假设说 App 组件是根组件。在此需要传入 `context `。\n\n```h\nimport { Provider } from './context';\n\nconst context = { title: 'React In Patterns' };\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={ context }>\n        <Header />\n      </Provider>\n    );\n  }\n};\n```\n包装组件以及子组件现在共享同一个 context 。`<Title> `组件是需要 title 字符串的组件之一，所以要在组件中使用 `<Consumer>` 。\n```h\nimport { Consumer } from './context';\n\nfunction Title() {\n  return (\n    <Consumer>{\n      ({ title }) => <h1>Title: { title }</h1>\n    }</Consumer>\n  );\n}\n```\n注意，`Consumer `类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。\n\n新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。\n\n## 使用模块系统\n\n如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。\n\n众所周知，JavaScript 中的典型模块系统具有缓存机制。在 [Node 官方文档](https://nodejs.org/api/modules.html#modules_caching) 中可以看到:\n\n> 模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require('foo') 都解析到同一文件，则返回相同的对象。\n> 多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。\n\n这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 [单例](https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript)，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。\n\n来创建一个新文件` di.jsx` ，它的代码如下所示:\n\n```h\nvar dependencies = {};\n\nexport function register(key, dependency) {\n  dependencies[key] = dependency;\n}\n\nexport function fetch(key) {\n  if (dependencies[key]) return dependencies[key];\n  throw new Error(`\"${ key } is not registered as dependency.`);\n}\n\nexport function wire(Component, deps, mapper) {\n  return class Injector extends React.Component {\n    constructor(props) {\n      super(props);\n      this._resolvedDependencies = mapper(...deps.map(fetch));\n    }\n    render() {\n      return (\n        <Component\n          {...this.state}\n          {...this.props}\n          {...this._resolvedDependencies}\n        />\n      );\n    }\n  };\n}\n```\n将依赖保存在了 `dependencies `这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 `register 和 fetch `这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 `setter 和 getter `。再然后是 `wire `函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 `mapper` 函数来提取所需属性。\n\n有了` di.jsx` 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。\n\n```h\n// app.jsx\nimport Header from './Header.jsx';\nimport { register } from './di.jsx';\n\nregister('my-awesome-title', 'React in patterns');\n\nclass App extends React.Component {\n  render() {\n    return <Header />;\n  }\n};\n\n// -----------------------------------\n// Header.jsx\nimport Title from './Title.jsx';\n\nexport default function Header() {\n  return (\n    <header>\n      <Title />\n    </header>\n  );\n}\n\n// -----------------------------------\n// Title.jsx\nimport { wire } from './di.jsx';\n\nvar Title = function(props) {\n  return <h1>{ props.title }</h1>;\n};\n\nexport default wire(\n  Title,\n  ['my-awesome-title'],\n  title => ({ title })\n);\n\n```\n如果查看 Title.jsx 文件的话，可以看到实际的组件和 `wire` 存在于不同的文件中。这种方式让组件和 `mapper` 函数的单元测试更简单。\n\n# 结语\n\n依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。","source":"_posts/React开发常用设计模式-依赖注入.md","raw":"---\ntitle: React开发常用设计模式-依赖注入\ndate: 2018-06-13 00:13:53\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 [依赖注入](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript) 的技术 (大多数人认为它是一种模式) 用来解决这种问题。\n\n在 React 中，对依赖注入的需要是显而易见的。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 依赖注入\n\n来考虑下面的应用的组件树:\n```h\n// Title.jsx\nexport default function Title(props) {\n  return <h1>{ props.title }</h1>;\n}\n\n// Header.jsx\nimport Title from './Title.jsx';\n\nexport default function Header() {\n  return (\n    <header>\n      <Title />\n    </header>\n  );\n}\n\n// App.jsx\nimport Header from './Header.jsx';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { title: 'React in patterns' };\n  }\n  render() {\n    return <Header />;\n  }\n};\n```\n字符串 \"React in patterns\" 应该以某种方式到达 `Title` 组件。最直接的方式就从 `App` 传到 `Header `，再从 `Header` 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。\n\n已经了解过 [高阶组件](http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6) ，它可以用来注入数据。来使用同样的技术来注入 title 变量:\n\n```h\n// inject.jsx\nconst title = 'React in patterns';\n\nexport default function inject(Component) {\n  return class Injector extends React.Component {\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ title }\n        />\n      )\n    }\n  };\n}\n\n// -----------------------------------\n// Header.jsx\nimport inject from './inject.jsx';\nimport Title from './Title.jsx';\n\nvar EnhancedTitle = inject(Title);\nexport default function Header() {\n  return (\n    <header>\n      <EnhancedTitle />\n    </header>\n  );\n}\n\n```\n`title `隐藏在了中间层 (高阶组件) ，在中间层将` title `属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。\n\n## 使用 React context (16.3 之前的版本)\n\n> 在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。\n\nReact 有 `context` 的概念。每个 React 组件都可以访问 `context `。它有些类似于 [事件总线](https://github.com/krasimir/EventBus) ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 `store` 。\n```h\n// 定义 context 的地方\nvar context = { title: 'React in patterns' };\n\nclass App extends React.Component {\n  getChildContext() {\n    return context;\n  }\n  ...\n};\nApp.childContextTypes = {\n  title: React.PropTypes.string\n};\n\n// 使用 context 的地方\nclass Inject extends React.Component {\n  render() {\n    var title = this.context.title;\n    ...\n  }\n}\nInject.contextTypes = {\n  title: React.PropTypes.string\n};\n```\n注意，需要使用` childContextTypes `和 `contextTypes` 来指定 `context `对象的具体签名。如果不指定的话，那么 `context` 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 `context `写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:\n\n```h\n// dependencies.js\nexport default {\n  data: {},\n  get(key) {\n    return this.data[key];\n  },\n  register(key, value) {\n    this.data[key] = value;\n  }\n}\n```\n然后，回到示例中，App 组件应该是这样的:\n```h\nimport dependencies from './dependencies';\n\ndependencies.register('title', 'React in patterns');\n\nclass App extends React.Component {\n  getChildContext() {\n    return dependencies;\n  }\n  render() {\n    return <Header />;\n  }\n};\nApp.childContextTypes = {\n  data: React.PropTypes.object,\n  get: React.PropTypes.func,\n  register: React.PropTypes.func\n};\n```\nTitle 组件通过 context 来获取数据:\n```h\n\n// Title.jsx\nexport default class Title extends React.Component {\n  render() {\n    return <h1>{ this.context.get('title') }</h1>\n  }\n}\nTitle.contextTypes = {\n  data: React.PropTypes.object,\n  get: React.PropTypes.func,\n  register: React.PropTypes.func\n};\n```\n理想情况下，不想每次需要访问 `context`时都指定`contextTypes`。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用`this.context.get('title')` 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:\n```h\n\n// Title.jsx\nimport wire from './wire';\n\nfunction Title(props) {\n  return <h1>{ props.title }</h1>;\n}\n\nexport default wire(Title, ['title'], function resolve(title) {\n  return { title };\n});\n```\n`wire `函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 `mapper `的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。\n\n`wire` 函数的代码如下所示:\n```h\nexport default function wire(Component, dependencies, mapper) {\n  class Inject extends React.Component {\n    render() {\n      var resolved = dependencies.map(\n        this.context.get.bind(this.context)\n      );\n      var props = mapper(...resolved);\n\n      return React.createElement(Component, props);\n    }\n  }\n  Inject.contextTypes = {\n    data: React.PropTypes.object,\n    get: React.PropTypes.func,\n    register: React.PropTypes.func\n  };\n  return Inject;\n};\n```\n`Inject` 是高阶组件，它可以访问 `context `并获取 `dependencies `数组中的所有项。`mapper` 函数接收 context 数据并将其转换成我们组建所需要的属性。\n\n## 使用 React context (16.3 及之后的版本)\n\nFackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。\n\n还是使用同一个示例，让字符串抵达` <Title> `组件。\n\n先来定义包含 `context `初始化的文件:\n```h\n// context.js\nimport { createContext } from 'react';\n\nconst Context = createContext({});\n\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n```\n`createContext `返回的对象具有 `Provider 和 Consumer `属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。\n\n假设说 App 组件是根组件。在此需要传入 `context `。\n\n```h\nimport { Provider } from './context';\n\nconst context = { title: 'React In Patterns' };\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={ context }>\n        <Header />\n      </Provider>\n    );\n  }\n};\n```\n包装组件以及子组件现在共享同一个 context 。`<Title> `组件是需要 title 字符串的组件之一，所以要在组件中使用 `<Consumer>` 。\n```h\nimport { Consumer } from './context';\n\nfunction Title() {\n  return (\n    <Consumer>{\n      ({ title }) => <h1>Title: { title }</h1>\n    }</Consumer>\n  );\n}\n```\n注意，`Consumer `类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。\n\n新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。\n\n## 使用模块系统\n\n如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。\n\n众所周知，JavaScript 中的典型模块系统具有缓存机制。在 [Node 官方文档](https://nodejs.org/api/modules.html#modules_caching) 中可以看到:\n\n> 模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require('foo') 都解析到同一文件，则返回相同的对象。\n> 多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。\n\n这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 [单例](https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript)，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。\n\n来创建一个新文件` di.jsx` ，它的代码如下所示:\n\n```h\nvar dependencies = {};\n\nexport function register(key, dependency) {\n  dependencies[key] = dependency;\n}\n\nexport function fetch(key) {\n  if (dependencies[key]) return dependencies[key];\n  throw new Error(`\"${ key } is not registered as dependency.`);\n}\n\nexport function wire(Component, deps, mapper) {\n  return class Injector extends React.Component {\n    constructor(props) {\n      super(props);\n      this._resolvedDependencies = mapper(...deps.map(fetch));\n    }\n    render() {\n      return (\n        <Component\n          {...this.state}\n          {...this.props}\n          {...this._resolvedDependencies}\n        />\n      );\n    }\n  };\n}\n```\n将依赖保存在了 `dependencies `这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 `register 和 fetch `这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 `setter 和 getter `。再然后是 `wire `函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 `mapper` 函数来提取所需属性。\n\n有了` di.jsx` 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。\n\n```h\n// app.jsx\nimport Header from './Header.jsx';\nimport { register } from './di.jsx';\n\nregister('my-awesome-title', 'React in patterns');\n\nclass App extends React.Component {\n  render() {\n    return <Header />;\n  }\n};\n\n// -----------------------------------\n// Header.jsx\nimport Title from './Title.jsx';\n\nexport default function Header() {\n  return (\n    <header>\n      <Title />\n    </header>\n  );\n}\n\n// -----------------------------------\n// Title.jsx\nimport { wire } from './di.jsx';\n\nvar Title = function(props) {\n  return <h1>{ props.title }</h1>;\n};\n\nexport default wire(\n  Title,\n  ['my-awesome-title'],\n  title => ({ title })\n);\n\n```\n如果查看 Title.jsx 文件的话，可以看到实际的组件和 `wire` 存在于不同的文件中。这种方式让组件和 `mapper` 函数的单元测试更简单。\n\n# 结语\n\n依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。","slug":"React开发常用设计模式-依赖注入","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne3001hkt89q8xtq97z","content":"<p>写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 <a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">依赖注入</a> 的技术 (大多数人认为它是一种模式) 用来解决这种问题。</p>\n<p>在 React 中，对依赖注入的需要是显而易见的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p>来考虑下面的应用的组件树:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Title</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;Title /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; title: 'React in patterns' &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>字符串 “React in patterns” 应该以某种方式到达 <code>Title</code> 组件。最直接的方式就从 <code>App</code> 传到 <code>Header</code>，再从 <code>Header</code> 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。</p>\n<p>已经了解过 <a href=\"http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">高阶组件</a> ，它可以用来注入数据。来使用同样的技术来注入 title 变量:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inject.jsx</span></span><br><span class=\"line\">const title = 'React in patterns';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">inject</span><span class=\"params\">(Component)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> class Injector extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; title &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import inject from './inject.jsx';</span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">var EnhancedTitle = inject(Title);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;EnhancedTitle /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>title</code>隐藏在了中间层 (高阶组件) ，在中间层将<code>title</code>属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。</p>\n<h2 id=\"使用-React-context-16-3-之前的版本\"><a href=\"#使用-React-context-16-3-之前的版本\" class=\"headerlink\" title=\"使用 React context (16.3 之前的版本)\"></a>使用 React context (16.3 之前的版本)</h2><blockquote>\n<p>在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。</p>\n</blockquote>\n<p>React 有 <code>context</code> 的概念。每个 React 组件都可以访问 <code>context</code>。它有些类似于 <a href=\"https://github.com/krasimir/EventBus\" target=\"_blank\" rel=\"noopener\">事件总线</a> ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 <code>store</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义 context 的地方</span></span><br><span class=\"line\">var context = &#123; title: 'React in patterns' &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">App.childContextTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 context 的地方</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inject</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    var title = <span class=\"keyword\">this</span>.context.title;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Inject.contextTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意，需要使用<code>childContextTypes</code>和 <code>contextTypes</code> 来指定 <code>context</code>对象的具体签名。如果不指定的话，那么 <code>context</code> 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 <code>context</code>写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dependencies.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  get(key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data[key] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，回到示例中，App 组件应该是这样的:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import dependencies from './dependencies';</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies.register('title', 'React in patterns');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dependencies;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">App.childContextTypes = &#123;</span><br><span class=\"line\">  data: React.PropTypes.object,</span><br><span class=\"line\">  get: React.PropTypes.func,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Title 组件通过 context 来获取数据:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Title</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Title.contextTypes = &#123;</span><br><span class=\"line\">  data: React.PropTypes.object,</span><br><span class=\"line\">  get: React.PropTypes.func,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>理想情况下，不想每次需要访问 <code>context</code>时都指定<code>contextTypes</code>。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用<code>this.context.get(&#39;title&#39;)</code> 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\">import wire from './wire';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default wire(Title, ['title'], function resolve(title) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; title &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>wire</code>函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 <code>mapper</code>的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。</p>\n<p><code>wire</code> 函数的代码如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">wire</span><span class=\"params\">(Component, dependencies, mapper)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inject</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      var resolved = dependencies.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.context.get.bind(<span class=\"keyword\">this</span>.context)</span><br><span class=\"line\">      );</span><br><span class=\"line\">      var props = mapper(...resolved);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> React.createElement(Component, props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Inject.contextTypes = &#123;</span><br><span class=\"line\">    data: React.PropTypes.object,</span><br><span class=\"line\">    get: React.PropTypes.func,</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Inject;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>Inject</code> 是高阶组件，它可以访问 <code>context</code>并获取 <code>dependencies</code>数组中的所有项。<code>mapper</code> 函数接收 context 数据并将其转换成我们组建所需要的属性。</p>\n<h2 id=\"使用-React-context-16-3-及之后的版本\"><a href=\"#使用-React-context-16-3-及之后的版本\" class=\"headerlink\" title=\"使用 React context (16.3 及之后的版本)\"></a>使用 React context (16.3 及之后的版本)</h2><p>Fackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。</p>\n<p>还是使用同一个示例，让字符串抵达<code>&lt;Title&gt;</code>组件。</p>\n<p>先来定义包含 <code>context</code>初始化的文件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// context.js</span></span><br><span class=\"line\">import &#123; createContext &#125; from 'react';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Context = createContext(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Provider = Context.Provider;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure></p>\n<p><code>createContext</code>返回的对象具有 <code>Provider 和 Consumer</code>属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。</p>\n<p>假设说 App 组件是根组件。在此需要传入 <code>context</code>。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Provider &#125; from './context';</span><br><span class=\"line\"></span><br><span class=\"line\">const context = &#123; title: 'React In Patterns' &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class=\"line\">        &lt;Header /&gt;</span><br><span class=\"line\">      &lt;/Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>包装组件以及子组件现在共享同一个 context 。<code>&lt;Title&gt;</code>组件是需要 title 字符串的组件之一，所以要在组件中使用 <code>&lt;Consumer&gt;</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Consumer &#125; from './context';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Consumer&gt;&#123;</span><br><span class=\"line\">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;&lt;/Consumer&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>Consumer</code>类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</p>\n<p>新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。</p>\n<h2 id=\"使用模块系统\"><a href=\"#使用模块系统\" class=\"headerlink\" title=\"使用模块系统\"></a>使用模块系统</h2><p>如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。</p>\n<p>众所周知，JavaScript 中的典型模块系统具有缓存机制。在 <a href=\"https://nodejs.org/api/modules.html#modules_caching\" target=\"_blank\" rel=\"noopener\">Node 官方文档</a> 中可以看到:</p>\n<blockquote>\n<p>模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象。<br>多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。</p>\n</blockquote>\n<p>这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 <a href=\"https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript\" target=\"_blank\" rel=\"noopener\">单例</a>，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。</p>\n<p>来创建一个新文件<code>di.jsx</code> ，它的代码如下所示:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dependencies = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> function <span class=\"title\">register</span><span class=\"params\">(key, dependency)</span> </span>&#123;</span><br><span class=\"line\">  dependencies[key] = dependency;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> function <span class=\"title\">fetch</span><span class=\"params\">(key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dependencies[key]) <span class=\"keyword\">return</span> dependencies[key];</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(`<span class=\"string\">\"$&#123; key &#125; is not registered as dependency.`);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export function wire(Component, deps, mapper) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return class Injector extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"string\">    constructor(props) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      super(props);</span></span><br><span class=\"line\"><span class=\"string\">      this._resolvedDependencies = mapper(...deps.map(fetch));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    render() &#123;</span></span><br><span class=\"line\"><span class=\"string\">      return (</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Component</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this.state&#125;</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this.props&#125;</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this._resolvedDependencies&#125;</span></span><br><span class=\"line\"><span class=\"string\">        /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      );</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>将依赖保存在了 <code>dependencies</code>这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 <code>register 和 fetch</code>这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 <code>setter 和 getter</code>。再然后是 <code>wire</code>函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 <code>mapper</code> 函数来提取所需属性。</p>\n<p>有了<code>di.jsx</code> 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\">import &#123; register &#125; from './di.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">register('my-awesome-title', 'React in patterns');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;Title /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\">import &#123; wire &#125; from './di.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">var Title = function(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title\">wire</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  Title,</span></span></span><br><span class=\"line\">  ['my-awesome-title'],</span><br><span class=\"line\">  title =&gt; (&#123; title &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>如果查看 Title.jsx 文件的话，可以看到实际的组件和 <code>wire</code> 存在于不同的文件中。这种方式让组件和 <code>mapper</code> 函数的单元测试更简单。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。</p>\n","site":{"data":{}},"excerpt":"<p>写的好多模块和组件都有依赖。能否管理这些依赖对于项目的成功至关重要。有一种叫做 <a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">依赖注入</a> 的技术 (大多数人认为它是一种模式) 用来解决这种问题。</p>\n<p>在 React 中，对依赖注入的需要是显而易见的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p>来考虑下面的应用的组件树:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Title</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;Title /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; title: 'React in patterns' &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>字符串 “React in patterns” 应该以某种方式到达 <code>Title</code> 组件。最直接的方式就从 <code>App</code> 传到 <code>Header</code>，再从 <code>Header</code> 传到 Title 。但是，对于三层组件还好，但是如果嵌套的层级很深，并且需要传多个属性呢？大多数组件都扮演着代理的角色，将属性转发给子组件。</p>\n<p>已经了解过 <a href=\"http://sangka-z.com/react-in-patterns-cn/chapter-4/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">高阶组件</a> ，它可以用来注入数据。来使用同样的技术来注入 title 变量:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inject.jsx</span></span><br><span class=\"line\">const title = 'React in patterns';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">inject</span><span class=\"params\">(Component)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> class Injector extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; title &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import inject from './inject.jsx';</span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">var EnhancedTitle = inject(Title);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;EnhancedTitle /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>title</code>隐藏在了中间层 (高阶组件) ，在中间层将<code>title</code>属性传给了原始的 Title 组件。一切都很不错，但它只解决了一半问题。现在不再需要在组件树中将 title 向下层层传递，但是需要考虑数据如何到达 inject.jsx 辅助函数。</p>\n<h2 id=\"使用-React-context-16-3-之前的版本\"><a href=\"#使用-React-context-16-3-之前的版本\" class=\"headerlink\" title=\"使用 React context (16.3 之前的版本)\"></a>使用 React context (16.3 之前的版本)</h2><blockquote>\n<p>在 React 16.3 版本中，React 团队引入了新版的 context API ，如果你想使用新版 API ，那么可以跳过此处。</p>\n</blockquote>\n<p>React 有 <code>context</code> 的概念。每个 React 组件都可以访问 <code>context</code>。它有些类似于 <a href=\"https://github.com/krasimir/EventBus\" target=\"_blank\" rel=\"noopener\">事件总线</a> ，但是为数据而生。可以把它想象成在任意地方都可以访问的单一 <code>store</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义 context 的地方</span></span><br><span class=\"line\">var context = &#123; title: 'React in patterns' &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">App.childContextTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 context 的地方</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inject</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    var title = <span class=\"keyword\">this</span>.context.title;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Inject.contextTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意，需要使用<code>childContextTypes</code>和 <code>contextTypes</code> 来指定 <code>context</code>对象的具体签名。如果不指定的话，那么 <code>context</code> 对象将为空。这点可能有点令人沮丧，因为可能会多写很多代码。所以将 <code>context</code>写成允许储存和获取数据的服务，而不是一个普通对象是一种最佳实践。例如:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dependencies.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  get(key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data[key] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，回到示例中，App 组件应该是这样的:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import dependencies from './dependencies';</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies.register('title', 'React in patterns');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dependencies;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">App.childContextTypes = &#123;</span><br><span class=\"line\">  data: React.PropTypes.object,</span><br><span class=\"line\">  get: React.PropTypes.func,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Title 组件通过 context 来获取数据:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Title</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Title.contextTypes = &#123;</span><br><span class=\"line\">  data: React.PropTypes.object,</span><br><span class=\"line\">  get: React.PropTypes.func,</span><br><span class=\"line\">  <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>理想情况下，不想每次需要访问 <code>context</code>时都指定<code>contextTypes</code>。可以使用高阶组件来包装类型细节。但更好的做法是，可以编写一个更具描述性的工具函数，从而帮助声明确切的类型。例如，不再直接使用<code>this.context.get(&#39;title&#39;)</code> 来访问 context ，而是告诉高阶组件需要传递给组件的属性。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\">import wire from './wire';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default wire(Title, ['title'], function resolve(title) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; title &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>wire</code>函数接收 React 组件、所需依赖 (依赖都已经注册过了) 的数组和我喜欢称之为 <code>mapper</code>的转换函数。mapper 函数接收存储在 context 中的原始数据，并返回组件 ( Title ) 稍后使用的属性。在本例中，传入只是字符串，即 title 变量。但是，在真正的应用中，这个依赖项可以是大型的数据集合，配置对象或其他东西。</p>\n<p><code>wire</code> 函数的代码如下所示:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">wire</span><span class=\"params\">(Component, dependencies, mapper)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inject</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      var resolved = dependencies.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.context.get.bind(<span class=\"keyword\">this</span>.context)</span><br><span class=\"line\">      );</span><br><span class=\"line\">      var props = mapper(...resolved);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> React.createElement(Component, props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Inject.contextTypes = &#123;</span><br><span class=\"line\">    data: React.PropTypes.object,</span><br><span class=\"line\">    get: React.PropTypes.func,</span><br><span class=\"line\">    <span class=\"keyword\">register</span>: React.PropTypes.func</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Inject;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>Inject</code> 是高阶组件，它可以访问 <code>context</code>并获取 <code>dependencies</code>数组中的所有项。<code>mapper</code> 函数接收 context 数据并将其转换成我们组建所需要的属性。</p>\n<h2 id=\"使用-React-context-16-3-及之后的版本\"><a href=\"#使用-React-context-16-3-及之后的版本\" class=\"headerlink\" title=\"使用 React context (16.3 及之后的版本)\"></a>使用 React context (16.3 及之后的版本)</h2><p>Fackbook 并不推荐使用 context API 。在官方文档中也有提到，此 API 不稳定，随时可能更改。确实也言中了。16.3 版本提供了一个新的 context API ，我认为新版 API 更自然，使用起来也更简单。</p>\n<p>还是使用同一个示例，让字符串抵达<code>&lt;Title&gt;</code>组件。</p>\n<p>先来定义包含 <code>context</code>初始化的文件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// context.js</span></span><br><span class=\"line\">import &#123; createContext &#125; from 'react';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Context = createContext(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Provider = Context.Provider;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure></p>\n<p><code>createContext</code>返回的对象具有 <code>Provider 和 Consumer</code>属性。它们实际上是有效的 React 类。Provicer 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。因为它们通常存在于不同的文件中，所以单独创建一个文件来进行它们的初始化是个不错的主意。</p>\n<p>假设说 App 组件是根组件。在此需要传入 <code>context</code>。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Provider &#125; from './context';</span><br><span class=\"line\"></span><br><span class=\"line\">const context = &#123; title: 'React In Patterns' &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class=\"line\">        &lt;Header /&gt;</span><br><span class=\"line\">      &lt;/Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>包装组件以及子组件现在共享同一个 context 。<code>&lt;Title&gt;</code>组件是需要 title 字符串的组件之一，所以要在组件中使用 <code>&lt;Consumer&gt;</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Consumer &#125; from './context';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Consumer&gt;&#123;</span><br><span class=\"line\">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;&lt;/Consumer&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>Consumer</code>类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</p>\n<p>新的 API 让人感觉更容易理解，同时样板文件代码更少。此 API 仍然还很新，但看起来很有前途。它开启了一系列全新的可能性。</p>\n<h2 id=\"使用模块系统\"><a href=\"#使用模块系统\" class=\"headerlink\" title=\"使用模块系统\"></a>使用模块系统</h2><p>如果不像使用 context 的话，还有一些其他方式来实现注入。它们并非 React 相关的，但是值得一提。方式之一就是使用模块系统。</p>\n<p>众所周知，JavaScript 中的典型模块系统具有缓存机制。在 <a href=\"https://nodejs.org/api/modules.html#modules_caching\" target=\"_blank\" rel=\"noopener\">Node 官方文档</a> 中可以看到:</p>\n<blockquote>\n<p>模块在第一次加载后会被缓存。这也意味着（类似其他缓存机制）如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象。<br>多次调用 require(foo) 不会导致模块的代码被执行多次。这是一个重要的特性。借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。</p>\n</blockquote>\n<p>这对依赖注入有什么帮助吗？当然，如果导出一个对象，实际上导出的是一个 <a href=\"https:/addyosmani.com/resources/essentialjsdesignpatterns/book#singletonpatternjavascript\" target=\"_blank\" rel=\"noopener\">单例</a>，并且每个导入该文件的其他模块都将获得同一个对象。这使得可以 register 依赖，并稍后在另一个文件中 fetch 它们。</p>\n<p>来创建一个新文件<code>di.jsx</code> ，它的代码如下所示:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dependencies = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> function <span class=\"title\">register</span><span class=\"params\">(key, dependency)</span> </span>&#123;</span><br><span class=\"line\">  dependencies[key] = dependency;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> function <span class=\"title\">fetch</span><span class=\"params\">(key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dependencies[key]) <span class=\"keyword\">return</span> dependencies[key];</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(`<span class=\"string\">\"$&#123; key &#125; is not registered as dependency.`);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export function wire(Component, deps, mapper) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return class Injector extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"string\">    constructor(props) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      super(props);</span></span><br><span class=\"line\"><span class=\"string\">      this._resolvedDependencies = mapper(...deps.map(fetch));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    render() &#123;</span></span><br><span class=\"line\"><span class=\"string\">      return (</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Component</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this.state&#125;</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this.props&#125;</span></span><br><span class=\"line\"><span class=\"string\">          &#123;...this._resolvedDependencies&#125;</span></span><br><span class=\"line\"><span class=\"string\">        /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      );</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>将依赖保存在了 <code>dependencies</code>这个全局变量中 (对于模块它是全局的，但对于整个应用来是并不是) 。然后，导出 <code>register 和 fetch</code>这两个函数，它们负责读写依赖关系的数据。它看起来有点像对简单的 JavaScript 对象实现的 <code>setter 和 getter</code>。再然后是 <code>wire</code>函数，它接收 React 组件并返回 高阶组件 。在组件的构造函数中，解析了依赖，并在稍后渲染原始组件时将其作为属性传给组件。按照相同的模式来描述需要的东西 (deps 参数)，并使用 <code>mapper</code> 函数来提取所需属性。</p>\n<p>有了<code>di.jsx</code> 辅助函数，我们又能够在应用的入口点 ( app.jsx ) 注册依赖，并且在任意组件 ( Title.jsx ) 中进行注入。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\">import &#123; register &#125; from './di.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">register('my-awesome-title', 'React in patterns');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Title from './Title.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;Title /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// Title.jsx</span></span><br><span class=\"line\">import &#123; wire &#125; from './di.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\">var Title = function(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title\">wire</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  Title,</span></span></span><br><span class=\"line\">  ['my-awesome-title'],</span><br><span class=\"line\">  title =&gt; (&#123; title &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>如果查看 Title.jsx 文件的话，可以看到实际的组件和 <code>wire</code> 存在于不同的文件中。这种方式让组件和 <code>mapper</code> 函数的单元测试更简单。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>依赖注入是一个大问题，尤其是在 JavaScript 中。许多人并没有意识到，但是，正确的依赖管理是每个开发周期中的关键过程。JavaScript 生态提供了不同的工具，作为开发者的我们应该挑选最适合自己的工具。</p>"},{"title":"React开发常用设计模式-单向数据流","date":"2018-05-16T14:57:28.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 单向数据流\n\n假设说有一个简单的 `Switcher` 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。\n```h\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { flag: false };\n    this._onButtonClick = e => this.setState({\n      flag: !this.state.flag\n    });\n  }\n  render() {\n    return (\n      <button onClick={ this._onButtonClick }>\n        { this.state.flag ? 'lights on' : 'lights off' }\n      </button>\n    );\n  }\n};\n\n// ... 渲染组件\nfunction App() {\n  return <Switcher />;\n};\n```\n此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 `Switcher` 组件。我们来将` flag` 提取到 `store` 中:\n```h\nvar Store = {\n  _flag: false,\n  set: function(value) {\n    this._flag = value;\n  },\n  get: function() {\n    return this._flag;\n  }\n};\n\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { flag: false };\n    this._onButtonClick = e => {\n      this.setState({ flag: !this.state.flag }, () => {\n        this.props.onChange(this.state.flag);\n      });\n    }\n  }\n  render() {\n    return (\n      <button onClick={ this._onButtonClick }>\n        { this.state.flag ? 'lights on' : 'lights off' }\n      </button>\n    );\n  }\n};\n\nfunction App() {\n  return <Switcher onChange={ Store.set.bind(Store) } />;\n};\n```\n`Store` 对象是一个 单例，它提供辅助函数 ( `getter` 和 `setter` ) 来读取/设置 `_flag` 属性。通过将 `setter` 传给` Switcher` 组件，我们能够更新外部数据。目前应用的工作流程大致如下:\n\n\n![单向数据流](React开发常用设计模式-单向数据流/react_store.jpg)\n\n假设我们可以通过 `Store` 将 `flag` 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 `flag` 为 `true` ，那么我们应该显示 \"lights on\"，而不是默认值 \"lights off\" 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 `Store` 中都有自身的状态。我们需要进行双向通讯，`Store `到组件和组件到` Store` 。\n```h\n// ... 在 App 组件中\n<Switcher\n  value={ Store.get() }\n  onChange={ Store.set.bind(Store) } />\n\n// ... 在 Switcher 组件中\nconstructor(props) {\n  super(props);\n  this.state = { flag: this.props.value };\n  ...\n  ```\n  工作流程改变后如下所示:\n  \n  ![单向数据流](React开发常用设计模式-单向数据流/react_store1.jpg)\n  \n  以上这些导致了需要在两处管理状态。如果 `Store` 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给` Switcher` 组件，这样就会增加应用的复杂度。\n\n单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 `store`) 进行状态管理。要实现单向数据流的话，我们需要改造一下 `Store` 对象。我们需要允许我们订阅数据变化的逻辑：\n```h\nvar Store = {\n  _handlers: [],\n  _flag: '',\n  subscribe: function(handler) {\n    this._handlers.push(handler);\n  },\n  set: function(value) {\n    this._flag = value;\n    this._handlers.forEach(handler => handler(value))\n  },\n  get: function() {\n    return this._flag;\n  }\n};\n```\n然后我们将其与 `App` 组件联系起来，每次 `Store` 中的值产生变化时，都将重新渲染组件:\n```h\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { value: Store.get() };\n    Store.subscribe(value => this.setState({ value }));\n  }\n  render() {\n    return (\n      <div>\n        <Switcher\n          value={ this.state.value }\n          onChange={ Store.set.bind(Store) } />\n      </div>\n    );\n  }\n};\n```\n做出改变后，`Switcher` 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。\n```h\nfunction Switcher({ value, onChange }) {\n  return (\n    <button onClick={ e => onChange(!value) }>\n      { value ? 'lights on' : 'lights off' }\n    </button>\n  );\n};\n\n<Switcher\n  value={ Store.get() }\n  onChange={ Store.set.bind(Store) } />\n```\n\n# 结语\n这种模式的好处是组件只负责展示 `store` 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。","source":"_posts/React开发常用设计模式-单向数据流.md","raw":"---\ntitle: React开发常用设计模式-单向数据流\ndate: 2018-05-16 22:57:28\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n\n\n单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 单向数据流\n\n假设说有一个简单的 `Switcher` 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。\n```h\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { flag: false };\n    this._onButtonClick = e => this.setState({\n      flag: !this.state.flag\n    });\n  }\n  render() {\n    return (\n      <button onClick={ this._onButtonClick }>\n        { this.state.flag ? 'lights on' : 'lights off' }\n      </button>\n    );\n  }\n};\n\n// ... 渲染组件\nfunction App() {\n  return <Switcher />;\n};\n```\n此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 `Switcher` 组件。我们来将` flag` 提取到 `store` 中:\n```h\nvar Store = {\n  _flag: false,\n  set: function(value) {\n    this._flag = value;\n  },\n  get: function() {\n    return this._flag;\n  }\n};\n\nclass Switcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { flag: false };\n    this._onButtonClick = e => {\n      this.setState({ flag: !this.state.flag }, () => {\n        this.props.onChange(this.state.flag);\n      });\n    }\n  }\n  render() {\n    return (\n      <button onClick={ this._onButtonClick }>\n        { this.state.flag ? 'lights on' : 'lights off' }\n      </button>\n    );\n  }\n};\n\nfunction App() {\n  return <Switcher onChange={ Store.set.bind(Store) } />;\n};\n```\n`Store` 对象是一个 单例，它提供辅助函数 ( `getter` 和 `setter` ) 来读取/设置 `_flag` 属性。通过将 `setter` 传给` Switcher` 组件，我们能够更新外部数据。目前应用的工作流程大致如下:\n\n\n![单向数据流](React开发常用设计模式-单向数据流/react_store.jpg)\n\n假设我们可以通过 `Store` 将 `flag` 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 `flag` 为 `true` ，那么我们应该显示 \"lights on\"，而不是默认值 \"lights off\" 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 `Store` 中都有自身的状态。我们需要进行双向通讯，`Store `到组件和组件到` Store` 。\n```h\n// ... 在 App 组件中\n<Switcher\n  value={ Store.get() }\n  onChange={ Store.set.bind(Store) } />\n\n// ... 在 Switcher 组件中\nconstructor(props) {\n  super(props);\n  this.state = { flag: this.props.value };\n  ...\n  ```\n  工作流程改变后如下所示:\n  \n  ![单向数据流](React开发常用设计模式-单向数据流/react_store1.jpg)\n  \n  以上这些导致了需要在两处管理状态。如果 `Store` 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给` Switcher` 组件，这样就会增加应用的复杂度。\n\n单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 `store`) 进行状态管理。要实现单向数据流的话，我们需要改造一下 `Store` 对象。我们需要允许我们订阅数据变化的逻辑：\n```h\nvar Store = {\n  _handlers: [],\n  _flag: '',\n  subscribe: function(handler) {\n    this._handlers.push(handler);\n  },\n  set: function(value) {\n    this._flag = value;\n    this._handlers.forEach(handler => handler(value))\n  },\n  get: function() {\n    return this._flag;\n  }\n};\n```\n然后我们将其与 `App` 组件联系起来，每次 `Store` 中的值产生变化时，都将重新渲染组件:\n```h\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { value: Store.get() };\n    Store.subscribe(value => this.setState({ value }));\n  }\n  render() {\n    return (\n      <div>\n        <Switcher\n          value={ this.state.value }\n          onChange={ Store.set.bind(Store) } />\n      </div>\n    );\n  }\n};\n```\n做出改变后，`Switcher` 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。\n```h\nfunction Switcher({ value, onChange }) {\n  return (\n    <button onClick={ e => onChange(!value) }>\n      { value ? 'lights on' : 'lights off' }\n    </button>\n  );\n};\n\n<Switcher\n  value={ Store.get() }\n  onChange={ Store.set.bind(Store) } />\n```\n\n# 结语\n这种模式的好处是组件只负责展示 `store` 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。","slug":"React开发常用设计模式-单向数据流","published":1,"updated":"2018-09-18T12:23:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne4001jkt8986vjcr98","content":"<p>单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h1><p>假设说有一个简单的 <code>Switcher</code> 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onButtonClick = e =&gt; <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      flag: !<span class=\"keyword\">this</span>.state.flag</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._onButtonClick &#125;&gt;</span><br><span class=\"line\">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 渲染组件</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Switcher /&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 <code>Switcher</code> 组件。我们来将<code>flag</code> 提取到 <code>store</code> 中:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Store = &#123;</span><br><span class=\"line\">  _flag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"built_in\">set</span>: function(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._flag = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onButtonClick = e =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; flag: !<span class=\"keyword\">this</span>.state.flag &#125;, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.onChange(<span class=\"keyword\">this</span>.state.flag);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._onButtonClick &#125;&gt;</span><br><span class=\"line\">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Switcher onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>Store</code> 对象是一个 单例，它提供辅助函数 ( <code>getter</code> 和 <code>setter</code> ) 来读取/设置 <code>_flag</code> 属性。通过将 <code>setter</code> 传给<code>Switcher</code> 组件，我们能够更新外部数据。目前应用的工作流程大致如下:</p>\n<p><img src=\"/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store.jpg\" alt=\"单向数据流\"></p>\n<p>假设我们可以通过 <code>Store</code> 将 <code>flag</code> 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 <code>flag</code> 为 <code>true</code> ，那么我们应该显示 “lights on”，而不是默认值 “lights off” 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 <code>Store</code> 中都有自身的状态。我们需要进行双向通讯，<code>Store</code>到组件和组件到<code>Store</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ... 在 App 组件中</span></span><br><span class=\"line\">&lt;Switcher</span><br><span class=\"line\">  value=&#123; Store.get() &#125;</span><br><span class=\"line\">  onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 在 Switcher 组件中</span></span><br><span class=\"line\">constructor(props) &#123;</span><br><span class=\"line\">  super(props);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"keyword\">this</span>.props.value &#125;;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>  工作流程改变后如下所示:</p>\n<p>  <img src=\"/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store1.jpg\" alt=\"单向数据流\"></p>\n<p>  以上这些导致了需要在两处管理状态。如果 <code>Store</code> 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给<code>Switcher</code> 组件，这样就会增加应用的复杂度。</p>\n<p>单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 <code>store</code>) 进行状态管理。要实现单向数据流的话，我们需要改造一下 <code>Store</code> 对象。我们需要允许我们订阅数据变化的逻辑：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Store = &#123;</span><br><span class=\"line\">  _handlers: [],</span><br><span class=\"line\">  _flag: '',</span><br><span class=\"line\">  subscribe: function(handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._handlers.push(handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">set</span>: function(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._flag = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._handlers.forEach(handler =&gt; handler(value))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们将其与 <code>App</code> 组件联系起来，每次 <code>Store</code> 中的值产生变化时，都将重新渲染组件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; value: Store.get() &#125;;</span><br><span class=\"line\">    Store.subscribe(value =&gt; <span class=\"keyword\">this</span>.setState(&#123; value &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Switcher</span><br><span class=\"line\">          value=&#123; <span class=\"keyword\">this</span>.state.value &#125;</span><br><span class=\"line\">          onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>做出改变后，<code>Switcher</code> 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Switcher</span><span class=\"params\">(&#123; value, onChange &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt;</span><br><span class=\"line\">      &#123; value ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">    &lt;/button&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Switcher</span><br><span class=\"line\">  value=&#123; Store.get() &#125;</span><br><span class=\"line\">  onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>这种模式的好处是组件只负责展示 <code>store</code> 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。</p>\n","site":{"data":{}},"excerpt":"<p>单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h1><p>假设说有一个简单的 <code>Switcher</code> 组件，它包含一个按钮。当点击按钮时，我们需要在组件中使用一个标识来保存组件的开关状态。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onButtonClick = e =&gt; <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      flag: !<span class=\"keyword\">this</span>.state.flag</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._onButtonClick &#125;&gt;</span><br><span class=\"line\">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 渲染组件</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Switcher /&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此时，我们将数据保存在了组件内部。或者换句话说，知道 flag 存在的只有 <code>Switcher</code> 组件。我们来将<code>flag</code> 提取到 <code>store</code> 中:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Store = &#123;</span><br><span class=\"line\">  _flag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"built_in\">set</span>: function(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._flag = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Switcher</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._onButtonClick = e =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; flag: !<span class=\"keyword\">this</span>.state.flag &#125;, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.onChange(<span class=\"keyword\">this</span>.state.flag);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123; <span class=\"keyword\">this</span>._onButtonClick &#125;&gt;</span><br><span class=\"line\">        &#123; this.state.flag ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Switcher onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>Store</code> 对象是一个 单例，它提供辅助函数 ( <code>getter</code> 和 <code>setter</code> ) 来读取/设置 <code>_flag</code> 属性。通过将 <code>setter</code> 传给<code>Switcher</code> 组件，我们能够更新外部数据。目前应用的工作流程大致如下:</p>\n<p><img src=\"/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store.jpg\" alt=\"单向数据流\"></p>\n<p>假设我们可以通过 <code>Store</code> 将 <code>flag</code> 值保存至服务端。当用户再使用时我们可以为其提供一个适当的初始值。如果用户上次离开时 <code>flag</code> 为 <code>true</code> ，那么我们应该显示 “lights on”，而不是默认值 “lights off” 。现在变得有一些麻烦，因为数据存在于两个地方。UI 和 <code>Store</code> 中都有自身的状态。我们需要进行双向通讯，<code>Store</code>到组件和组件到<code>Store</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ... 在 App 组件中</span></span><br><span class=\"line\">&lt;Switcher</span><br><span class=\"line\">  value=&#123; Store.get() &#125;</span><br><span class=\"line\">  onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 在 Switcher 组件中</span></span><br><span class=\"line\">constructor(props) &#123;</span><br><span class=\"line\">  super(props);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123; flag: <span class=\"keyword\">this</span>.props.value &#125;;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>  工作流程改变后如下所示:</p>\n<p>  <img src=\"/blog/2018/05/16/React开发常用设计模式-单向数据流/react_store1.jpg\" alt=\"单向数据流\"></p>\n<p>  以上这些导致了需要在两处管理状态。如果 <code>Store</code> 可以再根据系统中的其他操作更改其值，将演变成怎样一种情况？我们必须将这种变化传播给<code>Switcher</code> 组件，这样就会增加应用的复杂度。</p>\n<p>单向数据流正是用来解决此类问题。它消除了在多个地方同时管理状态的情况，它只会在一个地方 (通常就是 <code>store</code>) 进行状态管理。要实现单向数据流的话，我们需要改造一下 <code>Store</code> 对象。我们需要允许我们订阅数据变化的逻辑：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Store = &#123;</span><br><span class=\"line\">  _handlers: [],</span><br><span class=\"line\">  _flag: '',</span><br><span class=\"line\">  subscribe: function(handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._handlers.push(handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">set</span>: function(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._flag = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._handlers.forEach(handler =&gt; handler(value))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们将其与 <code>App</code> 组件联系起来，每次 <code>Store</code> 中的值产生变化时，都将重新渲染组件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; value: Store.get() &#125;;</span><br><span class=\"line\">    Store.subscribe(value =&gt; <span class=\"keyword\">this</span>.setState(&#123; value &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Switcher</span><br><span class=\"line\">          value=&#123; <span class=\"keyword\">this</span>.state.value &#125;</span><br><span class=\"line\">          onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>做出改变后，<code>Switcher</code> 将变得相当简单。我们不需要内部状态，所以组件可以使用无状态函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Switcher</span><span class=\"params\">(&#123; value, onChange &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt;</span><br><span class=\"line\">      &#123; value ? 'lights on' : 'lights off' &#125;</span><br><span class=\"line\">    &lt;/button&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Switcher</span><br><span class=\"line\">  value=&#123; Store.get() &#125;</span><br><span class=\"line\">  onChange=&#123; Store.<span class=\"built_in\">set</span>.bind(Store) &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>这种模式的好处是组件只负责展示 <code>store</code> 的数据即可。而唯一的数据源将使得开发更加简单。如果只能从中掌握一个知识点的话，会选这一章节。单向数据流彻底地改变了我设计功能时的思维方式，所以相信对你也同样有效。</p>"},{"title":"React开发常用设计模式-受控输入和非受控输入","date":"2018-05-14T16:19:01.000Z","description":null,"copyright":true,"top":null,"_content":"在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 受控输入和非受控输入\n在 React 表单管理中有两个经常使用的术语: `受控输入`和`非受控输入`。\n* 受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个` <input>` 字段，它就是受控的:\n ```\n class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' value={ this.state.value } />;\n  }\n};\n```\n上面代码的结果是我们可以操作` input` 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让` input `正常工作的话，需要为其添加` onChange` 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 `input `中输入的文字。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        value={ this.state.value }\n        onChange={ this._change } />\n    );\n  }\n  _handleInputChange(e) {\n    this.setState({ value: e.target.value });\n  }\n};\n```\n与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 `defaultValue` 属性来提供初始值，此后浏览器将负责保存输入的状态。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' defaultValue={ this.state.value } />\n  }\n};\n```\n上面的 `<input> `元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用[ Refs](Refs) 来获取 DOM 元素的实际引用。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        defaultValue={ this.state.value }\n        onChange={ this._change }\n        ref={ input => this.input = input }/>\n    );\n  }\n  _handleInputChange() {\n    this.setState({ value: this.input.value });\n  }\n};\n```\n`ref `属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量` input `中。之后当 `onChange `事件触发时，我们将 `input` 中的最新值保存到 `App` 组件的状态里。\n\n大量使用` refs` 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。\n\n# 结语\n使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。","source":"_posts/React开发常用设计模式-受控输入和非受控输入.md","raw":"---\ntitle: React开发常用设计模式-受控输入和非受控输入\ndate: 2018-05-15 00:19:01\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 受控输入和非受控输入\n在 React 表单管理中有两个经常使用的术语: `受控输入`和`非受控输入`。\n* 受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个` <input>` 字段，它就是受控的:\n ```\n class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' value={ this.state.value } />;\n  }\n};\n```\n上面代码的结果是我们可以操作` input` 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让` input `正常工作的话，需要为其添加` onChange` 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 `input `中输入的文字。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        value={ this.state.value }\n        onChange={ this._change } />\n    );\n  }\n  _handleInputChange(e) {\n    this.setState({ value: e.target.value });\n  }\n};\n```\n与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 `defaultValue` 属性来提供初始值，此后浏览器将负责保存输入的状态。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' defaultValue={ this.state.value } />\n  }\n};\n```\n上面的 `<input> `元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用[ Refs](Refs) 来获取 DOM 元素的实际引用。\n```\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        defaultValue={ this.state.value }\n        onChange={ this._change }\n        ref={ input => this.input = input }/>\n    );\n  }\n  _handleInputChange() {\n    this.setState({ value: this.input.value });\n  }\n};\n```\n`ref `属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量` input `中。之后当 `onChange `事件触发时，我们将 `input` 中的最新值保存到 `App` 组件的状态里。\n\n大量使用` refs` 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。\n\n# 结语\n使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。","slug":"React开发常用设计模式-受控输入和非受控输入","published":1,"updated":"2018-09-18T12:23:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne6001nkt89sfnsf6ea","content":"<p>在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"受控输入和非受控输入\"><a href=\"#受控输入和非受控输入\" class=\"headerlink\" title=\"受控输入和非受控输入\"></a>受控输入和非受控输入</h1><p>在 React 表单管理中有两个经常使用的术语: <code>受控输入</code>和<code>非受控输入</code>。</p>\n<ul>\n<li>受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个<code>&lt;input&gt;</code> 字段，它就是受控的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码的结果是我们可以操作<code>input</code> 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让<code>input</code>正常工作的话，需要为其添加<code>onChange</code> 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 <code>input</code>中输入的文字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">    this._change = this._handleInputChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&apos;text&apos;</span><br><span class=\"line\">        value=&#123; this.state.value &#125;</span><br><span class=\"line\">        onChange=&#123; this._change &#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleInputChange(e) &#123;</span><br><span class=\"line\">    this.setState(&#123; value: e.target.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 <code>defaultValue</code> 属性来提供初始值，此后浏览器将负责保存输入的状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面的 <code>&lt;input&gt;</code>元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用<a href=\"Refs\"> Refs</a> 来获取 DOM 元素的实际引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">    this._change = this._handleInputChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&apos;text&apos;</span><br><span class=\"line\">        defaultValue=&#123; this.state.value &#125;</span><br><span class=\"line\">        onChange=&#123; this._change &#125;</span><br><span class=\"line\">        ref=&#123; input =&gt; this.input = input &#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleInputChange() &#123;</span><br><span class=\"line\">    this.setState(&#123; value: this.input.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>ref</code>属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量<code>input</code>中。之后当 <code>onChange</code>事件触发时，我们将 <code>input</code> 中的最新值保存到 <code>App</code> 组件的状态里。</p>\n<p>大量使用<code>refs</code> 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>\n","site":{"data":{}},"excerpt":"<p>在 React 表单管理中有两个经常使用的术语:受控输入和非受控输入。受控输入是指输入值的来源是单一的。与之相反的是非受控输入，它让浏览器来处理用户的输入。使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"受控输入和非受控输入\"><a href=\"#受控输入和非受控输入\" class=\"headerlink\" title=\"受控输入和非受控输入\"></a>受控输入和非受控输入</h1><p>在 React 表单管理中有两个经常使用的术语: <code>受控输入</code>和<code>非受控输入</code>。</p>\n<ul>\n<li>受控输入是指输入值的来源是单一的。例如，下面的 App 组件有一个<code>&lt;input&gt;</code> 字段，它就是受控的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;input type=&apos;text&apos; value=&#123; this.state.value &#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码的结果是我们可以操作<code>input</code> 元素，但是无法改变它的值。它永远都不会更新，因为我们使用的是单一数据源: App 组件的状态。要想让<code>input</code>正常工作的话，需要为其添加<code>onChange</code> 处理方法来更新状态 (单一数据源)。onChange 会触发新的渲染周期，所以能看到在 <code>input</code>中输入的文字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">    this._change = this._handleInputChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&apos;text&apos;</span><br><span class=\"line\">        value=&#123; this.state.value &#125;</span><br><span class=\"line\">        onChange=&#123; this._change &#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleInputChange(e) &#123;</span><br><span class=\"line\">    this.setState(&#123; value: e.target.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>与之相反的是非受控输入，它让浏览器来处理用户的输入。我们还可以通过使用 <code>defaultValue</code> 属性来提供初始值，此后浏览器将负责保存输入的状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;input type=&apos;text&apos; defaultValue=&#123; this.state.value &#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面的 <code>&lt;input&gt;</code>元素其实没什么用，因为我们的组件并不知道用户更新的值。我们需要使用<a href=\"Refs\"> Refs</a> 来获取 DOM 元素的实际引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; value: &apos;hello&apos; &#125;;</span><br><span class=\"line\">    this._change = this._handleInputChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&apos;text&apos;</span><br><span class=\"line\">        defaultValue=&#123; this.state.value &#125;</span><br><span class=\"line\">        onChange=&#123; this._change &#125;</span><br><span class=\"line\">        ref=&#123; input =&gt; this.input = input &#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _handleInputChange() &#123;</span><br><span class=\"line\">    this.setState(&#123; value: this.input.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>ref</code>属性接收字符串或回调函数。上面的代码使用回调函数来将 DOM 元素保存在局部变量<code>input</code>中。之后当 <code>onChange</code>事件触发时，我们将 <code>input</code> 中的最新值保存到 <code>App</code> 组件的状态里。</p>\n<p>大量使用<code>refs</code> 并非是个好主意。如果你的应用中出现了这种情况的话，那么你需要考虑使用受控输入并重新审视组件。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>使用受控输入还是非受控输入，这个选择常常不被人所重视。但我相信这是一个最基本的决策，因为它决定了 React 组件的数据流。我个人认为非受控输入更像是一种反模式，应该尽量避免使用。</p>"},{"title":"React开发常用设计模式-展示型组件和容器型组件","date":"2018-05-15T15:34:58.000Z","description":null,"copyright":true,"top":null,"_content":"万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 展示型组件和容器型组件\n万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为`展示型组件`和`容器型组件`。\n\n我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 `Clock` 组件，它接收 [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象作为属性并显示实时时间。\n```h\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { time: this.props.time };\n    this._update = this._updateTime.bind(this);\n  }\n  render() {\n    const time = this._formatTime(this.state.time);\n    return (\n      <h1>\n        { time.hours } : { time.minutes } : { time.seconds }\n      </h1>\n    );\n  }\n  componentDidMount() {\n    this._interval = setInterval(this._update, 1000);\n  }\n  componentWillUnmount() {\n    clearInterval(this._interval);\n  }\n  _formatTime(time) {\n    var [ hours, minutes, seconds ] = [\n      time.getHours(),\n      time.getMinutes(),\n      time.getSeconds()\n    ].map(num => num < 10 ? '0' + num : num);\n\n    return { hours, minutes, seconds };\n  }\n  _updateTime() {\n    this.setState({\n      time: new Date(this.state.time.getTime() + 1000)\n    });\n  }\n};\n\nReactDOM.render(<Clock time={ new Date() }/>, ...);\n\n```\n在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 `setInterval` ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: `_formatTime` 和` _updateTime` 。`_formatTime` 用来提取时分秒并确保它们是两位数的形式。`_updateTime` 用来将` time` 对象设置为当前时间加一秒。\n\n# 问题\n这个组件中它做了好几件事，似乎承担了太多的职责。\n\n* 它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。\n* `_formatTime` 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。\n\n# 提取出容器型组件\n容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 [高阶组件](https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components) 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。\n\n下面是 `ClockContainer` 的代码:\n```h\n// Clock/index.js\nimport Clock from './Clock.jsx'; // <-- 展示型组件\n\nexport default class ClockContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { time: props.time };\n    this._update = this._updateTime.bind(this);\n  }\n  render() {\n    return <Clock { ...this._extract(this.state.time) }/>;\n  }\n  componentDidMount() {\n    this._interval = setInterval(this._update, 1000);\n  }\n  componentWillUnmount() {\n    clearInterval(this._interval);\n  }\n  _extract(time) {\n    return {\n      hours: time.getHours(),\n      minutes: time.getMinutes(),\n      seconds: time.getSeconds()\n    };\n  }\n  _updateTime() {\n    this.setState({\n      time: new Date(this.state.time.getTime() + 1000)\n    });\n  }\n};\n```\n它接收 `time` (date 对象) 属性，使用` setInterval` 循环并了解数据 (`getHours`、`getMinutes` 和 `getSeconds`) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。\n\n# 展示型组件\n展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 [无状态组件](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)，它们没有内部状态。\n\n在本示例中，展示型组件只包含两位数的检查并返回 `<h1>` 标签:\n```h\n// Clock/Clock.jsx\nexport default function Clock(props) {\n  var [ hours, minutes, seconds ] = [\n    props.hours,\n    props.minutes,\n    props.seconds\n  ].map(num => num < 10 ? '0' + num : num);\n\n  return <h1>{ hours } : { minutes } : { seconds }</h1>;\n};\n```\n# 优点\n将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。\n\n容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 `render` 方法中的 ·<Clock>· 组件。\n\n测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。\n\n# 结语\n\n容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。\n\n\n\n\n\n\n","source":"_posts/React开发常用设计模式-展示型组件和容器型组件.md","raw":"---\ntitle: React开发常用设计模式-展示型组件和容器型组件\ndate: 2018-05-15 23:34:58\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 展示型组件和容器型组件\n万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为`展示型组件`和`容器型组件`。\n\n我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 `Clock` 组件，它接收 [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象作为属性并显示实时时间。\n```h\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { time: this.props.time };\n    this._update = this._updateTime.bind(this);\n  }\n  render() {\n    const time = this._formatTime(this.state.time);\n    return (\n      <h1>\n        { time.hours } : { time.minutes } : { time.seconds }\n      </h1>\n    );\n  }\n  componentDidMount() {\n    this._interval = setInterval(this._update, 1000);\n  }\n  componentWillUnmount() {\n    clearInterval(this._interval);\n  }\n  _formatTime(time) {\n    var [ hours, minutes, seconds ] = [\n      time.getHours(),\n      time.getMinutes(),\n      time.getSeconds()\n    ].map(num => num < 10 ? '0' + num : num);\n\n    return { hours, minutes, seconds };\n  }\n  _updateTime() {\n    this.setState({\n      time: new Date(this.state.time.getTime() + 1000)\n    });\n  }\n};\n\nReactDOM.render(<Clock time={ new Date() }/>, ...);\n\n```\n在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 `setInterval` ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: `_formatTime` 和` _updateTime` 。`_formatTime` 用来提取时分秒并确保它们是两位数的形式。`_updateTime` 用来将` time` 对象设置为当前时间加一秒。\n\n# 问题\n这个组件中它做了好几件事，似乎承担了太多的职责。\n\n* 它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。\n* `_formatTime` 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。\n\n# 提取出容器型组件\n容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 [高阶组件](https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components) 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。\n\n下面是 `ClockContainer` 的代码:\n```h\n// Clock/index.js\nimport Clock from './Clock.jsx'; // <-- 展示型组件\n\nexport default class ClockContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { time: props.time };\n    this._update = this._updateTime.bind(this);\n  }\n  render() {\n    return <Clock { ...this._extract(this.state.time) }/>;\n  }\n  componentDidMount() {\n    this._interval = setInterval(this._update, 1000);\n  }\n  componentWillUnmount() {\n    clearInterval(this._interval);\n  }\n  _extract(time) {\n    return {\n      hours: time.getHours(),\n      minutes: time.getMinutes(),\n      seconds: time.getSeconds()\n    };\n  }\n  _updateTime() {\n    this.setState({\n      time: new Date(this.state.time.getTime() + 1000)\n    });\n  }\n};\n```\n它接收 `time` (date 对象) 属性，使用` setInterval` 循环并了解数据 (`getHours`、`getMinutes` 和 `getSeconds`) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。\n\n# 展示型组件\n展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 [无状态组件](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)，它们没有内部状态。\n\n在本示例中，展示型组件只包含两位数的检查并返回 `<h1>` 标签:\n```h\n// Clock/Clock.jsx\nexport default function Clock(props) {\n  var [ hours, minutes, seconds ] = [\n    props.hours,\n    props.minutes,\n    props.seconds\n  ].map(num => num < 10 ? '0' + num : num);\n\n  return <h1>{ hours } : { minutes } : { seconds }</h1>;\n};\n```\n# 优点\n将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。\n\n容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 `render` 方法中的 ·<Clock>· 组件。\n\n测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。\n\n# 结语\n\n容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。\n\n\n\n\n\n\n","slug":"React开发常用设计模式-展示型组件和容器型组件","published":1,"updated":"2018-09-18T12:23:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctne8001qkt89p6z04gbm","content":"<p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"展示型组件和容器型组件\"><a href=\"#展示型组件和容器型组件\" class=\"headerlink\" title=\"展示型组件和容器型组件\"></a>展示型组件和容器型组件</h1><p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为<code>展示型组件</code>和<code>容器型组件</code>。</p>\n<p>我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 <code>Clock</code> 组件，它接收 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\" rel=\"noopener\">Date</a> 对象作为属性并显示实时时间。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; time: <span class=\"keyword\">this</span>.props.time &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._update = <span class=\"keyword\">this</span>._updateTime.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time = <span class=\"keyword\">this</span>._formatTime(<span class=\"keyword\">this</span>.state.time);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;</span><br><span class=\"line\">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span><br><span class=\"line\">      &lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._interval = setInterval(<span class=\"keyword\">this</span>._update, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    clearInterval(<span class=\"keyword\">this</span>._interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _formatTime(time) &#123;</span><br><span class=\"line\">    var [ hours, minutes, seconds ] = [</span><br><span class=\"line\">      time.getHours(),</span><br><span class=\"line\">      time.getMinutes(),</span><br><span class=\"line\">      time.getSeconds()</span><br><span class=\"line\">    ].<span class=\"built_in\">map</span>(num =&gt; num &lt; <span class=\"number\">10</span> ? <span class=\"string\">'0'</span> + num : num);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; hours, minutes, seconds &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _updateTime() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">this</span>.state.time.getTime() + <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;Clock time=&#123; <span class=\"keyword\">new</span> Date() &#125;/&gt;, ...);</span><br></pre></td></tr></table></figure></p>\n<p>在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 <code>setInterval</code> ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: <code>_formatTime</code> 和<code>_updateTime</code> 。<code>_formatTime</code> 用来提取时分秒并确保它们是两位数的形式。<code>_updateTime</code> 用来将<code>time</code> 对象设置为当前时间加一秒。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>这个组件中它做了好几件事，似乎承担了太多的职责。</p>\n<ul>\n<li>它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。</li>\n<li><code>_formatTime</code> 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。</li>\n</ul>\n<h1 id=\"提取出容器型组件\"><a href=\"#提取出容器型组件\" class=\"headerlink\" title=\"提取出容器型组件\"></a>提取出容器型组件</h1><p>容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 <a href=\"https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components\" target=\"_blank\" rel=\"noopener\">高阶组件</a> 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。</p>\n<p>下面是 <code>ClockContainer</code> 的代码:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clock/index.js</span></span><br><span class=\"line\">import Clock from './Clock.jsx'; // &lt;-- 展示型组件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClockContainer</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; time: props.time &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._update = <span class=\"keyword\">this</span>._updateTime.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Clock &#123; ...<span class=\"keyword\">this</span>._extract(<span class=\"keyword\">this</span>.state.time) &#125;/&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._interval = setInterval(<span class=\"keyword\">this</span>._update, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    clearInterval(<span class=\"keyword\">this</span>._interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _extract(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      hours: time.getHours(),</span><br><span class=\"line\">      minutes: time.getMinutes(),</span><br><span class=\"line\">      seconds: time.getSeconds()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _updateTime() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">this</span>.state.time.getTime() + <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>它接收 <code>time</code> (date 对象) 属性，使用<code>setInterval</code> 循环并了解数据 (<code>getHours</code>、<code>getMinutes</code> 和 <code>getSeconds</code>) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。</p>\n<h1 id=\"展示型组件\"><a href=\"#展示型组件\" class=\"headerlink\" title=\"展示型组件\"></a>展示型组件</h1><p>展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 <a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态组件</a>，它们没有内部状态。</p>\n<p>在本示例中，展示型组件只包含两位数的检查并返回 <code>&lt;h1&gt;</code> 标签:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clock/Clock.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Clock</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  var [ hours, minutes, seconds ] = [</span><br><span class=\"line\">    props.hours,</span><br><span class=\"line\">    props.minutes,</span><br><span class=\"line\">    props.seconds</span><br><span class=\"line\">  ].<span class=\"built_in\">map</span>(num =&gt; num &lt; <span class=\"number\">10</span> ? <span class=\"string\">'0'</span> + num : num);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。</p>\n<p>容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 <code>render</code> 方法中的 ·<clock>· 组件。</clock></p>\n<p>测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。</p>\n","site":{"data":{}},"excerpt":"<p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为展示型组件和容器型组件。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"展示型组件和容器型组件\"><a href=\"#展示型组件和容器型组件\" class=\"headerlink\" title=\"展示型组件和容器型组件\"></a>展示型组件和容器型组件</h1><p>万事开头难。React 也不例外，作为初学者，我们也有一大堆问题。我应该将数据放在何处？如何进行变化通知？如何管理状态？这些问题的答案往往与上下文有关，而有时取决于 React 的实战经验。但是，有一种广泛使用的模式，有助于组织基于 React 的应用，那便是将组件分为<code>展示型组件</code>和<code>容器型组件</code>。</p>\n<p>我们先从一个简单示例开始，首先说明此示例的问题，然后将组件分成容器型组件和展示型组件。示例中使用的是 <code>Clock</code> 组件，它接收 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\" rel=\"noopener\">Date</a> 对象作为属性并显示实时时间。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; time: <span class=\"keyword\">this</span>.props.time &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._update = <span class=\"keyword\">this</span>._updateTime.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time = <span class=\"keyword\">this</span>._formatTime(<span class=\"keyword\">this</span>.state.time);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;</span><br><span class=\"line\">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span><br><span class=\"line\">      &lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._interval = setInterval(<span class=\"keyword\">this</span>._update, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    clearInterval(<span class=\"keyword\">this</span>._interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _formatTime(time) &#123;</span><br><span class=\"line\">    var [ hours, minutes, seconds ] = [</span><br><span class=\"line\">      time.getHours(),</span><br><span class=\"line\">      time.getMinutes(),</span><br><span class=\"line\">      time.getSeconds()</span><br><span class=\"line\">    ].<span class=\"built_in\">map</span>(num =&gt; num &lt; <span class=\"number\">10</span> ? <span class=\"string\">'0'</span> + num : num);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; hours, minutes, seconds &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _updateTime() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">this</span>.state.time.getTime() + <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;Clock time=&#123; <span class=\"keyword\">new</span> Date() &#125;/&gt;, ...);</span><br></pre></td></tr></table></figure></p>\n<p>在组件的构造函数中，我们初始化了组件的状态，这里只保存了当前时间。通过使用 <code>setInterval</code> ，我们每秒更新一次状态，然后组件会重新渲染。要想看起来像个真正的时钟，我们还使用了两个辅助函数: <code>_formatTime</code> 和<code>_updateTime</code> 。<code>_formatTime</code> 用来提取时分秒并确保它们是两位数的形式。<code>_updateTime</code> 用来将<code>time</code> 对象设置为当前时间加一秒。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>这个组件中它做了好几件事，似乎承担了太多的职责。</p>\n<ul>\n<li>它通过自身来修改状态。在组件中更改时间可能不是一个好主意，因为只有 Clock 组件知道当前时间。如果系统中的其他部分也需要此数据，那么将很难进行共享。</li>\n<li><code>_formatTime</code> 实际上做了两件事，它从时间对象中提取出所需信息，并确保这些值永远以两位数字的形式进行展示。这没什么问题，但如果提取操作不是函数的一部分那就更好了，因为函数绑定了 time 对象的类型。即此函数既要知道数据结构，同时又要对数据进行可视化处理。</li>\n</ul>\n<h1 id=\"提取出容器型组件\"><a href=\"#提取出容器型组件\" class=\"headerlink\" title=\"提取出容器型组件\"></a>提取出容器型组件</h1><p>容器型组件知道数据及其结构，以及数据的来源。它们知道是如何运转的，或所谓的业务逻辑。它们接收信息并对其进行处理，以方便展示型组件使用。通常，我们使用 <a href=\"https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components\" target=\"_blank\" rel=\"noopener\">高阶组件</a> 来创建容器型组件，因为它们为我们的自定义逻辑提供了缓冲区。</p>\n<p>下面是 <code>ClockContainer</code> 的代码:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clock/index.js</span></span><br><span class=\"line\">import Clock from './Clock.jsx'; // &lt;-- 展示型组件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClockContainer</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; time: props.time &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._update = <span class=\"keyword\">this</span>._updateTime.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;Clock &#123; ...<span class=\"keyword\">this</span>._extract(<span class=\"keyword\">this</span>.state.time) &#125;/&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._interval = setInterval(<span class=\"keyword\">this</span>._update, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    clearInterval(<span class=\"keyword\">this</span>._interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _extract(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      hours: time.getHours(),</span><br><span class=\"line\">      minutes: time.getMinutes(),</span><br><span class=\"line\">      seconds: time.getSeconds()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _updateTime() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">this</span>.state.time.getTime() + <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>它接收 <code>time</code> (date 对象) 属性，使用<code>setInterval</code> 循环并了解数据 (<code>getHours</code>、<code>getMinutes</code> 和 <code>getSeconds</code>) 的详情。最后渲染展示型组件并传入时分秒三个数字。这里没有任何展示相关的内容。只有业务逻辑。</p>\n<h1 id=\"展示型组件\"><a href=\"#展示型组件\" class=\"headerlink\" title=\"展示型组件\"></a>展示型组件</h1><p>展示型组件只涉及组件的外在展现形式。它们会有附加的 HTML 标记来使得页面更加漂亮。这种组件没有任何绑定及依赖。通常都是实现成 <a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态组件</a>，它们没有内部状态。</p>\n<p>在本示例中，展示型组件只包含两位数的检查并返回 <code>&lt;h1&gt;</code> 标签:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clock/Clock.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Clock</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  var [ hours, minutes, seconds ] = [</span><br><span class=\"line\">    props.hours,</span><br><span class=\"line\">    props.minutes,</span><br><span class=\"line\">    props.seconds</span><br><span class=\"line\">  ].<span class=\"built_in\">map</span>(num =&gt; num &lt; <span class=\"number\">10</span> ? <span class=\"string\">'0'</span> + num : num);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; hours &#125; : &#123; minutes &#125; : &#123; seconds &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>将组件分成容器型组件和展示型组件可以增加组件的可复用性。不改变时间或不使用 JavaScript Date 对象的应用中，都可以使用 Clock 函数/组件。原因是它相当单纯，不需要对所需数据的详情有任何了解。</p>\n<p>容器型组件封装了逻辑，它们可以搭配不同的展示型组件使用，因为它们不参与任何展示相关的工作。我们上面所采用的方法是一个很好的示例，它阐明了容器型组件是如何不关心展示部分的内容的。我们可以很容易地从数字时钟切换到模拟时钟，唯一的变化就是替换 <code>render</code> 方法中的 ·<clock>· 组件。</clock></p>\n<p>测试也将变得更容易，因为组件承担的职责更少。容器型组件不关心 UI 。展示型组件只是纯粹地负责展示，它可以很好地预测出渲染后的 HTML 标记。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>容器型和展示型的并非是新概念，但是它真的非常适合 React 。它使得应用具有更好的结构，易于管理和扩展。</p>"},{"title":"React开发常用设计模式-组件样式","date":"2018-06-13T16:10:32.000Z","description":null,"copyright":true,"top":null,"_content":"React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 组件样式\n\n## 经典 CSS 类\n\nJSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 `.css `文件中的。唯一需要注意的是 React 中使用的是 `className `，而不是 `class` 。例如:\n\n```h\n<h1 className='title'>Styling</h1>\n```\n\n## 内联样式\n\n内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。\n\n```h\nconst inlineStyles = {\n  color: 'red',\n  fontSize: '10px',\n  marginTop: '2em',\n  'border-top': 'solid 1px #000'\n};\n\n<h2 style={ inlineStyles }>Inline styling</h2>\n```\n因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:\n\n\n```h\nconst theme = {\n  fontFamily: 'Georgia',\n  color: 'blue'\n};\nconst paragraphText = {\n  ...theme,\n  fontSize: '20px'\n};\n\n```\n\n`theme `中有一些基础样式，然后在 `paragraphText` 中混入 `theme` 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。\n\n## CSS 模块\n\n[CSS 模块](https://github.com/css-modules/css-modules/blob/master/docs/get-started.md) 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。\n\n下面的示例可以让你快速对其运行原理有个大致的了解:\n```h\n/* style.css */\n.title {\n  color: green;\n}\n\n// App.jsx\nimport styles from \"./style.css\";\n\nfunction App() {\n  return <h1 style={ styles.title }>Hello world</h1>;\n}\n```\n默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。\n\n当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:\n```h\n\n.title {\n  composes: mainColor from \"./brand-colors.css\";\n}\n```\n\n## Styled-components\n\n[Styled-components](https://www.styled-components.com/) 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 `Link `组件，它具有特定的风格和用法，而再使用 `<a> `标签。\n\n```h\nconst Link = styled.a`\n  text-decoration: none;\n  padding: 4px;\n  border: solid 1px #999;\n  color: black;\n`;\n\n<Link href='http://google.com'>Google</Link>\n```\n还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:\n```h\nconst AnotherLink = styled(Link)`\n  color: blue;\n`;\n\n<AnotherLink href='http://facebook.com'>Facebook</AnotherLink>\n\n```\n到目前为止 `styled-components` 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。\n\n# 结语\n\n处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。","source":"_posts/React开发常用设计模式-组件样式.md","raw":"---\ntitle: React开发常用设计模式-组件样式\ndate: 2018-06-14 00:10:32\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\nReact 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 组件样式\n\n## 经典 CSS 类\n\nJSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 `.css `文件中的。唯一需要注意的是 React 中使用的是 `className `，而不是 `class` 。例如:\n\n```h\n<h1 className='title'>Styling</h1>\n```\n\n## 内联样式\n\n内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。\n\n```h\nconst inlineStyles = {\n  color: 'red',\n  fontSize: '10px',\n  marginTop: '2em',\n  'border-top': 'solid 1px #000'\n};\n\n<h2 style={ inlineStyles }>Inline styling</h2>\n```\n因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:\n\n\n```h\nconst theme = {\n  fontFamily: 'Georgia',\n  color: 'blue'\n};\nconst paragraphText = {\n  ...theme,\n  fontSize: '20px'\n};\n\n```\n\n`theme `中有一些基础样式，然后在 `paragraphText` 中混入 `theme` 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。\n\n## CSS 模块\n\n[CSS 模块](https://github.com/css-modules/css-modules/blob/master/docs/get-started.md) 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。\n\n下面的示例可以让你快速对其运行原理有个大致的了解:\n```h\n/* style.css */\n.title {\n  color: green;\n}\n\n// App.jsx\nimport styles from \"./style.css\";\n\nfunction App() {\n  return <h1 style={ styles.title }>Hello world</h1>;\n}\n```\n默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。\n\n当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:\n```h\n\n.title {\n  composes: mainColor from \"./brand-colors.css\";\n}\n```\n\n## Styled-components\n\n[Styled-components](https://www.styled-components.com/) 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 `Link `组件，它具有特定的风格和用法，而再使用 `<a> `标签。\n\n```h\nconst Link = styled.a`\n  text-decoration: none;\n  padding: 4px;\n  border: solid 1px #999;\n  color: black;\n`;\n\n<Link href='http://google.com'>Google</Link>\n```\n还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:\n```h\nconst AnotherLink = styled(Link)`\n  color: blue;\n`;\n\n<AnotherLink href='http://facebook.com'>Facebook</AnotherLink>\n\n```\n到目前为止 `styled-components` 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。\n\n# 结语\n\n处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。","slug":"React开发常用设计模式-组件样式","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctneb001vkt89c9zivkph","content":"<p>React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h1><h2 id=\"经典-CSS-类\"><a href=\"#经典-CSS-类\" class=\"headerlink\" title=\"经典 CSS 类\"></a>经典 CSS 类</h2><p>JSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 <code>.css</code>文件中的。唯一需要注意的是 React 中使用的是 <code>className</code>，而不是 <code>class</code> 。例如:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 className='title'&gt;Styling&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h2><p>内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inlineStyles = &#123;</span><br><span class=\"line\">  color: 'red',</span><br><span class=\"line\">  fontSize: '10px',</span><br><span class=\"line\">  marginTop: '2em',</span><br><span class=\"line\">  'border-top': 'solid 1px #000'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h2 style=&#123; inlineStyles &#125;&gt;Inline styling&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> theme = &#123;</span><br><span class=\"line\">  fontFamily: 'Georgia',</span><br><span class=\"line\">  color: 'blue'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> paragraphText = &#123;</span><br><span class=\"line\">  ...theme,</span><br><span class=\"line\">  fontSize: '20px'</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>theme</code>中有一些基础样式，然后在 <code>paragraphText</code> 中混入 <code>theme</code> 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。</p>\n<h2 id=\"CSS-模块\"><a href=\"#CSS-模块\" class=\"headerlink\" title=\"CSS 模块\"></a>CSS 模块</h2><p><a href=\"https://github.com/css-modules/css-modules/blob/master/docs/get-started.md\" target=\"_blank\" rel=\"noopener\">CSS 模块</a> 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。</p>\n<p>下面的示例可以让你快速对其运行原理有个大致的了解:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* style.css */</span></span><br><span class=\"line\">.title &#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> styles from <span class=\"string\">\"./style.css\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1 style=&#123; styles.title &#125;&gt;Hello world&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。</p>\n<p>当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.title &#123;</span><br><span class=\"line\">  composes: mainColor from <span class=\"string\">\"./brand-colors.css\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Styled-components\"><a href=\"#Styled-components\" class=\"headerlink\" title=\"Styled-components\"></a>Styled-components</h2><p><a href=\"https://www.styled-components.com/\" target=\"_blank\" rel=\"noopener\">Styled-components</a> 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 <code>Link</code>组件，它具有特定的风格和用法，而再使用 <code>&lt;a&gt;</code>标签。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Link = styled.a`</span><br><span class=\"line\">  text-decoration: none;</span><br><span class=\"line\">  padding: <span class=\"number\">4</span>px;</span><br><span class=\"line\">  border: solid <span class=\"number\">1</span>px #<span class=\"number\">999</span>;</span><br><span class=\"line\">  color: black;</span><br><span class=\"line\">`;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Link href='http://google.com'&gt;Google&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n<p>还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> AnotherLink = styled(Link)`</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">`;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;AnotherLink href='http://facebook.com'&gt;Facebook&lt;/AnotherLink&gt;</span><br></pre></td></tr></table></figure></p>\n<p>到目前为止 <code>styled-components</code> 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。</p>\n","site":{"data":{}},"excerpt":"<p>React 是视图层。因此，它可以控制在浏览器中渲染的标记。众所周知，页面上的 HTML 标记与 CSS 的样式是紧密联系在一起的。有几种方式来处理 React 应用的样式，接下来介绍这些最流行的方式。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h1><h2 id=\"经典-CSS-类\"><a href=\"#经典-CSS-类\" class=\"headerlink\" title=\"经典 CSS 类\"></a>经典 CSS 类</h2><p>JSX 语法相当接近于 HTML 语法。因此，拥有与 HTML 几乎相同的标签属性，仍然可以使用 CSS 类来处理样式。类是定义在外部的 <code>.css</code>文件中的。唯一需要注意的是 React 中使用的是 <code>className</code>，而不是 <code>class</code> 。例如:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 className='title'&gt;Styling&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h2><p>内联样式也能很好的工作。类似于 HTML ，可以通过 style 属性来直接传入样式。但是，style 属性在 HTML 中是字符串，而在 JSX 中必须得是一个对象。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inlineStyles = &#123;</span><br><span class=\"line\">  color: 'red',</span><br><span class=\"line\">  fontSize: '10px',</span><br><span class=\"line\">  marginTop: '2em',</span><br><span class=\"line\">  'border-top': 'solid 1px #000'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h2 style=&#123; inlineStyles &#125;&gt;Inline styling&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>因为用 JavaScript 编写样式，所以从语法角度来看，是有一些限制的。如果想要使用原始的 CSS 属性名称，那么需要用引号包裹起来，否则需要遵循驼峰式命名规则。但是，使用 JavaScript 编写样式却非常有趣，它比普通的 CSS 更具灵活性。例如样式的继承:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> theme = &#123;</span><br><span class=\"line\">  fontFamily: 'Georgia',</span><br><span class=\"line\">  color: 'blue'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> paragraphText = &#123;</span><br><span class=\"line\">  ...theme,</span><br><span class=\"line\">  fontSize: '20px'</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>theme</code>中有一些基础样式，然后在 <code>paragraphText</code> 中混入 <code>theme</code> 的样式。简而言之，能够使用 JavaScript 的全部能力来组织 CSS 。重要的是最终生成了一个传给 style 属性的对象。</p>\n<h2 id=\"CSS-模块\"><a href=\"#CSS-模块\" class=\"headerlink\" title=\"CSS 模块\"></a>CSS 模块</h2><p><a href=\"https://github.com/css-modules/css-modules/blob/master/docs/get-started.md\" target=\"_blank\" rel=\"noopener\">CSS 模块</a> 是建立在到目前为止所介绍过的内容之上的。如果你不喜欢 JavaScript 用法来写 CSS ，那么可以使用 CSS 模块，它可以让继续编写普通的 CSS 。通常，这个库是在打包阶段发挥作用的。可以将它作为编译步骤的一部分进行连接，但通常作为构建系统插件分发。</p>\n<p>下面的示例可以让你快速对其运行原理有个大致的了解:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* style.css */</span></span><br><span class=\"line\">.title &#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> styles from <span class=\"string\">\"./style.css\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1 style=&#123; styles.title &#125;&gt;Hello world&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下是无法这样使用的，只有使用了 CSS 模块，才能直接导入普通的 CSS 文件并使用其中的类。</p>\n<p>当提到 普通的 CSS ，并非真的指最原始的 CSS 。它支持一些非常有用的组合技巧。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.title &#123;</span><br><span class=\"line\">  composes: mainColor from <span class=\"string\">\"./brand-colors.css\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Styled-components\"><a href=\"#Styled-components\" class=\"headerlink\" title=\"Styled-components\"></a>Styled-components</h2><p><a href=\"https://www.styled-components.com/\" target=\"_blank\" rel=\"noopener\">Styled-components</a> 则是另一种完全不同的方向。此库不再为 React 组件提供内联样式。需要使用组件来表示它的外观感受。例如，创建了 <code>Link</code>组件，它具有特定的风格和用法，而再使用 <code>&lt;a&gt;</code>标签。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Link = styled.a`</span><br><span class=\"line\">  text-decoration: none;</span><br><span class=\"line\">  padding: <span class=\"number\">4</span>px;</span><br><span class=\"line\">  border: solid <span class=\"number\">1</span>px #<span class=\"number\">999</span>;</span><br><span class=\"line\">  color: black;</span><br><span class=\"line\">`;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Link href='http://google.com'&gt;Google&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n<p>还有一种扩展类的机制。还可以使用 Link 组件，但是会改变它的文字颜色，像这样:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> AnotherLink = styled(Link)`</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">`;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;AnotherLink href='http://facebook.com'&gt;Facebook&lt;/AnotherLink&gt;</span><br></pre></td></tr></table></figure></p>\n<p>到目前为止 <code>styled-components</code> 可能是多种处理 React 样式的方法中我最感兴趣的。用它来创建组件非常简单，并可以忘记样式本身的存在。如果你的公司有能力创建一个设计系统并用它构建产品的话，那么这个选项可能是最合适的。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>处理 React 应用的样式有多种方式。在生产环境中试验过所有方式，可以说无所谓对与错。正如 JavaScript 中大多数技术一样，你需要挑选一个更适合你的方式。</p>"},{"title":"React开发常用设计模式-组件通讯","date":"2018-05-14T15:09:05.000Z","description":null,"copyright":true,"top":null,"_content":"每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 组件通讯\n每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。\n\n![输入](React开发常用设计模式-组件通讯/reactput.png)\n\n# 输入\nReact 组件的输入是它的 props 。传递数据的方式如下:\n```h\n// Demo.jsx\nfunction Demo(props) {\n  return <h1>{ props.text }</h1>;\n}\nDemo.propTypes = {\n  text: PropTypes.string\n};\nDemo.defaultProps = {\n  text: 'Hello world'\n};\n\n// App.jsx\nfunction App() {\n  return <Demo text='Hello React' />;\n}\n```\n`Demo` 组件只有一个输入属性 `text` 。父组件 (App) 在使用 `<Demo>` 标签时提供此属性。在定义组件的同时我们还定义了 `propTypes` 。在 `propTypes` 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。\n\nReact 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:\n```h\nfunction SomethingElse({ answer }) {\n  return <div>The answer is { answer }</div>;\n}\nfunction Answer() {\n  return <span>42</span>;\n}\n\n<SomethingElse answer={ <Answer /> } />\n```\n\n还有一个 `props.children` 属性，它可以让我们访问父组件标签内的子元素。例如:\n```h\nfunction Title({ text, children }) {\n  return (\n    <h1>\n      { text }\n      { children }\n    </h1>\n  );\n}\nfunction App() {\n  return (\n    <Title text='Hello React'>\n      <span>community</span>\n    </Title>\n  );\n}\n```\n运行结果：\n{% asset_img react_1.png React开发常用设计模式-组件通讯 %}\n<!-- ![运行结果](React开发常用设计模式-组件通讯/react_1.png) -->\n\n在这个示例中，App 组件中的 `<span>community</span>` 就是 Title 组件中的 `children` 属性。注意，如果我们将 `{ children }` 从 Title 组件中移除，那么 `<span>` 标签将不会渲染。\n\n16.3 版本之前，组件还有一种间接输入，叫做` context` 。整个 React 组件树可能有一个 `context` 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 [依赖注入](http://sangka-z.com/react-in-patterns-cn/chapter-10/) 章节。\n\n# 输出\nReact 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。\n\n在下面的示例中，有一个组件` <NameField />`，它接受用户的输入并能将结果发送出去。\n```h\nfunction NameField({ valueUpdated }) {\n  return (\n    <input\n      onChange={ event => valueUpdated(event.target.value) } />\n  );\n};\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { name: '' };\n  }\n  render() {\n    return (\n      <div>\n        <NameField\n          valueUpdated={ name => this.setState({ name }) } />\n        Name: { this.state.name }\n      </div>\n    );\n  }\n};\n```\n运行结果：\n{% asset_img react_2.png React开发常用设计模式-组件通讯 %}\n\n<!-- ![运行结果](**React-开发常用设计模式-前言**/react_2.png) -->\n\n通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。\n```h\nclass ResultsPage extends React.Component {\n  componentDidMount() {\n    this.props.getResults();\n  }\n  render() {\n    if (this.props.results) {\n      return <List results={ this.props.results } />;\n    } else {\n      return <LoadingScreen />\n    }\n  }\n}\n```\n假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 `/results` 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在` componentDidMount` 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 `<List>` 组件。\n\n# 结语\n我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。\n\n","source":"_posts/React开发常用设计模式-组件通讯.md","raw":"---\ntitle: React开发常用设计模式-组件通讯\ndate: 2018-05-14 23:09:05\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 组件通讯\n每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。\n\n![输入](React开发常用设计模式-组件通讯/reactput.png)\n\n# 输入\nReact 组件的输入是它的 props 。传递数据的方式如下:\n```h\n// Demo.jsx\nfunction Demo(props) {\n  return <h1>{ props.text }</h1>;\n}\nDemo.propTypes = {\n  text: PropTypes.string\n};\nDemo.defaultProps = {\n  text: 'Hello world'\n};\n\n// App.jsx\nfunction App() {\n  return <Demo text='Hello React' />;\n}\n```\n`Demo` 组件只有一个输入属性 `text` 。父组件 (App) 在使用 `<Demo>` 标签时提供此属性。在定义组件的同时我们还定义了 `propTypes` 。在 `propTypes` 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。\n\nReact 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:\n```h\nfunction SomethingElse({ answer }) {\n  return <div>The answer is { answer }</div>;\n}\nfunction Answer() {\n  return <span>42</span>;\n}\n\n<SomethingElse answer={ <Answer /> } />\n```\n\n还有一个 `props.children` 属性，它可以让我们访问父组件标签内的子元素。例如:\n```h\nfunction Title({ text, children }) {\n  return (\n    <h1>\n      { text }\n      { children }\n    </h1>\n  );\n}\nfunction App() {\n  return (\n    <Title text='Hello React'>\n      <span>community</span>\n    </Title>\n  );\n}\n```\n运行结果：\n{% asset_img react_1.png React开发常用设计模式-组件通讯 %}\n<!-- ![运行结果](React开发常用设计模式-组件通讯/react_1.png) -->\n\n在这个示例中，App 组件中的 `<span>community</span>` 就是 Title 组件中的 `children` 属性。注意，如果我们将 `{ children }` 从 Title 组件中移除，那么 `<span>` 标签将不会渲染。\n\n16.3 版本之前，组件还有一种间接输入，叫做` context` 。整个 React 组件树可能有一个 `context` 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 [依赖注入](http://sangka-z.com/react-in-patterns-cn/chapter-10/) 章节。\n\n# 输出\nReact 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。\n\n在下面的示例中，有一个组件` <NameField />`，它接受用户的输入并能将结果发送出去。\n```h\nfunction NameField({ valueUpdated }) {\n  return (\n    <input\n      onChange={ event => valueUpdated(event.target.value) } />\n  );\n};\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { name: '' };\n  }\n  render() {\n    return (\n      <div>\n        <NameField\n          valueUpdated={ name => this.setState({ name }) } />\n        Name: { this.state.name }\n      </div>\n    );\n  }\n};\n```\n运行结果：\n{% asset_img react_2.png React开发常用设计模式-组件通讯 %}\n\n<!-- ![运行结果](**React-开发常用设计模式-前言**/react_2.png) -->\n\n通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。\n```h\nclass ResultsPage extends React.Component {\n  componentDidMount() {\n    this.props.getResults();\n  }\n  render() {\n    if (this.props.results) {\n      return <List results={ this.props.results } />;\n    } else {\n      return <LoadingScreen />\n    }\n  }\n}\n```\n假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 `/results` 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在` componentDidMount` 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 `<List>` 组件。\n\n# 结语\n我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。\n\n","slug":"React开发常用设计模式-组件通讯","published":1,"updated":"2018-09-18T12:24:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnec001ykt89v0vm5wh6","content":"<p>每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h1><p>每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。</p>\n<p><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/reactput.png\" alt=\"输入\"></p>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>React 组件的输入是它的 props 。传递数据的方式如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Demo.jsx</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Demo</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.text &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Demo.propTypes = &#123;</span><br><span class=\"line\">  text: PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Demo.defaultProps = &#123;</span><br><span class=\"line\">  text: 'Hello world'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  return &lt;Demo text='Hello React' /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Demo</code> 组件只有一个输入属性 <code>text</code> 。父组件 (App) 在使用 <code>&lt;Demo&gt;</code> 标签时提供此属性。在定义组件的同时我们还定义了 <code>propTypes</code> 。在 <code>propTypes</code> 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。</p>\n<p>React 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">SomethingElse</span><span class=\"params\">(&#123; answer &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;div&gt;The answer is &#123; answer &#125;&lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Answer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;span&gt;<span class=\"number\">42</span>&lt;/span&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;SomethingElse answer=&#123; &lt;Answer /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>还有一个 <code>props.children</code> 属性，它可以让我们访问父组件标签内的子元素。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">(&#123; text, children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">      &#123; text &#125;</span><br><span class=\"line\">      &#123; children &#125;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Title text='Hello React'&gt;</span><br><span class=\"line\">      &lt;span&gt;community&lt;/span&gt;</span><br><span class=\"line\">    &lt;/Title&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/react_1.png\" title=\"React开发常用设计模式-组件通讯\"><br><!-- ![运行结果](React开发常用设计模式-组件通讯/react_1.png) --></p>\n<p>在这个示例中，App 组件中的 <code>&lt;span&gt;community&lt;/span&gt;</code> 就是 Title 组件中的 <code>children</code> 属性。注意，如果我们将 <code>{ children }</code> 从 Title 组件中移除，那么 <code>&lt;span&gt;</code> 标签将不会渲染。</p>\n<p>16.3 版本之前，组件还有一种间接输入，叫做<code>context</code> 。整个 React 组件树可能有一个 <code>context</code> 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 <a href=\"http://sangka-z.com/react-in-patterns-cn/chapter-10/\" target=\"_blank\" rel=\"noopener\">依赖注入</a> 章节。</p>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><p>React 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。</p>\n<p>在下面的示例中，有一个组件<code>&lt;NameField /&gt;</code>，它接受用户的输入并能将结果发送出去。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">NameField</span><span class=\"params\">(&#123; valueUpdated &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      onChange=&#123; event =&gt; valueUpdated(event.target.value) &#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.state = &#123; name: '' &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;NameField</span><br><span class=\"line\">          valueUpdated=&#123; name =&gt; <span class=\"keyword\">this</span>.setState(&#123; name &#125;) &#125; /&gt;</span><br><span class=\"line\">        Name: &#123; <span class=\"keyword\">this</span>.state.name &#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/react_2.png\" title=\"React开发常用设计模式-组件通讯\"></p>\n<!-- ![运行结果](**React-开发常用设计模式-前言**/react_2.png) -->\n<p>通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResultsPage</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.getResults();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.results) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;List results=&#123; <span class=\"keyword\">this</span>.props.results &#125; /&gt;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;LoadingScreen /&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 <code>/results</code> 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在<code>componentDidMount</code> 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 <code>&lt;List&gt;</code> 组件。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。</p>\n","site":{"data":{}},"excerpt":"<p>每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一:易于抽象，易于组合。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h1><p>每个 React 组件就像一个独立运行的小型系统。它有自己的状态、输入和输出。</p>\n<p><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/reactput.png\" alt=\"输入\"></p>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>React 组件的输入是它的 props 。传递数据的方式如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Demo.jsx</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Demo</span><span class=\"params\">(props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123; props.text &#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Demo.propTypes = &#123;</span><br><span class=\"line\">  text: PropTypes.<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Demo.defaultProps = &#123;</span><br><span class=\"line\">  text: 'Hello world'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  return &lt;Demo text='Hello React' /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Demo</code> 组件只有一个输入属性 <code>text</code> 。父组件 (App) 在使用 <code>&lt;Demo&gt;</code> 标签时提供此属性。在定义组件的同时我们还定义了 <code>propTypes</code> 。在 <code>propTypes</code> 中我们定义了每个属性的类型，这样的话，当某些属性的类型并非我们所预期时，React 会在控制台中进行提示。defaultProps 是另一个有用的选项。我们可以使用它来为组件的属性设置默认值，这样就算开发者忘记传入属性也能保障组件具有有效值。</p>\n<p>React 并没有严格定义传入的属性应该是什么。它可以是任何我们想要传入的。例如，它可以是另外一个组件:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">SomethingElse</span><span class=\"params\">(&#123; answer &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;div&gt;The answer is &#123; answer &#125;&lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Answer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;span&gt;<span class=\"number\">42</span>&lt;/span&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;SomethingElse answer=&#123; &lt;Answer /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>还有一个 <code>props.children</code> 属性，它可以让我们访问父组件标签内的子元素。例如:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">Title</span><span class=\"params\">(&#123; text, children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">      &#123; text &#125;</span><br><span class=\"line\">      &#123; children &#125;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Title text='Hello React'&gt;</span><br><span class=\"line\">      &lt;span&gt;community&lt;/span&gt;</span><br><span class=\"line\">    &lt;/Title&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/react_1.png\" title=\"React开发常用设计模式-组件通讯\"><br><!-- ![运行结果](React开发常用设计模式-组件通讯/react_1.png) --></p>\n<p>在这个示例中，App 组件中的 <code>&lt;span&gt;community&lt;/span&gt;</code> 就是 Title 组件中的 <code>children</code> 属性。注意，如果我们将 <code>{ children }</code> 从 Title 组件中移除，那么 <code>&lt;span&gt;</code> 标签将不会渲染。</p>\n<p>16.3 版本之前，组件还有一种间接输入，叫做<code>context</code> 。整个 React 组件树可能有一个 <code>context</code> 对象，组件树中的每个组件都可以访问它。想了解更多，请阅读 <a href=\"http://sangka-z.com/react-in-patterns-cn/chapter-10/\" target=\"_blank\" rel=\"noopener\">依赖注入</a> 章节。</p>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><p>React 组件第一个明显的输出便是渲染出来的 HTML 。这是我们视觉上能看到的。但是，因为传入的属性可以是任何东西，包括函数，我们可以使用它来发送数据或触发操作。</p>\n<p>在下面的示例中，有一个组件<code>&lt;NameField /&gt;</code>，它接受用户的输入并能将结果发送出去。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">NameField</span><span class=\"params\">(&#123; valueUpdated &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      onChange=&#123; event =&gt; valueUpdated(event.target.value) &#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.state = &#123; name: '' &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;NameField</span><br><span class=\"line\">          valueUpdated=&#123; name =&gt; <span class=\"keyword\">this</span>.setState(&#123; name &#125;) &#125; /&gt;</span><br><span class=\"line\">        Name: &#123; <span class=\"keyword\">this</span>.state.name &#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组件通讯/react_2.png\" title=\"React开发常用设计模式-组件通讯\"></p>\n<!-- ![运行结果](**React-开发常用设计模式-前言**/react_2.png) -->\n<p>通常，我们需要逻辑的切入点。React 自带了十分方便的生命周期方法，它们可以用来触发操作。例如，在某个页面，我们需要获取外部的数据资源。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResultsPage</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.getResults();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.results) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;List results=&#123; <span class=\"keyword\">this</span>.props.results &#125; /&gt;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;LoadingScreen /&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设，我们要开发一个搜索结果的功能。我们已经有了一个搜索页面，我们在这里进行搜索。当点击提交按钮时，将跳转至 <code>/results</code> 页面，这里将显示搜索的结果。当我们进入结果显示页时，我们首先需要渲染加载页面，同时在<code>componentDidMount</code> 生命周期钩子中触发请求结果数据的操作。当得到数据后，我们会将其传给 <code>&lt;List&gt;</code> 组件。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>我们可以将每个 React 组件想象成是一个黑盒，这种方式很不错。它有自己的输入、生命周期及输出。我们所需要做的只是将这些盒子组合起来。这或许就是 React 所提供的优势之一: 易于抽象，易于组合。</p>"},{"title":"React开发常用设计模式-组合 (composition)","date":"2018-05-14T15:52:47.000Z","description":null,"copyright":true,"top":null,"_content":"对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 组合 ( composition )\nReact 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。\n\n我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 `Reac`t 组件 `—App`、`Header` 和 `Navigation` 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:\n```h\n<App> -> <Header> -> <Navigation>\n```\n组合这些组件的简单方法是在需要它们的时候引用即可。\n```h\n// app.jsx\nimport Header from './Header.jsx';\n\nexport default function App() {\n  return <Header />;\n}\n\n// Header.jsx\nimport Navigation from './Navigation.jsx';\n\nexport default function Header() {\n  return <header><Navigation /></header>;\n}\n\n// Navigation.jsx\nexport default function Navigation() {\n  return (<nav> ... </nav>);\n}\n```\n但是，这种方式会引入一些问题:\n* 我们可以把 App 看作是主要的组合场所。`Header` 可能还有其他元素，比如 `logo`、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 `Navigation` 的 `Header` 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。\n* 代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 `Navigation` 组件出了问题，那么 `Header` 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: [浅层渲染 ( shallow rendering](https://facebook.github.io/react/docs/test-utils.html#shallow-rendering) ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)\n\n# 使用 React children API\nReact 提供了便利的 [children](https://facebook.github.io/react/docs/multiple-components.html#children) 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 `Header` 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:\n```h\nexport default function App() {\n  return (\n    <Header>\n      <Navigation />\n    </Header>\n  );\n}\nexport default function Header({ children }) {\n  return <header>{ children }</header>;\n};\n```\n注意，如果不在 `Heade`r 中使用 `{ children } `的话，那么 `Navigation` 组件永远不会渲染。\n\n现在 Header 组件的测试变得更简单了，因为完全可以使用空 `<div>` 来渲染 `Header` 组件。这会使用组件更独立，并让我们专注于应用的一小部分。\n\n# 将 child 作为 prop 传入\n每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。\n```h\nconst Title = function () {\n  return <h1>Hello there!</h1>;\n}\nconst Header = function ({ title, children }) {\n  return (\n    <header>\n      { title }\n      { children }\n    </header>\n  );\n}\nfunction App() {\n  return (\n    <Header title={ <Title /> }>\n      <Navigation />\n    </Header>\n  );\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_5.png)\n\n当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。\n# 高阶组件\n很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 [装饰器模式](http://robdodson.me/javascript-design-patterns-decorator/) 十分相似，因为它是对组件的包装与增强。\n\n从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:\n```h\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    render() {\n      return (\n        <Component {...this.props} />\n      )\n    }\n  };\n\nvar OriginalTitle = () => <h1>Hello world</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n\nclass App extends React.Component {\n  render() {\n    return <EnhancedTitle />;\n  }\n};\n```\n高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有` OriginalTitle `所需要的配置:\n```h\nvar config = require('path/to/configuration');\n\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ config.appTitle }\n        />\n      )\n    }\n  };\n\nvar OriginalTitle  = ({ title }) => <h1>{ title }</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n\n```\n`appTitle` 是封装在高阶组件内部的。`OriginalTitle` 只知道它所接收的 `title` 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建` mocks` 。\n\n这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 `OriginalTitle` 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 `OriginalTitle` 。\n```h\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    constructor(props) {\n      super(props);\n\n      this.state = { remoteTitle: null };\n    }\n    componentDidMount() {\n      fetchRemoteData('path/to/endpoint').then(data => {\n        this.setState({ remoteTitle: data.title });\n      });\n    }\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ config.appTitle }\n          remoteTitle={ this.state.remoteTitle }\n        />\n      )\n    }\n  };\n\nvar OriginalTitle  = ({ title, remoteTitle }) =>\n  <h1>{ title }{ remoteTitle }</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n```\n这次，`OriginalTitle` 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。\n* 关于高阶组件的创建问题[，Dan Abramov](https://github.com/gaearon) 提出了一个 [非常棒的观点](https://github.com/krasimir/react-in-patterns/issues/12)，像调用 `enhanceComponent` 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 \n\n# 将函数作为 children 传入和 render prop\nReact 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 `children` 属性都是 `React` 组件。然而，有一种新的模式越来越受欢迎，`children` 属性是一个 `JSX` 表达式。我们先从传入一个简单对象开始。\n```h\nfunction UserName({ children }) {\n  return (\n    <div>\n      <b>{ children.lastName }</b>,\n      { children.firstName }\n    </div>\n  );\n}\n\nfunction App() {\n  const user = {\n    firstName: 'Krasimir',\n    lastName: 'Tsonev'\n  };\n  return (\n    <UserName>{ user }</UserName>\n  );\n}\n```\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_6.png)\n\n\n这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。`TodoList` 组件只是简单地封装了所需的 HTML 标记。\n```h\nfunction TodoList({ todos, children }) {\n  return (\n    <section className='main-section'>\n      <ul className='todo-list'>{\n        todos.map((todo, i) => (\n          <li key={ i }>{ children(todo) }</li>\n        ))\n      }</ul>\n    </section>\n  );\n}\n\nfunction App() {\n  const todos = [\n    { label: 'Write tests', status: 'done' },\n    { label: 'Sent report', status: 'progress' },\n    { label: 'Answer emails', status: 'done' }\n  ];\n  const isCompleted = todo => todo.status === 'done';\n  return (\n    <TodoList todos={ todos }>\n      {\n        todo => isCompleted(todo) ?\n          <b>{ todo.label }</b> :\n          todo.label\n      }\n    </TodoList>\n  );\n}\n```\n\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_7.png)\n\n\n注意观察 App 组件是如何不暴露数据结构的。`TodoList` 完全不知道 `label` 和 `status 属性。\n\n名为 `render prop` 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 `render` 属性，而不是 `children` 。\n```h\nfunction TodoList({ todos, render }) {\n  return (\n    <section className='main-section'>\n      <ul className='todo-list'>{\n        todos.map((todo, i) => (\n          <li key={ i }>{ render(todo) }</li>\n        ))\n      }</ul>\n    </section>\n  );\n}\n\nreturn (\n  <TodoList\n    todos={ todos }\n    render={\n      todo => isCompleted(todo) ?\n        <b>{ todo.label }</b> : todo.label\n    } />\n);\n\n```\n\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_8.png)\n\n\n这两种模式 将函数作为 `children` 传入 和 `render prop` 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。\n```h\nclass DataProvider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { data: null };\n    setTimeout(() => this.setState({ data: 'Hey there!' }), 5000);\n  }\n  render() {\n    if (this.state.data === null) return null;\n    return (\n      <section>{ this.props.render(this.state.data) }</section>\n    );\n  }\n}\n```\n`DataProvider` 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个` <section>`，`<section>` 的内容是由 `render` 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。\n```\n<DataProvider render={ data => <p>The data is here!</p> } />\n```\n我们描述了我们想要做的事，而不是如何去做。细节都封装在了 `DataProvider` 中。最近，使用这种模式，某些界面限制只对具有 `read:products` 权限的用户开放。我们使用的是` render prop` 模式。\n```h\n<Authorize\n  permissionsInclude={[ 'read:products' ]}\n  render={ () => <ProductsList /> } />\n  ```\n  这种声明式的方式相当不错，不言自明。`Authorize` 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 `ProductList `。\n  \n  # 结语\n  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。\n\n","source":"_posts/React开发常用设计模式-组合-composition.md","raw":"---\ntitle: React开发常用设计模式-组合 (composition)\ndate: 2018-05-14 23:52:47\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n# 组合 ( composition )\nReact 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。\n\n我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 `Reac`t 组件 `—App`、`Header` 和 `Navigation` 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:\n```h\n<App> -> <Header> -> <Navigation>\n```\n组合这些组件的简单方法是在需要它们的时候引用即可。\n```h\n// app.jsx\nimport Header from './Header.jsx';\n\nexport default function App() {\n  return <Header />;\n}\n\n// Header.jsx\nimport Navigation from './Navigation.jsx';\n\nexport default function Header() {\n  return <header><Navigation /></header>;\n}\n\n// Navigation.jsx\nexport default function Navigation() {\n  return (<nav> ... </nav>);\n}\n```\n但是，这种方式会引入一些问题:\n* 我们可以把 App 看作是主要的组合场所。`Header` 可能还有其他元素，比如 `logo`、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 `Navigation` 的 `Header` 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。\n* 代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 `Navigation` 组件出了问题，那么 `Header` 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: [浅层渲染 ( shallow rendering](https://facebook.github.io/react/docs/test-utils.html#shallow-rendering) ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)\n\n# 使用 React children API\nReact 提供了便利的 [children](https://facebook.github.io/react/docs/multiple-components.html#children) 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 `Header` 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:\n```h\nexport default function App() {\n  return (\n    <Header>\n      <Navigation />\n    </Header>\n  );\n}\nexport default function Header({ children }) {\n  return <header>{ children }</header>;\n};\n```\n注意，如果不在 `Heade`r 中使用 `{ children } `的话，那么 `Navigation` 组件永远不会渲染。\n\n现在 Header 组件的测试变得更简单了，因为完全可以使用空 `<div>` 来渲染 `Header` 组件。这会使用组件更独立，并让我们专注于应用的一小部分。\n\n# 将 child 作为 prop 传入\n每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。\n```h\nconst Title = function () {\n  return <h1>Hello there!</h1>;\n}\nconst Header = function ({ title, children }) {\n  return (\n    <header>\n      { title }\n      { children }\n    </header>\n  );\n}\nfunction App() {\n  return (\n    <Header title={ <Title /> }>\n      <Navigation />\n    </Header>\n  );\n};\n```\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_5.png)\n\n当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。\n# 高阶组件\n很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 [装饰器模式](http://robdodson.me/javascript-design-patterns-decorator/) 十分相似，因为它是对组件的包装与增强。\n\n从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:\n```h\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    render() {\n      return (\n        <Component {...this.props} />\n      )\n    }\n  };\n\nvar OriginalTitle = () => <h1>Hello world</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n\nclass App extends React.Component {\n  render() {\n    return <EnhancedTitle />;\n  }\n};\n```\n高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有` OriginalTitle `所需要的配置:\n```h\nvar config = require('path/to/configuration');\n\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ config.appTitle }\n        />\n      )\n    }\n  };\n\nvar OriginalTitle  = ({ title }) => <h1>{ title }</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n\n```\n`appTitle` 是封装在高阶组件内部的。`OriginalTitle` 只知道它所接收的 `title` 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建` mocks` 。\n\n这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 `OriginalTitle` 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 `OriginalTitle` 。\n```h\nvar enhanceComponent = (Component) =>\n  class Enhance extends React.Component {\n    constructor(props) {\n      super(props);\n\n      this.state = { remoteTitle: null };\n    }\n    componentDidMount() {\n      fetchRemoteData('path/to/endpoint').then(data => {\n        this.setState({ remoteTitle: data.title });\n      });\n    }\n    render() {\n      return (\n        <Component\n          {...this.props}\n          title={ config.appTitle }\n          remoteTitle={ this.state.remoteTitle }\n        />\n      )\n    }\n  };\n\nvar OriginalTitle  = ({ title, remoteTitle }) =>\n  <h1>{ title }{ remoteTitle }</h1>;\nvar EnhancedTitle = enhanceComponent(OriginalTitle);\n```\n这次，`OriginalTitle` 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。\n* 关于高阶组件的创建问题[，Dan Abramov](https://github.com/gaearon) 提出了一个 [非常棒的观点](https://github.com/krasimir/react-in-patterns/issues/12)，像调用 `enhanceComponent` 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 \n\n# 将函数作为 children 传入和 render prop\nReact 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 `children` 属性都是 `React` 组件。然而，有一种新的模式越来越受欢迎，`children` 属性是一个 `JSX` 表达式。我们先从传入一个简单对象开始。\n```h\nfunction UserName({ children }) {\n  return (\n    <div>\n      <b>{ children.lastName }</b>,\n      { children.firstName }\n    </div>\n  );\n}\n\nfunction App() {\n  const user = {\n    firstName: 'Krasimir',\n    lastName: 'Tsonev'\n  };\n  return (\n    <UserName>{ user }</UserName>\n  );\n}\n```\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_6.png)\n\n\n这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。`TodoList` 组件只是简单地封装了所需的 HTML 标记。\n```h\nfunction TodoList({ todos, children }) {\n  return (\n    <section className='main-section'>\n      <ul className='todo-list'>{\n        todos.map((todo, i) => (\n          <li key={ i }>{ children(todo) }</li>\n        ))\n      }</ul>\n    </section>\n  );\n}\n\nfunction App() {\n  const todos = [\n    { label: 'Write tests', status: 'done' },\n    { label: 'Sent report', status: 'progress' },\n    { label: 'Answer emails', status: 'done' }\n  ];\n  const isCompleted = todo => todo.status === 'done';\n  return (\n    <TodoList todos={ todos }>\n      {\n        todo => isCompleted(todo) ?\n          <b>{ todo.label }</b> :\n          todo.label\n      }\n    </TodoList>\n  );\n}\n```\n\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_7.png)\n\n\n注意观察 App 组件是如何不暴露数据结构的。`TodoList` 完全不知道 `label` 和 `status 属性。\n\n名为 `render prop` 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 `render` 属性，而不是 `children` 。\n```h\nfunction TodoList({ todos, render }) {\n  return (\n    <section className='main-section'>\n      <ul className='todo-list'>{\n        todos.map((todo, i) => (\n          <li key={ i }>{ render(todo) }</li>\n        ))\n      }</ul>\n    </section>\n  );\n}\n\nreturn (\n  <TodoList\n    todos={ todos }\n    render={\n      todo => isCompleted(todo) ?\n        <b>{ todo.label }</b> : todo.label\n    } />\n);\n\n```\n\n运行结果：\n![运行结果](React开发常用设计模式-组合-composition/react_8.png)\n\n\n这两种模式 将函数作为 `children` 传入 和 `render prop` 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。\n```h\nclass DataProvider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { data: null };\n    setTimeout(() => this.setState({ data: 'Hey there!' }), 5000);\n  }\n  render() {\n    if (this.state.data === null) return null;\n    return (\n      <section>{ this.props.render(this.state.data) }</section>\n    );\n  }\n}\n```\n`DataProvider` 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个` <section>`，`<section>` 的内容是由 `render` 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。\n```\n<DataProvider render={ data => <p>The data is here!</p> } />\n```\n我们描述了我们想要做的事，而不是如何去做。细节都封装在了 `DataProvider` 中。最近，使用这种模式，某些界面限制只对具有 `read:products` 权限的用户开放。我们使用的是` render prop` 模式。\n```h\n<Authorize\n  permissionsInclude={[ 'read:products' ]}\n  render={ () => <ProductsList /> } />\n  ```\n  这种声明式的方式相当不错，不言自明。`Authorize` 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 `ProductList `。\n  \n  # 结语\n  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。\n\n","slug":"React开发常用设计模式-组合-composition","published":1,"updated":"2018-09-18T12:24:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctned0021kt89ws444o90","content":"<p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"组合-composition\"><a href=\"#组合-composition\" class=\"headerlink\" title=\"组合 ( composition )\"></a>组合 ( composition )</h1><p>React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。</p>\n<p>我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 <code>Reac</code>t 组件 <code>—App</code>、<code>Header</code> 和 <code>Navigation</code> 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt;</span><br></pre></td></tr></table></figure></p>\n<p>组合这些组件的简单方法是在需要它们的时候引用即可。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Navigation from './Navigation.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Navigation.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Navigation</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;nav&gt; ... &lt;/nav&gt;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，这种方式会引入一些问题:</p>\n<ul>\n<li>我们可以把 App 看作是主要的组合场所。<code>Header</code> 可能还有其他元素，比如 <code>logo</code>、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 <code>Navigation</code> 的 <code>Header</code> 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。</li>\n<li>代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 <code>Navigation</code> 组件出了问题，那么 <code>Header</code> 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: <a href=\"https://facebook.github.io/react/docs/test-utils.html#shallow-rendering\" target=\"_blank\" rel=\"noopener\">浅层渲染 ( shallow rendering</a> ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)</li>\n</ul>\n<h1 id=\"使用-React-children-API\"><a href=\"#使用-React-children-API\" class=\"headerlink\" title=\"使用 React children API\"></a>使用 React children API</h1><p>React 提供了便利的 <a href=\"https://facebook.github.io/react/docs/multiple-components.html#children\" target=\"_blank\" rel=\"noopener\">children</a> 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 <code>Header</code> 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Header&gt;</span><br><span class=\"line\">      &lt;Navigation /&gt;</span><br><span class=\"line\">    &lt;/Header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">(&#123; children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;header&gt;&#123; children &#125;&lt;/header&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果不在 <code>Heade</code>r 中使用 <code>{ children }</code>的话，那么 <code>Navigation</code> 组件永远不会渲染。</p>\n<p>现在 Header 组件的测试变得更简单了，因为完全可以使用空 <code>&lt;div&gt;</code> 来渲染 <code>Header</code> 组件。这会使用组件更独立，并让我们专注于应用的一小部分。</p>\n<h1 id=\"将-child-作为-prop-传入\"><a href=\"#将-child-作为-prop-传入\" class=\"headerlink\" title=\"将 child 作为 prop 传入\"></a>将 child 作为 prop 传入</h1><p>每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Title = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;Hello there!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Header = function (&#123; title, children &#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &#123; title &#125;</span><br><span class=\"line\">      &#123; children &#125;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt;</span><br><span class=\"line\">      &lt;Navigation /&gt;</span><br><span class=\"line\">    &lt;/Header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_5.png\" alt=\"运行结果\"></p>\n<p>当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。</p>\n<h1 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h1><p>很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 <a href=\"http://robdodson.me/javascript-design-patterns-decorator/\" target=\"_blank\" rel=\"noopener\">装饰器模式</a> 十分相似，因为它是对组件的包装与增强。</p>\n<p>从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component &#123;...<span class=\"keyword\">this</span>.props&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;EnhancedTitle /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有<code>OriginalTitle</code>所需要的配置:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = require('path/to/configuration');</span><br><span class=\"line\"></span><br><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; config.appTitle &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle  = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p>\n<p><code>appTitle</code> 是封装在高阶组件内部的。<code>OriginalTitle</code> 只知道它所接收的 <code>title</code> 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建<code>mocks</code> 。</p>\n<p>这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 <code>OriginalTitle</code> 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 <code>OriginalTitle</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123; remoteTitle: null &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      fetchRemoteData('path/to/endpoint').then(data =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; config.appTitle &#125;</span><br><span class=\"line\">          remoteTitle=&#123; <span class=\"keyword\">this</span>.state.remoteTitle &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class=\"line\">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p>\n<p>这次，<code>OriginalTitle</code> 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。</p>\n<ul>\n<li>关于高阶组件的创建问题<a href=\"https://github.com/gaearon\" target=\"_blank\" rel=\"noopener\">，Dan Abramov</a> 提出了一个 <a href=\"https://github.com/krasimir/react-in-patterns/issues/12\" target=\"_blank\" rel=\"noopener\">非常棒的观点</a>，像调用 <code>enhanceComponent</code> 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 </li>\n</ul>\n<h1 id=\"将函数作为-children-传入和-render-prop\"><a href=\"#将函数作为-children-传入和-render-prop\" class=\"headerlink\" title=\"将函数作为 children 传入和 render prop\"></a>将函数作为 children 传入和 render prop</h1><p>React 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 <code>children</code> 属性都是 <code>React</code> 组件。然而，有一种新的模式越来越受欢迎，<code>children</code> 属性是一个 <code>JSX</code> 表达式。我们先从传入一个简单对象开始。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">UserName</span><span class=\"params\">(&#123; children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;,</span><br><span class=\"line\">      &#123; children.firstName &#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">    firstName: 'Krasimir',</span><br><span class=\"line\">    lastName: 'Tsonev'</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_6.png\" alt=\"运行结果\"></p>\n<p>这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。<code>TodoList</code> 组件只是简单地封装了所需的 HTML 标记。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">TodoList</span><span class=\"params\">(&#123; todos, children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;section className='main-section'&gt;</span><br><span class=\"line\">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class=\"line\">        todos.<span class=\"built_in\">map</span>((todo, i) =&gt; (</span><br><span class=\"line\">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;&lt;/ul&gt;</span><br><span class=\"line\">    &lt;/section&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> todos = [</span><br><span class=\"line\">    &#123; label: 'Write tests', status: 'done' &#125;,</span><br><span class=\"line\">    &#123; label: 'Sent report', status: 'progress' &#125;,</span><br><span class=\"line\">    &#123; label: 'Answer emails', status: 'done' &#125;</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  const isCompleted = todo =&gt; todo.status === 'done';</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        todo =&gt; isCompleted(todo) ?</span><br><span class=\"line\">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class=\"line\">          todo.label</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/TodoList&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_7.png\" alt=\"运行结果\"></p>\n<p>注意观察 App 组件是如何不暴露数据结构的。<code>TodoList</code> 完全不知道 <code>label</code> 和 `status 属性。</p>\n<p>名为 <code>render prop</code> 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 <code>render</code> 属性，而不是 <code>children</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">TodoList</span><span class=\"params\">(&#123; todos, render &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;section className='main-section'&gt;</span><br><span class=\"line\">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class=\"line\">        todos.<span class=\"built_in\">map</span>((todo, i) =&gt; (</span><br><span class=\"line\">          &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;&lt;/ul&gt;</span><br><span class=\"line\">    &lt;/section&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> (</span><br><span class=\"line\">  &lt;TodoList</span><br><span class=\"line\">    todos=&#123; todos &#125;</span><br><span class=\"line\">    render=&#123;</span><br><span class=\"line\">      todo =&gt; isCompleted(todo) ?</span><br><span class=\"line\">        &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label</span><br><span class=\"line\">    &#125; /&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_8.png\" alt=\"运行结果\"></p>\n<p>这两种模式 将函数作为 <code>children</code> 传入 和 <code>render prop</code> 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataProvider</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; data: null &#125;;</span><br><span class=\"line\">    setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.data === null) <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;section&gt;&#123; <span class=\"keyword\">this</span>.props.render(<span class=\"keyword\">this</span>.state.data) &#125;&lt;/section&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DataProvider</code> 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个<code>&lt;section&gt;</code>，<code>&lt;section&gt;</code> 的内容是由 <code>render</code> 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>我们描述了我们想要做的事，而不是如何去做。细节都封装在了 <code>DataProvider</code> 中。最近，使用这种模式，某些界面限制只对具有 <code>read:products</code> 权限的用户开放。我们使用的是<code>render prop</code> 模式。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Authorize</span><br><span class=\"line\">  permissionsInclude=&#123;[ 'read:products' ]&#125;</span><br><span class=\"line\">  render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  这种声明式的方式相当不错，不言自明。<code>Authorize</code> 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 <code>ProductList</code>。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>\n","site":{"data":{}},"excerpt":"<p>对于事件处理，React 提供了一系列属性。解决方案几乎和使用标准化 DOM 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"组合-composition\"><a href=\"#组合-composition\" class=\"headerlink\" title=\"组合 ( composition )\"></a>组合 ( composition )</h1><p>React 最大的好处是它的可组合性。就我个人而言，我不知道还有哪个框架能提供这样如此简单地创建和组合组件的方式。本节我们将探讨一些好用的组合技巧，这些技巧都是经过实战验证的。</p>\n<p>我们来看一个简单示例。假设我们的应用有一个头部，我们想在头部中放置导航。我们有三个 <code>Reac</code>t 组件 <code>—App</code>、<code>Header</code> 和 <code>Navigation</code> 。这三个组件是一个嵌套一个的，所以我们得到的依赖关系如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;App&gt; -&gt; &lt;Header&gt; -&gt; &lt;Navigation&gt;</span><br></pre></td></tr></table></figure></p>\n<p>组合这些组件的简单方法是在需要它们的时候引用即可。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.jsx</span></span><br><span class=\"line\">import Header from './Header.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;Header /&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Header.jsx</span></span><br><span class=\"line\">import Navigation from './Navigation.jsx';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Navigation.jsx</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Navigation</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;nav&gt; ... &lt;/nav&gt;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，这种方式会引入一些问题:</p>\n<ul>\n<li>我们可以把 App 看作是主要的组合场所。<code>Header</code> 可能还有其他元素，比如 <code>logo</code>、搜索框或标语。如果它们是以某种方式通过 App 组件传入的就好了，这样我们就无需创建目前这种硬编码的依赖关系。再比如说我们如果需要一个没有 <code>Navigation</code> 的 <code>Header</code> 组件该怎么办？我们无法轻松实现，因为我们将这两个组件紧绑在了一起。</li>\n<li>代码很难测试。在 Header 中或许有一些业务逻辑，要测试它的话我们需要创建出一个组件实例。但是，因为它还导入了其他组件，所以我们还要为这些导入的组件创建实例，这样的话测试就变的很重。如果 <code>Navigation</code> 组件出了问题，那么 <code>Header</code> 组件的测试已将被破坏，这完全不是我们想要的效果。(注意: <a href=\"https://facebook.github.io/react/docs/test-utils.html#shallow-rendering\" target=\"_blank\" rel=\"noopener\">浅层渲染 ( shallow rendering</a> ) 通过不渲染 Header 组件嵌套的子元素能在一定程度上解决此问题。)</li>\n</ul>\n<h1 id=\"使用-React-children-API\"><a href=\"#使用-React-children-API\" class=\"headerlink\" title=\"使用 React children API\"></a>使用 React children API</h1><p>React 提供了便利的 <a href=\"https://facebook.github.io/react/docs/multiple-components.html#children\" target=\"_blank\" rel=\"noopener\">children</a> 属性。通过它父组件可以读取/访问它的嵌套子元素。此 API 可以使得 <code>Header</code> 组件不用知晓它的嵌套子元素，从而解放之前的依赖关系:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Header&gt;</span><br><span class=\"line\">      &lt;Navigation /&gt;</span><br><span class=\"line\">    &lt;/Header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> function <span class=\"title\">Header</span><span class=\"params\">(&#123; children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;header&gt;&#123; children &#125;&lt;/header&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果不在 <code>Heade</code>r 中使用 <code>{ children }</code>的话，那么 <code>Navigation</code> 组件永远不会渲染。</p>\n<p>现在 Header 组件的测试变得更简单了，因为完全可以使用空 <code>&lt;div&gt;</code> 来渲染 <code>Header</code> 组件。这会使用组件更独立，并让我们专注于应用的一小部分。</p>\n<h1 id=\"将-child-作为-prop-传入\"><a href=\"#将-child-作为-prop-传入\" class=\"headerlink\" title=\"将 child 作为 prop 传入\"></a>将 child 作为 prop 传入</h1><p>每个 React 组件都接收属性。正如之前所提到的，关于传入的属性是什么并没有任何严格的规定。我们甚至可以传入其他组件。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Title = function () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;Hello there!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Header = function (&#123; title, children &#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &#123; title &#125;</span><br><span class=\"line\">      &#123; children &#125;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Header title=&#123; &lt;Title /&gt; &#125;&gt;</span><br><span class=\"line\">      &lt;Navigation /&gt;</span><br><span class=\"line\">    &lt;/Header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_5.png\" alt=\"运行结果\"></p>\n<p>当遇到像 Header 这样的组件时，这种技术非常有用，它们需要对其嵌套的子元素进行决策，但并不关心它们的实际情况。</p>\n<h1 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h1><p>很长一段时期内，高阶组件都是增强和组合 React 元素的最流行的方式。它们看上去与 <a href=\"http://robdodson.me/javascript-design-patterns-decorator/\" target=\"_blank\" rel=\"noopener\">装饰器模式</a> 十分相似，因为它是对组件的包装与增强。</p>\n<p>从技术角度来说，高阶组件通常是函数，它接收原始组件并返回原始组件的增强/填充版本。最简单的示例如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component &#123;...<span class=\"keyword\">this</span>.props&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;EnhancedTitle /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>高阶组件要做的第一件事就是渲染原始组件。将高阶组件的 props 传给原始组件是一种最佳实践。这种方式将保持原始组件的输入。这便是这种模式的最大好处，因为我们控制了原始组件的输入，而输入可以包含原始组件通常无法访问的内容。假设我们有<code>OriginalTitle</code>所需要的配置:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = require('path/to/configuration');</span><br><span class=\"line\"></span><br><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; config.appTitle &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle  = (&#123; title &#125;) =&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p>\n<p><code>appTitle</code> 是封装在高阶组件内部的。<code>OriginalTitle</code> 只知道它所接收的 <code>title</code> 属性，它完全不知道数据是来自配置文件的。这就是一个巨大的优势，因为它使得我们可以将组件的代码块进行隔离。它还有助于组件的测试，因为我们可以轻易地创建<code>mocks</code> 。</p>\n<p>这种模式的另外一个特点是为附加的逻辑提供了很好的缓冲区。例如，如果 <code>OriginalTitle</code> 需要的数据来自远程服务器。我们可以在高阶组件中请求此数据，然后将其作为属性传给 <code>OriginalTitle</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhanceComponent = (Component) =&gt;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123; remoteTitle: null &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      fetchRemoteData('path/to/endpoint').then(data =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Component</span><br><span class=\"line\">          &#123;...<span class=\"keyword\">this</span>.props&#125;</span><br><span class=\"line\">          title=&#123; config.appTitle &#125;</span><br><span class=\"line\">          remoteTitle=&#123; <span class=\"keyword\">this</span>.state.remoteTitle &#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class=\"line\">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class=\"line\">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></p>\n<p>这次，<code>OriginalTitle</code> 只知道它接收两个属性，然后将它们并排渲染出来。它只关心数据的表现，而无需关心数据的来源和方式。</p>\n<ul>\n<li>关于高阶组件的创建问题<a href=\"https://github.com/gaearon\" target=\"_blank\" rel=\"noopener\">，Dan Abramov</a> 提出了一个 <a href=\"https://github.com/krasimir/react-in-patterns/issues/12\" target=\"_blank\" rel=\"noopener\">非常棒的观点</a>，像调用 <code>enhanceComponent</code> 这样的函数时，应该在组件定义的层级调用。换句话说，在另一个 React 组件中做这件事是有问题的，它会导致应用速度变慢并导致性能问题。 </li>\n</ul>\n<h1 id=\"将函数作为-children-传入和-render-prop\"><a href=\"#将函数作为-children-传入和-render-prop\" class=\"headerlink\" title=\"将函数作为 children 传入和 render prop\"></a>将函数作为 children 传入和 render prop</h1><p>React 社区开始转向一个有趣的方向。到目前为止，我们的示例中的 <code>children</code> 属性都是 <code>React</code> 组件。然而，有一种新的模式越来越受欢迎，<code>children</code> 属性是一个 <code>JSX</code> 表达式。我们先从传入一个简单对象开始。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">UserName</span><span class=\"params\">(&#123; children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;b&gt;&#123; children.lastName &#125;&lt;/b&gt;,</span><br><span class=\"line\">      &#123; children.firstName &#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">    firstName: 'Krasimir',</span><br><span class=\"line\">    lastName: 'Tsonev'</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;UserName&gt;&#123; user &#125;&lt;/UserName&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_6.png\" alt=\"运行结果\"></p>\n<p>这看起来有点怪怪的，但实际上它确实非常强大。例如，当某些父组件所知道的内容不需要传给子组件时。下面的示例是待办事项的列表。App 组件拥有全部的数据，并且它知道如何确定待办事项是否完成。<code>TodoList</code> 组件只是简单地封装了所需的 HTML 标记。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">TodoList</span><span class=\"params\">(&#123; todos, children &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;section className='main-section'&gt;</span><br><span class=\"line\">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class=\"line\">        todos.<span class=\"built_in\">map</span>((todo, i) =&gt; (</span><br><span class=\"line\">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;&lt;/ul&gt;</span><br><span class=\"line\">    &lt;/section&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">App</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> todos = [</span><br><span class=\"line\">    &#123; label: 'Write tests', status: 'done' &#125;,</span><br><span class=\"line\">    &#123; label: 'Sent report', status: 'progress' &#125;,</span><br><span class=\"line\">    &#123; label: 'Answer emails', status: 'done' &#125;</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  const isCompleted = todo =&gt; todo.status === 'done';</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        todo =&gt; isCompleted(todo) ?</span><br><span class=\"line\">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class=\"line\">          todo.label</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/TodoList&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_7.png\" alt=\"运行结果\"></p>\n<p>注意观察 App 组件是如何不暴露数据结构的。<code>TodoList</code> 完全不知道 <code>label</code> 和 `status 属性。</p>\n<p>名为 <code>render prop</code> 的模式与上面所讲的基本相同，除了渲染待办事项使用的是 <code>render</code> 属性，而不是 <code>children</code> 。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">TodoList</span><span class=\"params\">(&#123; todos, render &#125;)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;section className='main-section'&gt;</span><br><span class=\"line\">      &lt;ul className='todo-list'&gt;&#123;</span><br><span class=\"line\">        todos.<span class=\"built_in\">map</span>((todo, i) =&gt; (</span><br><span class=\"line\">          &lt;li key=&#123; i &#125;&gt;&#123; render(todo) &#125;&lt;/li&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;&lt;/ul&gt;</span><br><span class=\"line\">    &lt;/section&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> (</span><br><span class=\"line\">  &lt;TodoList</span><br><span class=\"line\">    todos=&#123; todos &#125;</span><br><span class=\"line\">    render=&#123;</span><br><span class=\"line\">      todo =&gt; isCompleted(todo) ?</span><br><span class=\"line\">        &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; : todo.label</span><br><span class=\"line\">    &#125; /&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/05/14/React开发常用设计模式-组合-composition/react_8.png\" alt=\"运行结果\"></p>\n<p>这两种模式 将函数作为 <code>children</code> 传入 和 <code>render prop</code> 是我最新非常喜欢的。当我们想要复用代码时，它们提供了灵活性和帮助。它们还是抽象命令式代码的强力方式。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataProvider</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; data: null &#125;;</span><br><span class=\"line\">    setTimeout(() =&gt; this.setState(&#123; data: 'Hey there!' &#125;), 5000);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.data === null) <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;section&gt;&#123; <span class=\"keyword\">this</span>.props.render(<span class=\"keyword\">this</span>.state.data) &#125;&lt;/section&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DataProvider</code> 刚开始不渲染任何内容。5 秒后我们更新了组件的状态并渲染出一个<code>&lt;section&gt;</code>，<code>&lt;section&gt;</code> 的内容是由 <code>render</code> 属性返回的。可以想象一下同样的组件，数据是从远程服务器获取的，我们只想数据获取后才进行显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;DataProvider render=&#123; data =&gt; &lt;p&gt;The data is here!&lt;/p&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>我们描述了我们想要做的事，而不是如何去做。细节都封装在了 <code>DataProvider</code> 中。最近，使用这种模式，某些界面限制只对具有 <code>read:products</code> 权限的用户开放。我们使用的是<code>render prop</code> 模式。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Authorize</span><br><span class=\"line\">  permissionsInclude=&#123;[ 'read:products' ]&#125;</span><br><span class=\"line\">  render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  这种声明式的方式相当不错，不言自明。<code>Authorize</code> 会进行认证，以检查当前用户是否具有权限。如果用户具有读取产品列表的权限，那么我们便渲染 <code>ProductList</code>。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>  你是否对为何还在使用 HTML 感到奇怪？HTML 是在互联网创建之初创建的，直到现在我们仍然在使用它。原因在于它的高度可组合性。React 和它的 JSX 看起来像进化的 HTML ，因此它具备同样的功能。因此，请确保精通组合，因为它是 React 最大的好处之一。</p>"},{"title":"React开发常用设计模式-集成第三方库","date":"2018-06-14T15:49:58.000Z","description":null,"copyright":true,"top":null,"_content":"React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 集成第三方库\n接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。\n\n## 示例\n\n这个示例挑选了 [tag-it](https://github.com/aehlke/tag-it) 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：\n\n```h\n<ul>\n  <li>JavaScript</li>\n  <li>CSS</li>\n</ul>\n\n```\n转换成:\n\n![react](http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png)\n\n要运行起来，需要引入 `jQueyr、jQuery UI 和 tag-it `插件。这是运行的代码\n```h\n$('<dom element selector>').tagit();\n```\n选择 DOM 元素，然后调用 `tagit()` 。\n\n现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:\n\n```h\n// Tags.jsx\nclass Tags extends React.Component {\n  render() {\n    return (\n      <ul>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        )\n      }\n      </ul>\n    );\n  }\n};\n\n// App.jsx\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { tags: ['JavaScript', 'CSS' ] };\n  }\n  render() {\n    return (\n      <div>\n        <Tags tags={ this.state.tags } />\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<App />, document.querySelector('#container'));\n```\nApp 类是入口。它使用了` Tags `组件，Tags 组件会根据传入的 `tags` 属性来展示无序列表。当 React 在页面上渲染列表时就有了` <ul> `标签，这样就可以和 `jQuery` 插件连接起来。\n\n## 强制单通道渲染\n\n首先，要做的就是强制 `Tags` 组件进行单通道渲染。这是因为当 React 在实际 `DOM `中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 `shouldComponentUpdate`，像这样:\n```h\n\nclass Tags extends React.Component {\n  shouldComponentUpdate() {\n    return false;\n  }\n  ...\n\n```\n这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 `shouldComponentUpdate` 对于 React 组件来说，是让其知道是否触发 `render` 方法。这适用于的场景，因为想使用 React 来添加 `HTML` 标记，添加完后就不想再依靠 React 。\n\n## 初始化插件\nReact 提供了 [API](https://facebook.github.io/react/docs/refs-and-the-dom.html) 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。\n\n```h\nclass Tags extends React.Component {\n  ...\n  componentDidMount() {\n    this.list = $(this.refs.list);\n    this.list.tagit();\n  }\n  render() {\n    return (\n      <ul ref='list'>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        )\n      }\n      </ul>\n    );\n  }\n  ...\n  ```\n上面的代码和 `shouldComponentUpdate` 一起使用就会使 React 渲染出有两项的 `<ul> `，然后 `tag-it` 会其转换成标签可编辑的插件。\n\n## 使用 React 控制插件\n\n假如说我们想要通过代码来为已经运行的 `tag-it` 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 `Tags` 组件，但同时还要保持单通道渲染。\n\n为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 `Tags` 组件。\n\n```h\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this._addNewTag = this._addNewTag.bind(this);\n    this.state = {\n      tags: ['JavaScript', 'CSS' ],\n      newTag: null\n    };\n  }\n  _addNewTag() {\n    this.setState({ newTag: this.refs.field.value });\n  }\n  render() {\n    return (\n      <div>\n        <p>Add new tag:</p>\n        <div>\n          <input type='text' ref='field' />\n          <button onClick={ this._addNewTag }>Add</button>\n        </div>\n        <Tags\n          tags={ this.state.tags }\n          newTag={ this.state.newTag } />\n      </div>\n    );\n  }\n}\n\n```\n我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 `Tags` 组件的重新渲染。但由于 `shouldComponentUpdate `的存在，页面上不会有任何的更新。唯一的变化就是得到 `newTag `属性的新值，另一个生命周期方法 `componentWillReceiveProps` 会捕获到属性的新值:\n\n```h\nclass Tags extends React.Component {\n  ...\n  componentWillReceiveProps(newProps) {\n    this.list.tagit('createTag', newProps.newTag);\n  }\n  ...\n```\n`.tagit('createTag', newProps.newTag) `是纯粹的 jQuery 代码。如果想调用第三方库的方法，`componentWillReceiveProps `是个不错的选择。\n\n下面是 Tags 组件的完整代码:\n\n```h\nclass Tags extends React.Component {\n  componentDidMount() {\n    this.list = $(this.refs.list);\n    this.list.tagit();\n  }\n  shouldComponentUpdate() {\n    return false;\n  }\n  componentWillReceiveProps(newProps) {\n    this.list.tagit('createTag', newProps.newTag);\n  }\n  render() {\n    return (\n      <ul ref='list'>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        ) \n      }\n      </ul>\n    );\n  }\n};\n\n```\n\n# 结语\n\n尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。\n\n# 总结\n\nReact 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。","source":"_posts/React开发常用设计模式-集成第三方库.md","raw":"---\ntitle: React开发常用设计模式-集成第三方库\ndate: 2018-06-14 23:49:58\ntags: [React,Javascript]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\nReact 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。\n\n![React](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png)\n\n<!--more-->\n\n# 集成第三方库\n接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。\n\n## 示例\n\n这个示例挑选了 [tag-it](https://github.com/aehlke/tag-it) 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：\n\n```h\n<ul>\n  <li>JavaScript</li>\n  <li>CSS</li>\n</ul>\n\n```\n转换成:\n\n![react](http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png)\n\n要运行起来，需要引入 `jQueyr、jQuery UI 和 tag-it `插件。这是运行的代码\n```h\n$('<dom element selector>').tagit();\n```\n选择 DOM 元素，然后调用 `tagit()` 。\n\n现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:\n\n```h\n// Tags.jsx\nclass Tags extends React.Component {\n  render() {\n    return (\n      <ul>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        )\n      }\n      </ul>\n    );\n  }\n};\n\n// App.jsx\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { tags: ['JavaScript', 'CSS' ] };\n  }\n  render() {\n    return (\n      <div>\n        <Tags tags={ this.state.tags } />\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<App />, document.querySelector('#container'));\n```\nApp 类是入口。它使用了` Tags `组件，Tags 组件会根据传入的 `tags` 属性来展示无序列表。当 React 在页面上渲染列表时就有了` <ul> `标签，这样就可以和 `jQuery` 插件连接起来。\n\n## 强制单通道渲染\n\n首先，要做的就是强制 `Tags` 组件进行单通道渲染。这是因为当 React 在实际 `DOM `中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 `shouldComponentUpdate`，像这样:\n```h\n\nclass Tags extends React.Component {\n  shouldComponentUpdate() {\n    return false;\n  }\n  ...\n\n```\n这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 `shouldComponentUpdate` 对于 React 组件来说，是让其知道是否触发 `render` 方法。这适用于的场景，因为想使用 React 来添加 `HTML` 标记，添加完后就不想再依靠 React 。\n\n## 初始化插件\nReact 提供了 [API](https://facebook.github.io/react/docs/refs-and-the-dom.html) 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。\n\n```h\nclass Tags extends React.Component {\n  ...\n  componentDidMount() {\n    this.list = $(this.refs.list);\n    this.list.tagit();\n  }\n  render() {\n    return (\n      <ul ref='list'>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        )\n      }\n      </ul>\n    );\n  }\n  ...\n  ```\n上面的代码和 `shouldComponentUpdate` 一起使用就会使 React 渲染出有两项的 `<ul> `，然后 `tag-it` 会其转换成标签可编辑的插件。\n\n## 使用 React 控制插件\n\n假如说我们想要通过代码来为已经运行的 `tag-it` 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 `Tags` 组件，但同时还要保持单通道渲染。\n\n为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 `Tags` 组件。\n\n```h\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this._addNewTag = this._addNewTag.bind(this);\n    this.state = {\n      tags: ['JavaScript', 'CSS' ],\n      newTag: null\n    };\n  }\n  _addNewTag() {\n    this.setState({ newTag: this.refs.field.value });\n  }\n  render() {\n    return (\n      <div>\n        <p>Add new tag:</p>\n        <div>\n          <input type='text' ref='field' />\n          <button onClick={ this._addNewTag }>Add</button>\n        </div>\n        <Tags\n          tags={ this.state.tags }\n          newTag={ this.state.newTag } />\n      </div>\n    );\n  }\n}\n\n```\n我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 `Tags` 组件的重新渲染。但由于 `shouldComponentUpdate `的存在，页面上不会有任何的更新。唯一的变化就是得到 `newTag `属性的新值，另一个生命周期方法 `componentWillReceiveProps` 会捕获到属性的新值:\n\n```h\nclass Tags extends React.Component {\n  ...\n  componentWillReceiveProps(newProps) {\n    this.list.tagit('createTag', newProps.newTag);\n  }\n  ...\n```\n`.tagit('createTag', newProps.newTag) `是纯粹的 jQuery 代码。如果想调用第三方库的方法，`componentWillReceiveProps `是个不错的选择。\n\n下面是 Tags 组件的完整代码:\n\n```h\nclass Tags extends React.Component {\n  componentDidMount() {\n    this.list = $(this.refs.list);\n    this.list.tagit();\n  }\n  shouldComponentUpdate() {\n    return false;\n  }\n  componentWillReceiveProps(newProps) {\n    this.list.tagit('createTag', newProps.newTag);\n  }\n  render() {\n    return (\n      <ul ref='list'>\n      { \n        this.props.tags.map(\n          (tag, i) => <li key={ i }>{ tag } </li>\n        ) \n      }\n      </ul>\n    );\n  }\n};\n\n```\n\n# 结语\n\n尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。\n\n# 总结\n\nReact 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。","slug":"React开发常用设计模式-集成第三方库","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnee0024kt89zn8g8t8w","content":"<p>React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>\n<a id=\"more\"></a>\n<h1 id=\"集成第三方库\"><a href=\"#集成第三方库\" class=\"headerlink\" title=\"集成第三方库\"></a>集成第三方库</h1><p>接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>这个示例挑选了 <a href=\"https://github.com/aehlke/tag-it\" target=\"_blank\" rel=\"noopener\">tag-it</a> 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;JavaScript&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;CSS&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>转换成:</p>\n<p><img src=\"http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png\" alt=\"react\"></p>\n<p>要运行起来，需要引入 <code>jQueyr、jQuery UI 和 tag-it</code>插件。这是运行的代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$('&lt;dom element selector&gt;').tagit();</span><br></pre></td></tr></table></figure></p>\n<p>选择 DOM 元素，然后调用 <code>tagit()</code> 。</p>\n<p>现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tags.jsx</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.state = &#123; tags: ['JavaScript', 'CSS' ] &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Tags tags=&#123; <span class=\"keyword\">this</span>.state.tags &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;App /&gt;, document.querySelector('#container'));</span><br></pre></td></tr></table></figure>\n<p>App 类是入口。它使用了<code>Tags</code>组件，Tags 组件会根据传入的 <code>tags</code> 属性来展示无序列表。当 React 在页面上渲染列表时就有了<code>&lt;ul&gt;</code>标签，这样就可以和 <code>jQuery</code> 插件连接起来。</p>\n<h2 id=\"强制单通道渲染\"><a href=\"#强制单通道渲染\" class=\"headerlink\" title=\"强制单通道渲染\"></a>强制单通道渲染</h2><p>首先，要做的就是强制 <code>Tags</code> 组件进行单通道渲染。这是因为当 React 在实际 <code>DOM</code>中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 <code>shouldComponentUpdate</code>，像这样:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  shouldComponentUpdate() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 <code>shouldComponentUpdate</code> 对于 React 组件来说，是让其知道是否触发 <code>render</code> 方法。这适用于的场景，因为想使用 React 来添加 <code>HTML</code> 标记，添加完后就不想再依靠 React 。</p>\n<h2 id=\"初始化插件\"><a href=\"#初始化插件\" class=\"headerlink\" title=\"初始化插件\"></a>初始化插件</h2><p>React 提供了 <a href=\"https://facebook.github.io/react/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"noopener\">API</a> 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span> = $(<span class=\"keyword\">this</span>.refs.<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span>.tagit();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul ref='list'&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>上面的代码和 <code>shouldComponentUpdate</code> 一起使用就会使 React 渲染出有两项的 <code>&lt;ul&gt;</code>，然后 <code>tag-it</code> 会其转换成标签可编辑的插件。</p>\n<h2 id=\"使用-React-控制插件\"><a href=\"#使用-React-控制插件\" class=\"headerlink\" title=\"使用 React 控制插件\"></a>使用 React 控制插件</h2><p>假如说我们想要通过代码来为已经运行的 <code>tag-it</code> 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 <code>Tags</code> 组件，但同时还要保持单通道渲染。</p>\n<p>为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 <code>Tags</code> 组件。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._addNewTag = <span class=\"keyword\">this</span>._addNewTag.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      tags: ['JavaScript', 'CSS' ],</span><br><span class=\"line\">      newTag: null</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _addNewTag() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; newTag: <span class=\"keyword\">this</span>.refs.field.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;Add <span class=\"keyword\">new</span> tag:&lt;/p&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;input type='text' ref='field' /&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123; <span class=\"keyword\">this</span>._addNewTag &#125;&gt;Add&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;Tags</span><br><span class=\"line\">          tags=&#123; <span class=\"keyword\">this</span>.state.tags &#125;</span><br><span class=\"line\">          newTag=&#123; <span class=\"keyword\">this</span>.state.newTag &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 <code>Tags</code> 组件的重新渲染。但由于 <code>shouldComponentUpdate</code>的存在，页面上不会有任何的更新。唯一的变化就是得到 <code>newTag</code>属性的新值，另一个生命周期方法 <code>componentWillReceiveProps</code> 会捕获到属性的新值:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  componentWillReceiveProps(newProps) &#123;</span><br><span class=\"line\">    this.list.tagit('createTag', newProps.newTag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p><code>.tagit(&#39;createTag&#39;, newProps.newTag)</code>是纯粹的 jQuery 代码。如果想调用第三方库的方法，<code>componentWillReceiveProps</code>是个不错的选择。</p>\n<p>下面是 Tags 组件的完整代码:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span> = $(<span class=\"keyword\">this</span>.refs.<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span>.tagit();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  shouldComponentUpdate() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillReceiveProps(newProps) &#123;</span><br><span class=\"line\">    this.list.tagit('createTag', newProps.newTag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul ref='list'&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        ) </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>React 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。</p>\n","site":{"data":{}},"excerpt":"<p>React 或许是构建 UI 的最佳选择之一。良好的设计与强大的支持，还有庞大的社区。但是，有些情况下，想要使用外部服务或想要集成一些完全不同的东西。众所周知，React 在底层与实际 DOM 有大量的交互并控制页面上渲染什么，基本上它是开发者与实际 DOM 间的桥梁。这也正是为什么 React 集成第三方组件有些麻烦的地方。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/react_d.png\" alt=\"React\"></p>","more":"<h1 id=\"集成第三方库\"><a href=\"#集成第三方库\" class=\"headerlink\" title=\"集成第三方库\"></a>集成第三方库</h1><p>接下来介绍如何安全地混用 React 和 jQuery 的 UI 插件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>这个示例挑选了 <a href=\"https://github.com/aehlke/tag-it\" target=\"_blank\" rel=\"noopener\">tag-it</a> 这个 jQuery 插件。它将无序列表转换成可以管理标签的输入框：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;JavaScript&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;CSS&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>转换成:</p>\n<p><img src=\"http://druilong.coding.me/blog/2018/06/11/React开发常用设计模式-Redux/tag-it.png\" alt=\"react\"></p>\n<p>要运行起来，需要引入 <code>jQueyr、jQuery UI 和 tag-it</code>插件。这是运行的代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$('&lt;dom element selector&gt;').tagit();</span><br></pre></td></tr></table></figure></p>\n<p>选择 DOM 元素，然后调用 <code>tagit()</code> 。</p>\n<p>现在，来创建一个简单的 React 应用，它将使用 jQuery 插件:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tags.jsx</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.state = &#123; tags: ['JavaScript', 'CSS' ] &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Tags tags=&#123; <span class=\"keyword\">this</span>.state.tags &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;App /&gt;, document.querySelector('#container'));</span><br></pre></td></tr></table></figure>\n<p>App 类是入口。它使用了<code>Tags</code>组件，Tags 组件会根据传入的 <code>tags</code> 属性来展示无序列表。当 React 在页面上渲染列表时就有了<code>&lt;ul&gt;</code>标签，这样就可以和 <code>jQuery</code> 插件连接起来。</p>\n<h2 id=\"强制单通道渲染\"><a href=\"#强制单通道渲染\" class=\"headerlink\" title=\"强制单通道渲染\"></a>强制单通道渲染</h2><p>首先，要做的就是强制 <code>Tags</code> 组件进行单通道渲染。这是因为当 React 在实际 <code>DOM</code>中添加完容器元素后，想将控制权交给 jQuery 。如果不做控制的话，那么 React 和 jQuery 将会操纵同一个 DOM 元素而彼此之间不知情。要实现单通道渲染，需要使用生命周期方法 <code>shouldComponentUpdate</code>，像这样:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  shouldComponentUpdate() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>这里永远都返回 false ，想让组件知道永远不进行重新渲染。定义 <code>shouldComponentUpdate</code> 对于 React 组件来说，是让其知道是否触发 <code>render</code> 方法。这适用于的场景，因为想使用 React 来添加 <code>HTML</code> 标记，添加完后就不想再依靠 React 。</p>\n<h2 id=\"初始化插件\"><a href=\"#初始化插件\" class=\"headerlink\" title=\"初始化插件\"></a>初始化插件</h2><p>React 提供了 <a href=\"https://facebook.github.io/react/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"noopener\">API</a> 来访问实际 DOM 节点。需要在相应的节点上使用 ref 属性，稍后可以通过 this.refs 来访问 DOM 。componentDidMount 是最适合初始化 tag-it 插件的生命周期方法。这是因为当 React 将 render 方法返回的结果挂载到 DOM 时才调用此方法。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span> = $(<span class=\"keyword\">this</span>.refs.<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span>.tagit();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul ref='list'&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>上面的代码和 <code>shouldComponentUpdate</code> 一起使用就会使 React 渲染出有两项的 <code>&lt;ul&gt;</code>，然后 <code>tag-it</code> 会其转换成标签可编辑的插件。</p>\n<h2 id=\"使用-React-控制插件\"><a href=\"#使用-React-控制插件\" class=\"headerlink\" title=\"使用 React 控制插件\"></a>使用 React 控制插件</h2><p>假如说我们想要通过代码来为已经运行的 <code>tag-it</code> 插件添加新标签。这种操作将由 React 组件触发，并需要使用 jQuery API 。我们需要找到一种方式将数据传递给 <code>Tags</code> 组件，但同时还要保持单通道渲染。</p>\n<p>为了说明整个过程，我们需要在 App 类中添加一个输入框和按钮，点击按钮时将输入框的值传给 <code>Tags</code> 组件。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._addNewTag = <span class=\"keyword\">this</span>._addNewTag.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      tags: ['JavaScript', 'CSS' ],</span><br><span class=\"line\">      newTag: null</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _addNewTag() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; newTag: <span class=\"keyword\">this</span>.refs.field.value &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;Add <span class=\"keyword\">new</span> tag:&lt;/p&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;input type='text' ref='field' /&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123; <span class=\"keyword\">this</span>._addNewTag &#125;&gt;Add&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;Tags</span><br><span class=\"line\">          tags=&#123; <span class=\"keyword\">this</span>.state.tags &#125;</span><br><span class=\"line\">          newTag=&#123; <span class=\"keyword\">this</span>.state.newTag &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用内部状态来存储新添加的标签名称。每次点击按钮时，我就更新状态并触发 <code>Tags</code> 组件的重新渲染。但由于 <code>shouldComponentUpdate</code>的存在，页面上不会有任何的更新。唯一的变化就是得到 <code>newTag</code>属性的新值，另一个生命周期方法 <code>componentWillReceiveProps</code> 会捕获到属性的新值:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  componentWillReceiveProps(newProps) &#123;</span><br><span class=\"line\">    this.list.tagit('createTag', newProps.newTag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p><code>.tagit(&#39;createTag&#39;, newProps.newTag)</code>是纯粹的 jQuery 代码。如果想调用第三方库的方法，<code>componentWillReceiveProps</code>是个不错的选择。</p>\n<p>下面是 Tags 组件的完整代码:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tags</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span> = $(<span class=\"keyword\">this</span>.refs.<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">list</span>.tagit();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  shouldComponentUpdate() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillReceiveProps(newProps) &#123;</span><br><span class=\"line\">    this.list.tagit('createTag', newProps.newTag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul ref='list'&gt;</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.tags.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">          (tag, i) =&gt; &lt;li key=&#123; i &#125;&gt;&#123; tag &#125; &lt;/li&gt;</span><br><span class=\"line\">        ) </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>尽管 React 承担了操纵 DOM 树的工作，但仍可以集成第三方的库和服务。生命周期方法让在渲染过程中可以进行足够的控制，这样才能够完美地连接 React 和非 React 世界。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>React 已然成为最流行的 UI 构建库。它自带的 API 很棒，简单而强大。麻烦的部分是构建复杂应用的话， React 本身往往并不足够。有些概念必须要知道，才能做出正确的选择。由社区所提出的这些设计模式在大规模应用中运行良好。</p>"},{"title":"Hello World","date":"2018-05-01T16:46:29.000Z","description":null,"copyright":true,"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-05-02 00:46:29\ntags: 生活\ndescription: \ncopyright: true\ncategories: Hexo\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-09-20T02:27:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnef0028kt895an3mmo6","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><a id=\"more\"></a>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"iTerm2 + oh my zsh打造最强Mac终端","date":"2018-07-22T14:53:37.000Z","description":null,"copyright":true,"top":null,"_content":"iTerm2 + oh my zsh 打造最强Mac终端\n\n![iTerm2](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg)\n\n<!-- more -->\n\n#安装iTerm2\niTerm2官方下载地址 [http://www.iterm2.com/downloads.html](http://www.iterm2.com/downloads.html)\n\n#安装 oh-my-zsh\n\n```h\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh \n```\n\n\n#配置\n创建配置文件\n```h\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\n# 设置zsh为默认的shell\n\n`chsh -s /bin/zsh`\n\n此时，zsh已经安装成功 \n\n接来下，可以去https://github.com/robbyrussell/oh-my-zsh/wiki/themes 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。 ","source":"_posts/iTerm2-oh-my-zsh-agnoster-打造最强Mac终端.md","raw":"---\ntitle: iTerm2 + oh my zsh打造最强Mac终端\ndate: 2018-07-22 22:53:37\ntags: [软件,编程]\ndescription: \ncopyright: true\ncategories: 软件\ntop:\n---\niTerm2 + oh my zsh 打造最强Mac终端\n\n![iTerm2](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg)\n\n<!-- more -->\n\n#安装iTerm2\niTerm2官方下载地址 [http://www.iterm2.com/downloads.html](http://www.iterm2.com/downloads.html)\n\n#安装 oh-my-zsh\n\n```h\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh \n```\n\n\n#配置\n创建配置文件\n```h\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\n# 设置zsh为默认的shell\n\n`chsh -s /bin/zsh`\n\n此时，zsh已经安装成功 \n\n接来下，可以去https://github.com/robbyrussell/oh-my-zsh/wiki/themes 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。 ","slug":"iTerm2-oh-my-zsh-agnoster-打造最强Mac终端","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctneg002bkt89bs4oz5jr","content":"<p>iTerm2 + oh my zsh 打造最强Mac终端</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg\" alt=\"iTerm2\"></p>\n<a id=\"more\"></a>\n<p>#安装iTerm2<br>iTerm2官方下载地址 <a href=\"http://www.iterm2.com/downloads.html\" target=\"_blank\" rel=\"noopener\">http://www.iterm2.com/downloads.html</a></p>\n<p>#安装 oh-my-zsh</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https:<span class=\"comment\">//raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span></span><br></pre></td></tr></table></figure>\n<p>#配置<br>创建配置文件<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-<span class=\"keyword\">template</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"设置zsh为默认的shell\"><a href=\"#设置zsh为默认的shell\" class=\"headerlink\" title=\"设置zsh为默认的shell\"></a>设置zsh为默认的shell</h1><p><code>chsh -s /bin/zsh</code></p>\n<p>此时，zsh已经安装成功 </p>\n<p>接来下，可以去<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a> 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。 </p>\n","site":{"data":{}},"excerpt":"<p>iTerm2 + oh my zsh 打造最强Mac终端</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/logo2x.jpg\" alt=\"iTerm2\"></p>","more":"<p>#安装iTerm2<br>iTerm2官方下载地址 <a href=\"http://www.iterm2.com/downloads.html\" target=\"_blank\" rel=\"noopener\">http://www.iterm2.com/downloads.html</a></p>\n<p>#安装 oh-my-zsh</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https:<span class=\"comment\">//raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span></span><br></pre></td></tr></table></figure>\n<p>#配置<br>创建配置文件<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-<span class=\"keyword\">template</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"设置zsh为默认的shell\"><a href=\"#设置zsh为默认的shell\" class=\"headerlink\" title=\"设置zsh为默认的shell\"></a>设置zsh为默认的shell</h1><p><code>chsh -s /bin/zsh</code></p>\n<p>此时，zsh已经安装成功 </p>\n<p>接来下，可以去<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a> 上下载一些zsh的主题，放置在 ~/.oh-my-zsh/themes 目录目录下，并在配置文件.zshrc中进行适当的配置。其实，默认情况下，themes目录下已有很多样式。 </p>"},{"title":"mongodb数据库的使用","date":"2018-05-20T16:05:33.000Z","description":null,"copyright":true,"top":null,"_content":"\n突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png)\n\n<!-- more -->\n\n\n# 一、mongodb的开启和关闭\n## 1. 查找mongod是否可用\n`which mongod`\n\n## 2. 启动mongodb\n指定path 和log日志 \n`mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log`\n\n## 3. 关闭数据库\n`mongod --shutdown`\n\n# 二、mongodb的操作\n## 1. 连接服务器\n`mongod 115.29.137.34:27017`\n\n## 2. 使用数据库\n(不存在的数据库也可以使用,插入数据之后会自动保存) \n`use mydb`\n\n## 3. 权限登陆\n`db.auth('username','password')`\n\n## 4. 展示数据库列表\n`show dbs`\n\n## 5. 插入数据\n(类似于mysql的表) \n`db.users.insert({'name':'xiaomo'}) `\n`db.users.insert({'name':'xiaoming','age':25}) `\n`db.users.insert({'name':'xiaoming','age':24,'sex':'女'})`\n\n## 6. 查询集合\n(前提是use了一个数据库) \n有一个System.indexes 是索引\n`show collections`\n\n## 7. 不带条件查询\n`db.users.find()`\n\n## 8. 带条件查询\n(参数是一个对象) \n`db.users.find({'name':'xiaomo'})`\n\n## 9. 更新数据\n(有三个参数,1:查询条件,2:更新的内容 3：更新的配置) \n`db.users.update({'name':'xiaomo',{$set:{'name:'xm}}) `修改满足条件的第一条数据 \n`db.users.update({'name':'xiaomo',{$set:{'name:'xm}},{multi:true}) `修改所有满足条件的数据\n\n## 10. 保存数据\n(只有一个参数，必须要传id，后面是要修改的数据) \n`db.users.save({'id':'objectId(574710a97a3afd63cde56a49)','age':30})`\n\n## 11. 删除数据\n(1:条件 2 是否删除所有符合条件的) \n`db.users.remove({'name':'xiaomoing'},true)`\n\n## 12. 删除集合\n`db.users.drop()`\n\n# 三、使用mongoose操作数据库\n## 1. 模块的介绍\n连接mongdodb的驱动\n\n## 2. 配置和链接\n`npm install --save mongoose`\n```h\n  var mongoose = require('mongoose');\n  <!-- var uri = 'mongodb://username:password@hostname:port/databasename'; -->\n  var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';\n  mongoose.connect(uri);\n```\n## 3. Model 和Shema\n\n```h\n // model.js\nvar Schema = mongoose.Schema,\n    ObjectId = Schema.ObjectId;\n\nvar BlogPost = new Schema({\n    author    : ObjectId,\n    title     : String,\n    body      : String,\n    date      : Date\n});\n\n//Model\nmongoose.model('blog',Schema);\n\nvar Comment = new Schema({\n  name: { type: String, default: 'hahaha' },\n  age: { type: Number, min: 18, index: true },\n  bio: { type: String, match: /[a-z]/ },\n  date: { type: Date, default: Date.now }\n});\n\n// a setter\nComment.path('name').set(function (v) {\n  return capitalize(v);\n});\n\n// middleware\nComment.pre('save', function (next) {\n  notify(this.get('email'));\n  next();\n});\n```\n## 4. 创建文档\n```h\n  //insert.js\n  var mongoose ＝ require('mongoose');\n  require('./model.js'); //执行\n  var Blog = mongoose.model('blog');\n  var blog = new Blog({\n      name:'xiaomo',\n      age:25,\n      bio:'don't know',\n      date:new Date\n    });\n\n  book.save(function(err){\n      console.log('save status:'+err);\n    });\n```\n## 5. 删除文档\n\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.findOne({'name':'xiaomo'},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    if(doc){\n    doc.reomove();\n  }\n    })\n```\n## 6. 简单查询\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.find({},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n第一个满足条件的结果\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.findOne({'name':'xiaomo'},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n## 7. 条件语句\n```h\n // condation.js\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  //名字是xiaomo或者xiaoming 可以用$or和$and\n  var condation = {\n    $or  $and:[\n    {'name':'xiaomo'},\n    {'name':'xiaoming'}\n    ]\n  }\n  Blog.find(condation,function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n# 三、在项目中使用mongoose\n## 1. 生成项目\n`koa koatest -e koatest`\n\n## 2. 安装依赖\n`cd koatest && npm install`\n\n## 3. 安装mongoose\n`npm install --save mongoose`\n\n## 4. 创建模型\n```h\n  // models/users.server.model.js\n  var mongoose = require('mongoose');\n  var UserSchema = new mongoose.Schema({\n      uid:Number,\n      username:String,\n      createTime:Date,\n      lastLogin:Date\n    })\n  module.exports = mongoose.model('User',UserSchema);\n```\n## 5. 创建配置文件\n```h\n  // config/config.js\n  module.exports={\n    mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'\n  }\n  //config/mongoose.js\n  var mongoose = require('mongoose');\n  var config = require('./config.js');\n\n  module.exports=function(){\n    var db = mongoose.connect(config.mongodb);\n    require('./../models/users.server.model.js');\n    return db;\n  }\n```\n## 6. 操作mongdodb 代码\n```h\n  //routers/users.js\n  var router = require('koa-router')();\n  var mongoose = require('mongoose');\n  var User = mongoose.model('User');\n  router.get('/', function *(next) {\n      //add\n      var user = new User({\n        uid:\n        })\n      this.body = yield User.find({});\n  });\n  module.exports = router;\n  ```\n\n  嗯嗯,就这样吧，完！","source":"_posts/mongodb数据库的使用.md","raw":"---\ntitle: mongodb数据库的使用\ndate: 2018-05-21 00:05:33\ntags: [mongoDB,Javascript,Node]\ndescription: \ncopyright: true\ncategories: mongoDB\ntop:\n---\n\n突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png)\n\n<!-- more -->\n\n\n# 一、mongodb的开启和关闭\n## 1. 查找mongod是否可用\n`which mongod`\n\n## 2. 启动mongodb\n指定path 和log日志 \n`mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log`\n\n## 3. 关闭数据库\n`mongod --shutdown`\n\n# 二、mongodb的操作\n## 1. 连接服务器\n`mongod 115.29.137.34:27017`\n\n## 2. 使用数据库\n(不存在的数据库也可以使用,插入数据之后会自动保存) \n`use mydb`\n\n## 3. 权限登陆\n`db.auth('username','password')`\n\n## 4. 展示数据库列表\n`show dbs`\n\n## 5. 插入数据\n(类似于mysql的表) \n`db.users.insert({'name':'xiaomo'}) `\n`db.users.insert({'name':'xiaoming','age':25}) `\n`db.users.insert({'name':'xiaoming','age':24,'sex':'女'})`\n\n## 6. 查询集合\n(前提是use了一个数据库) \n有一个System.indexes 是索引\n`show collections`\n\n## 7. 不带条件查询\n`db.users.find()`\n\n## 8. 带条件查询\n(参数是一个对象) \n`db.users.find({'name':'xiaomo'})`\n\n## 9. 更新数据\n(有三个参数,1:查询条件,2:更新的内容 3：更新的配置) \n`db.users.update({'name':'xiaomo',{$set:{'name:'xm}}) `修改满足条件的第一条数据 \n`db.users.update({'name':'xiaomo',{$set:{'name:'xm}},{multi:true}) `修改所有满足条件的数据\n\n## 10. 保存数据\n(只有一个参数，必须要传id，后面是要修改的数据) \n`db.users.save({'id':'objectId(574710a97a3afd63cde56a49)','age':30})`\n\n## 11. 删除数据\n(1:条件 2 是否删除所有符合条件的) \n`db.users.remove({'name':'xiaomoing'},true)`\n\n## 12. 删除集合\n`db.users.drop()`\n\n# 三、使用mongoose操作数据库\n## 1. 模块的介绍\n连接mongdodb的驱动\n\n## 2. 配置和链接\n`npm install --save mongoose`\n```h\n  var mongoose = require('mongoose');\n  <!-- var uri = 'mongodb://username:password@hostname:port/databasename'; -->\n  var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';\n  mongoose.connect(uri);\n```\n## 3. Model 和Shema\n\n```h\n // model.js\nvar Schema = mongoose.Schema,\n    ObjectId = Schema.ObjectId;\n\nvar BlogPost = new Schema({\n    author    : ObjectId,\n    title     : String,\n    body      : String,\n    date      : Date\n});\n\n//Model\nmongoose.model('blog',Schema);\n\nvar Comment = new Schema({\n  name: { type: String, default: 'hahaha' },\n  age: { type: Number, min: 18, index: true },\n  bio: { type: String, match: /[a-z]/ },\n  date: { type: Date, default: Date.now }\n});\n\n// a setter\nComment.path('name').set(function (v) {\n  return capitalize(v);\n});\n\n// middleware\nComment.pre('save', function (next) {\n  notify(this.get('email'));\n  next();\n});\n```\n## 4. 创建文档\n```h\n  //insert.js\n  var mongoose ＝ require('mongoose');\n  require('./model.js'); //执行\n  var Blog = mongoose.model('blog');\n  var blog = new Blog({\n      name:'xiaomo',\n      age:25,\n      bio:'don't know',\n      date:new Date\n    });\n\n  book.save(function(err){\n      console.log('save status:'+err);\n    });\n```\n## 5. 删除文档\n\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.findOne({'name':'xiaomo'},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    if(doc){\n    doc.reomove();\n  }\n    })\n```\n## 6. 简单查询\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.find({},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n第一个满足条件的结果\n```h\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  Blog.findOne({'name':'xiaomo'},function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n## 7. 条件语句\n```h\n // condation.js\n  var mongoose = require('mongoose');\n  require('./model.js');\n  var Blog = mongoose.model('blog');\n  //名字是xiaomo或者xiaoming 可以用$or和$and\n  var condation = {\n    $or  $and:[\n    {'name':'xiaomo'},\n    {'name':'xiaoming'}\n    ]\n  }\n  Blog.find(condation,function(err,doc){\n    if(err){\n    console.log(err)\n    return;\n    }\n    console.log('result',doc)\n    })\n```\n# 三、在项目中使用mongoose\n## 1. 生成项目\n`koa koatest -e koatest`\n\n## 2. 安装依赖\n`cd koatest && npm install`\n\n## 3. 安装mongoose\n`npm install --save mongoose`\n\n## 4. 创建模型\n```h\n  // models/users.server.model.js\n  var mongoose = require('mongoose');\n  var UserSchema = new mongoose.Schema({\n      uid:Number,\n      username:String,\n      createTime:Date,\n      lastLogin:Date\n    })\n  module.exports = mongoose.model('User',UserSchema);\n```\n## 5. 创建配置文件\n```h\n  // config/config.js\n  module.exports={\n    mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'\n  }\n  //config/mongoose.js\n  var mongoose = require('mongoose');\n  var config = require('./config.js');\n\n  module.exports=function(){\n    var db = mongoose.connect(config.mongodb);\n    require('./../models/users.server.model.js');\n    return db;\n  }\n```\n## 6. 操作mongdodb 代码\n```h\n  //routers/users.js\n  var router = require('koa-router')();\n  var mongoose = require('mongoose');\n  var User = mongoose.model('User');\n  router.get('/', function *(next) {\n      //add\n      var user = new User({\n        uid:\n        })\n      this.body = yield User.find({});\n  });\n  module.exports = router;\n  ```\n\n  嗯嗯,就这样吧，完！","slug":"mongodb数据库的使用","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnej002fkt895cgwv1wk","content":"<p>突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"一、mongodb的开启和关闭\"><a href=\"#一、mongodb的开启和关闭\" class=\"headerlink\" title=\"一、mongodb的开启和关闭\"></a>一、mongodb的开启和关闭</h1><h2 id=\"1-查找mongod是否可用\"><a href=\"#1-查找mongod是否可用\" class=\"headerlink\" title=\"1. 查找mongod是否可用\"></a>1. 查找mongod是否可用</h2><p><code>which mongod</code></p>\n<h2 id=\"2-启动mongodb\"><a href=\"#2-启动mongodb\" class=\"headerlink\" title=\"2. 启动mongodb\"></a>2. 启动mongodb</h2><p>指定path 和log日志<br><code>mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log</code></p>\n<h2 id=\"3-关闭数据库\"><a href=\"#3-关闭数据库\" class=\"headerlink\" title=\"3. 关闭数据库\"></a>3. 关闭数据库</h2><p><code>mongod --shutdown</code></p>\n<h1 id=\"二、mongodb的操作\"><a href=\"#二、mongodb的操作\" class=\"headerlink\" title=\"二、mongodb的操作\"></a>二、mongodb的操作</h1><h2 id=\"1-连接服务器\"><a href=\"#1-连接服务器\" class=\"headerlink\" title=\"1. 连接服务器\"></a>1. 连接服务器</h2><p><code>mongod 115.29.137.34:27017</code></p>\n<h2 id=\"2-使用数据库\"><a href=\"#2-使用数据库\" class=\"headerlink\" title=\"2. 使用数据库\"></a>2. 使用数据库</h2><p>(不存在的数据库也可以使用,插入数据之后会自动保存)<br><code>use mydb</code></p>\n<h2 id=\"3-权限登陆\"><a href=\"#3-权限登陆\" class=\"headerlink\" title=\"3. 权限登陆\"></a>3. 权限登陆</h2><p><code>db.auth(&#39;username&#39;,&#39;password&#39;)</code></p>\n<h2 id=\"4-展示数据库列表\"><a href=\"#4-展示数据库列表\" class=\"headerlink\" title=\"4. 展示数据库列表\"></a>4. 展示数据库列表</h2><p><code>show dbs</code></p>\n<h2 id=\"5-插入数据\"><a href=\"#5-插入数据\" class=\"headerlink\" title=\"5. 插入数据\"></a>5. 插入数据</h2><p>(类似于mysql的表)<br><code>db.users.insert({&#39;name&#39;:&#39;xiaomo&#39;})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:25})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:24,&#39;sex&#39;:&#39;女&#39;})</code></p>\n<h2 id=\"6-查询集合\"><a href=\"#6-查询集合\" class=\"headerlink\" title=\"6. 查询集合\"></a>6. 查询集合</h2><p>(前提是use了一个数据库)<br>有一个System.indexes 是索引<br><code>show collections</code></p>\n<h2 id=\"7-不带条件查询\"><a href=\"#7-不带条件查询\" class=\"headerlink\" title=\"7. 不带条件查询\"></a>7. 不带条件查询</h2><p><code>db.users.find()</code></p>\n<h2 id=\"8-带条件查询\"><a href=\"#8-带条件查询\" class=\"headerlink\" title=\"8. 带条件查询\"></a>8. 带条件查询</h2><p>(参数是一个对象)<br><code>db.users.find({&#39;name&#39;:&#39;xiaomo&#39;})</code></p>\n<h2 id=\"9-更新数据\"><a href=\"#9-更新数据\" class=\"headerlink\" title=\"9. 更新数据\"></a>9. 更新数据</h2><p>(有三个参数,1:查询条件,2:更新的内容 3：更新的配置)<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}})</code>修改满足条件的第一条数据<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}},{multi:true})</code>修改所有满足条件的数据</p>\n<h2 id=\"10-保存数据\"><a href=\"#10-保存数据\" class=\"headerlink\" title=\"10. 保存数据\"></a>10. 保存数据</h2><p>(只有一个参数，必须要传id，后面是要修改的数据)<br><code>db.users.save({&#39;id&#39;:&#39;objectId(574710a97a3afd63cde56a49)&#39;,&#39;age&#39;:30})</code></p>\n<h2 id=\"11-删除数据\"><a href=\"#11-删除数据\" class=\"headerlink\" title=\"11. 删除数据\"></a>11. 删除数据</h2><p>(1:条件 2 是否删除所有符合条件的)<br><code>db.users.remove({&#39;name&#39;:&#39;xiaomoing&#39;},true)</code></p>\n<h2 id=\"12-删除集合\"><a href=\"#12-删除集合\" class=\"headerlink\" title=\"12. 删除集合\"></a>12. 删除集合</h2><p><code>db.users.drop()</code></p>\n<h1 id=\"三、使用mongoose操作数据库\"><a href=\"#三、使用mongoose操作数据库\" class=\"headerlink\" title=\"三、使用mongoose操作数据库\"></a>三、使用mongoose操作数据库</h1><h2 id=\"1-模块的介绍\"><a href=\"#1-模块的介绍\" class=\"headerlink\" title=\"1. 模块的介绍\"></a>1. 模块的介绍</h2><p>连接mongdodb的驱动</p>\n<h2 id=\"2-配置和链接\"><a href=\"#2-配置和链接\" class=\"headerlink\" title=\"2. 配置和链接\"></a>2. 配置和链接</h2><p><code>npm install --save mongoose</code><br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">&lt;!-- var uri = 'mongodb://username:password@hostname:port/databasename'; --&gt;</span><br><span class=\"line\">var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';</span><br><span class=\"line\">mongoose.connect(uri);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Model-和Shema\"><a href=\"#3-Model-和Shema\" class=\"headerlink\" title=\"3. Model 和Shema\"></a>3. Model 和Shema</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// model.js</span></span><br><span class=\"line\">var Schema = mongoose.Schema,</span><br><span class=\"line\">    ObjectId = Schema.ObjectId;</span><br><span class=\"line\"></span><br><span class=\"line\">var BlogPost = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">    author    : ObjectId,</span><br><span class=\"line\">    title     : String,</span><br><span class=\"line\">    body      : String,</span><br><span class=\"line\">    date      : Date</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Model</span></span><br><span class=\"line\">mongoose.model('blog',Schema);</span><br><span class=\"line\"></span><br><span class=\"line\">var Comment = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">  name: &#123; type: String, default: 'hahaha' &#125;,</span><br><span class=\"line\">  age: &#123; type: Number, min: <span class=\"number\">18</span>, index: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  bio: &#123; type: String, match: /[a-z]/ &#125;,</span><br><span class=\"line\">  date: &#123; type: Date, <span class=\"keyword\">default</span>: Date.now &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a setter</span></span><br><span class=\"line\">Comment.path('name').set(function (v) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> capitalize(v);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">Comment.pre('save', function (next) &#123;</span><br><span class=\"line\">  notify(this.get('email'));</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-创建文档\"><a href=\"#4-创建文档\" class=\"headerlink\" title=\"4. 创建文档\"></a>4. 创建文档</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//insert.js</span></span><br><span class=\"line\">var mongoose ＝ require('mongoose');</span><br><span class=\"line\">require('./model.js'); //执行</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">var blog = <span class=\"keyword\">new</span> Blog(&#123;</span><br><span class=\"line\">    name:'xiaomo',</span><br><span class=\"line\">    age:<span class=\"number\">25</span>,</span><br><span class=\"line\">    bio:'don't know',</span><br><span class=\"line\">    date:<span class=\"keyword\">new</span> Date</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.save(function(err)&#123;</span><br><span class=\"line\">    console.log('save status:'+err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-删除文档\"><a href=\"#5-删除文档\" class=\"headerlink\" title=\"5. 删除文档\"></a>5. 删除文档</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(doc)&#123;</span><br><span class=\"line\">  doc.reomove();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-简单查询\"><a href=\"#6-简单查询\" class=\"headerlink\" title=\"6. 简单查询\"></a>6. 简单查询</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.find(&#123;&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log('result',doc)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>第一个满足条件的结果<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log('result',doc)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-条件语句\"><a href=\"#7-条件语句\" class=\"headerlink\" title=\"7. 条件语句\"></a>7. 条件语句</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// condation.js</span></span><br><span class=\"line\"> var mongoose = require('mongoose');</span><br><span class=\"line\"> require('./model.js');</span><br><span class=\"line\"> var Blog = mongoose.model('blog');</span><br><span class=\"line\"> <span class=\"comment\">//名字是xiaomo或者xiaoming 可以用$or和$and</span></span><br><span class=\"line\"> var condation = &#123;</span><br><span class=\"line\">   $<span class=\"keyword\">or</span>  $<span class=\"keyword\">and</span>:[</span><br><span class=\"line\">   &#123;'name':'xiaomo'&#125;,</span><br><span class=\"line\">   &#123;'name':'xiaoming'&#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> Blog.find(condation,function(err,doc)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log('result',doc)</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、在项目中使用mongoose\"><a href=\"#三、在项目中使用mongoose\" class=\"headerlink\" title=\"三、在项目中使用mongoose\"></a>三、在项目中使用mongoose</h1><h2 id=\"1-生成项目\"><a href=\"#1-生成项目\" class=\"headerlink\" title=\"1. 生成项目\"></a>1. 生成项目</h2><p><code>koa koatest -e koatest</code></p>\n<h2 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h2><p><code>cd koatest &amp;&amp; npm install</code></p>\n<h2 id=\"3-安装mongoose\"><a href=\"#3-安装mongoose\" class=\"headerlink\" title=\"3. 安装mongoose\"></a>3. 安装mongoose</h2><p><code>npm install --save mongoose</code></p>\n<h2 id=\"4-创建模型\"><a href=\"#4-创建模型\" class=\"headerlink\" title=\"4. 创建模型\"></a>4. 创建模型</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// models/users.server.model.js</span></span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;</span><br><span class=\"line\">    uid:Number,</span><br><span class=\"line\">    username:String,</span><br><span class=\"line\">    createTime:Date,</span><br><span class=\"line\">    lastLogin:Date</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">module.exports = mongoose.model('User',UserSchema);</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-创建配置文件\"><a href=\"#5-创建配置文件\" class=\"headerlink\" title=\"5. 创建配置文件\"></a>5. 创建配置文件</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.js</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports=&#123;</span><br><span class=\"line\">  mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//config/mongoose.js</span></span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var config = require('./config.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports=function()&#123;</span><br><span class=\"line\">  var db = mongoose.connect(config.mongodb);</span><br><span class=\"line\">  require('./../models/users.server.model.js');</span><br><span class=\"line\">  <span class=\"keyword\">return</span> db;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-操作mongdodb-代码\"><a href=\"#6-操作mongdodb-代码\" class=\"headerlink\" title=\"6. 操作mongdodb 代码\"></a>6. 操作mongdodb 代码</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//routers/users.js</span></span><br><span class=\"line\">var router = require('koa-router')();</span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var User = mongoose.model('User');</span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function *(next) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//add</span></span><br><span class=\"line\">    var user = <span class=\"keyword\">new</span> User(&#123;</span><br><span class=\"line\">      uid:</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body = yield User.find(&#123;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n<p>  嗯嗯,就这样吧，完！</p>\n","site":{"data":{}},"excerpt":"<p>突然间需要使用这个东西了，调试还遇到了问题，所以还是简单了解一下他吧。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/mongodb_d.png\" alt=\"js\"></p>","more":"<h1 id=\"一、mongodb的开启和关闭\"><a href=\"#一、mongodb的开启和关闭\" class=\"headerlink\" title=\"一、mongodb的开启和关闭\"></a>一、mongodb的开启和关闭</h1><h2 id=\"1-查找mongod是否可用\"><a href=\"#1-查找mongod是否可用\" class=\"headerlink\" title=\"1. 查找mongod是否可用\"></a>1. 查找mongod是否可用</h2><p><code>which mongod</code></p>\n<h2 id=\"2-启动mongodb\"><a href=\"#2-启动mongodb\" class=\"headerlink\" title=\"2. 启动mongodb\"></a>2. 启动mongodb</h2><p>指定path 和log日志<br><code>mongod --dbpath /data2/db --port=27017 --fork /data2/db/log/mongod.log</code></p>\n<h2 id=\"3-关闭数据库\"><a href=\"#3-关闭数据库\" class=\"headerlink\" title=\"3. 关闭数据库\"></a>3. 关闭数据库</h2><p><code>mongod --shutdown</code></p>\n<h1 id=\"二、mongodb的操作\"><a href=\"#二、mongodb的操作\" class=\"headerlink\" title=\"二、mongodb的操作\"></a>二、mongodb的操作</h1><h2 id=\"1-连接服务器\"><a href=\"#1-连接服务器\" class=\"headerlink\" title=\"1. 连接服务器\"></a>1. 连接服务器</h2><p><code>mongod 115.29.137.34:27017</code></p>\n<h2 id=\"2-使用数据库\"><a href=\"#2-使用数据库\" class=\"headerlink\" title=\"2. 使用数据库\"></a>2. 使用数据库</h2><p>(不存在的数据库也可以使用,插入数据之后会自动保存)<br><code>use mydb</code></p>\n<h2 id=\"3-权限登陆\"><a href=\"#3-权限登陆\" class=\"headerlink\" title=\"3. 权限登陆\"></a>3. 权限登陆</h2><p><code>db.auth(&#39;username&#39;,&#39;password&#39;)</code></p>\n<h2 id=\"4-展示数据库列表\"><a href=\"#4-展示数据库列表\" class=\"headerlink\" title=\"4. 展示数据库列表\"></a>4. 展示数据库列表</h2><p><code>show dbs</code></p>\n<h2 id=\"5-插入数据\"><a href=\"#5-插入数据\" class=\"headerlink\" title=\"5. 插入数据\"></a>5. 插入数据</h2><p>(类似于mysql的表)<br><code>db.users.insert({&#39;name&#39;:&#39;xiaomo&#39;})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:25})</code><br><code>db.users.insert({&#39;name&#39;:&#39;xiaoming&#39;,&#39;age&#39;:24,&#39;sex&#39;:&#39;女&#39;})</code></p>\n<h2 id=\"6-查询集合\"><a href=\"#6-查询集合\" class=\"headerlink\" title=\"6. 查询集合\"></a>6. 查询集合</h2><p>(前提是use了一个数据库)<br>有一个System.indexes 是索引<br><code>show collections</code></p>\n<h2 id=\"7-不带条件查询\"><a href=\"#7-不带条件查询\" class=\"headerlink\" title=\"7. 不带条件查询\"></a>7. 不带条件查询</h2><p><code>db.users.find()</code></p>\n<h2 id=\"8-带条件查询\"><a href=\"#8-带条件查询\" class=\"headerlink\" title=\"8. 带条件查询\"></a>8. 带条件查询</h2><p>(参数是一个对象)<br><code>db.users.find({&#39;name&#39;:&#39;xiaomo&#39;})</code></p>\n<h2 id=\"9-更新数据\"><a href=\"#9-更新数据\" class=\"headerlink\" title=\"9. 更新数据\"></a>9. 更新数据</h2><p>(有三个参数,1:查询条件,2:更新的内容 3：更新的配置)<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}})</code>修改满足条件的第一条数据<br><code>db.users.update({&#39;name&#39;:&#39;xiaomo&#39;,{$set:{&#39;name:&#39;xm}},{multi:true})</code>修改所有满足条件的数据</p>\n<h2 id=\"10-保存数据\"><a href=\"#10-保存数据\" class=\"headerlink\" title=\"10. 保存数据\"></a>10. 保存数据</h2><p>(只有一个参数，必须要传id，后面是要修改的数据)<br><code>db.users.save({&#39;id&#39;:&#39;objectId(574710a97a3afd63cde56a49)&#39;,&#39;age&#39;:30})</code></p>\n<h2 id=\"11-删除数据\"><a href=\"#11-删除数据\" class=\"headerlink\" title=\"11. 删除数据\"></a>11. 删除数据</h2><p>(1:条件 2 是否删除所有符合条件的)<br><code>db.users.remove({&#39;name&#39;:&#39;xiaomoing&#39;},true)</code></p>\n<h2 id=\"12-删除集合\"><a href=\"#12-删除集合\" class=\"headerlink\" title=\"12. 删除集合\"></a>12. 删除集合</h2><p><code>db.users.drop()</code></p>\n<h1 id=\"三、使用mongoose操作数据库\"><a href=\"#三、使用mongoose操作数据库\" class=\"headerlink\" title=\"三、使用mongoose操作数据库\"></a>三、使用mongoose操作数据库</h1><h2 id=\"1-模块的介绍\"><a href=\"#1-模块的介绍\" class=\"headerlink\" title=\"1. 模块的介绍\"></a>1. 模块的介绍</h2><p>连接mongdodb的驱动</p>\n<h2 id=\"2-配置和链接\"><a href=\"#2-配置和链接\" class=\"headerlink\" title=\"2. 配置和链接\"></a>2. 配置和链接</h2><p><code>npm install --save mongoose</code><br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">&lt;!-- var uri = 'mongodb://username:password@hostname:port/databasename'; --&gt;</span><br><span class=\"line\">var uri = 'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin';</span><br><span class=\"line\">mongoose.connect(uri);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Model-和Shema\"><a href=\"#3-Model-和Shema\" class=\"headerlink\" title=\"3. Model 和Shema\"></a>3. Model 和Shema</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// model.js</span></span><br><span class=\"line\">var Schema = mongoose.Schema,</span><br><span class=\"line\">    ObjectId = Schema.ObjectId;</span><br><span class=\"line\"></span><br><span class=\"line\">var BlogPost = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">    author    : ObjectId,</span><br><span class=\"line\">    title     : String,</span><br><span class=\"line\">    body      : String,</span><br><span class=\"line\">    date      : Date</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Model</span></span><br><span class=\"line\">mongoose.model('blog',Schema);</span><br><span class=\"line\"></span><br><span class=\"line\">var Comment = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">  name: &#123; type: String, default: 'hahaha' &#125;,</span><br><span class=\"line\">  age: &#123; type: Number, min: <span class=\"number\">18</span>, index: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  bio: &#123; type: String, match: /[a-z]/ &#125;,</span><br><span class=\"line\">  date: &#123; type: Date, <span class=\"keyword\">default</span>: Date.now &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a setter</span></span><br><span class=\"line\">Comment.path('name').set(function (v) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> capitalize(v);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">Comment.pre('save', function (next) &#123;</span><br><span class=\"line\">  notify(this.get('email'));</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-创建文档\"><a href=\"#4-创建文档\" class=\"headerlink\" title=\"4. 创建文档\"></a>4. 创建文档</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//insert.js</span></span><br><span class=\"line\">var mongoose ＝ require('mongoose');</span><br><span class=\"line\">require('./model.js'); //执行</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">var blog = <span class=\"keyword\">new</span> Blog(&#123;</span><br><span class=\"line\">    name:'xiaomo',</span><br><span class=\"line\">    age:<span class=\"number\">25</span>,</span><br><span class=\"line\">    bio:'don't know',</span><br><span class=\"line\">    date:<span class=\"keyword\">new</span> Date</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.save(function(err)&#123;</span><br><span class=\"line\">    console.log('save status:'+err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-删除文档\"><a href=\"#5-删除文档\" class=\"headerlink\" title=\"5. 删除文档\"></a>5. 删除文档</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(doc)&#123;</span><br><span class=\"line\">  doc.reomove();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-简单查询\"><a href=\"#6-简单查询\" class=\"headerlink\" title=\"6. 简单查询\"></a>6. 简单查询</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.find(&#123;&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log('result',doc)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>第一个满足条件的结果<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">require('./model.js');</span><br><span class=\"line\">var Blog = mongoose.model('blog');</span><br><span class=\"line\">Blog.findOne(&#123;'name':'xiaomo'&#125;,function(err,doc)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log('result',doc)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-条件语句\"><a href=\"#7-条件语句\" class=\"headerlink\" title=\"7. 条件语句\"></a>7. 条件语句</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// condation.js</span></span><br><span class=\"line\"> var mongoose = require('mongoose');</span><br><span class=\"line\"> require('./model.js');</span><br><span class=\"line\"> var Blog = mongoose.model('blog');</span><br><span class=\"line\"> <span class=\"comment\">//名字是xiaomo或者xiaoming 可以用$or和$and</span></span><br><span class=\"line\"> var condation = &#123;</span><br><span class=\"line\">   $<span class=\"keyword\">or</span>  $<span class=\"keyword\">and</span>:[</span><br><span class=\"line\">   &#123;'name':'xiaomo'&#125;,</span><br><span class=\"line\">   &#123;'name':'xiaoming'&#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> Blog.find(condation,function(err,doc)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">   console.<span class=\"built_in\">log</span>(err)</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log('result',doc)</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、在项目中使用mongoose\"><a href=\"#三、在项目中使用mongoose\" class=\"headerlink\" title=\"三、在项目中使用mongoose\"></a>三、在项目中使用mongoose</h1><h2 id=\"1-生成项目\"><a href=\"#1-生成项目\" class=\"headerlink\" title=\"1. 生成项目\"></a>1. 生成项目</h2><p><code>koa koatest -e koatest</code></p>\n<h2 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h2><p><code>cd koatest &amp;&amp; npm install</code></p>\n<h2 id=\"3-安装mongoose\"><a href=\"#3-安装mongoose\" class=\"headerlink\" title=\"3. 安装mongoose\"></a>3. 安装mongoose</h2><p><code>npm install --save mongoose</code></p>\n<h2 id=\"4-创建模型\"><a href=\"#4-创建模型\" class=\"headerlink\" title=\"4. 创建模型\"></a>4. 创建模型</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// models/users.server.model.js</span></span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;</span><br><span class=\"line\">    uid:Number,</span><br><span class=\"line\">    username:String,</span><br><span class=\"line\">    createTime:Date,</span><br><span class=\"line\">    lastLogin:Date</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">module.exports = mongoose.model('User',UserSchema);</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-创建配置文件\"><a href=\"#5-创建配置文件\" class=\"headerlink\" title=\"5. 创建配置文件\"></a>5. 创建配置文件</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.js</span></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports=&#123;</span><br><span class=\"line\">  mongodb:'mongodb://xiaomo:xiaomo@115.29.137.34:27017/admin'</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//config/mongoose.js</span></span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var config = require('./config.js');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports=function()&#123;</span><br><span class=\"line\">  var db = mongoose.connect(config.mongodb);</span><br><span class=\"line\">  require('./../models/users.server.model.js');</span><br><span class=\"line\">  <span class=\"keyword\">return</span> db;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-操作mongdodb-代码\"><a href=\"#6-操作mongdodb-代码\" class=\"headerlink\" title=\"6. 操作mongdodb 代码\"></a>6. 操作mongdodb 代码</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//routers/users.js</span></span><br><span class=\"line\">var router = require('koa-router')();</span><br><span class=\"line\">var mongoose = require('mongoose');</span><br><span class=\"line\">var User = mongoose.model('User');</span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function *(next) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//add</span></span><br><span class=\"line\">    var user = <span class=\"keyword\">new</span> User(&#123;</span><br><span class=\"line\">      uid:</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body = yield User.find(&#123;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n<p>  嗯嗯,就这样吧，完！</p>"},{"title":"next主题模板一些配置","date":"2018-05-05T13:23:49.000Z","description":null,"copyright":true,"_content":"使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n\n\n# 1.修改文章底部的那个带#号的标签\n    \n实现效果图\n\n具体实现方法\n\n    ``` bash\n        /themes/next/layout/_macro/post.swig\n        找到 \n        rel=\"tag\">#\n        修改为\n        <i class=\"fa fa-tag\"></i>\n        完整的应该是这样的：  <a href=\"{{ url_for(tag.path) }}\" rel=\"tag\"><i class=\"fa fa-tag\"></i> {{ tag.name }}</a>\n    ```\n\n\n# 2.在每篇文章末尾统一添加“本文结束”标记\n\n实现效果图\n\n具体实现方法\n\n``` bash\n\n    在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：\n\n    <div>\n        {% if not is_index %}\n            <div style=\"text-align:center;color: #ccc;font-size:14px;\">-------------本文结束<i class=\"fa fa-paw\"></i>感谢您的阅读-------------</div>\n        {% endif %}\n    </div>\n\n    接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：\n\n    <div>\n    {% if not is_index %}\n        {% include 'passage-end-tag.swig' %}\n    {% endif %}\n    </div>\n```\n\n然后打开主题配置文件`（_config.yml)`,在末尾添加：\n``` bash\n    # 文章末尾添加“本文结束”标记\n    passage_end_tag:\n    enabled: true\n\n```\n完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。\n\n# 3.修改“代码块自定义样式\n具体实现方法\n打开 `\\themes\\next\\source\\css\\_custom\\custom.styl`,向里面加入：(颜色可以自己定义)\n``` bash\n    // Custom styles.\n    code {\n        color: #ff7600;\n        background: #fbf7f8;\n        margin: 2px;\n    }\n    // 大代码块的自定义样式\n    .highlight, pre {\n        margin: 5px 0;\n        padding: 5px;\n        border-radius: 3px;\n    }\n    .highlight, code, pre {\n        border: 1px solid #d6d6d6;\n    }\n```\n# 4.侧边栏社交小图标设置\n具体实现方法\n打开主题配置文件`（_config.yml）`，搜索`social_icons:`,在[图标库](https://fontawesome.com/icons?from=io)找自己喜欢的小图标，并将名字复制在如下位置，保存即可\n``` hash\n    # 社交链接\n    # Social Links\n    social:\n    GitHub: https://github.com/Duanruilong\n    CSDN: https://github.com/Duanruilong\n    微博: https://github.com/Duanruilong\n    QQ: https://github.com/Duanruilong\n    知乎: https://github.com/Duanruilong\n    # Social Links Icons/设定链接的图标\n    social_icons:\n    enable: true\n    icons_only: false\n    transition: true\n    # Icon Mappings.\n    # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome\n    GitHub: github\n    E-Mail: envelope\n    Google: google\n    Twitter: twitter\n    Instagram: instagram\n    StackOverflow: stack-overflow\n    微博: weibo\n    知乎: envelope\n    QQ: qq\n    微信: weixin\n    CSDN: crosshairs\n    links_title: discord\n```\n# 5.在网站底部加上访问量\n具体实现方法\n打开`\\themes\\next\\layout\\_partials\\footer.swig`文件,在copyright前加上这句话：\n``` hash\n    <script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n然后再合适的位置添加显示统计的代码，如图：\n``` hash\n    <div class=\"powered-by\">\n    <i class=\"fa fa-user-md\"></i><span id=\"busuanzi_container_site_uv\">\n    本站访客数:<span id=\"busuanzi_value_site_uv\"></span>\n    </span>\n    </div>\n```\n在这里有两中不同计算方式的统计代码：\n\n    1.pv的方式，单个用户连续点击n篇文章，记录n次访问量\n    ``` hash\n        <span id=\"busuanzi_container_site_pv\">\n            本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n        </span>\n    ```\n\n    2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数\n    ``` hash\n        <span id=\"busuanzi_container_site_uv\">\n            本站总访问量<span id=\"busuanzi_value_site_uv\"></span>次\n        </span>\n    ```\n\n添加之后再执行`hexo d -g`，然后再刷新页面就能看到效果\n\n# 6.添加热度\n具体实现方法\nnext主题集成`leanCloud`，打开`/themes/next/layout/_macro/post.swig`,在画红线的区域添加`℃`：\n``` hash\n    {% if theme.post_meta.item_text %}\n        <span class=\"post-meta-item-text\">{{__('post.visitors')}} </span>\n    {% endif %}\n    <span class=\"leancloud-visitors-count\"></span>\n    <span>℃</span>\n```\n然后打开，`/themes/next/languages/zh-Hans.yml`,将画红框的改为热度就可以了\n``` hash\npost:\n  created: 创建于\n  modified: 更新于\n  sticky: 置顶\n  posted: 发表于\n  in: 分类于\n  read_more: 阅读全文\n  untitled: 未命名\n  toc_empty: 此文章未包含目录\n  visitors: 热度\n  wordcount: 字数统计\n  min2read: 阅读时长\n  copyright:\n```\n# 7.网站底部字数统计\n具体方法实现\n切换到根目录下，然后运行如下代码\n``` hash\n    $ npm install hexo-wordcount --save\n```\n然后在`/themes/next/layout/_partials/footer.swig`文件尾部加上：\n``` hash\n<div class=\"theme-info\">\n  <div class=\"powered-by\"></div>\n  <span class=\"post-count\">博客全站共{{ totalcount(site) }}字</span>\n</div>\n```\n# 8.添加 README.md 文件\n每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。\n\n在 Hexo 目录下的 `source` 根目录下添加一个 `README.md` 文件，修改站点配置文件 `_config.yml`，将 `skip_render` 参数的值设置为:\n``` hash\nskip_render: README.md\n```\n保存退出即可。再次使用 `hexo d` 命令部署博客的时候就不会在渲染 README.md 这个文件了。\n# 9.设置网站的图标Favicon\n在[EasyIcon](https://www.easyicon.net/)中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在`/themes/next/source/images`里，并且修改主题配置文件：\n``` hash\n# Put your favicon.ico into `hexo-site/source/` directory.\nfavicon: /favicon.ico\n```\n# 11.实现统计功能\n在根目录下安装 `hexo-wordcount`,运行：\n``` hash\n$ npm install hexo-wordcount --save\n```\n然后在主题的配置文件中，配置如下：\n``` hash\n# Post wordcount display settings\n# Dependencies: https://github.com/willin/hexo-wordcount\npost_wordcount:\n  item_text: true\n  wordcount: true\n  min2read: true\n```\n# 12.添加顶部加载条\n打开`/themes/next/layout/_partials/head.swig`文件，添加如下代码\n```hash\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n<link href=\"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css\" rel=\"stylesheet\">\n```\n但是，默认的是粉色的，要改变颜色可以在`/themes/next/layout/_partials/head.swig`文件中添加如下代码（接在刚才link的后面）\n```hash\n<style>\n    .pace .pace-progress {\n        background: #1E92FB; /*进度条颜色*/\n        height: 3px;\n    }\n    .pace .pace-progress-inner {\n         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/\n    }\n    .pace .pace-activity {\n        border-top-color: #1E92FB;    /*上边框颜色*/\n        border-left-color: #1E92FB;    /*左边框颜色*/\n    }\n</style>\n```\n现在升级最新版的next主题，升级后只需修改主题配置文件(`_config.yml`)将`pace: false`改为`pace: true`就行了，你还可以换不同样式的加载条.\n# 13.在文章底部增加版权信息\n在目录 `next/layout/_macro/`下添加 `my-copyright.swig`：\n```hash\n{% if page.copyright %}\n<div class=\"my_post_copyright\">\n  <script src=\"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js\"></script>\n  \n  <!-- JS库 sweetalert 可修改路径 -->\n  <script src=\"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js\"></script>\n  <script src=\"https://unpkg.com/sweetalert/dist/sweetalert.min.js\"></script>\n  <p><span>本文标题:</span><a href=\"{{ url_for(page.path) }}\">{{ page.title }}</a></p>\n  <p><span>文章作者:</span><a href=\"/\" title=\"访问 {{ theme.author }} 的个人博客\">{{ theme.author }}</a></p>\n  <p><span>发布时间:</span>{{ page.date.format(\"YYYY年MM月DD日 - HH:MM\") }}</p>\n  <p><span>最后更新:</span>{{ page.updated.format(\"YYYY年MM月DD日 - HH:MM\") }}</p>\n  <p><span>原始链接:</span><a href=\"{{ url_for(page.path) }}\" title=\"{{ page.title }}\">{{ page.permalink }}</a>\n    <span class=\"copy-path\"  title=\"点击复制文章链接\"><i class=\"fa fa-clipboard\" data-clipboard-text=\"{{ page.permalink }}\"  aria-label=\"复制成功！\"></i></span>\n  </p>\n  <p><span>许可协议:</span><i class=\"fa fa-creative-commons\"></i> <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" title=\"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)\">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  \n</div>\n<script> \n    var clipboard = new Clipboard('.fa-clipboard');\n    $(\".fa-clipboard\").click(function(){\n      clipboard.on('success', function(){\n        swal({   \n          title: \"\",   \n          text: '复制成功',\n          icon: \"success\", \n          showConfirmButton: true\n          });\n\t});\n    });  \n</script>\n{% endif %}\n```\n在目录`next/source/css/_common/components/post/`下添加`my-post-copyright.styl`：\n``` hash\n.my_post_copyright {\n  width: 85%;\n  max-width: 45em;\n  margin: 2.8em auto 0;\n  padding: 0.5em 1.0em;\n  border: 1px solid #d3d3d3;\n  font-size: 0.93rem;\n  line-height: 1.6em;\n  word-break: break-all;\n  background: rgba(255,255,255,0.4);\n}\n.my_post_copyright p{margin:0;}\n.my_post_copyright span {\n  display: inline-block;\n  width: 5.2em;\n  color: #b5b5b5;\n  font-weight: bold;\n}\n.my_post_copyright .raw {\n  margin-left: 1em;\n  width: 5em;\n}\n.my_post_copyright a {\n  color: #808080;\n  border-bottom:0;\n}\n.my_post_copyright a:hover {\n  color: #a3d2a3;\n  text-decoration: underline;\n}\n.my_post_copyright:hover .fa-clipboard {\n  color: #000;\n}\n.my_post_copyright .post-url:hover {\n  font-weight: normal;\n}\n.my_post_copyright .copy-path {\n  margin-left: 1em;\n  width: 1em;\n  +mobile(){display:none;}\n}\n.my_post_copyright .copy-path:hover {\n  color: #808080;\n  cursor: pointer;\n}\n```\n修改`next/layout/_macro/post.swig`，在代码\n```hash\n<div>\n      {% if not is_index %}\n        {% include 'wechat-subscriber.swig' %}\n      {% endif %}\n</div>\n```\n之前添加增加如下代码：\n``` hash\n<div>\n      {% if not is_index %}\n        {% include 'my-copyright.swig' %}\n      {% endif %}\n</div>\n```\n修改`next/source/css/_common/components/post/post.styl`文件，在最后一行增加代码：\n``` hash\n@import \"my-post-copyright\"\n```\n保存重新生成即可。\n如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：\n\n小技巧：如果你觉得每次都要输入`copyright: true`很麻烦的话,那么在`/scaffolds/post.md`文件中添加：\n``` hash\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\ndescription: \ncopyright: \ncategories:\n---\n```\n这样每次`hexo new \"你的内容\"`之后，生成的md文件会自动把`copyright:`加到里面去\n(注意：如果解析出来之后，你的原始链接有问题：如：`http://yoursite.com/2018/05/05/next主题模板一些配置/`,那么在根目录下`_config.yml`中写成类似这样：）\n``` hash\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://duanruilong.github.io/\nroot: /blog\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n```\n# 14.修改网页底部的桃心\n打开`themes/next/layout/_partials/footer.swig`，找到：\n``` hash\n<span class=\"with-love\">\n    <i class=\"fa fa-{{ theme.authoricon }}\" style=\"color:red\"></i>\n</span>\n  ```\n然后还是在[图标库](https://fontawesome.com/icons?from=io)中找到你自己喜欢的图标，然后修改画红线的部分就可以了。\n# 15.文章加密访问\n打开`themes->next->layout->_partials->head.swig`文件,在以下位置插入这样一段代码：\n``` hash\n<script>\n    (function () {\n        if ('{{ page.password }}') {\n            if (prompt('请输入文章密码') !== '{{ page.password }}') {\n                alert('密码错误！');\n                if (history.length === 1) {\n                    location.replace(\"http://xxxxxxx.xxx\"); // 这里替换成你的首页\n                } else {\n                    history.back();\n                }\n            }\n        }\n    })();\n</script>\n```\n然后在文章上写成类似这样：\n``` hash\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\ndescription: \ncopyright: \ncategories:\npassword: password\n---\n```\n# 16.添加jiathis分享\n在主题配置文件中，jiathis为true，就行了\n``` hash\n# Share 分享\njiathis: true\n# Warning: JiaThis does not support https.\n#add_this_id:\n```\n如果你想自定义话，打开`themes/next/layout/_partials/share/jiathis.swig`修改就可以了\n``` hash\n<!-- JiaThis Button BEGIN -->\n<div class=\"jiathis_style\">\n  <a class=\"jiathis_button_tsina\"></a>\n  <a class=\"jiathis_button_tqq\"></a>\n  <a class=\"jiathis_button_weixin\"></a>\n  <a class=\"jiathis_button_cqq\"></a>\n  <a class=\"jiathis_button_douban\"></a>\n  <a class=\"jiathis_button_renren\"></a>\n  <a class=\"jiathis_button_qzone\"></a>\n  <a class=\"jiathis_button_kaixin001\"></a>\n  <a class=\"jiathis_button_copy\"></a>\n  <a href=\"http://www.jiathis.com/share\" class=\"jiathis jiathis_txt jiathis_separator jtico jtico_jiathis\" target=\"_blank\"></a>\n  <a class=\"jiathis_counter_style\"></a>\n</div>\n```\n# 17.博文置顶或者排序\n修改 `hero-generator-index` 插件，把文件：`node_modules/hexo-generator-index/lib/generator.js` 内的代码替换为：\n``` hash\n'use strict';\nvar pagination = require('hexo-pagination');\nmodule.exports = function(locals){\n  var config = this.config;\n  var posts = locals.posts;\n    posts.data = posts.data.sort(function(a, b) {\n        if(a.top && b.top) { // 两篇文章top都有定义\n            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排\n            else return b.top - a.top; // 否则按照top值降序排\n        }\n        else if(a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）\n            return -1;\n        }\n        else if(!a.top && b.top) {\n            return 1;\n        }\n        else return b.date - a.date; // 都没定义按照文章日期降序排\n    });\n  var paginationDir = config.pagination_dir || 'page';\n  return pagination('', posts, {\n    perPage: config.index_generator.per_page,\n    layout: ['index', 'archive'],\n    format: paginationDir + '/%d/',\n    data: {\n      __index: true\n    }\n  });\n};\n```\n在文章中添加 `top` 值，数值越大文章越靠前，如\n``` hash \n---\ntitle: 第一篇blog\ndate: 2018-05-04 23:38:11\ntags: 生活\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\ncopyright: true\ntop: 12\n---\n```\n# 18.修改字体大小\n打开`\\themes\\next\\source\\css\\ _variables\\base.styl`文件，将`$font-size-base`改成`16px`，如下所示：\n``` hash\n$font-size-base            =16px\n```\n# 19.修改打赏字体不闪动\n修改文件`next/source/css/_common/components/post/post-reward.styl`，然后注释其中的函数`wechat:hover`和`alipay:hover`，如下：\n```hash\n/* 注释文字闪动函数\n #wechat:hover p{\n    animation: roll 0.1s infinite linear;\n    -webkit-animation: roll 0.1s infinite linear;\n    -moz-animation: roll 0.1s infinite linear;\n}\n #alipay:hover p{\n   animation: roll 0.1s infinite linear;\n    -webkit-animation: roll 0.1s infinite linear;\n    -moz-animation: roll 0.1s infinite linear;\n}\n*/\n```\n# 20.点击爆炸效果\n跟那个红心是差不多的，首先在`themes/next/source/js/src`里面建一个叫f`ireworks.js`的文件，代码如下：\n```hash\n\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t<e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i<numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&&\"toggle-sidebar\"!==e.target.id&&\"A\"!==e.target.nodeName&&\"IMG\"!==e.target.nodeName&&(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)}\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t<e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i<numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&&\"toggle-sidebar\"!==e.target.id&&\"A\"!==e.target.nodeName&&\"IMG\"!==e.target.nodeName&&(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)};\n```\n打开`themes/next/layout/_layout.swig`,在`</body>`上面写下如下代码：\n```hash\n{% if theme.fireworks %}\n   <canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" ></canvas> \n   <script type=\"text/javascript\" src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"></script> \n   <script type=\"text/javascript\" src=\"/js/src/fireworks.js\"></script>\n{% endif %}\n\n\n```\n打开主题配置文件，在里面最后写下：\n```hash\n# Fireworks\nfireworks: true\n```\n# 21.DaoVoice 在线联系\n首先在 [daovoice](http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f) 注册账号,[邀请码](http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f)是`0f81ff2f`，注册完成后会得到一个 app_id :\n\n```hash\ndaovoice('init', {\n  app_id: \"0000000\"\n});\ndaovoice('update');\n```\n\n记下这个 app_id的值，然后打开`/themes/next/layout/_partials/head.swig`,写下如下代码：\n```hash\n\n{% if theme.daovoice %}\n  <script>\n  (function(i,s,o,g,r,a,m){i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)})(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/0f81ff2f.js\",\"daovoice\")\n  daovoice('init', {\n      app_id: \"{{theme.daovoice_app_id}}\"\n    });\n  daovoice('update');\n  </script>\n{% endif %}\n\n``````````````````````````````````````````````\n{# #238, Disable Baidu tranformation #}\n<meta http-equiv=\"Cache-Control\" content=\"no-transform\" />\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n\n\n{% if theme.google_site_verification %}\n  <meta name=\"google-site-verification\" content=\"{{ theme.google_site_verification }}\" />\n{% endif %}\n\n{% if theme.daovoice %}\n  <script>\n  (function(i,s,o,g,r,a,m){i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)})(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/0f81ff2f.js\",\"daovoice\")\n  daovoice('init', {\n      app_id: \"{{theme.daovoice_app_id}}\"\n    });\n  daovoice('update');\n  </script>\n{% endif %}\n```\n接着打开主题配置文件，在最后写下如下代码：\n```hash\n# Online contact \ndaovoice: true\ndaovoice_app_id: 这里填你的刚才获得的 app_id\n```\n重新 `hexo g && hexo s` 就能看到效果了。\n安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式\n\n# 22.添加跟帖(来必力)\n有两种实现方法：\n①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件`_config.yml` 文件中添加如下配置:\n```hash\ngentie_productKey: #your-gentie-product-key\n```\n②如果你不想更新的话，那么按下面步骤进行：\n首先，还是在主题配置文件`_config.yml` 文件中添加如下配置:\n```hash\ngentie_productKey: #your-gentie-product-key\n```\n\n","source":"_posts/next主题模板一些配置.md","raw":"---\ntitle: next主题模板一些配置\ndate: 2018-05-05 21:23:49\ntags: 编程\ndescription: \ncopyright: true\ncategories: Hexo\n---\n使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n\n\n# 1.修改文章底部的那个带#号的标签\n    \n实现效果图\n\n具体实现方法\n\n    ``` bash\n        /themes/next/layout/_macro/post.swig\n        找到 \n        rel=\"tag\">#\n        修改为\n        <i class=\"fa fa-tag\"></i>\n        完整的应该是这样的：  <a href=\"{{ url_for(tag.path) }}\" rel=\"tag\"><i class=\"fa fa-tag\"></i> {{ tag.name }}</a>\n    ```\n\n\n# 2.在每篇文章末尾统一添加“本文结束”标记\n\n实现效果图\n\n具体实现方法\n\n``` bash\n\n    在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：\n\n    <div>\n        {% if not is_index %}\n            <div style=\"text-align:center;color: #ccc;font-size:14px;\">-------------本文结束<i class=\"fa fa-paw\"></i>感谢您的阅读-------------</div>\n        {% endif %}\n    </div>\n\n    接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：\n\n    <div>\n    {% if not is_index %}\n        {% include 'passage-end-tag.swig' %}\n    {% endif %}\n    </div>\n```\n\n然后打开主题配置文件`（_config.yml)`,在末尾添加：\n``` bash\n    # 文章末尾添加“本文结束”标记\n    passage_end_tag:\n    enabled: true\n\n```\n完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。\n\n# 3.修改“代码块自定义样式\n具体实现方法\n打开 `\\themes\\next\\source\\css\\_custom\\custom.styl`,向里面加入：(颜色可以自己定义)\n``` bash\n    // Custom styles.\n    code {\n        color: #ff7600;\n        background: #fbf7f8;\n        margin: 2px;\n    }\n    // 大代码块的自定义样式\n    .highlight, pre {\n        margin: 5px 0;\n        padding: 5px;\n        border-radius: 3px;\n    }\n    .highlight, code, pre {\n        border: 1px solid #d6d6d6;\n    }\n```\n# 4.侧边栏社交小图标设置\n具体实现方法\n打开主题配置文件`（_config.yml）`，搜索`social_icons:`,在[图标库](https://fontawesome.com/icons?from=io)找自己喜欢的小图标，并将名字复制在如下位置，保存即可\n``` hash\n    # 社交链接\n    # Social Links\n    social:\n    GitHub: https://github.com/Duanruilong\n    CSDN: https://github.com/Duanruilong\n    微博: https://github.com/Duanruilong\n    QQ: https://github.com/Duanruilong\n    知乎: https://github.com/Duanruilong\n    # Social Links Icons/设定链接的图标\n    social_icons:\n    enable: true\n    icons_only: false\n    transition: true\n    # Icon Mappings.\n    # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome\n    GitHub: github\n    E-Mail: envelope\n    Google: google\n    Twitter: twitter\n    Instagram: instagram\n    StackOverflow: stack-overflow\n    微博: weibo\n    知乎: envelope\n    QQ: qq\n    微信: weixin\n    CSDN: crosshairs\n    links_title: discord\n```\n# 5.在网站底部加上访问量\n具体实现方法\n打开`\\themes\\next\\layout\\_partials\\footer.swig`文件,在copyright前加上这句话：\n``` hash\n    <script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n然后再合适的位置添加显示统计的代码，如图：\n``` hash\n    <div class=\"powered-by\">\n    <i class=\"fa fa-user-md\"></i><span id=\"busuanzi_container_site_uv\">\n    本站访客数:<span id=\"busuanzi_value_site_uv\"></span>\n    </span>\n    </div>\n```\n在这里有两中不同计算方式的统计代码：\n\n    1.pv的方式，单个用户连续点击n篇文章，记录n次访问量\n    ``` hash\n        <span id=\"busuanzi_container_site_pv\">\n            本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n        </span>\n    ```\n\n    2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数\n    ``` hash\n        <span id=\"busuanzi_container_site_uv\">\n            本站总访问量<span id=\"busuanzi_value_site_uv\"></span>次\n        </span>\n    ```\n\n添加之后再执行`hexo d -g`，然后再刷新页面就能看到效果\n\n# 6.添加热度\n具体实现方法\nnext主题集成`leanCloud`，打开`/themes/next/layout/_macro/post.swig`,在画红线的区域添加`℃`：\n``` hash\n    {% if theme.post_meta.item_text %}\n        <span class=\"post-meta-item-text\">{{__('post.visitors')}} </span>\n    {% endif %}\n    <span class=\"leancloud-visitors-count\"></span>\n    <span>℃</span>\n```\n然后打开，`/themes/next/languages/zh-Hans.yml`,将画红框的改为热度就可以了\n``` hash\npost:\n  created: 创建于\n  modified: 更新于\n  sticky: 置顶\n  posted: 发表于\n  in: 分类于\n  read_more: 阅读全文\n  untitled: 未命名\n  toc_empty: 此文章未包含目录\n  visitors: 热度\n  wordcount: 字数统计\n  min2read: 阅读时长\n  copyright:\n```\n# 7.网站底部字数统计\n具体方法实现\n切换到根目录下，然后运行如下代码\n``` hash\n    $ npm install hexo-wordcount --save\n```\n然后在`/themes/next/layout/_partials/footer.swig`文件尾部加上：\n``` hash\n<div class=\"theme-info\">\n  <div class=\"powered-by\"></div>\n  <span class=\"post-count\">博客全站共{{ totalcount(site) }}字</span>\n</div>\n```\n# 8.添加 README.md 文件\n每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。\n\n在 Hexo 目录下的 `source` 根目录下添加一个 `README.md` 文件，修改站点配置文件 `_config.yml`，将 `skip_render` 参数的值设置为:\n``` hash\nskip_render: README.md\n```\n保存退出即可。再次使用 `hexo d` 命令部署博客的时候就不会在渲染 README.md 这个文件了。\n# 9.设置网站的图标Favicon\n在[EasyIcon](https://www.easyicon.net/)中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在`/themes/next/source/images`里，并且修改主题配置文件：\n``` hash\n# Put your favicon.ico into `hexo-site/source/` directory.\nfavicon: /favicon.ico\n```\n# 11.实现统计功能\n在根目录下安装 `hexo-wordcount`,运行：\n``` hash\n$ npm install hexo-wordcount --save\n```\n然后在主题的配置文件中，配置如下：\n``` hash\n# Post wordcount display settings\n# Dependencies: https://github.com/willin/hexo-wordcount\npost_wordcount:\n  item_text: true\n  wordcount: true\n  min2read: true\n```\n# 12.添加顶部加载条\n打开`/themes/next/layout/_partials/head.swig`文件，添加如下代码\n```hash\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n<link href=\"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css\" rel=\"stylesheet\">\n```\n但是，默认的是粉色的，要改变颜色可以在`/themes/next/layout/_partials/head.swig`文件中添加如下代码（接在刚才link的后面）\n```hash\n<style>\n    .pace .pace-progress {\n        background: #1E92FB; /*进度条颜色*/\n        height: 3px;\n    }\n    .pace .pace-progress-inner {\n         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/\n    }\n    .pace .pace-activity {\n        border-top-color: #1E92FB;    /*上边框颜色*/\n        border-left-color: #1E92FB;    /*左边框颜色*/\n    }\n</style>\n```\n现在升级最新版的next主题，升级后只需修改主题配置文件(`_config.yml`)将`pace: false`改为`pace: true`就行了，你还可以换不同样式的加载条.\n# 13.在文章底部增加版权信息\n在目录 `next/layout/_macro/`下添加 `my-copyright.swig`：\n```hash\n{% if page.copyright %}\n<div class=\"my_post_copyright\">\n  <script src=\"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js\"></script>\n  \n  <!-- JS库 sweetalert 可修改路径 -->\n  <script src=\"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js\"></script>\n  <script src=\"https://unpkg.com/sweetalert/dist/sweetalert.min.js\"></script>\n  <p><span>本文标题:</span><a href=\"{{ url_for(page.path) }}\">{{ page.title }}</a></p>\n  <p><span>文章作者:</span><a href=\"/\" title=\"访问 {{ theme.author }} 的个人博客\">{{ theme.author }}</a></p>\n  <p><span>发布时间:</span>{{ page.date.format(\"YYYY年MM月DD日 - HH:MM\") }}</p>\n  <p><span>最后更新:</span>{{ page.updated.format(\"YYYY年MM月DD日 - HH:MM\") }}</p>\n  <p><span>原始链接:</span><a href=\"{{ url_for(page.path) }}\" title=\"{{ page.title }}\">{{ page.permalink }}</a>\n    <span class=\"copy-path\"  title=\"点击复制文章链接\"><i class=\"fa fa-clipboard\" data-clipboard-text=\"{{ page.permalink }}\"  aria-label=\"复制成功！\"></i></span>\n  </p>\n  <p><span>许可协议:</span><i class=\"fa fa-creative-commons\"></i> <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" title=\"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)\">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  \n</div>\n<script> \n    var clipboard = new Clipboard('.fa-clipboard');\n    $(\".fa-clipboard\").click(function(){\n      clipboard.on('success', function(){\n        swal({   \n          title: \"\",   \n          text: '复制成功',\n          icon: \"success\", \n          showConfirmButton: true\n          });\n\t});\n    });  \n</script>\n{% endif %}\n```\n在目录`next/source/css/_common/components/post/`下添加`my-post-copyright.styl`：\n``` hash\n.my_post_copyright {\n  width: 85%;\n  max-width: 45em;\n  margin: 2.8em auto 0;\n  padding: 0.5em 1.0em;\n  border: 1px solid #d3d3d3;\n  font-size: 0.93rem;\n  line-height: 1.6em;\n  word-break: break-all;\n  background: rgba(255,255,255,0.4);\n}\n.my_post_copyright p{margin:0;}\n.my_post_copyright span {\n  display: inline-block;\n  width: 5.2em;\n  color: #b5b5b5;\n  font-weight: bold;\n}\n.my_post_copyright .raw {\n  margin-left: 1em;\n  width: 5em;\n}\n.my_post_copyright a {\n  color: #808080;\n  border-bottom:0;\n}\n.my_post_copyright a:hover {\n  color: #a3d2a3;\n  text-decoration: underline;\n}\n.my_post_copyright:hover .fa-clipboard {\n  color: #000;\n}\n.my_post_copyright .post-url:hover {\n  font-weight: normal;\n}\n.my_post_copyright .copy-path {\n  margin-left: 1em;\n  width: 1em;\n  +mobile(){display:none;}\n}\n.my_post_copyright .copy-path:hover {\n  color: #808080;\n  cursor: pointer;\n}\n```\n修改`next/layout/_macro/post.swig`，在代码\n```hash\n<div>\n      {% if not is_index %}\n        {% include 'wechat-subscriber.swig' %}\n      {% endif %}\n</div>\n```\n之前添加增加如下代码：\n``` hash\n<div>\n      {% if not is_index %}\n        {% include 'my-copyright.swig' %}\n      {% endif %}\n</div>\n```\n修改`next/source/css/_common/components/post/post.styl`文件，在最后一行增加代码：\n``` hash\n@import \"my-post-copyright\"\n```\n保存重新生成即可。\n如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：\n\n小技巧：如果你觉得每次都要输入`copyright: true`很麻烦的话,那么在`/scaffolds/post.md`文件中添加：\n``` hash\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\ndescription: \ncopyright: \ncategories:\n---\n```\n这样每次`hexo new \"你的内容\"`之后，生成的md文件会自动把`copyright:`加到里面去\n(注意：如果解析出来之后，你的原始链接有问题：如：`http://yoursite.com/2018/05/05/next主题模板一些配置/`,那么在根目录下`_config.yml`中写成类似这样：）\n``` hash\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://duanruilong.github.io/\nroot: /blog\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n```\n# 14.修改网页底部的桃心\n打开`themes/next/layout/_partials/footer.swig`，找到：\n``` hash\n<span class=\"with-love\">\n    <i class=\"fa fa-{{ theme.authoricon }}\" style=\"color:red\"></i>\n</span>\n  ```\n然后还是在[图标库](https://fontawesome.com/icons?from=io)中找到你自己喜欢的图标，然后修改画红线的部分就可以了。\n# 15.文章加密访问\n打开`themes->next->layout->_partials->head.swig`文件,在以下位置插入这样一段代码：\n``` hash\n<script>\n    (function () {\n        if ('{{ page.password }}') {\n            if (prompt('请输入文章密码') !== '{{ page.password }}') {\n                alert('密码错误！');\n                if (history.length === 1) {\n                    location.replace(\"http://xxxxxxx.xxx\"); // 这里替换成你的首页\n                } else {\n                    history.back();\n                }\n            }\n        }\n    })();\n</script>\n```\n然后在文章上写成类似这样：\n``` hash\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\ndescription: \ncopyright: \ncategories:\npassword: password\n---\n```\n# 16.添加jiathis分享\n在主题配置文件中，jiathis为true，就行了\n``` hash\n# Share 分享\njiathis: true\n# Warning: JiaThis does not support https.\n#add_this_id:\n```\n如果你想自定义话，打开`themes/next/layout/_partials/share/jiathis.swig`修改就可以了\n``` hash\n<!-- JiaThis Button BEGIN -->\n<div class=\"jiathis_style\">\n  <a class=\"jiathis_button_tsina\"></a>\n  <a class=\"jiathis_button_tqq\"></a>\n  <a class=\"jiathis_button_weixin\"></a>\n  <a class=\"jiathis_button_cqq\"></a>\n  <a class=\"jiathis_button_douban\"></a>\n  <a class=\"jiathis_button_renren\"></a>\n  <a class=\"jiathis_button_qzone\"></a>\n  <a class=\"jiathis_button_kaixin001\"></a>\n  <a class=\"jiathis_button_copy\"></a>\n  <a href=\"http://www.jiathis.com/share\" class=\"jiathis jiathis_txt jiathis_separator jtico jtico_jiathis\" target=\"_blank\"></a>\n  <a class=\"jiathis_counter_style\"></a>\n</div>\n```\n# 17.博文置顶或者排序\n修改 `hero-generator-index` 插件，把文件：`node_modules/hexo-generator-index/lib/generator.js` 内的代码替换为：\n``` hash\n'use strict';\nvar pagination = require('hexo-pagination');\nmodule.exports = function(locals){\n  var config = this.config;\n  var posts = locals.posts;\n    posts.data = posts.data.sort(function(a, b) {\n        if(a.top && b.top) { // 两篇文章top都有定义\n            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排\n            else return b.top - a.top; // 否则按照top值降序排\n        }\n        else if(a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）\n            return -1;\n        }\n        else if(!a.top && b.top) {\n            return 1;\n        }\n        else return b.date - a.date; // 都没定义按照文章日期降序排\n    });\n  var paginationDir = config.pagination_dir || 'page';\n  return pagination('', posts, {\n    perPage: config.index_generator.per_page,\n    layout: ['index', 'archive'],\n    format: paginationDir + '/%d/',\n    data: {\n      __index: true\n    }\n  });\n};\n```\n在文章中添加 `top` 值，数值越大文章越靠前，如\n``` hash \n---\ntitle: 第一篇blog\ndate: 2018-05-04 23:38:11\ntags: 生活\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\ncopyright: true\ntop: 12\n---\n```\n# 18.修改字体大小\n打开`\\themes\\next\\source\\css\\ _variables\\base.styl`文件，将`$font-size-base`改成`16px`，如下所示：\n``` hash\n$font-size-base            =16px\n```\n# 19.修改打赏字体不闪动\n修改文件`next/source/css/_common/components/post/post-reward.styl`，然后注释其中的函数`wechat:hover`和`alipay:hover`，如下：\n```hash\n/* 注释文字闪动函数\n #wechat:hover p{\n    animation: roll 0.1s infinite linear;\n    -webkit-animation: roll 0.1s infinite linear;\n    -moz-animation: roll 0.1s infinite linear;\n}\n #alipay:hover p{\n   animation: roll 0.1s infinite linear;\n    -webkit-animation: roll 0.1s infinite linear;\n    -moz-animation: roll 0.1s infinite linear;\n}\n*/\n```\n# 20.点击爆炸效果\n跟那个红心是差不多的，首先在`themes/next/source/js/src`里面建一个叫f`ireworks.js`的文件，代码如下：\n```hash\n\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t<e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i<numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&&\"toggle-sidebar\"!==e.target.id&&\"A\"!==e.target.nodeName&&\"IMG\"!==e.target.nodeName&&(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)}\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t<e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i<numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:\"linear\",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(\".fireworks\");if(canvasEl){var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){\"sidebar\"!==e.target.id&&\"toggle-sidebar\"!==e.target.id&&\"A\"!==e.target.nodeName&&\"IMG\"!==e.target.nodeName&&(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)};\n```\n打开`themes/next/layout/_layout.swig`,在`</body>`上面写下如下代码：\n```hash\n{% if theme.fireworks %}\n   <canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" ></canvas> \n   <script type=\"text/javascript\" src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"></script> \n   <script type=\"text/javascript\" src=\"/js/src/fireworks.js\"></script>\n{% endif %}\n\n\n```\n打开主题配置文件，在里面最后写下：\n```hash\n# Fireworks\nfireworks: true\n```\n# 21.DaoVoice 在线联系\n首先在 [daovoice](http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f) 注册账号,[邀请码](http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f)是`0f81ff2f`，注册完成后会得到一个 app_id :\n\n```hash\ndaovoice('init', {\n  app_id: \"0000000\"\n});\ndaovoice('update');\n```\n\n记下这个 app_id的值，然后打开`/themes/next/layout/_partials/head.swig`,写下如下代码：\n```hash\n\n{% if theme.daovoice %}\n  <script>\n  (function(i,s,o,g,r,a,m){i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)})(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/0f81ff2f.js\",\"daovoice\")\n  daovoice('init', {\n      app_id: \"{{theme.daovoice_app_id}}\"\n    });\n  daovoice('update');\n  </script>\n{% endif %}\n\n``````````````````````````````````````````````\n{# #238, Disable Baidu tranformation #}\n<meta http-equiv=\"Cache-Control\" content=\"no-transform\" />\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n\n\n{% if theme.google_site_verification %}\n  <meta name=\"google-site-verification\" content=\"{{ theme.google_site_verification }}\" />\n{% endif %}\n\n{% if theme.daovoice %}\n  <script>\n  (function(i,s,o,g,r,a,m){i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)})(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/0f81ff2f.js\",\"daovoice\")\n  daovoice('init', {\n      app_id: \"{{theme.daovoice_app_id}}\"\n    });\n  daovoice('update');\n  </script>\n{% endif %}\n```\n接着打开主题配置文件，在最后写下如下代码：\n```hash\n# Online contact \ndaovoice: true\ndaovoice_app_id: 这里填你的刚才获得的 app_id\n```\n重新 `hexo g && hexo s` 就能看到效果了。\n安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式\n\n# 22.添加跟帖(来必力)\n有两种实现方法：\n①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件`_config.yml` 文件中添加如下配置:\n```hash\ngentie_productKey: #your-gentie-product-key\n```\n②如果你不想更新的话，那么按下面步骤进行：\n首先，还是在主题配置文件`_config.yml` 文件中添加如下配置:\n```hash\ngentie_productKey: #your-gentie-product-key\n```\n\n","slug":"next主题模板一些配置","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnej002ikt89abm9nvum","content":"<p>使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"1-修改文章底部的那个带-号的标签\"><a href=\"#1-修改文章底部的那个带-号的标签\" class=\"headerlink\" title=\"1.修改文章底部的那个带#号的标签\"></a>1.修改文章底部的那个带#号的标签</h1><p>实现效果图</p>\n<p>具体实现方法</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/themes/next/layout/_macro/post.swig</span><br><span class=\"line\">找到 </span><br><span class=\"line\">rel=<span class=\"string\">\"tag\"</span>&gt;<span class=\"comment\">#</span></span><br><span class=\"line\">修改为</span><br><span class=\"line\">&lt;i class=<span class=\"string\">\"fa fa-tag\"</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">完整的应该是这样的：  &lt;a href=<span class=\"string\">\"&#123;&#123; url_for(tag.path) &#125;&#125;\"</span> rel=<span class=\"string\">\"tag\"</span>&gt;&lt;i class=<span class=\"string\">\"fa fa-tag\"</span>&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><h1 id=\"2-在每篇文章末尾统一添加“本文结束”标记\"><a href=\"#2-在每篇文章末尾统一添加“本文结束”标记\" class=\"headerlink\" title=\"2.在每篇文章末尾统一添加“本文结束”标记\"></a>2.在每篇文章末尾统一添加“本文结束”标记</h1><p>实现效果图</p>\n<p>具体实现方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">        &lt;div style=<span class=\"string\">\"text-align:center;color: #ccc;font-size:14px;\"</span>&gt;-------------本文结束&lt;i class=<span class=\"string\">\"fa fa-paw\"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">    &#123;% include <span class=\"string\">'passage-end-tag.swig'</span> %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>然后打开主题配置文件<code>（_config.yml)</code>,在末尾添加：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文章末尾添加“本文结束”标记</span></span><br><span class=\"line\">passage_end_tag:</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>\n<h1 id=\"3-修改“代码块自定义样式\"><a href=\"#3-修改“代码块自定义样式\" class=\"headerlink\" title=\"3.修改“代码块自定义样式\"></a>3.修改“代码块自定义样式</h1><p>具体实现方法<br>打开 <code>\\themes\\next\\source\\css\\_custom\\custom.styl</code>,向里面加入：(颜色可以自己定义)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Custom styles.</span><br><span class=\"line\">code &#123;</span><br><span class=\"line\">    color: <span class=\"comment\">#ff7600;</span></span><br><span class=\"line\">    background: <span class=\"comment\">#fbf7f8;</span></span><br><span class=\"line\">    margin: 2px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 大代码块的自定义样式</span><br><span class=\"line\">.highlight, pre &#123;</span><br><span class=\"line\">    margin: 5px 0;</span><br><span class=\"line\">    padding: 5px;</span><br><span class=\"line\">    border-radius: 3px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.highlight, code, pre &#123;</span><br><span class=\"line\">    border: 1px solid <span class=\"comment\">#d6d6d6;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-侧边栏社交小图标设置\"><a href=\"#4-侧边栏社交小图标设置\" class=\"headerlink\" title=\"4.侧边栏社交小图标设置\"></a>4.侧边栏社交小图标设置</h1><p>具体实现方法<br>打开主题配置文件<code>（_config.yml）</code>，搜索<code>social_icons:</code>,在<a href=\"https://fontawesome.com/icons?from=io\" target=\"_blank\" rel=\"noopener\">图标库</a>找自己喜欢的小图标，并将名字复制在如下位置，保存即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 社交链接</span><br><span class=\"line\"># Social Links</span><br><span class=\"line\">social:</span><br><span class=\"line\">GitHub: https://github.com/Duanruilong</span><br><span class=\"line\">CSDN: https://github.com/Duanruilong</span><br><span class=\"line\">微博: https://github.com/Duanruilong</span><br><span class=\"line\">QQ: https://github.com/Duanruilong</span><br><span class=\"line\">知乎: https://github.com/Duanruilong</span><br><span class=\"line\"># Social Links Icons/设定链接的图标</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">icons_only: false</span><br><span class=\"line\">transition: true</span><br><span class=\"line\"># Icon Mappings.</span><br><span class=\"line\"># KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span><br><span class=\"line\">GitHub: github</span><br><span class=\"line\">E-Mail: envelope</span><br><span class=\"line\">Google: google</span><br><span class=\"line\">Twitter: twitter</span><br><span class=\"line\">Instagram: instagram</span><br><span class=\"line\">StackOverflow: stack-overflow</span><br><span class=\"line\">微博: weibo</span><br><span class=\"line\">知乎: envelope</span><br><span class=\"line\">QQ: qq</span><br><span class=\"line\">微信: weixin</span><br><span class=\"line\">CSDN: crosshairs</span><br><span class=\"line\">links_title: discord</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5-在网站底部加上访问量\"><a href=\"#5-在网站底部加上访问量\" class=\"headerlink\" title=\"5.在网站底部加上访问量\"></a>5.在网站底部加上访问量</h1><p>具体实现方法<br>打开<code>\\themes\\next\\layout\\_partials\\footer.swig</code>文件,在copyright前加上这句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后再合适的位置添加显示统计的代码，如图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class=\"line\">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这里有两中不同计算方式的统计代码：</p>\n<pre><code>1.pv的方式，单个用户连续点击n篇文章，记录n次访问量\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>添加之后再执行<code>hexo d -g</code>，然后再刷新页面就能看到效果</p>\n<h1 id=\"6-添加热度\"><a href=\"#6-添加热度\" class=\"headerlink\" title=\"6.添加热度\"></a>6.添加热度</h1><p>具体实现方法<br>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code>,在画红线的区域添加<code>℃</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.post_meta.item_text %&#125;</span><br><span class=\"line\">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\">&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>,将画红框的改为热度就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post:</span><br><span class=\"line\">  created: 创建于</span><br><span class=\"line\">  modified: 更新于</span><br><span class=\"line\">  sticky: 置顶</span><br><span class=\"line\">  posted: 发表于</span><br><span class=\"line\">  in: 分类于</span><br><span class=\"line\">  read_more: 阅读全文</span><br><span class=\"line\">  untitled: 未命名</span><br><span class=\"line\">  toc_empty: 此文章未包含目录</span><br><span class=\"line\">  visitors: 热度</span><br><span class=\"line\">  wordcount: 字数统计</span><br><span class=\"line\">  min2read: 阅读时长</span><br><span class=\"line\">  copyright:</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-网站底部字数统计\"><a href=\"#7-网站底部字数统计\" class=\"headerlink\" title=\"7.网站底部字数统计\"></a>7.网站底部字数统计</h1><p>具体方法实现<br>切换到根目录下，然后运行如下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>\n<p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"8-添加-README-md-文件\"><a href=\"#8-添加-README-md-文件\" class=\"headerlink\" title=\"8.添加 README.md 文件\"></a>8.添加 README.md 文件</h1><p>每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。</p>\n<p>在 Hexo 目录下的 <code>source</code> 根目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: README.md</span><br></pre></td></tr></table></figure></p>\n<p>保存退出即可。再次使用 <code>hexo d</code> 命令部署博客的时候就不会在渲染 README.md 这个文件了。</p>\n<h1 id=\"9-设置网站的图标Favicon\"><a href=\"#9-设置网站的图标Favicon\" class=\"headerlink\" title=\"9.设置网站的图标Favicon\"></a>9.设置网站的图标Favicon</h1><p>在<a href=\"https://www.easyicon.net/\" target=\"_blank\" rel=\"noopener\">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在<code>/themes/next/source/images</code>里，并且修改主题配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Put your favicon.ico into `hexo-site/source/` directory.</span><br><span class=\"line\">favicon: /favicon.ico</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"11-实现统计功能\"><a href=\"#11-实现统计功能\" class=\"headerlink\" title=\"11.实现统计功能\"></a>11.实现统计功能</h1><p>在根目录下安装 <code>hexo-wordcount</code>,运行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>\n<p>然后在主题的配置文件中，配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Post wordcount display settings</span><br><span class=\"line\"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class=\"line\">post_wordcount:</span><br><span class=\"line\">  item_text: true</span><br><span class=\"line\">  wordcount: true</span><br><span class=\"line\">  min2read: true</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"12-添加顶部加载条\"><a href=\"#12-添加顶部加载条\" class=\"headerlink\" title=\"12.添加顶部加载条\"></a>12.添加顶部加载条</h1><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件，添加如下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>但是，默认的是粉色的，要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .pace .pace-progress &#123;</span><br><span class=\"line\">        background: #1E92FB; /*进度条颜色*/</span><br><span class=\"line\">        height: 3px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .pace .pace-progress-inner &#123;</span><br><span class=\"line\">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .pace .pace-activity &#123;</span><br><span class=\"line\">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class=\"line\">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在升级最新版的next主题，升级后只需修改主题配置文件(<code>_config.yml</code>)将<code>pace: false</code>改为<code>pace: true</code>就行了，你还可以换不同样式的加载条.</p>\n<h1 id=\"13-在文章底部增加版权信息\"><a href=\"#13-在文章底部增加版权信息\" class=\"headerlink\" title=\"13.在文章底部增加版权信息\"></a>13.在文章底部增加版权信息</h1><p>在目录 <code>next/layout/_macro/</code>下添加 <code>my-copyright.swig</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.copyright %&#125;</span><br><span class=\"line\">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class=\"line\">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt; </span><br><span class=\"line\">    var clipboard = new Clipboard(&apos;.fa-clipboard&apos;);</span><br><span class=\"line\">    $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class=\"line\">      clipboard.on(&apos;success&apos;, function()&#123;</span><br><span class=\"line\">        swal(&#123;   </span><br><span class=\"line\">          title: &quot;&quot;,   </span><br><span class=\"line\">          text: &apos;复制成功&apos;,</span><br><span class=\"line\">          icon: &quot;success&quot;, </span><br><span class=\"line\">          showConfirmButton: true</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.my_post_copyright &#123;</span><br><span class=\"line\">  width: 85%;</span><br><span class=\"line\">  max-width: 45em;</span><br><span class=\"line\">  margin: 2.8em auto 0;</span><br><span class=\"line\">  padding: 0.5em 1.0em;</span><br><span class=\"line\">  border: 1px solid #d3d3d3;</span><br><span class=\"line\">  font-size: 0.93rem;</span><br><span class=\"line\">  line-height: 1.6em;</span><br><span class=\"line\">  word-break: break-all;</span><br><span class=\"line\">  background: rgba(255,255,255,0.4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class=\"line\">.my_post_copyright span &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  width: 5.2em;</span><br><span class=\"line\">  color: #b5b5b5;</span><br><span class=\"line\">  font-weight: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .raw &#123;</span><br><span class=\"line\">  margin-left: 1em;</span><br><span class=\"line\">  width: 5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright a &#123;</span><br><span class=\"line\">  color: #808080;</span><br><span class=\"line\">  border-bottom:0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright a:hover &#123;</span><br><span class=\"line\">  color: #a3d2a3;</span><br><span class=\"line\">  text-decoration: underline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class=\"line\">  color: #000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .post-url:hover &#123;</span><br><span class=\"line\">  font-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .copy-path &#123;</span><br><span class=\"line\">  margin-left: 1em;</span><br><span class=\"line\">  width: 1em;</span><br><span class=\"line\">  +mobile()&#123;display:none;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .copy-path:hover &#123;</span><br><span class=\"line\">  color: #808080;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>next/layout/_macro/post.swig</code>，在代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">      &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &#123;% include &apos;wechat-subscriber.swig&apos; %&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>之前添加增加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">      &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &#123;% include &apos;my-copyright.swig&apos; %&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></p>\n<p>保存重新生成即可。<br>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：</p>\n<p>小技巧：如果你觉得每次都要输入<code>copyright: true</code>很麻烦的话,那么在<code>/scaffolds/post.md</code>文件中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">description: </span><br><span class=\"line\">copyright: </span><br><span class=\"line\">categories:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>这样每次<code>hexo new &quot;你的内容&quot;</code>之后，生成的md文件会自动把<code>copyright:</code>加到里面去<br>(注意：如果解析出来之后，你的原始链接有问题：如：<code>http://yoursite.com/2018/05/05/next主题模板一些配置/</code>,那么在根目录下<code>_config.yml</code>中写成类似这样：）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: https://duanruilong.github.io/</span><br><span class=\"line\">root: /blog</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">permalink_defaults:</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"14-修改网页底部的桃心\"><a href=\"#14-修改网页底部的桃心\" class=\"headerlink\" title=\"14.修改网页底部的桃心\"></a>14.修改网页底部的桃心</h1><p>打开<code>themes/next/layout/_partials/footer.swig</code>，找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class=\"line\">    &lt;i class=&quot;fa fa-&#123;&#123; theme.authoricon &#125;&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后还是在<a href=\"https://fontawesome.com/icons?from=io\" target=\"_blank\" rel=\"noopener\">图标库</a>中找到你自己喜欢的图标，然后修改画红线的部分就可以了。</p>\n<h1 id=\"15-文章加密访问\"><a href=\"#15-文章加密访问\" class=\"headerlink\" title=\"15.文章加密访问\"></a>15.文章加密访问</h1><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在以下位置插入这样一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    (function () &#123;</span><br><span class=\"line\">        if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class=\"line\">            if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class=\"line\">                alert(&apos;密码错误！&apos;);</span><br><span class=\"line\">                if (history.length === 1) &#123;</span><br><span class=\"line\">                    location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    history.back();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在文章上写成类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">description: </span><br><span class=\"line\">copyright: </span><br><span class=\"line\">categories:</span><br><span class=\"line\">password: password</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"16-添加jiathis分享\"><a href=\"#16-添加jiathis分享\" class=\"headerlink\" title=\"16.添加jiathis分享\"></a>16.添加jiathis分享</h1><p>在主题配置文件中，jiathis为true，就行了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Share 分享</span><br><span class=\"line\">jiathis: true</span><br><span class=\"line\"># Warning: JiaThis does not support https.</span><br><span class=\"line\">#add_this_id:</span><br></pre></td></tr></table></figure></p>\n<p>如果你想自定义话，打开<code>themes/next/layout/_partials/share/jiathis.swig</code>修改就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- JiaThis Button BEGIN --&gt;</span><br><span class=\"line\">&lt;div class=&quot;jiathis_style&quot;&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_kaixin001&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a href=&quot;http://www.jiathis.com/share&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"17-博文置顶或者排序\"><a href=\"#17-博文置顶或者排序\" class=\"headerlink\" title=\"17.博文置顶或者排序\"></a>17.博文置顶或者排序</h1><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class=\"line\">module.exports = function(locals)&#123;</span><br><span class=\"line\">  var config = this.config;</span><br><span class=\"line\">  var posts = locals.posts;</span><br><span class=\"line\">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class=\"line\">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class=\"line\">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class=\"line\">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class=\"line\">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class=\"line\">    perPage: config.index_generator.per_page,</span><br><span class=\"line\">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class=\"line\">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      __index: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 第一篇blog</span><br><span class=\"line\">date: 2018-05-04 23:38:11</span><br><span class=\"line\">tags: 生活</span><br><span class=\"line\">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class=\"line\">copyright: true</span><br><span class=\"line\">top: 12</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"18-修改字体大小\"><a href=\"#18-修改字体大小\" class=\"headerlink\" title=\"18.修改字体大小\"></a>18.修改字体大小</h1><p>打开<code>\\themes\\next\\source\\css\\ _variables\\base.styl</code>文件，将<code>$font-size-base</code>改成<code>16px</code>，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$font-size-base            =16px</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"19-修改打赏字体不闪动\"><a href=\"#19-修改打赏字体不闪动\" class=\"headerlink\" title=\"19.修改打赏字体不闪动\"></a>19.修改打赏字体不闪动</h1><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 注释文字闪动函数</span><br><span class=\"line\"> #wechat:hover p&#123;</span><br><span class=\"line\">    animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -moz-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> #alipay:hover p&#123;</span><br><span class=\"line\">   animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -moz-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"20-点击爆炸效果\"><a href=\"#20-点击爆炸效果\" class=\"headerlink\" title=\"20.点击爆炸效果\"></a>20.点击爆炸效果</h1><p>跟那个红心是差不多的，首先在<code>themes/next/source/js/src</code>里面建一个叫f<code>ireworks.js</code>的文件，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.fireworks %&#125;</span><br><span class=\"line\">   &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; </span><br><span class=\"line\">   &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; </span><br><span class=\"line\">   &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打开主题配置文件，在里面最后写下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Fireworks</span><br><span class=\"line\">fireworks: true</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"21-DaoVoice-在线联系\"><a href=\"#21-DaoVoice-在线联系\" class=\"headerlink\" title=\"21.DaoVoice 在线联系\"></a>21.DaoVoice 在线联系</h1><p>首先在 <a href=\"http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f\" target=\"_blank\" rel=\"noopener\">daovoice</a> 注册账号,<a href=\"http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f\" target=\"_blank\" rel=\"noopener\">邀请码</a>是<code>0f81ff2f</code>，注册完成后会得到一个 app_id :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daovoice(&apos;init&apos;, &#123;</span><br><span class=\"line\">  app_id: &quot;0000000&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">daovoice(&apos;update&apos;);</span><br></pre></td></tr></table></figure>\n<p>记下这个 app_id的值，然后打开<code>/themes/next/layout/_partials/head.swig</code>,写下如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;% if theme.daovoice %&#125;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class=\"line\">  daovoice(&apos;init&apos;, &#123;</span><br><span class=\"line\">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  daovoice(&apos;update&apos;);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```````````````````````````````````````````</span><br></pre></td></tr></table></figure></p>\n<p><meta http-equiv=\"Cache-Control\" content=\"no-transform\"></p>\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\">\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着打开主题配置文件，在最后写下如下代码：</span><br><span class=\"line\">```hash</span><br><span class=\"line\"># Online contact </span><br><span class=\"line\">daovoice: true</span><br><span class=\"line\">daovoice_app_id: 这里填你的刚才获得的 app_id</span><br></pre></td></tr></table></figure>\n<p>重新 <code>hexo g &amp;&amp; hexo s</code> 就能看到效果了。<br>安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式</p>\n<h1 id=\"22-添加跟帖-来必力\"><a href=\"#22-添加跟帖-来必力\" class=\"headerlink\" title=\"22.添加跟帖(来必力)\"></a>22.添加跟帖(来必力)</h1><p>有两种实现方法：<br>①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p>\n<p>②如果你不想更新的话，那么按下面步骤进行：<br>首先，还是在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>使用Hexo + Github去搭建一个属于自己的博客站点，这里是一些next相关的细节配置。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>","more":"<h1 id=\"1-修改文章底部的那个带-号的标签\"><a href=\"#1-修改文章底部的那个带-号的标签\" class=\"headerlink\" title=\"1.修改文章底部的那个带#号的标签\"></a>1.修改文章底部的那个带#号的标签</h1><p>实现效果图</p>\n<p>具体实现方法</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/themes/next/layout/_macro/post.swig</span><br><span class=\"line\">找到 </span><br><span class=\"line\">rel=<span class=\"string\">\"tag\"</span>&gt;<span class=\"comment\">#</span></span><br><span class=\"line\">修改为</span><br><span class=\"line\">&lt;i class=<span class=\"string\">\"fa fa-tag\"</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">完整的应该是这样的：  &lt;a href=<span class=\"string\">\"&#123;&#123; url_for(tag.path) &#125;&#125;\"</span> rel=<span class=\"string\">\"tag\"</span>&gt;&lt;i class=<span class=\"string\">\"fa fa-tag\"</span>&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><h1 id=\"2-在每篇文章末尾统一添加“本文结束”标记\"><a href=\"#2-在每篇文章末尾统一添加“本文结束”标记\" class=\"headerlink\" title=\"2.在每篇文章末尾统一添加“本文结束”标记\"></a>2.在每篇文章末尾统一添加“本文结束”标记</h1><p>实现效果图</p>\n<p>具体实现方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">        &lt;div style=<span class=\"string\">\"text-align:center;color: #ccc;font-size:14px;\"</span>&gt;-------------本文结束&lt;i class=<span class=\"string\">\"fa fa-paw\"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下部分代码（post-footer之前两个DIV）：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">    &#123;% include <span class=\"string\">'passage-end-tag.swig'</span> %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>然后打开主题配置文件<code>（_config.yml)</code>,在末尾添加：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文章末尾添加“本文结束”标记</span></span><br><span class=\"line\">passage_end_tag:</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>\n<h1 id=\"3-修改“代码块自定义样式\"><a href=\"#3-修改“代码块自定义样式\" class=\"headerlink\" title=\"3.修改“代码块自定义样式\"></a>3.修改“代码块自定义样式</h1><p>具体实现方法<br>打开 <code>\\themes\\next\\source\\css\\_custom\\custom.styl</code>,向里面加入：(颜色可以自己定义)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Custom styles.</span><br><span class=\"line\">code &#123;</span><br><span class=\"line\">    color: <span class=\"comment\">#ff7600;</span></span><br><span class=\"line\">    background: <span class=\"comment\">#fbf7f8;</span></span><br><span class=\"line\">    margin: 2px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 大代码块的自定义样式</span><br><span class=\"line\">.highlight, pre &#123;</span><br><span class=\"line\">    margin: 5px 0;</span><br><span class=\"line\">    padding: 5px;</span><br><span class=\"line\">    border-radius: 3px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.highlight, code, pre &#123;</span><br><span class=\"line\">    border: 1px solid <span class=\"comment\">#d6d6d6;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-侧边栏社交小图标设置\"><a href=\"#4-侧边栏社交小图标设置\" class=\"headerlink\" title=\"4.侧边栏社交小图标设置\"></a>4.侧边栏社交小图标设置</h1><p>具体实现方法<br>打开主题配置文件<code>（_config.yml）</code>，搜索<code>social_icons:</code>,在<a href=\"https://fontawesome.com/icons?from=io\" target=\"_blank\" rel=\"noopener\">图标库</a>找自己喜欢的小图标，并将名字复制在如下位置，保存即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 社交链接</span><br><span class=\"line\"># Social Links</span><br><span class=\"line\">social:</span><br><span class=\"line\">GitHub: https://github.com/Duanruilong</span><br><span class=\"line\">CSDN: https://github.com/Duanruilong</span><br><span class=\"line\">微博: https://github.com/Duanruilong</span><br><span class=\"line\">QQ: https://github.com/Duanruilong</span><br><span class=\"line\">知乎: https://github.com/Duanruilong</span><br><span class=\"line\"># Social Links Icons/设定链接的图标</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">icons_only: false</span><br><span class=\"line\">transition: true</span><br><span class=\"line\"># Icon Mappings.</span><br><span class=\"line\"># KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span><br><span class=\"line\">GitHub: github</span><br><span class=\"line\">E-Mail: envelope</span><br><span class=\"line\">Google: google</span><br><span class=\"line\">Twitter: twitter</span><br><span class=\"line\">Instagram: instagram</span><br><span class=\"line\">StackOverflow: stack-overflow</span><br><span class=\"line\">微博: weibo</span><br><span class=\"line\">知乎: envelope</span><br><span class=\"line\">QQ: qq</span><br><span class=\"line\">微信: weixin</span><br><span class=\"line\">CSDN: crosshairs</span><br><span class=\"line\">links_title: discord</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5-在网站底部加上访问量\"><a href=\"#5-在网站底部加上访问量\" class=\"headerlink\" title=\"5.在网站底部加上访问量\"></a>5.在网站底部加上访问量</h1><p>具体实现方法<br>打开<code>\\themes\\next\\layout\\_partials\\footer.swig</code>文件,在copyright前加上这句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后再合适的位置添加显示统计的代码，如图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class=\"line\">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这里有两中不同计算方式的统计代码：</p>\n<pre><code>1.pv的方式，单个用户连续点击n篇文章，记录n次访问量\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n2.uv的方式，单个用户连续点击n篇文章，只记录1次访客数\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>添加之后再执行<code>hexo d -g</code>，然后再刷新页面就能看到效果</p>\n<h1 id=\"6-添加热度\"><a href=\"#6-添加热度\" class=\"headerlink\" title=\"6.添加热度\"></a>6.添加热度</h1><p>具体实现方法<br>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code>,在画红线的区域添加<code>℃</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.post_meta.item_text %&#125;</span><br><span class=\"line\">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\">&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后打开，<code>/themes/next/languages/zh-Hans.yml</code>,将画红框的改为热度就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post:</span><br><span class=\"line\">  created: 创建于</span><br><span class=\"line\">  modified: 更新于</span><br><span class=\"line\">  sticky: 置顶</span><br><span class=\"line\">  posted: 发表于</span><br><span class=\"line\">  in: 分类于</span><br><span class=\"line\">  read_more: 阅读全文</span><br><span class=\"line\">  untitled: 未命名</span><br><span class=\"line\">  toc_empty: 此文章未包含目录</span><br><span class=\"line\">  visitors: 热度</span><br><span class=\"line\">  wordcount: 字数统计</span><br><span class=\"line\">  min2read: 阅读时长</span><br><span class=\"line\">  copyright:</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-网站底部字数统计\"><a href=\"#7-网站底部字数统计\" class=\"headerlink\" title=\"7.网站底部字数统计\"></a>7.网站底部字数统计</h1><p>具体方法实现<br>切换到根目录下，然后运行如下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>\n<p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"8-添加-README-md-文件\"><a href=\"#8-添加-README-md-文件\" class=\"headerlink\" title=\"8.添加 README.md 文件\"></a>8.添加 README.md 文件</h1><p>每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。</p>\n<p>在 Hexo 目录下的 <code>source</code> 根目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: README.md</span><br></pre></td></tr></table></figure></p>\n<p>保存退出即可。再次使用 <code>hexo d</code> 命令部署博客的时候就不会在渲染 README.md 这个文件了。</p>\n<h1 id=\"9-设置网站的图标Favicon\"><a href=\"#9-设置网站的图标Favicon\" class=\"headerlink\" title=\"9.设置网站的图标Favicon\"></a>9.设置网站的图标Favicon</h1><p>在<a href=\"https://www.easyicon.net/\" target=\"_blank\" rel=\"noopener\">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在<code>/themes/next/source/images</code>里，并且修改主题配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Put your favicon.ico into `hexo-site/source/` directory.</span><br><span class=\"line\">favicon: /favicon.ico</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"11-实现统计功能\"><a href=\"#11-实现统计功能\" class=\"headerlink\" title=\"11.实现统计功能\"></a>11.实现统计功能</h1><p>在根目录下安装 <code>hexo-wordcount</code>,运行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>\n<p>然后在主题的配置文件中，配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Post wordcount display settings</span><br><span class=\"line\"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class=\"line\">post_wordcount:</span><br><span class=\"line\">  item_text: true</span><br><span class=\"line\">  wordcount: true</span><br><span class=\"line\">  min2read: true</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"12-添加顶部加载条\"><a href=\"#12-添加顶部加载条\" class=\"headerlink\" title=\"12.添加顶部加载条\"></a>12.添加顶部加载条</h1><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件，添加如下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>但是，默认的是粉色的，要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .pace .pace-progress &#123;</span><br><span class=\"line\">        background: #1E92FB; /*进度条颜色*/</span><br><span class=\"line\">        height: 3px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .pace .pace-progress-inner &#123;</span><br><span class=\"line\">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .pace .pace-activity &#123;</span><br><span class=\"line\">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class=\"line\">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在升级最新版的next主题，升级后只需修改主题配置文件(<code>_config.yml</code>)将<code>pace: false</code>改为<code>pace: true</code>就行了，你还可以换不同样式的加载条.</p>\n<h1 id=\"13-在文章底部增加版权信息\"><a href=\"#13-在文章底部增加版权信息\" class=\"headerlink\" title=\"13.在文章底部增加版权信息\"></a>13.在文章底部增加版权信息</h1><p>在目录 <code>next/layout/_macro/</code>下添加 <code>my-copyright.swig</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.copyright %&#125;</span><br><span class=\"line\">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class=\"line\">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt; </span><br><span class=\"line\">    var clipboard = new Clipboard(&apos;.fa-clipboard&apos;);</span><br><span class=\"line\">    $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class=\"line\">      clipboard.on(&apos;success&apos;, function()&#123;</span><br><span class=\"line\">        swal(&#123;   </span><br><span class=\"line\">          title: &quot;&quot;,   </span><br><span class=\"line\">          text: &apos;复制成功&apos;,</span><br><span class=\"line\">          icon: &quot;success&quot;, </span><br><span class=\"line\">          showConfirmButton: true</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.my_post_copyright &#123;</span><br><span class=\"line\">  width: 85%;</span><br><span class=\"line\">  max-width: 45em;</span><br><span class=\"line\">  margin: 2.8em auto 0;</span><br><span class=\"line\">  padding: 0.5em 1.0em;</span><br><span class=\"line\">  border: 1px solid #d3d3d3;</span><br><span class=\"line\">  font-size: 0.93rem;</span><br><span class=\"line\">  line-height: 1.6em;</span><br><span class=\"line\">  word-break: break-all;</span><br><span class=\"line\">  background: rgba(255,255,255,0.4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class=\"line\">.my_post_copyright span &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  width: 5.2em;</span><br><span class=\"line\">  color: #b5b5b5;</span><br><span class=\"line\">  font-weight: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .raw &#123;</span><br><span class=\"line\">  margin-left: 1em;</span><br><span class=\"line\">  width: 5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright a &#123;</span><br><span class=\"line\">  color: #808080;</span><br><span class=\"line\">  border-bottom:0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright a:hover &#123;</span><br><span class=\"line\">  color: #a3d2a3;</span><br><span class=\"line\">  text-decoration: underline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class=\"line\">  color: #000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .post-url:hover &#123;</span><br><span class=\"line\">  font-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .copy-path &#123;</span><br><span class=\"line\">  margin-left: 1em;</span><br><span class=\"line\">  width: 1em;</span><br><span class=\"line\">  +mobile()&#123;display:none;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.my_post_copyright .copy-path:hover &#123;</span><br><span class=\"line\">  color: #808080;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>next/layout/_macro/post.swig</code>，在代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">      &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &#123;% include &apos;wechat-subscriber.swig&apos; %&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>之前添加增加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">      &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &#123;% include &apos;my-copyright.swig&apos; %&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></p>\n<p>保存重新生成即可。<br>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：</p>\n<p>小技巧：如果你觉得每次都要输入<code>copyright: true</code>很麻烦的话,那么在<code>/scaffolds/post.md</code>文件中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">description: </span><br><span class=\"line\">copyright: </span><br><span class=\"line\">categories:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>这样每次<code>hexo new &quot;你的内容&quot;</code>之后，生成的md文件会自动把<code>copyright:</code>加到里面去<br>(注意：如果解析出来之后，你的原始链接有问题：如：<code>http://yoursite.com/2018/05/05/next主题模板一些配置/</code>,那么在根目录下<code>_config.yml</code>中写成类似这样：）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: https://duanruilong.github.io/</span><br><span class=\"line\">root: /blog</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">permalink_defaults:</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"14-修改网页底部的桃心\"><a href=\"#14-修改网页底部的桃心\" class=\"headerlink\" title=\"14.修改网页底部的桃心\"></a>14.修改网页底部的桃心</h1><p>打开<code>themes/next/layout/_partials/footer.swig</code>，找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class=\"line\">    &lt;i class=&quot;fa fa-&#123;&#123; theme.authoricon &#125;&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后还是在<a href=\"https://fontawesome.com/icons?from=io\" target=\"_blank\" rel=\"noopener\">图标库</a>中找到你自己喜欢的图标，然后修改画红线的部分就可以了。</p>\n<h1 id=\"15-文章加密访问\"><a href=\"#15-文章加密访问\" class=\"headerlink\" title=\"15.文章加密访问\"></a>15.文章加密访问</h1><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在以下位置插入这样一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    (function () &#123;</span><br><span class=\"line\">        if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class=\"line\">            if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123;</span><br><span class=\"line\">                alert(&apos;密码错误！&apos;);</span><br><span class=\"line\">                if (history.length === 1) &#123;</span><br><span class=\"line\">                    location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    history.back();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在文章上写成类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">description: </span><br><span class=\"line\">copyright: </span><br><span class=\"line\">categories:</span><br><span class=\"line\">password: password</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"16-添加jiathis分享\"><a href=\"#16-添加jiathis分享\" class=\"headerlink\" title=\"16.添加jiathis分享\"></a>16.添加jiathis分享</h1><p>在主题配置文件中，jiathis为true，就行了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Share 分享</span><br><span class=\"line\">jiathis: true</span><br><span class=\"line\"># Warning: JiaThis does not support https.</span><br><span class=\"line\">#add_this_id:</span><br></pre></td></tr></table></figure></p>\n<p>如果你想自定义话，打开<code>themes/next/layout/_partials/share/jiathis.swig</code>修改就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- JiaThis Button BEGIN --&gt;</span><br><span class=\"line\">&lt;div class=&quot;jiathis_style&quot;&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_kaixin001&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a href=&quot;http://www.jiathis.com/share&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">  &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"17-博文置顶或者排序\"><a href=\"#17-博文置顶或者排序\" class=\"headerlink\" title=\"17.博文置顶或者排序\"></a>17.博文置顶或者排序</h1><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class=\"line\">module.exports = function(locals)&#123;</span><br><span class=\"line\">  var config = this.config;</span><br><span class=\"line\">  var posts = locals.posts;</span><br><span class=\"line\">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class=\"line\">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class=\"line\">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class=\"line\">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class=\"line\">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class=\"line\">    perPage: config.index_generator.per_page,</span><br><span class=\"line\">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class=\"line\">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      __index: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 第一篇blog</span><br><span class=\"line\">date: 2018-05-04 23:38:11</span><br><span class=\"line\">tags: 生活</span><br><span class=\"line\">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class=\"line\">copyright: true</span><br><span class=\"line\">top: 12</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"18-修改字体大小\"><a href=\"#18-修改字体大小\" class=\"headerlink\" title=\"18.修改字体大小\"></a>18.修改字体大小</h1><p>打开<code>\\themes\\next\\source\\css\\ _variables\\base.styl</code>文件，将<code>$font-size-base</code>改成<code>16px</code>，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$font-size-base            =16px</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"19-修改打赏字体不闪动\"><a href=\"#19-修改打赏字体不闪动\" class=\"headerlink\" title=\"19.修改打赏字体不闪动\"></a>19.修改打赏字体不闪动</h1><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 注释文字闪动函数</span><br><span class=\"line\"> #wechat:hover p&#123;</span><br><span class=\"line\">    animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -moz-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> #alipay:hover p&#123;</span><br><span class=\"line\">   animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -webkit-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">    -moz-animation: roll 0.1s infinite linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"20-点击爆炸效果\"><a href=\"#20-点击爆炸效果\" class=\"headerlink\" title=\"20.点击爆炸效果\"></a>20.点击爆炸效果</h1><p>跟那个红心是差不多的，首先在<code>themes/next/source/js/src</code>里面建一个叫f<code>ireworks.js</code>的文件，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.fireworks %&#125;</span><br><span class=\"line\">   &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; </span><br><span class=\"line\">   &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; </span><br><span class=\"line\">   &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打开主题配置文件，在里面最后写下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Fireworks</span><br><span class=\"line\">fireworks: true</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"21-DaoVoice-在线联系\"><a href=\"#21-DaoVoice-在线联系\" class=\"headerlink\" title=\"21.DaoVoice 在线联系\"></a>21.DaoVoice 在线联系</h1><p>首先在 <a href=\"http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f\" target=\"_blank\" rel=\"noopener\">daovoice</a> 注册账号,<a href=\"http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f\" target=\"_blank\" rel=\"noopener\">邀请码</a>是<code>0f81ff2f</code>，注册完成后会得到一个 app_id :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daovoice(&apos;init&apos;, &#123;</span><br><span class=\"line\">  app_id: &quot;0000000&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">daovoice(&apos;update&apos;);</span><br></pre></td></tr></table></figure>\n<p>记下这个 app_id的值，然后打开<code>/themes/next/layout/_partials/head.swig</code>,写下如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;% if theme.daovoice %&#125;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class=\"line\">  daovoice(&apos;init&apos;, &#123;</span><br><span class=\"line\">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  daovoice(&apos;update&apos;);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```````````````````````````````````````````</span><br></pre></td></tr></table></figure></p>\n<p><meta http-equiv=\"Cache-Control\" content=\"no-transform\"></p>\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\">\n\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着打开主题配置文件，在最后写下如下代码：</span><br><span class=\"line\">```hash</span><br><span class=\"line\"># Online contact </span><br><span class=\"line\">daovoice: true</span><br><span class=\"line\">daovoice_app_id: 这里填你的刚才获得的 app_id</span><br></pre></td></tr></table></figure>\n<p>重新 <code>hexo g &amp;&amp; hexo s</code> 就能看到效果了。<br>安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式</p>\n<h1 id=\"22-添加跟帖-来必力\"><a href=\"#22-添加跟帖-来必力\" class=\"headerlink\" title=\"22.添加跟帖(来必力)\"></a>22.添加跟帖(来必力)</h1><p>有两种实现方法：<br>①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p>\n<p>②如果你不想更新的话，那么按下面步骤进行：<br>首先，还是在主题配置文件<code>_config.yml</code> 文件中添加如下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure></p>"},{"title":"什么是 Rax，以及 Rax 的特点","date":"2018-05-10T16:29:57.000Z","description":null,"copyright":true,"top":null,"_content":"\n![Rac](https://img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png)\n\n\n\nRax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax.\n\n<!-- more -->\n# Rax\n经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。\n于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。\n\n# Rax 与 React\nReact 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。\n\n# Rax 的特点\n#### 1、设计上支持不同容器\nRax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。\n\n#### 2、体积足够小\n如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。\n\n#### 3、支持返回多个同级节点\n任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：\n``` hash\nimport {createElement, Component, render} from 'rax';\n\nclass Test extends Component {\n  render() {\n    return [1, 2, 3].map((item) => {\n      return <p>{item}</p>;\n    });\n  }\n}\n```\n这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。\n\n#### 4、标准化\n在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.\n当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。\n## 未来\nWrite once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。\n对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?\n了解更多 Rax 相关内容，欢迎访问 [alibaba.github.io/rax](alibaba.github.io/rax) \n来自Rax 团队敬上。\n原文链接[https://alibaba.github.io/rax/blog/whats-rax](https://alibaba.github.io/rax/blog/whats-rax)\n\n\n\n\n","source":"_posts/什么是-Rax，以及-Rax-的特点.md","raw":"---\ntitle: 什么是 Rax，以及 Rax 的特点\ndate: 2018-05-11 00:29:57\ntags: [编程,React]\ndescription: \ncopyright: true\ncategories: React\ntop:\n---\n\n![Rac](https://img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png)\n\n\n\nRax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax.\n\n<!-- more -->\n# Rax\n经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。\n于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。\n\n# Rax 与 React\nReact 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。\n\n# Rax 的特点\n#### 1、设计上支持不同容器\nRax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。\n\n#### 2、体积足够小\n如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。\n\n#### 3、支持返回多个同级节点\n任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：\n``` hash\nimport {createElement, Component, render} from 'rax';\n\nclass Test extends Component {\n  render() {\n    return [1, 2, 3].map((item) => {\n      return <p>{item}</p>;\n    });\n  }\n}\n```\n这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。\n\n#### 4、标准化\n在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.\n当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。\n## 未来\nWrite once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。\n对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?\n了解更多 Rax 相关内容，欢迎访问 [alibaba.github.io/rax](alibaba.github.io/rax) \n来自Rax 团队敬上。\n原文链接[https://alibaba.github.io/rax/blog/whats-rax](https://alibaba.github.io/rax/blog/whats-rax)\n\n\n\n\n","slug":"什么是-Rax，以及-Rax-的特点","published":1,"updated":"2018-09-18T13:07:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnel002mkt89t5t9avtl","content":"<p><img src=\"https://img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png\" alt=\"Rac\"></p>\n<p>Rax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax.</p>\n<a id=\"more\"></a>\n<h1 id=\"Rax\"><a href=\"#Rax\" class=\"headerlink\" title=\"Rax\"></a>Rax</h1><p>经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。<br>于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。</p>\n<h1 id=\"Rax-与-React\"><a href=\"#Rax-与-React\" class=\"headerlink\" title=\"Rax 与 React\"></a>Rax 与 React</h1><p>React 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。</p>\n<h1 id=\"Rax-的特点\"><a href=\"#Rax-的特点\" class=\"headerlink\" title=\"Rax 的特点\"></a>Rax 的特点</h1><h4 id=\"1、设计上支持不同容器\"><a href=\"#1、设计上支持不同容器\" class=\"headerlink\" title=\"1、设计上支持不同容器\"></a>1、设计上支持不同容器</h4><p>Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。</p>\n<h4 id=\"2、体积足够小\"><a href=\"#2、体积足够小\" class=\"headerlink\" title=\"2、体积足够小\"></a>2、体积足够小</h4><p>如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。</p>\n<h4 id=\"3、支持返回多个同级节点\"><a href=\"#3、支持返回多个同级节点\" class=\"headerlink\" title=\"3、支持返回多个同级节点\"></a>3、支持返回多个同级节点</h4><p>任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;createElement, Component, render&#125; from &apos;rax&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return [1, 2, 3].map((item) =&gt; &#123;</span><br><span class=\"line\">      return &lt;p&gt;&#123;item&#125;&lt;/p&gt;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。</p>\n<h4 id=\"4、标准化\"><a href=\"#4、标准化\" class=\"headerlink\" title=\"4、标准化\"></a>4、标准化</h4><p>在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.<br>当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。</p>\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。<br>对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?<br>了解更多 Rax 相关内容，欢迎访问 <a href=\"alibaba.github.io/rax\">alibaba.github.io/rax</a><br>来自Rax 团队敬上。<br>原文链接<a href=\"https://alibaba.github.io/rax/blog/whats-rax\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/rax/blog/whats-rax</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png\" alt=\"Rac\"></p>\n<p>Rax is a universal JavaScript library with a largely React-compatible API. If you use React, you already know how to use Rax.</p>","more":"<h1 id=\"Rax\"><a href=\"#Rax\" class=\"headerlink\" title=\"Rax\"></a>Rax</h1><p>经过这次试水，Weex 的方案开始逐步使用，证明了这套方案未来的场景及可行性，2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。<br>于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。</p>\n<h1 id=\"Rax-与-React\"><a href=\"#Rax-与-React\" class=\"headerlink\" title=\"Rax 与 React\"></a>Rax 与 React</h1><p>React 是一种标准，Rax 是对该标准的一个实现。Rax 只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React。当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。</p>\n<h1 id=\"Rax-的特点\"><a href=\"#Rax-的特点\" class=\"headerlink\" title=\"Rax 的特点\"></a>Rax 的特点</h1><h4 id=\"1、设计上支持不同容器\"><a href=\"#1、设计上支持不同容器\" class=\"headerlink\" title=\"1、设计上支持不同容器\"></a>1、设计上支持不同容器</h4><p>Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。</p>\n<h4 id=\"2、体积足够小\"><a href=\"#2、体积足够小\" class=\"headerlink\" title=\"2、体积足够小\"></a>2、体积足够小</h4><p>如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。</p>\n<h4 id=\"3、支持返回多个同级节点\"><a href=\"#3、支持返回多个同级节点\" class=\"headerlink\" title=\"3、支持返回多个同级节点\"></a>3、支持返回多个同级节点</h4><p>任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;createElement, Component, render&#125; from &apos;rax&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return [1, 2, 3].map((item) =&gt; &#123;</span><br><span class=\"line\">      return &lt;p&gt;&#123;item&#125;&lt;/p&gt;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。</p>\n<h4 id=\"4、标准化\"><a href=\"#4、标准化\" class=\"headerlink\" title=\"4、标准化\"></a>4、标准化</h4><p>在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 navigator, document, location, alert 等 W3C 的标准 API.<br>当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。</p>\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。<br>对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax?<br>了解更多 Rax 相关内容，欢迎访问 <a href=\"alibaba.github.io/rax\">alibaba.github.io/rax</a><br>来自Rax 团队敬上。<br>原文链接<a href=\"https://alibaba.github.io/rax/blog/whats-rax\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/rax/blog/whats-rax</a></p>"},{"title":"使用Hexo + Github搭建个人博客详细配置","date":"2018-05-05T11:02:51.000Z","description":null,"copyright":true,"_content":"\n开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。\n\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n\n# 新建文章\n\n`hexo new '文章标题'`\n\n# 生成静态网页&部署\n\n` hexo clean ` 清除缓存\n` hexo g ` 生成静态网页\n` hexo d  ` 开始部署\n\n连接写法：` hexo c && hexo g && hexo d`\n\n# 开启评论\n1.我使用多说代替自带的评论，在[多说](http://duoshuo.com/) 网站注册 > 后台管理 > 添加新站点 > 工具 === 复制通用代码 里面有 short_name\n\n在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的\n\n复制到 themes\\landscape\\layout\\_partial\\article.ejs\n把\n```h\n<% if (!index && post.comments && config.disqus_shortname){ %>\n<section id=\"comments\">\n<div id=\"disqus_thread\">\n  <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n</div>\n</section>\n<% } %>\n\n```\n改为\n```h\n<% if (!index && post.comments && config.disqus_shortname){ %>\n  <section id=\"comments\">\n    <!-- 多说评论框 start -->\n    <div class=\"ds-thread\" data-thread-key=\"<%= post.layout %>-<%= post.slug %>\" data-title=\"<%= post.title %>\" data-url=\"<%= page.permalink %>\"></div>\n    <!-- 多说评论框 end -->\n    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n    <script type=\"text/javascript\">\n    var duoshuoQuery = {short_name:'<%= config.disqus_shortname %>'};\n      (function() {\n        var ds = document.createElement('script');\n        ds.type = 'text/javascript';ds.async = true;\n        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n        ds.charset = 'UTF-8';\n        (document.getElementsByTagName('head')[0] \n         || document.getElementsByTagName('body')[0]).appendChild(ds);\n      })();\n      </script>\n    <!-- 多说公共JS代码 end -->\n  </section>\n<% } %>\n```\n\n\n# hexo相处里的错误\n\n## 部署没有权限\n\n```h\n[master 74ddc79] Site updated: 2018-07-22 23:14:27\n 1 file changed, 1 insertion(+), 1 deletion(-)\nWarning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.<anonymous> (/Users/duanruilong/Github/hexo/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:106:13)\n    at ChildProcess.emit (events.js:191:7)\n    at maybeClose (internal/child_process.js:877:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)\n\n\n```\n查看权限\n\n```h\n\n➜  ~ ssh -T git@github.com\ngit@github.com: Permission denied (publickey).\n\n<!--就是没有权限 -->\n```\n\n### 接下来这样来\n\n#### 1、检查是否有SSH key\n\n- 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ，查看是否有SSH keys。如果有，直接进行第三步。\n\n#### 2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：\n\n`ssh-keygen -t rsa -C \"邮箱名\"`\n\n然后会出现：\n```h\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/dell/.ssh/id_rsa):\n\n直接回车就可以。\n然后会出现：\n\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n\n要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，直接输入就好。\n然后会出现：\n\nYour identification has been saved in /c/Users/dell/.ssh/id_rsa.\nYour public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.\nThe key fingerprint is:\n65:69:······02:4b emailname@email.com\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|                 |\n|       .   o .   |\n|    . o o = o    |\n|   . o * = o     |\n|  E  o + o .     |\n| . o.   . .      |\n|     ..          |\n+-----------------+\n\n至此，密钥已经成功生成。\n\n```\n\n#### 3、接下来在github上添加SSH key：\n\n- ① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是/Users/duanruilong/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n- ② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n- ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。\n\n#### 4、测试设置是否成功\n\n`ssh -T git@github.com`\n\n有可能会出现：\n\n```h\n\n    The authenticity of host 'github.com (192.30.252.1)' can't be established.\n    RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n    Are you sure you want to continue connecting (yes/no)?\n\n    或者是\n\n    The authenticity of host 'github.com (192.30.252.1)' can't be established.\n    RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n    Are you sure you want to continue connecting (yes/no)?\n\n    这种情况下，直接 yes 回车\n\n    然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）：\n\n    Hi username! You've successfully authenticated, but GitHub does not \n    provide shell access.\n\n```\n\n#### 5、设置用户信息\n\n`~ git config --global user.name`\n`~ git config --global user.email`\n\n#### 6、然后就可以部署你的博客\n\n`hexo g  && hexo d`\n","source":"_posts/使用Hexo-Github搭建个人博客详细配置.md","raw":"---\ntitle: 使用Hexo + Github搭建个人博客详细配置\ndate: 2018-05-05 19:02:51\ntags: 生活\ndescription: \ncopyright: true\ncategories: Hexo\n---\n\n开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。\n\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n\n# 新建文章\n\n`hexo new '文章标题'`\n\n# 生成静态网页&部署\n\n` hexo clean ` 清除缓存\n` hexo g ` 生成静态网页\n` hexo d  ` 开始部署\n\n连接写法：` hexo c && hexo g && hexo d`\n\n# 开启评论\n1.我使用多说代替自带的评论，在[多说](http://duoshuo.com/) 网站注册 > 后台管理 > 添加新站点 > 工具 === 复制通用代码 里面有 short_name\n\n在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的\n\n复制到 themes\\landscape\\layout\\_partial\\article.ejs\n把\n```h\n<% if (!index && post.comments && config.disqus_shortname){ %>\n<section id=\"comments\">\n<div id=\"disqus_thread\">\n  <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n</div>\n</section>\n<% } %>\n\n```\n改为\n```h\n<% if (!index && post.comments && config.disqus_shortname){ %>\n  <section id=\"comments\">\n    <!-- 多说评论框 start -->\n    <div class=\"ds-thread\" data-thread-key=\"<%= post.layout %>-<%= post.slug %>\" data-title=\"<%= post.title %>\" data-url=\"<%= page.permalink %>\"></div>\n    <!-- 多说评论框 end -->\n    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n    <script type=\"text/javascript\">\n    var duoshuoQuery = {short_name:'<%= config.disqus_shortname %>'};\n      (function() {\n        var ds = document.createElement('script');\n        ds.type = 'text/javascript';ds.async = true;\n        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n        ds.charset = 'UTF-8';\n        (document.getElementsByTagName('head')[0] \n         || document.getElementsByTagName('body')[0]).appendChild(ds);\n      })();\n      </script>\n    <!-- 多说公共JS代码 end -->\n  </section>\n<% } %>\n```\n\n\n# hexo相处里的错误\n\n## 部署没有权限\n\n```h\n[master 74ddc79] Site updated: 2018-07-22 23:14:27\n 1 file changed, 1 insertion(+), 1 deletion(-)\nWarning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.<anonymous> (/Users/duanruilong/Github/hexo/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:106:13)\n    at ChildProcess.emit (events.js:191:7)\n    at maybeClose (internal/child_process.js:877:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)\n\n\n```\n查看权限\n\n```h\n\n➜  ~ ssh -T git@github.com\ngit@github.com: Permission denied (publickey).\n\n<!--就是没有权限 -->\n```\n\n### 接下来这样来\n\n#### 1、检查是否有SSH key\n\n- 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ，查看是否有SSH keys。如果有，直接进行第三步。\n\n#### 2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：\n\n`ssh-keygen -t rsa -C \"邮箱名\"`\n\n然后会出现：\n```h\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/dell/.ssh/id_rsa):\n\n直接回车就可以。\n然后会出现：\n\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n\n要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，直接输入就好。\n然后会出现：\n\nYour identification has been saved in /c/Users/dell/.ssh/id_rsa.\nYour public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.\nThe key fingerprint is:\n65:69:······02:4b emailname@email.com\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|                 |\n|       .   o .   |\n|    . o o = o    |\n|   . o * = o     |\n|  E  o + o .     |\n| . o.   . .      |\n|     ..          |\n+-----------------+\n\n至此，密钥已经成功生成。\n\n```\n\n#### 3、接下来在github上添加SSH key：\n\n- ① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是/Users/duanruilong/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n- ② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n- ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。\n\n#### 4、测试设置是否成功\n\n`ssh -T git@github.com`\n\n有可能会出现：\n\n```h\n\n    The authenticity of host 'github.com (192.30.252.1)' can't be established.\n    RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n    Are you sure you want to continue connecting (yes/no)?\n\n    或者是\n\n    The authenticity of host 'github.com (192.30.252.1)' can't be established.\n    RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n    Are you sure you want to continue connecting (yes/no)?\n\n    这种情况下，直接 yes 回车\n\n    然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）：\n\n    Hi username! You've successfully authenticated, but GitHub does not \n    provide shell access.\n\n```\n\n#### 5、设置用户信息\n\n`~ git config --global user.name`\n`~ git config --global user.email`\n\n#### 6、然后就可以部署你的博客\n\n`hexo g  && hexo d`\n","slug":"使用Hexo-Github搭建个人博客详细配置","published":1,"updated":"2018-09-18T12:25:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnem002qkt89kvuy1vg2","content":"<p>开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><p><code>hexo new &#39;文章标题&#39;</code></p>\n<h1 id=\"生成静态网页-amp-部署\"><a href=\"#生成静态网页-amp-部署\" class=\"headerlink\" title=\"生成静态网页&amp;部署\"></a>生成静态网页&amp;部署</h1><p><code>hexo clean</code> 清除缓存<br><code>hexo g</code> 生成静态网页<br><code>hexo d</code> 开始部署</p>\n<p>连接写法：<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code></p>\n<h1 id=\"开启评论\"><a href=\"#开启评论\" class=\"headerlink\" title=\"开启评论\"></a>开启评论</h1><p>1.我使用多说代替自带的评论，在<a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a> 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</p>\n<p>在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</p>\n<p>复制到 themes\\landscape\\layout_partial\\article.ejs<br>把<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class=\"line\">&lt;section id=<span class=\"string\">\"comments\"</span>&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"disqus_thread\"</span>&gt;</span><br><span class=\"line\">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=<span class=\"string\">\"//disqus.com/?ref_noscript\"</span>&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n<p>改为<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class=\"line\">  &lt;section id=<span class=\"string\">\"comments\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 多说评论框 start --&gt;</span><br><span class=\"line\">    &lt;div class=<span class=\"string\">\"ds-thread\"</span> data-thread-key=<span class=\"string\">\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\"</span> data-title=<span class=\"string\">\"&lt;%= post.title %&gt;\"</span> data-url=<span class=\"string\">\"&lt;%= page.permalink %&gt;\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;!-- 多说评论框 end --&gt;</span><br><span class=\"line\">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    var duoshuoQuery = &#123;short_name:'&lt;%= config.disqus_shortname %&gt;'&#125;;</span><br><span class=\"line\">      (function() &#123;</span><br><span class=\"line\">        var ds = document.createElement('script');</span><br><span class=\"line\">        ds.type = 'text/javascript';ds.async = true;</span><br><span class=\"line\">        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';</span><br><span class=\"line\">        ds.charset = 'UTF-8';</span><br><span class=\"line\">        (document.getElementsByTagName('head')[0] </span><br><span class=\"line\">         || document.getElementsByTagName('body')[0]).appendChild(ds);</span><br><span class=\"line\">      &#125;)();</span><br><span class=\"line\">      &lt;/script&gt;</span><br><span class=\"line\">    &lt;!-- 多说公共JS代码 end --&gt;</span><br><span class=\"line\">  &lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"hexo相处里的错误\"><a href=\"#hexo相处里的错误\" class=\"headerlink\" title=\"hexo相处里的错误\"></a>hexo相处里的错误</h1><h2 id=\"部署没有权限\"><a href=\"#部署没有权限\" class=\"headerlink\" title=\"部署没有权限\"></a>部署没有权限</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[master <span class=\"number\">74</span>ddc79] Site updated: <span class=\"number\">2018</span><span class=\"number\">-07</span><span class=\"number\">-22</span> <span class=\"number\">23</span>:<span class=\"number\">14</span>:<span class=\"number\">27</span></span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">1</span> insertion(+), <span class=\"number\">1</span> deletion(-)</span><br><span class=\"line\">Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could <span class=\"keyword\">not</span> read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\"><span class=\"keyword\">and</span> the repository exists.</span><br><span class=\"line\">FATAL Something's wrong. Maybe you can find the solution here: http:<span class=\"comment\">//hexo.io/docs/troubleshooting.html</span></span><br><span class=\"line\">Error: Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could <span class=\"keyword\">not</span> read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\"><span class=\"keyword\">and</span> the repository exists.</span><br><span class=\"line\"></span><br><span class=\"line\">    at ChildProcess.&lt;anonymous&gt; (/Users/duanruilong/Github/hexo/node_modules/hexo-util/lib/spawn.js:<span class=\"number\">37</span>:<span class=\"number\">17</span>)</span><br><span class=\"line\">    <span class=\"function\">at <span class=\"title\">emitTwo</span> <span class=\"params\">(events.js:<span class=\"number\">106</span>:<span class=\"number\">13</span>)</span></span></span><br><span class=\"line\">    at ChildProcess.emit (events.js:191:7)</span><br><span class=\"line\">    <span class=\"function\">at <span class=\"title\">maybeClose</span> <span class=\"params\">(internal/child_process.js:<span class=\"number\">877</span>:<span class=\"number\">16</span>)</span></span></span><br><span class=\"line\">    at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)</span><br></pre></td></tr></table></figure>\n<p>查看权限</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">➜  ~ ssh -T git@github.com</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--就是没有权限 --&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接下来这样来\"><a href=\"#接下来这样来\" class=\"headerlink\" title=\"接下来这样来\"></a>接下来这样来</h3><h4 id=\"1、检查是否有SSH-key\"><a href=\"#1、检查是否有SSH-key\" class=\"headerlink\" title=\"1、检查是否有SSH key\"></a>1、检查是否有SSH key</h4><ul>\n<li>登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接进行第三步。</li>\n</ul>\n<h4 id=\"2、新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：\"><a href=\"#2、新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：\" class=\"headerlink\" title=\"2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：\"></a>2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：</h4><p><code>ssh-keygen -t rsa -C &quot;邮箱名&quot;</code></p>\n<p>然后会出现：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating <span class=\"keyword\">public</span>/<span class=\"keyword\">private</span> rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa):</span><br><span class=\"line\"></span><br><span class=\"line\">直接回车就可以。</span><br><span class=\"line\">然后会出现：</span><br><span class=\"line\"></span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\"></span><br><span class=\"line\">要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：输入密码的时候没有*字样的，直接输入就好。</span><br><span class=\"line\">然后会出现：</span><br><span class=\"line\"></span><br><span class=\"line\">Your identification has been saved in /c/Users/dell/.ssh/id_rsa.</span><br><span class=\"line\">Your <span class=\"keyword\">public</span> key has been saved in /c/Users/dell/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\"><span class=\"number\">65</span>:<span class=\"number\">69</span>:······<span class=\"number\">02</span>:<span class=\"number\">4b</span> emailname@email.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+--[ RSA <span class=\"number\">2048</span>]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|       .   o .   |</span><br><span class=\"line\">|    . o o = o    |</span><br><span class=\"line\">|   . o * = o     |</span><br><span class=\"line\">|  E  o + o .     |</span><br><span class=\"line\">| . o.   . .      |</span><br><span class=\"line\">|     ..          |</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\"></span><br><span class=\"line\">至此，密钥已经成功生成。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、接下来在github上添加SSH-key：\"><a href=\"#3、接下来在github上添加SSH-key：\" class=\"headerlink\" title=\"3、接下来在github上添加SSH key：\"></a>3、接下来在github上添加SSH key：</h4><ul>\n<li><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是/Users/duanruilong/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n</li>\n<li><p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n</li>\n<li><p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。</p>\n</li>\n</ul>\n<h4 id=\"4、测试设置是否成功\"><a href=\"#4、测试设置是否成功\" class=\"headerlink\" title=\"4、测试设置是否成功\"></a>4、测试设置是否成功</h4><p><code>ssh -T git@github.com</code></p>\n<p>有可能会出现：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'github.com (192.30.252.1)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is <span class=\"number\">16</span>:<span class=\"number\">27</span>:ac:a5:<span class=\"number\">76</span>:<span class=\"number\">28</span>:<span class=\"number\">2</span>d:<span class=\"number\">36</span>:<span class=\"number\">63</span>:<span class=\"number\">1b</span>:<span class=\"number\">56</span>:<span class=\"number\">4</span>d:eb:df:a6:<span class=\"number\">48.</span></span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br><span class=\"line\"></span><br><span class=\"line\">或者是</span><br><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'github.com (192.30.252.1)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br><span class=\"line\"></span><br><span class=\"line\">这种情况下，直接 yes 回车</span><br><span class=\"line\"></span><br><span class=\"line\">然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）：</span><br><span class=\"line\"></span><br><span class=\"line\">Hi username! You've successfully authenticated, but GitHub does <span class=\"keyword\">not</span> </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、设置用户信息\"><a href=\"#5、设置用户信息\" class=\"headerlink\" title=\"5、设置用户信息\"></a>5、设置用户信息</h4><p><code>~ git config --global user.name</code><br><code>~ git config --global user.email</code></p>\n<h4 id=\"6、然后就可以部署你的博客\"><a href=\"#6、然后就可以部署你的博客\" class=\"headerlink\" title=\"6、然后就可以部署你的博客\"></a>6、然后就可以部署你的博客</h4><p><code>hexo g  &amp;&amp; hexo d</code></p>\n","site":{"data":{}},"excerpt":"<p>开始使用Hexo + Github去搭建一个属于自己的博客站点，可以在这里发布一下自己的想法，一些问题积累，一些发现。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>","more":"<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><p><code>hexo new &#39;文章标题&#39;</code></p>\n<h1 id=\"生成静态网页-amp-部署\"><a href=\"#生成静态网页-amp-部署\" class=\"headerlink\" title=\"生成静态网页&amp;部署\"></a>生成静态网页&amp;部署</h1><p><code>hexo clean</code> 清除缓存<br><code>hexo g</code> 生成静态网页<br><code>hexo d</code> 开始部署</p>\n<p>连接写法：<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code></p>\n<h1 id=\"开启评论\"><a href=\"#开启评论\" class=\"headerlink\" title=\"开启评论\"></a>开启评论</h1><p>1.我使用多说代替自带的评论，在<a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a> 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</p>\n<p>在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</p>\n<p>复制到 themes\\landscape\\layout_partial\\article.ejs<br>把<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class=\"line\">&lt;section id=<span class=\"string\">\"comments\"</span>&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"disqus_thread\"</span>&gt;</span><br><span class=\"line\">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=<span class=\"string\">\"//disqus.com/?ref_noscript\"</span>&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n<p>改为<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class=\"line\">  &lt;section id=<span class=\"string\">\"comments\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 多说评论框 start --&gt;</span><br><span class=\"line\">    &lt;div class=<span class=\"string\">\"ds-thread\"</span> data-thread-key=<span class=\"string\">\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\"</span> data-title=<span class=\"string\">\"&lt;%= post.title %&gt;\"</span> data-url=<span class=\"string\">\"&lt;%= page.permalink %&gt;\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;!-- 多说评论框 end --&gt;</span><br><span class=\"line\">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    var duoshuoQuery = &#123;short_name:'&lt;%= config.disqus_shortname %&gt;'&#125;;</span><br><span class=\"line\">      (function() &#123;</span><br><span class=\"line\">        var ds = document.createElement('script');</span><br><span class=\"line\">        ds.type = 'text/javascript';ds.async = true;</span><br><span class=\"line\">        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';</span><br><span class=\"line\">        ds.charset = 'UTF-8';</span><br><span class=\"line\">        (document.getElementsByTagName('head')[0] </span><br><span class=\"line\">         || document.getElementsByTagName('body')[0]).appendChild(ds);</span><br><span class=\"line\">      &#125;)();</span><br><span class=\"line\">      &lt;/script&gt;</span><br><span class=\"line\">    &lt;!-- 多说公共JS代码 end --&gt;</span><br><span class=\"line\">  &lt;/section&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"hexo相处里的错误\"><a href=\"#hexo相处里的错误\" class=\"headerlink\" title=\"hexo相处里的错误\"></a>hexo相处里的错误</h1><h2 id=\"部署没有权限\"><a href=\"#部署没有权限\" class=\"headerlink\" title=\"部署没有权限\"></a>部署没有权限</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[master <span class=\"number\">74</span>ddc79] Site updated: <span class=\"number\">2018</span><span class=\"number\">-07</span><span class=\"number\">-22</span> <span class=\"number\">23</span>:<span class=\"number\">14</span>:<span class=\"number\">27</span></span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">1</span> insertion(+), <span class=\"number\">1</span> deletion(-)</span><br><span class=\"line\">Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could <span class=\"keyword\">not</span> read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\"><span class=\"keyword\">and</span> the repository exists.</span><br><span class=\"line\">FATAL Something's wrong. Maybe you can find the solution here: http:<span class=\"comment\">//hexo.io/docs/troubleshooting.html</span></span><br><span class=\"line\">Error: Warning: Permanently added the RSA host key for IP address '13.250.177.223' to the list of known hosts.</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could <span class=\"keyword\">not</span> read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\"><span class=\"keyword\">and</span> the repository exists.</span><br><span class=\"line\"></span><br><span class=\"line\">    at ChildProcess.&lt;anonymous&gt; (/Users/duanruilong/Github/hexo/node_modules/hexo-util/lib/spawn.js:<span class=\"number\">37</span>:<span class=\"number\">17</span>)</span><br><span class=\"line\">    <span class=\"function\">at <span class=\"title\">emitTwo</span> <span class=\"params\">(events.js:<span class=\"number\">106</span>:<span class=\"number\">13</span>)</span></span></span><br><span class=\"line\">    at ChildProcess.emit (events.js:191:7)</span><br><span class=\"line\">    <span class=\"function\">at <span class=\"title\">maybeClose</span> <span class=\"params\">(internal/child_process.js:<span class=\"number\">877</span>:<span class=\"number\">16</span>)</span></span></span><br><span class=\"line\">    at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)</span><br></pre></td></tr></table></figure>\n<p>查看权限</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">➜  ~ ssh -T git@github.com</span><br><span class=\"line\">git@github.com: Permission denied (publickey).</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--就是没有权限 --&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接下来这样来\"><a href=\"#接下来这样来\" class=\"headerlink\" title=\"接下来这样来\"></a>接下来这样来</h3><h4 id=\"1、检查是否有SSH-key\"><a href=\"#1、检查是否有SSH-key\" class=\"headerlink\" title=\"1、检查是否有SSH key\"></a>1、检查是否有SSH key</h4><ul>\n<li>登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接进行第三步。</li>\n</ul>\n<h4 id=\"2、新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：\"><a href=\"#2、新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：\" class=\"headerlink\" title=\"2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：\"></a>2、新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：</h4><p><code>ssh-keygen -t rsa -C &quot;邮箱名&quot;</code></p>\n<p>然后会出现：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating <span class=\"keyword\">public</span>/<span class=\"keyword\">private</span> rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa):</span><br><span class=\"line\"></span><br><span class=\"line\">直接回车就可以。</span><br><span class=\"line\">然后会出现：</span><br><span class=\"line\"></span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\"></span><br><span class=\"line\">要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：输入密码的时候没有*字样的，直接输入就好。</span><br><span class=\"line\">然后会出现：</span><br><span class=\"line\"></span><br><span class=\"line\">Your identification has been saved in /c/Users/dell/.ssh/id_rsa.</span><br><span class=\"line\">Your <span class=\"keyword\">public</span> key has been saved in /c/Users/dell/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\"><span class=\"number\">65</span>:<span class=\"number\">69</span>:······<span class=\"number\">02</span>:<span class=\"number\">4b</span> emailname@email.com</span><br><span class=\"line\">The key's randomart image is:</span><br><span class=\"line\">+--[ RSA <span class=\"number\">2048</span>]----+</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">|       .   o .   |</span><br><span class=\"line\">|    . o o = o    |</span><br><span class=\"line\">|   . o * = o     |</span><br><span class=\"line\">|  E  o + o .     |</span><br><span class=\"line\">| . o.   . .      |</span><br><span class=\"line\">|     ..          |</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\"></span><br><span class=\"line\">至此，密钥已经成功生成。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、接下来在github上添加SSH-key：\"><a href=\"#3、接下来在github上添加SSH-key：\" class=\"headerlink\" title=\"3、接下来在github上添加SSH key：\"></a>3、接下来在github上添加SSH key：</h4><ul>\n<li><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是/Users/duanruilong/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n</li>\n<li><p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n</li>\n<li><p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。</p>\n</li>\n</ul>\n<h4 id=\"4、测试设置是否成功\"><a href=\"#4、测试设置是否成功\" class=\"headerlink\" title=\"4、测试设置是否成功\"></a>4、测试设置是否成功</h4><p><code>ssh -T git@github.com</code></p>\n<p>有可能会出现：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'github.com (192.30.252.1)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is <span class=\"number\">16</span>:<span class=\"number\">27</span>:ac:a5:<span class=\"number\">76</span>:<span class=\"number\">28</span>:<span class=\"number\">2</span>d:<span class=\"number\">36</span>:<span class=\"number\">63</span>:<span class=\"number\">1b</span>:<span class=\"number\">56</span>:<span class=\"number\">4</span>d:eb:df:a6:<span class=\"number\">48.</span></span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br><span class=\"line\"></span><br><span class=\"line\">或者是</span><br><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'github.com (192.30.252.1)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br><span class=\"line\"></span><br><span class=\"line\">这种情况下，直接 yes 回车</span><br><span class=\"line\"></span><br><span class=\"line\">然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）：</span><br><span class=\"line\"></span><br><span class=\"line\">Hi username! You've successfully authenticated, but GitHub does <span class=\"keyword\">not</span> </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、设置用户信息\"><a href=\"#5、设置用户信息\" class=\"headerlink\" title=\"5、设置用户信息\"></a>5、设置用户信息</h4><p><code>~ git config --global user.name</code><br><code>~ git config --global user.email</code></p>\n<h4 id=\"6、然后就可以部署你的博客\"><a href=\"#6、然后就可以部署你的博客\" class=\"headerlink\" title=\"6、然后就可以部署你的博客\"></a>6、然后就可以部署你的博客</h4><p><code>hexo g  &amp;&amp; hexo d</code></p>"},{"title":"前端小笔记本","date":"2018-07-31T16:09:43.000Z","description":null,"copyright":true,"top":null,"_content":"\n这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png)\n\n<!-- more -->\n\n# Node环境起一个服务\n\n## 准备工作\n需要安装NodeJS环境\n- 1、安装Express\n`npm install express -g`\n`npm install express-generator -g`\n\n- 2、初始化项目\n新建项目\n`express 项目名称`\n\n```h\n➜  Weichat express serverDmo\n\n  warning: the default view engine will not be jade in future releases\n  warning: use `--view=jade' or `--help' for additional options\n\n\n   create : serverDmo/\n   create : serverDmo/public/\n   create : serverDmo/public/javascripts/\n   create : serverDmo/public/images/\n   create : serverDmo/public/stylesheets/\n   create : serverDmo/public/stylesheets/style.css\n   create : serverDmo/routes/\n   create : serverDmo/routes/index.js\n   create : serverDmo/routes/users.js\n   create : serverDmo/views/\n   create : serverDmo/views/error.jade\n   create : serverDmo/views/index.jade\n   create : serverDmo/views/layout.jade\n   create : serverDmo/app.js\n   create : serverDmo/package.json\n   create : serverDmo/bin/\n   create : serverDmo/bin/www\n\n   change directory:\n     $ cd serverDmo\n\n   install dependencies:\n     $ npm install\n\n   run the app:\n     $ DEBUG=serverdmo:* npm start\n\n```\n目录介绍：\n/bin:用来启动应用（服务器）\n/public: 存放静态资源目录\n/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。\n/views: 模板文件所在目录 文件格式为.jade\n目录app.js程序main文件 这个是服务器启动的入口\n\n## 首先启动服务器\n`npm start //启动服务器`\n\n在浏览器中访问 http://localhost:3000/\n\n## 基本使用\n打开app.js 这里介绍下主要代码\n```h\n var express = require('express');\n var path = require('path');\n var favicon = require('serve-favicon');\n var logger = require('morgan');\n var cookieParser = require('cookie-parser');\n var bodyParser = require('body-parser');\n\n var app = express();\n\n\n///=======路由信息 （接口地址）开始 存放在./routes目录下===========//\n var routes = require('./routes/index');//home page接口\n var users = require('./routes/users'); //用户接口\n\n app.use('/', routes); //在app中注册routes该接口 \n app.use('/users', users);//在app中注册users接口\n///=======路由信息 （接口地址 介绍===========//\n\n\n\n///=======模板 开始===========//\n// view engine setup\n app.set('views', path.join(__dirname, 'views'));\n app.set('view engine', 'jade');\n///=======模板 结束===========//\n\n当我们在浏览器中 访问 http://localhost:3000/ 调用的就是index中的接口\n我们打开index.js就可以看到该接口的定义：\nvar express = require('express');\nvar router = express.Router();\n\n\n//定义一个get请求 path为根目录\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n定义一个路由的基本格式为：\n`app.METHOD(PATH, HANDLER)`\n其中：\napp 是 express 的实例。\nMETHOD是 HTTP 请求方法。\nPATH 是服务器上的路径。\nHANDLER 是在路由匹配时执行的函数。\n以上的定义代表\n\n\n","source":"_posts/前端小笔记本.md","raw":"---\ntitle: 前端小笔记本\ndate: 2018-08-01 00:09:43\ntags: [Javascript,小程序,编程,React]\ndescription: \ncopyright: true\ncategories: 编程\ntop:\n---\n\n这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png)\n\n<!-- more -->\n\n# Node环境起一个服务\n\n## 准备工作\n需要安装NodeJS环境\n- 1、安装Express\n`npm install express -g`\n`npm install express-generator -g`\n\n- 2、初始化项目\n新建项目\n`express 项目名称`\n\n```h\n➜  Weichat express serverDmo\n\n  warning: the default view engine will not be jade in future releases\n  warning: use `--view=jade' or `--help' for additional options\n\n\n   create : serverDmo/\n   create : serverDmo/public/\n   create : serverDmo/public/javascripts/\n   create : serverDmo/public/images/\n   create : serverDmo/public/stylesheets/\n   create : serverDmo/public/stylesheets/style.css\n   create : serverDmo/routes/\n   create : serverDmo/routes/index.js\n   create : serverDmo/routes/users.js\n   create : serverDmo/views/\n   create : serverDmo/views/error.jade\n   create : serverDmo/views/index.jade\n   create : serverDmo/views/layout.jade\n   create : serverDmo/app.js\n   create : serverDmo/package.json\n   create : serverDmo/bin/\n   create : serverDmo/bin/www\n\n   change directory:\n     $ cd serverDmo\n\n   install dependencies:\n     $ npm install\n\n   run the app:\n     $ DEBUG=serverdmo:* npm start\n\n```\n目录介绍：\n/bin:用来启动应用（服务器）\n/public: 存放静态资源目录\n/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。\n/views: 模板文件所在目录 文件格式为.jade\n目录app.js程序main文件 这个是服务器启动的入口\n\n## 首先启动服务器\n`npm start //启动服务器`\n\n在浏览器中访问 http://localhost:3000/\n\n## 基本使用\n打开app.js 这里介绍下主要代码\n```h\n var express = require('express');\n var path = require('path');\n var favicon = require('serve-favicon');\n var logger = require('morgan');\n var cookieParser = require('cookie-parser');\n var bodyParser = require('body-parser');\n\n var app = express();\n\n\n///=======路由信息 （接口地址）开始 存放在./routes目录下===========//\n var routes = require('./routes/index');//home page接口\n var users = require('./routes/users'); //用户接口\n\n app.use('/', routes); //在app中注册routes该接口 \n app.use('/users', users);//在app中注册users接口\n///=======路由信息 （接口地址 介绍===========//\n\n\n\n///=======模板 开始===========//\n// view engine setup\n app.set('views', path.join(__dirname, 'views'));\n app.set('view engine', 'jade');\n///=======模板 结束===========//\n\n当我们在浏览器中 访问 http://localhost:3000/ 调用的就是index中的接口\n我们打开index.js就可以看到该接口的定义：\nvar express = require('express');\nvar router = express.Router();\n\n\n//定义一个get请求 path为根目录\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n定义一个路由的基本格式为：\n`app.METHOD(PATH, HANDLER)`\n其中：\napp 是 express 的实例。\nMETHOD是 HTTP 请求方法。\nPATH 是服务器上的路径。\nHANDLER 是在路由匹配时执行的函数。\n以上的定义代表\n\n\n","slug":"前端小笔记本","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctneq002ukt89j4z6363x","content":"<p>这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"Node环境起一个服务\"><a href=\"#Node环境起一个服务\" class=\"headerlink\" title=\"Node环境起一个服务\"></a>Node环境起一个服务</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>需要安装NodeJS环境</p>\n<ul>\n<li><p>1、安装Express<br><code>npm install express -g</code><br><code>npm install express-generator -g</code></p>\n</li>\n<li><p>2、初始化项目<br>新建项目<br><code>express 项目名称</code></p>\n</li>\n</ul>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  Weichat express serverDmo</span><br><span class=\"line\"></span><br><span class=\"line\">  warning: the <span class=\"keyword\">default</span> view engine will <span class=\"keyword\">not</span> be jade in future releases</span><br><span class=\"line\">  warning: use `--view=jade' <span class=\"keyword\">or</span> `--help' <span class=\"keyword\">for</span> additional options</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   create : serverDmo/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/javascripts/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/images/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/stylesheets/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/stylesheets/style.css</span><br><span class=\"line\">   create : serverDmo/routes/</span><br><span class=\"line\">   create : serverDmo/routes/index.js</span><br><span class=\"line\">   create : serverDmo/routes/users.js</span><br><span class=\"line\">   create : serverDmo/views/</span><br><span class=\"line\">   create : serverDmo/views/error.jade</span><br><span class=\"line\">   create : serverDmo/views/index.jade</span><br><span class=\"line\">   create : serverDmo/views/layout.jade</span><br><span class=\"line\">   create : serverDmo/app.js</span><br><span class=\"line\">   create : serverDmo/package.json</span><br><span class=\"line\">   create : serverDmo/bin/</span><br><span class=\"line\">   create : serverDmo/bin/www</span><br><span class=\"line\"></span><br><span class=\"line\">   change directory:</span><br><span class=\"line\">     $ cd serverDmo</span><br><span class=\"line\"></span><br><span class=\"line\">   install dependencies:</span><br><span class=\"line\">     $ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">   run the app:</span><br><span class=\"line\">     $ DEBUG=serverdmo:* npm start</span><br></pre></td></tr></table></figure>\n<p>目录介绍：<br>/bin:用来启动应用（服务器）<br>/public: 存放静态资源目录<br>/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。<br>/views: 模板文件所在目录 文件格式为.jade<br>目录app.js程序main文件 这个是服务器启动的入口</p>\n<h2 id=\"首先启动服务器\"><a href=\"#首先启动服务器\" class=\"headerlink\" title=\"首先启动服务器\"></a>首先启动服务器</h2><p><code>npm start //启动服务器</code></p>\n<p>在浏览器中访问 <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>打开app.js 这里介绍下主要代码<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var express = require('express');</span><br><span class=\"line\"> var path = require('path');</span><br><span class=\"line\"> var favicon = require('serve-favicon');</span><br><span class=\"line\"> var logger = require('morgan');</span><br><span class=\"line\"> var cookieParser = require('cookie-parser');</span><br><span class=\"line\"> var bodyParser = require('body-parser');</span><br><span class=\"line\"></span><br><span class=\"line\"> var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///=======路由信息 （接口地址）开始 存放在./routes目录下===========//</span></span><br><span class=\"line\"> var routes = require('./routes/index');//home page接口</span><br><span class=\"line\"> var users = require('./routes/users'); //用户接口</span><br><span class=\"line\"></span><br><span class=\"line\"> app.use(<span class=\"string\">'/'</span>, routes); <span class=\"comment\">//在app中注册routes该接口 </span></span><br><span class=\"line\"> app.use('/users', users);//在app中注册users接口</span><br><span class=\"line\"><span class=\"comment\">///=======路由信息 （接口地址 介绍===========//</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///=======模板 开始===========//</span></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\"> app.set('views', path.join(__dirname, 'views'));</span><br><span class=\"line\"> app.set('view engine', 'jade');</span><br><span class=\"line\"><span class=\"comment\">///=======模板 结束===========//</span></span><br><span class=\"line\"></span><br><span class=\"line\">当我们在浏览器中 访问 http:<span class=\"comment\">//localhost:3000/ 调用的就是index中的接口</span></span><br><span class=\"line\">我们打开index.js就可以看到该接口的定义：</span><br><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个get请求 path为根目录</span></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function(req, res, next) &#123;</span><br><span class=\"line\"> res.render('index', &#123; title: 'Express' &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个路由的基本格式为：<br><code>app.METHOD(PATH, HANDLER)</code><br>其中：<br>app 是 express 的实例。<br>METHOD是 HTTP 请求方法。<br>PATH 是服务器上的路径。<br>HANDLER 是在路由匹配时执行的函数。<br>以上的定义代表</p>\n","site":{"data":{}},"excerpt":"<p>这里会收录一些偶尔不知道了，就去找一下的东西，慢慢积累。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png\" alt=\"js\"></p>","more":"<h1 id=\"Node环境起一个服务\"><a href=\"#Node环境起一个服务\" class=\"headerlink\" title=\"Node环境起一个服务\"></a>Node环境起一个服务</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>需要安装NodeJS环境</p>\n<ul>\n<li><p>1、安装Express<br><code>npm install express -g</code><br><code>npm install express-generator -g</code></p>\n</li>\n<li><p>2、初始化项目<br>新建项目<br><code>express 项目名称</code></p>\n</li>\n</ul>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  Weichat express serverDmo</span><br><span class=\"line\"></span><br><span class=\"line\">  warning: the <span class=\"keyword\">default</span> view engine will <span class=\"keyword\">not</span> be jade in future releases</span><br><span class=\"line\">  warning: use `--view=jade' <span class=\"keyword\">or</span> `--help' <span class=\"keyword\">for</span> additional options</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   create : serverDmo/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/javascripts/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/images/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/stylesheets/</span><br><span class=\"line\">   create : serverDmo/<span class=\"keyword\">public</span>/stylesheets/style.css</span><br><span class=\"line\">   create : serverDmo/routes/</span><br><span class=\"line\">   create : serverDmo/routes/index.js</span><br><span class=\"line\">   create : serverDmo/routes/users.js</span><br><span class=\"line\">   create : serverDmo/views/</span><br><span class=\"line\">   create : serverDmo/views/error.jade</span><br><span class=\"line\">   create : serverDmo/views/index.jade</span><br><span class=\"line\">   create : serverDmo/views/layout.jade</span><br><span class=\"line\">   create : serverDmo/app.js</span><br><span class=\"line\">   create : serverDmo/package.json</span><br><span class=\"line\">   create : serverDmo/bin/</span><br><span class=\"line\">   create : serverDmo/bin/www</span><br><span class=\"line\"></span><br><span class=\"line\">   change directory:</span><br><span class=\"line\">     $ cd serverDmo</span><br><span class=\"line\"></span><br><span class=\"line\">   install dependencies:</span><br><span class=\"line\">     $ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">   run the app:</span><br><span class=\"line\">     $ DEBUG=serverdmo:* npm start</span><br></pre></td></tr></table></figure>\n<p>目录介绍：<br>/bin:用来启动应用（服务器）<br>/public: 存放静态资源目录<br>/routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。<br>/views: 模板文件所在目录 文件格式为.jade<br>目录app.js程序main文件 这个是服务器启动的入口</p>\n<h2 id=\"首先启动服务器\"><a href=\"#首先启动服务器\" class=\"headerlink\" title=\"首先启动服务器\"></a>首先启动服务器</h2><p><code>npm start //启动服务器</code></p>\n<p>在浏览器中访问 <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>打开app.js 这里介绍下主要代码<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var express = require('express');</span><br><span class=\"line\"> var path = require('path');</span><br><span class=\"line\"> var favicon = require('serve-favicon');</span><br><span class=\"line\"> var logger = require('morgan');</span><br><span class=\"line\"> var cookieParser = require('cookie-parser');</span><br><span class=\"line\"> var bodyParser = require('body-parser');</span><br><span class=\"line\"></span><br><span class=\"line\"> var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///=======路由信息 （接口地址）开始 存放在./routes目录下===========//</span></span><br><span class=\"line\"> var routes = require('./routes/index');//home page接口</span><br><span class=\"line\"> var users = require('./routes/users'); //用户接口</span><br><span class=\"line\"></span><br><span class=\"line\"> app.use(<span class=\"string\">'/'</span>, routes); <span class=\"comment\">//在app中注册routes该接口 </span></span><br><span class=\"line\"> app.use('/users', users);//在app中注册users接口</span><br><span class=\"line\"><span class=\"comment\">///=======路由信息 （接口地址 介绍===========//</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///=======模板 开始===========//</span></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\"> app.set('views', path.join(__dirname, 'views'));</span><br><span class=\"line\"> app.set('view engine', 'jade');</span><br><span class=\"line\"><span class=\"comment\">///=======模板 结束===========//</span></span><br><span class=\"line\"></span><br><span class=\"line\">当我们在浏览器中 访问 http:<span class=\"comment\">//localhost:3000/ 调用的就是index中的接口</span></span><br><span class=\"line\">我们打开index.js就可以看到该接口的定义：</span><br><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个get请求 path为根目录</span></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, function(req, res, next) &#123;</span><br><span class=\"line\"> res.render('index', &#123; title: 'Express' &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个路由的基本格式为：<br><code>app.METHOD(PATH, HANDLER)</code><br>其中：<br>app 是 express 的实例。<br>METHOD是 HTTP 请求方法。<br>PATH 是服务器上的路径。<br>HANDLER 是在路由匹配时执行的函数。<br>以上的定义代表</p>"},{"title":"前端面试集锦","date":"2018-05-24T14:30:17.000Z","description":null,"copyright":true,"top":9,"_content":"\n这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png)\n\n<!--more-->\n\n# 前言\n\n> 一些更新从最新的开始\n\n# Ract\n\n## React生命周期?\n### React 生命周期分为三种状态 `1. 初始化` `2.更新` `3.销毁`\n\n![react生命周期](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png)\n\n<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->\n\n> 初始化\n\n1、`getDefaultProps()` 设置默认的props，也可以使用`dufaultProps`设置组件的默认属性\n2、`getInitialState()`在es6的class语法里是没有这个函数的，可直接在`construction`里去定义`this.state`也就可以访问到`this.props`\n3、`compontentWillMount()`整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改`state`值\n4、`render` 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了\n5、`compontentDidMount()` 组件渲染完成之后调用，且只调用一次\n\n> 更新\n\n6、`componentWillReceiverProps(nextProps)` 在组件初始化的时候不会触发，组件接收到新的`props`时触发\n7、`shouldCompontUpdate(nextProps, nextState)` 这里是`React`性能优化非常重要的生命周期。在组件接收到新的`props`或者`state`时可以触发这个生命周期，可以对比前后`props`和`state`是否一样，如果相同一样则返回`false`去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行`diff`算法对比，极大地节省性能。\n8、`componentWillUpdate(nextProps, nextState)` 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改`state`\n9、`render()` 渲染组件\n10、 `componentDidUpdate()` 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取`dom`节点\n\n> 卸载\n\n\n11、`componentWillUnmount()` 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等\n***\n\n\n\n# 前端的一些知识模块\n** HTML **\n对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储\n\n** CSS **\nflex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性\n\n** JavaScript **\n数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE\n\n** 其他 **\n移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作\n\n作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。\n\n# HTML\n##  Doctype作用？标准模式与兼容模式各有什么区别?\n\n1、`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于 `<html> `标签之前。告知浏览器的解析器用什么文档标准解析这个文档。`DOCTYPE`不存在或格式不正确会导致文档以兼容模式呈现。\n\n2、`标准模式的排版` 和 `JS运作模式`都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。\n***\n## HTML5 为什么只需要写 <!DOCTYPE HTML>？\nHTML5不基于`SGML`,所以不需要对DTD进行引用，但是他也需要`DOCTYPE`来规范浏览器的行为。\n***\n## 常见的浏览器有哪些，及其浏览器的内核是啥？\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]\nWebkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]\n***\n## 浏览器内核的理解？\n主要分为两部分：`渲染引擎（Layout engineer或Rendering Engine）`和`JS引擎`\n> 渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。\n\n> JS引擎：解析和执行JavaScript实现网页动态效果。\n***\n## 页面样式引入，`link`与``@import`的区别？\n1、`link`属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；\n2、`@import`是CSS提供的，只能用于加载CSS;\n3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n4、`import`是CSS2.1 提出的，只在IE5以上才能被识别，而`link`是XHTML标签，`无兼容问题`;\n***\n## 行内元素有哪些，块级元素有哪些，空元素有哪些？\n> CSS规范规定，每个元素都有`display`属性，确定该元素的类型，每个元素都有默认的`display`值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。\n\n行内元素: `a b span img input select strong(强调的语气)`\n块级元素：`div p ul ol li dl dt dd h1 h2 h3 h4 ...`\n常见的空元素: `<br> <hr> <img> <input> <link> <meta>`和`<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>`\n***\n## HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\n```h\nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n    - 绘画 canvas;\n    - 用于媒介回放的 video 和 audio 元素;\n    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n    - sessionStorage 的数据在浏览器关闭后自动删除;\n    - 语意化更好的内容元素，比如 article、footer、header、nav、section;\n    - 表单控件，calendar、date、time、email、url、search;\n    - 新的技术webworker, websocket, Geolocation;\n\n    - 移除的元素：\n        纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n        对可用性产生负面影响的元素：frame，frameset，noframes；\n\n   - 支持HTML5新标签：\n        IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n        可以利用这一特性让这些浏览器支持HTML5新标签，\n        浏览器支持新标签后，还需要添加标签默认的样式。\n\n        当然也可以直接使用成熟的框架、比如html5shim;\n        <!--[if lt IE 9]>\n            <script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n        <![endif]-->\n\n如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n```\n***\n## 简述一下你对HTML语义化的理解？\n`用正确的标签做正确的事情。`\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n***\n## HTML5的离线储存怎么使用，工作原理能不能解释一下？\n>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n\n如何使用：\n1、页面头部像下面一样加入一个`manifest`的属性；\n2、在`cache.manifest`文件的编写离线存储的资源；\n    `CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html`\n3、在离线状态时，操作`window.applicationCache`进行需求实现。\n\n详细的使用请参考：[HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/),[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n***\n## 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n在线的情况下，浏览器发现html头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n详细请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n***\n## 描述一下 `Cookies`，`SessionStorage` 和 `LocalStorage` 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n存储大小：\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n* localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n* sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n* cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n***\n## **Iframe有那些缺点？**\niframe会阻塞主页面的Onload事件；\n搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\niframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n> 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。\n***\n## Label的作用是什么？是怎么用的？\n> `label`标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n\n```\n<label for=\"Name\">Number:</label>\n<input type=“text“name=\"Name\" id=\"Name\"/>\n\n<label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n***\n\n\n# CSS\n\n## 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n（1）有两种， `IE 盒子模型`、`W3C 盒子模型`；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n***\n\n\n\n# 算法题\n\n### 快速排序\n\n思路:\n- 随机选择数组中的一个数 A，以这个数为基准\n- 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边\n- 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的\n- 这时候将左边和右边的数再递归上面的过程\n```h\nconst Arr = [85, 24, 63, 45, 17, 31, 96, 50];\nfunction quickSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    let pivotIndex = Math.floor(arr.length / 2);\n    let pivot = arr.splice(pivotIndex, 1)[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickSort(left).concat([pivot], quickSort(right));\n}\n\nconsole.log(quickSort(Arr));\n```\nps:\n这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。\n其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。\n\n这里是不同的声音： [面试官：阮一峰版的快速排序完全是错的](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40)\n\n***\n\n### 二分排序法\n\n二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。\n二分查找是一种「分治」思想的算法，大概流程如下：\n\n- 数组中排在中间的数字 A，与要找的数字比较大小\n- 因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A\n- 较小则说明应该从查找数字的后半部分查找\n- 这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止\n\n\n题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n```h\n\nfunction Find(target, array) {\n    let i = 0;\n    let j = array[i].length - 1;\n    while (i < array.length && j >= 0) {\n        if (array[i][j] < target) {\n            i++;\n        } else if (array[i][j] > target) {\n            j--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n//测试用例\nconsole.log(Find(10, [\n    [1, 2, 3, 4], \n    [5, 9, 10, 11], \n    [13, 20, 21, 23]\n    ])\n);\n\n```\n***\n\n### 解析url后的参数\n\n```h\nfunction parseParam(url) {\n  let obj = {};\n  let arr = url.split(\"?\");\n  if (arr.length == 1) { //判断没有问号\n    return \"无参数\"\n  }\n  let total = arr[1].split(\"&\");\n  for (let i = 0; i < total.length; i++) {\n    let single = total[i].split(\"=\");\n    if (single[0] == '') { //判断有？但是没有参数\n      return '无参数'\n    }\n    if (!single[1]) {\n      obj[single[0]] = true;\n    } else {\n      if (obj[single[0]]) {\n        let concat\n        if (!Array.isArray(obj[single[0]])) { //判断是否数组\n          concat = [obj[single[0]]]\n        } else {\n          concat = obj[single[0]];\n        }\n        concat.push(single[1]);\n        concat = new Set(concat);\n        concat = Array.from(concat) //数组去重\n        obj[single[0]] = concat\n      } else {\n        obj[single[0]] = decodeURI(single[1]) //进行转码\n      }\n    }\n  }\n  return obj\n}\n\nvar url = 'http://www.baidu.com/?user=huixin&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';\n\nvar params = parseParam(url)\n\nconsole.log(params)\n\n```\n***\n\n### 实现一个简单的模版引擎：\n\n例如：我叫a,年龄b，性别c； let data = { name: '小明', age: 18, } 没有定义的返回undefined\n\n```h\n\nlet template = '我是{name}，年龄{age}，性别{sex}';\nlet data = {\n    name: '小明',\n    age: 18,\n}\nconst  reg= /({([a-zA-Z]+)})/g;\nvar r= '',regrounp={};\nwhile( r = reg.exec(template) ){\n    Object.defineProperty(regrounp,r[2],{\n        enumerable:true,\n        value:r[2]\n    })\n}\n\nvar render = (template,regrounp)=>{\n    var result='';\n    for( key in regrounp){\n        if(data[key] == undefined){\n            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,\"g\"),undefined);\n        }else{\t\t\n            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,\"g\"),data[key]);\n        }\n    }\n    return result\n}\nlet newtemple = render(template, regrounp);\nconsole.log(newtemple) // 结果： 我是小明，年龄18，性别undefined\n\n```\n\n对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。\n\n\n这里有一片很好的文章 推荐 [编写一个简单的JavaScript模板引擎](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46)\n\n***\n\n### 如何快速让字符串变成已千为精度的数字\n\n```h\nfunction exchange(num) {\n    num += ''; //转成字符串\n    if (num.length <= 3) {\n        return num;\n    }\n\n    num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) => {\n        console.log(v)\n        return v + ',';\n    });\n    return num;\n}\n\nconsole.log(exchange(1234567));\n```\n***\n\n### 实现 JS 对象的深拷贝\n\n深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。\n分析下怎么做 深拷贝 ：\n\n- 首先假设深拷贝这个方法已经完成，为 deepClo\n- 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复\n\n```h\nfunction deepClo(o1, o2) {\n    for (let k in o2) {\n        if (typeof o2[k] === 'object') {\n            o1[k] = {};\n            deepClo(o1[k], o2[k]);\n        } else {\n            o1[k] = o2[k];\n        }\n    }\n}\n// 测试用例\nlet obj = {\n    a: 1,\n    b: [1, 2, 3],\n    c: {}\n};\nlet emptyObj = Object.create(null);\ndeepClo(emptyObj, obj);\nconsole.log(emptyObj.a == obj.a);\nconsole.log(emptyObj.b == obj.b);\n\n```\n递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。\n\n***\n\n### 求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项\n\n```h\n下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：\n let count = 0;\n function fn(n) {\n    let cache = {};\n    function _fn(n) {\n        if (cache[n]) {\n            return cache[n];\n        }\n        count++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        let prev = _fn(n - 1);\n        cache[n - 1] = prev;\n        let next = _fn(n - 2);\n        cache[n - 2] = next;\n        return prev + next;\n    }\n    return _fn(n);\n}\n\nlet count2 = 0;\nfunction fn2(n) {\n    count2++;\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return fn2(n - 1) + fn2(n - 2);\n}\n\nconsole.log(fn(20), count); // 6765 20\nconsole.log(fn2(20), count2); // 6765 13529\n\n```\n***\n\n### 算法的效率\n\n算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。\n常见的时间复杂度有：\n\n- 常数阶 O(1)\n- 对数阶 O(logN)\n- 线性阶 O(n)\n- 线性对数阶 O(nlogN)\n- 平方阶 O(n^2)\n- 立方阶 O(n^3)\n- !k次方阶 O(n^k)\n- 指数阶 O(2^n)\n\n随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n一般做算法复杂度分析的时候，遵循下面的技巧：\n\n- 看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推\n- 如果有二分，则为O(logN)\n- 保留最高项，去除常数项\n\n题目：分析下面代码的算法复杂度\n\n```h\nlet i =0; // 语句执行一次 \nwhile (i < n) { // 语句执行 n 次 \n  console.log(`Current i is ${i}`); //语句执行 n 次\n  i++; // 语句执行 n 次\n}\n根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。\n\n```\n更多阅读：\n[在 JavaScript 中学习数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18)\n[我接触过的前端数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension)\n\n\n","source":"_posts/前端面试集锦.md","raw":"---\ntitle: 前端面试集锦\ndate: 2018-05-24 22:30:17\ntags: [CSS,编程,Javascript,ES6]\ndescription: \ncopyright: true\ncategories: 编程\ntop: 9\n---\n\n这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png)\n\n<!--more-->\n\n# 前言\n\n> 一些更新从最新的开始\n\n# Ract\n\n## React生命周期?\n### React 生命周期分为三种状态 `1. 初始化` `2.更新` `3.销毁`\n\n![react生命周期](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png)\n\n<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->\n\n> 初始化\n\n1、`getDefaultProps()` 设置默认的props，也可以使用`dufaultProps`设置组件的默认属性\n2、`getInitialState()`在es6的class语法里是没有这个函数的，可直接在`construction`里去定义`this.state`也就可以访问到`this.props`\n3、`compontentWillMount()`整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改`state`值\n4、`render` 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了\n5、`compontentDidMount()` 组件渲染完成之后调用，且只调用一次\n\n> 更新\n\n6、`componentWillReceiverProps(nextProps)` 在组件初始化的时候不会触发，组件接收到新的`props`时触发\n7、`shouldCompontUpdate(nextProps, nextState)` 这里是`React`性能优化非常重要的生命周期。在组件接收到新的`props`或者`state`时可以触发这个生命周期，可以对比前后`props`和`state`是否一样，如果相同一样则返回`false`去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行`diff`算法对比，极大地节省性能。\n8、`componentWillUpdate(nextProps, nextState)` 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改`state`\n9、`render()` 渲染组件\n10、 `componentDidUpdate()` 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取`dom`节点\n\n> 卸载\n\n\n11、`componentWillUnmount()` 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等\n***\n\n\n\n# 前端的一些知识模块\n** HTML **\n对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储\n\n** CSS **\nflex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性\n\n** JavaScript **\n数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE\n\n** 其他 **\n移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作\n\n作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。\n\n# HTML\n##  Doctype作用？标准模式与兼容模式各有什么区别?\n\n1、`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于 `<html> `标签之前。告知浏览器的解析器用什么文档标准解析这个文档。`DOCTYPE`不存在或格式不正确会导致文档以兼容模式呈现。\n\n2、`标准模式的排版` 和 `JS运作模式`都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。\n***\n## HTML5 为什么只需要写 <!DOCTYPE HTML>？\nHTML5不基于`SGML`,所以不需要对DTD进行引用，但是他也需要`DOCTYPE`来规范浏览器的行为。\n***\n## 常见的浏览器有哪些，及其浏览器的内核是啥？\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]\nWebkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]\n***\n## 浏览器内核的理解？\n主要分为两部分：`渲染引擎（Layout engineer或Rendering Engine）`和`JS引擎`\n> 渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。\n\n> JS引擎：解析和执行JavaScript实现网页动态效果。\n***\n## 页面样式引入，`link`与``@import`的区别？\n1、`link`属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；\n2、`@import`是CSS提供的，只能用于加载CSS;\n3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n4、`import`是CSS2.1 提出的，只在IE5以上才能被识别，而`link`是XHTML标签，`无兼容问题`;\n***\n## 行内元素有哪些，块级元素有哪些，空元素有哪些？\n> CSS规范规定，每个元素都有`display`属性，确定该元素的类型，每个元素都有默认的`display`值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。\n\n行内元素: `a b span img input select strong(强调的语气)`\n块级元素：`div p ul ol li dl dt dd h1 h2 h3 h4 ...`\n常见的空元素: `<br> <hr> <img> <input> <link> <meta>`和`<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>`\n***\n## HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\n```h\nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n    - 绘画 canvas;\n    - 用于媒介回放的 video 和 audio 元素;\n    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n    - sessionStorage 的数据在浏览器关闭后自动删除;\n    - 语意化更好的内容元素，比如 article、footer、header、nav、section;\n    - 表单控件，calendar、date、time、email、url、search;\n    - 新的技术webworker, websocket, Geolocation;\n\n    - 移除的元素：\n        纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n        对可用性产生负面影响的元素：frame，frameset，noframes；\n\n   - 支持HTML5新标签：\n        IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n        可以利用这一特性让这些浏览器支持HTML5新标签，\n        浏览器支持新标签后，还需要添加标签默认的样式。\n\n        当然也可以直接使用成熟的框架、比如html5shim;\n        <!--[if lt IE 9]>\n            <script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n        <![endif]-->\n\n如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n```\n***\n## 简述一下你对HTML语义化的理解？\n`用正确的标签做正确的事情。`\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n***\n## HTML5的离线储存怎么使用，工作原理能不能解释一下？\n>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n\n如何使用：\n1、页面头部像下面一样加入一个`manifest`的属性；\n2、在`cache.manifest`文件的编写离线存储的资源；\n    `CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html`\n3、在离线状态时，操作`window.applicationCache`进行需求实现。\n\n详细的使用请参考：[HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/),[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n***\n## 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n在线的情况下，浏览器发现html头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n详细请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)\n***\n## 描述一下 `Cookies`，`SessionStorage` 和 `LocalStorage` 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n存储大小：\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n* localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n* sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n* cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n***\n## **Iframe有那些缺点？**\niframe会阻塞主页面的Onload事件；\n搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\niframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n> 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。\n***\n## Label的作用是什么？是怎么用的？\n> `label`标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n\n```\n<label for=\"Name\">Number:</label>\n<input type=“text“name=\"Name\" id=\"Name\"/>\n\n<label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n***\n\n\n# CSS\n\n## 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n（1）有两种， `IE 盒子模型`、`W3C 盒子模型`；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n***\n\n\n\n# 算法题\n\n### 快速排序\n\n思路:\n- 随机选择数组中的一个数 A，以这个数为基准\n- 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边\n- 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的\n- 这时候将左边和右边的数再递归上面的过程\n```h\nconst Arr = [85, 24, 63, 45, 17, 31, 96, 50];\nfunction quickSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    let pivotIndex = Math.floor(arr.length / 2);\n    let pivot = arr.splice(pivotIndex, 1)[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickSort(left).concat([pivot], quickSort(right));\n}\n\nconsole.log(quickSort(Arr));\n```\nps:\n这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。\n其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。\n\n这里是不同的声音： [面试官：阮一峰版的快速排序完全是错的](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40)\n\n***\n\n### 二分排序法\n\n二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。\n二分查找是一种「分治」思想的算法，大概流程如下：\n\n- 数组中排在中间的数字 A，与要找的数字比较大小\n- 因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A\n- 较小则说明应该从查找数字的后半部分查找\n- 这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止\n\n\n题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n```h\n\nfunction Find(target, array) {\n    let i = 0;\n    let j = array[i].length - 1;\n    while (i < array.length && j >= 0) {\n        if (array[i][j] < target) {\n            i++;\n        } else if (array[i][j] > target) {\n            j--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n//测试用例\nconsole.log(Find(10, [\n    [1, 2, 3, 4], \n    [5, 9, 10, 11], \n    [13, 20, 21, 23]\n    ])\n);\n\n```\n***\n\n### 解析url后的参数\n\n```h\nfunction parseParam(url) {\n  let obj = {};\n  let arr = url.split(\"?\");\n  if (arr.length == 1) { //判断没有问号\n    return \"无参数\"\n  }\n  let total = arr[1].split(\"&\");\n  for (let i = 0; i < total.length; i++) {\n    let single = total[i].split(\"=\");\n    if (single[0] == '') { //判断有？但是没有参数\n      return '无参数'\n    }\n    if (!single[1]) {\n      obj[single[0]] = true;\n    } else {\n      if (obj[single[0]]) {\n        let concat\n        if (!Array.isArray(obj[single[0]])) { //判断是否数组\n          concat = [obj[single[0]]]\n        } else {\n          concat = obj[single[0]];\n        }\n        concat.push(single[1]);\n        concat = new Set(concat);\n        concat = Array.from(concat) //数组去重\n        obj[single[0]] = concat\n      } else {\n        obj[single[0]] = decodeURI(single[1]) //进行转码\n      }\n    }\n  }\n  return obj\n}\n\nvar url = 'http://www.baidu.com/?user=huixin&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';\n\nvar params = parseParam(url)\n\nconsole.log(params)\n\n```\n***\n\n### 实现一个简单的模版引擎：\n\n例如：我叫a,年龄b，性别c； let data = { name: '小明', age: 18, } 没有定义的返回undefined\n\n```h\n\nlet template = '我是{name}，年龄{age}，性别{sex}';\nlet data = {\n    name: '小明',\n    age: 18,\n}\nconst  reg= /({([a-zA-Z]+)})/g;\nvar r= '',regrounp={};\nwhile( r = reg.exec(template) ){\n    Object.defineProperty(regrounp,r[2],{\n        enumerable:true,\n        value:r[2]\n    })\n}\n\nvar render = (template,regrounp)=>{\n    var result='';\n    for( key in regrounp){\n        if(data[key] == undefined){\n            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,\"g\"),undefined);\n        }else{\t\t\n            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,\"g\"),data[key]);\n        }\n    }\n    return result\n}\nlet newtemple = render(template, regrounp);\nconsole.log(newtemple) // 结果： 我是小明，年龄18，性别undefined\n\n```\n\n对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。\n\n\n这里有一片很好的文章 推荐 [编写一个简单的JavaScript模板引擎](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46)\n\n***\n\n### 如何快速让字符串变成已千为精度的数字\n\n```h\nfunction exchange(num) {\n    num += ''; //转成字符串\n    if (num.length <= 3) {\n        return num;\n    }\n\n    num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) => {\n        console.log(v)\n        return v + ',';\n    });\n    return num;\n}\n\nconsole.log(exchange(1234567));\n```\n***\n\n### 实现 JS 对象的深拷贝\n\n深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。\n分析下怎么做 深拷贝 ：\n\n- 首先假设深拷贝这个方法已经完成，为 deepClo\n- 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复\n\n```h\nfunction deepClo(o1, o2) {\n    for (let k in o2) {\n        if (typeof o2[k] === 'object') {\n            o1[k] = {};\n            deepClo(o1[k], o2[k]);\n        } else {\n            o1[k] = o2[k];\n        }\n    }\n}\n// 测试用例\nlet obj = {\n    a: 1,\n    b: [1, 2, 3],\n    c: {}\n};\nlet emptyObj = Object.create(null);\ndeepClo(emptyObj, obj);\nconsole.log(emptyObj.a == obj.a);\nconsole.log(emptyObj.b == obj.b);\n\n```\n递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。\n\n***\n\n### 求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项\n\n```h\n下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：\n let count = 0;\n function fn(n) {\n    let cache = {};\n    function _fn(n) {\n        if (cache[n]) {\n            return cache[n];\n        }\n        count++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        let prev = _fn(n - 1);\n        cache[n - 1] = prev;\n        let next = _fn(n - 2);\n        cache[n - 2] = next;\n        return prev + next;\n    }\n    return _fn(n);\n}\n\nlet count2 = 0;\nfunction fn2(n) {\n    count2++;\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return fn2(n - 1) + fn2(n - 2);\n}\n\nconsole.log(fn(20), count); // 6765 20\nconsole.log(fn2(20), count2); // 6765 13529\n\n```\n***\n\n### 算法的效率\n\n算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。\n常见的时间复杂度有：\n\n- 常数阶 O(1)\n- 对数阶 O(logN)\n- 线性阶 O(n)\n- 线性对数阶 O(nlogN)\n- 平方阶 O(n^2)\n- 立方阶 O(n^3)\n- !k次方阶 O(n^k)\n- 指数阶 O(2^n)\n\n随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n一般做算法复杂度分析的时候，遵循下面的技巧：\n\n- 看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推\n- 如果有二分，则为O(logN)\n- 保留最高项，去除常数项\n\n题目：分析下面代码的算法复杂度\n\n```h\nlet i =0; // 语句执行一次 \nwhile (i < n) { // 语句执行 n 次 \n  console.log(`Current i is ${i}`); //语句执行 n 次\n  i++; // 语句执行 n 次\n}\n根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。\n\n```\n更多阅读：\n[在 JavaScript 中学习数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18)\n[我接触过的前端数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension)\n\n\n","slug":"前端面试集锦","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnes002xkt89p7jmxtts","content":"<p>这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>一些更新从最新的开始</p>\n</blockquote>\n<h1 id=\"Ract\"><a href=\"#Ract\" class=\"headerlink\" title=\"Ract\"></a>Ract</h1><h2 id=\"React生命周期\"><a href=\"#React生命周期\" class=\"headerlink\" title=\"React生命周期?\"></a>React生命周期?</h2><h3 id=\"React-生命周期分为三种状态-1-初始化-2-更新-3-销毁\"><a href=\"#React-生命周期分为三种状态-1-初始化-2-更新-3-销毁\" class=\"headerlink\" title=\"React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁\"></a>React 生命周期分为三种状态 <code>1. 初始化</code> <code>2.更新</code> <code>3.销毁</code></h3><p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png\" alt=\"react生命周期\"></p>\n<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->\n<blockquote>\n<p>初始化</p>\n</blockquote>\n<p>1、<code>getDefaultProps()</code> 设置默认的props，也可以使用<code>dufaultProps</code>设置组件的默认属性<br>2、<code>getInitialState()</code>在es6的class语法里是没有这个函数的，可直接在<code>construction</code>里去定义<code>this.state</code>也就可以访问到<code>this.props</code><br>3、<code>compontentWillMount()</code>整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改<code>state</code>值<br>4、<code>render</code> 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了<br>5、<code>compontentDidMount()</code> 组件渲染完成之后调用，且只调用一次</p>\n<blockquote>\n<p>更新</p>\n</blockquote>\n<p>6、<code>componentWillReceiverProps(nextProps)</code> 在组件初始化的时候不会触发，组件接收到新的<code>props</code>时触发<br>7、<code>shouldCompontUpdate(nextProps, nextState)</code> 这里是<code>React</code>性能优化非常重要的生命周期。在组件接收到新的<code>props</code>或者<code>state</code>时可以触发这个生命周期，可以对比前后<code>props</code>和<code>state</code>是否一样，如果相同一样则返回<code>false</code>去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行<code>diff</code>算法对比，极大地节省性能。<br>8、<code>componentWillUpdate(nextProps, nextState)</code> 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改<code>state</code><br>9、<code>render()</code> 渲染组件<br>10、 <code>componentDidUpdate()</code> 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取<code>dom</code>节点</p>\n<blockquote>\n<p>卸载</p>\n</blockquote>\n<p>11、<code>componentWillUnmount()</code> 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等</p>\n<hr>\n<h1 id=\"前端的一些知识模块\"><a href=\"#前端的一些知识模块\" class=\"headerlink\" title=\"前端的一些知识模块\"></a>前端的一些知识模块</h1><p><strong> HTML </strong><br>对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储</p>\n<p><strong> CSS </strong><br>flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性</p>\n<p><strong> JavaScript </strong><br>数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE</p>\n<p><strong> 其他 </strong><br>移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作</p>\n<p>作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。</p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><h2 id=\"Doctype作用？标准模式与兼容模式各有什么区别\"><a href=\"#Doctype作用？标准模式与兼容模式各有什么区别\" class=\"headerlink\" title=\"Doctype作用？标准模式与兼容模式各有什么区别?\"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h2><p>1、<code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于 <code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现。</p>\n<p>2、<code>标准模式的排版</code> 和 <code>JS运作模式</code>都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。</p>\n<hr>\n<h2 id=\"HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\"><a href=\"#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\" class=\"headerlink\" title=\"HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？\"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h2><p>HTML5不基于<code>SGML</code>,所以不需要对DTD进行引用，但是他也需要<code>DOCTYPE</code>来规范浏览器的行为。</p>\n<hr>\n<h2 id=\"常见的浏览器有哪些，及其浏览器的内核是啥？\"><a href=\"#常见的浏览器有哪些，及其浏览器的内核是啥？\" class=\"headerlink\" title=\"常见的浏览器有哪些，及其浏览器的内核是啥？\"></a>常见的浏览器有哪些，及其浏览器的内核是啥？</h2><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]</p>\n<hr>\n<h2 id=\"浏览器内核的理解？\"><a href=\"#浏览器内核的理解？\" class=\"headerlink\" title=\"浏览器内核的理解？\"></a>浏览器内核的理解？</h2><p>主要分为两部分：<code>渲染引擎（Layout engineer或Rendering Engine）</code>和<code>JS引擎</code></p>\n<blockquote>\n<p>渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。</p>\n</blockquote>\n<blockquote>\n<p>JS引擎：解析和执行JavaScript实现网页动态效果。</p>\n</blockquote>\n<hr>\n<h2 id=\"页面样式引入，link与-import-的区别？\"><a href=\"#页面样式引入，link与-import-的区别？\" class=\"headerlink\" title=\"页面样式引入，link与@import`的区别？\"></a>页面样式引入，<code>link</code>与<code></code>@import`的区别？</h2><p>1、<code>link</code>属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<br>2、<code>@import</code>是CSS提供的，只能用于加载CSS;<br>3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>4、<code>import</code>是CSS2.1 提出的，只在IE5以上才能被识别，而<code>link</code>是XHTML标签，<code>无兼容问题</code>;</p>\n<hr>\n<h2 id=\"行内元素有哪些，块级元素有哪些，空元素有哪些？\"><a href=\"#行内元素有哪些，块级元素有哪些，空元素有哪些？\" class=\"headerlink\" title=\"行内元素有哪些，块级元素有哪些，空元素有哪些？\"></a>行内元素有哪些，块级元素有哪些，空元素有哪些？</h2><blockquote>\n<p>CSS规范规定，每个元素都有<code>display</code>属性，确定该元素的类型，每个元素都有默认的<code>display</code>值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p>\n</blockquote>\n<p>行内元素: <code>a b span img input select strong(强调的语气)</code><br>块级元素：<code>div p ul ol li dl dt dd h1 h2 h3 h4 ...</code><br>常见的空元素: <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>和<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p>\n<hr>\n<h2 id=\"HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？\"><a href=\"#HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？\" class=\"headerlink\" title=\"HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\"></a>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class=\"line\">    - 绘画 canvas;</span><br><span class=\"line\">    - 用于媒介回放的 video 和 audio 元素;</span><br><span class=\"line\">    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class=\"line\">    - sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class=\"line\">    - 语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class=\"line\">    - 表单控件，calendar、date、time、email、url、search;</span><br><span class=\"line\">    - 新的技术webworker, websocket, Geolocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    - 移除的元素：</span><br><span class=\"line\">        纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class=\"line\">        对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class=\"line\"></span><br><span class=\"line\">   - 支持HTML5新标签：</span><br><span class=\"line\">        IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class=\"line\">        可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class=\"line\">        浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">        当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class=\"line\">        &lt;!--[<span class=\"keyword\">if</span> lt IE <span class=\"number\">9</span>]&gt;</span><br><span class=\"line\">            &lt;script&gt; src=<span class=\"string\">\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</span>&lt;/script&gt;</span><br><span class=\"line\">        &lt;![endif]--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"简述一下你对HTML语义化的理解？\"><a href=\"#简述一下你对HTML语义化的理解？\" class=\"headerlink\" title=\"简述一下你对HTML语义化的理解？\"></a>简述一下你对HTML语义化的理解？</h2><p><code>用正确的标签做正确的事情。</code><br>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>\n<hr>\n<h2 id=\"HTML5的离线储存怎么使用，工作原理能不能解释一下？\"><a href=\"#HTML5的离线储存怎么使用，工作原理能不能解释一下？\" class=\"headerlink\" title=\"HTML5的离线储存怎么使用，工作原理能不能解释一下？\"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下？</h2><blockquote>\n<p> 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n</blockquote>\n<p>如何使用：<br>1、页面头部像下面一样加入一个<code>manifest</code>的属性；<br>2、在<code>cache.manifest</code>文件的编写离线存储的资源；<br>    <code>CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html</code><br>3、在离线状态时，操作<code>window.applicationCache</code>进行需求实现。</p>\n<p>详细的使用请参考：<a href=\"http://yanhaijing.com/html/2014/12/28/html5-manifest/\" target=\"_blank\" rel=\"noopener\">HTML5 离线缓存-manifest简介</a>,<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n<hr>\n<h2 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。<br>详细请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n<hr>\n<h2 id=\"描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？\"><a href=\"#描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？\" class=\"headerlink\" title=\"描述一下 Cookies，SessionStorage 和 LocalStorage 的区别？\"></a>描述一下 <code>Cookies</code>，<code>SessionStorage</code> 和 <code>LocalStorage</code> 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。<br>存储大小：</p>\n<ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n</ul>\n<p>有期时间：</p>\n<ul>\n<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>\n<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li>\n<li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<hr>\n<h2 id=\"Iframe有那些缺点？\"><a href=\"#Iframe有那些缺点？\" class=\"headerlink\" title=\"Iframe有那些缺点？\"></a><strong>Iframe有那些缺点？</strong></h2><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>\n<p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>\n<blockquote>\n<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>\n</blockquote>\n<hr>\n<h2 id=\"Label的作用是什么？是怎么用的？\"><a href=\"#Label的作用是什么？是怎么用的？\" class=\"headerlink\" title=\"Label的作用是什么？是怎么用的？\"></a>Label的作用是什么？是怎么用的？</h2><blockquote>\n<p><code>label</code>标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><h2 id=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"><a href=\"#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>（1）有两种， <code>IE 盒子模型</code>、<code>W3C 盒子模型</code>；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;</p>\n<hr>\n<h1 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h1><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>思路:</p>\n<ul>\n<li>随机选择数组中的一个数 A，以这个数为基准</li>\n<li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li>\n<li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li>\n<li>这时候将左边和右边的数再递归上面的过程<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Arr = [<span class=\"number\">85</span>, <span class=\"number\">24</span>, <span class=\"number\">63</span>, <span class=\"number\">45</span>, <span class=\"number\">17</span>, <span class=\"number\">31</span>, <span class=\"number\">96</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">quickSort</span><span class=\"params\">(arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let pivotIndex = Math.<span class=\"built_in\">floor</span>(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    let pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    let left = [];</span><br><span class=\"line\">    let right = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(quickSort(Arr));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ps:<br>这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。<br>其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。</p>\n<p>这里是不同的声音： <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40\" target=\"_blank\" rel=\"noopener\">面试官：阮一峰版的快速排序完全是错的</a></p>\n<hr>\n<h3 id=\"二分排序法\"><a href=\"#二分排序法\" class=\"headerlink\" title=\"二分排序法\"></a>二分排序法</h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。<br>二分查找是一种「分治」思想的算法，大概流程如下：</p>\n<ul>\n<li>数组中排在中间的数字 A，与要找的数字比较大小</li>\n<li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A</li>\n<li>较小则说明应该从查找数字的后半部分查找</li>\n<li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li>\n</ul>\n<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Find</span><span class=\"params\">(target, <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">    let i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    let j = <span class=\"built_in\">array</span>[i].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"built_in\">array</span>.length &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i][j] &lt; target) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i][j] &gt; target) &#123;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试用例</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Find(<span class=\"number\">10</span>, [</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], </span><br><span class=\"line\">    [<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>], </span><br><span class=\"line\">    [<span class=\"number\">13</span>, <span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\">    ])</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"解析url后的参数\"><a href=\"#解析url后的参数\" class=\"headerlink\" title=\"解析url后的参数\"></a>解析url后的参数</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">parseParam</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">  let obj = &#123;&#125;;</span><br><span class=\"line\">  let arr = url.split(<span class=\"string\">\"?\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123; <span class=\"comment\">//判断没有问号</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"无参数\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let total = arr[<span class=\"number\">1</span>].split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; total.length; i++) &#123;</span><br><span class=\"line\">    let single = total[i].split(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">    if (single[0] == '') &#123; //判断有？但是没有参数</span><br><span class=\"line\">      return '无参数'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!single[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      obj[single[<span class=\"number\">0</span>]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj[single[<span class=\"number\">0</span>]]) &#123;</span><br><span class=\"line\">        let concat</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Array.isArray(obj[single[<span class=\"number\">0</span>]])) &#123; <span class=\"comment\">//判断是否数组</span></span><br><span class=\"line\">          concat = [obj[single[<span class=\"number\">0</span>]]]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          concat = obj[single[<span class=\"number\">0</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        concat.push(single[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        concat = <span class=\"keyword\">new</span> Set(concat);</span><br><span class=\"line\">        concat = Array.from(concat) <span class=\"comment\">//数组去重</span></span><br><span class=\"line\">        obj[single[<span class=\"number\">0</span>]] = concat</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj[single[<span class=\"number\">0</span>]] = decodeURI(single[<span class=\"number\">1</span>]) <span class=\"comment\">//进行转码</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var url = 'http://www.baidu.com/?user=huixin&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled';</span><br><span class=\"line\"></span><br><span class=\"line\">var params = parseParam(url)</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(params)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"实现一个简单的模版引擎：\"><a href=\"#实现一个简单的模版引擎：\" class=\"headerlink\" title=\"实现一个简单的模版引擎：\"></a>实现一个简单的模版引擎：</h3><p>例如：我叫a,年龄b，性别c； let data = { name: ‘小明’, age: 18, } 没有定义的返回undefined</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let template = '我是&#123;name&#125;，年龄&#123;age&#125;，性别&#123;sex&#125;';</span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\">    name: '小明',</span><br><span class=\"line\">    age: <span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span>  reg= /(&#123;([a-zA-Z]+)&#125;)/g;</span><br><span class=\"line\">var r= '',regrounp=&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">while</span>( r = reg.exec(<span class=\"keyword\">template</span>) )&#123;</span><br><span class=\"line\">    Object.defineProperty(regrounp,r[<span class=\"number\">2</span>],&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">        value:r[<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var render = (<span class=\"keyword\">template</span>,regrounp)=&gt;&#123;</span><br><span class=\"line\">    var result='';</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( key in regrounp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data[key] == undefined)&#123;</span><br><span class=\"line\">            result  = (result || <span class=\"keyword\">template</span>).replace(<span class=\"keyword\">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class=\"string\">\"g\"</span>),undefined);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;\t\t</span><br><span class=\"line\">            result  = (result || <span class=\"keyword\">template</span>).replace(<span class=\"keyword\">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class=\"string\">\"g\"</span>),data[key]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let newtemple = render(<span class=\"keyword\">template</span>, regrounp);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(newtemple) <span class=\"comment\">// 结果： 我是小明，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>\n<p>对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。</p>\n<p>这里有一片很好的文章 推荐 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46\" target=\"_blank\" rel=\"noopener\">编写一个简单的JavaScript模板引擎</a></p>\n<hr>\n<h3 id=\"如何快速让字符串变成已千为精度的数字\"><a href=\"#如何快速让字符串变成已千为精度的数字\" class=\"headerlink\" title=\"如何快速让字符串变成已千为精度的数字\"></a>如何快速让字符串变成已千为精度的数字</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">exchange</span><span class=\"params\">(num)</span> </span>&#123;</span><br><span class=\"line\">    num += ''; //转成字符串</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num.length &lt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    num = num.replace(/\\d&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;(?=(\\d&#123;<span class=\"number\">3</span>&#125;)+$)/g, (v) =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v + <span class=\"string\">','</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(exchange(<span class=\"number\">1234567</span>));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"实现-JS-对象的深拷贝\"><a href=\"#实现-JS-对象的深拷贝\" class=\"headerlink\" title=\"实现 JS 对象的深拷贝\"></a>实现 JS 对象的深拷贝</h3><p>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。<br>分析下怎么做 深拷贝 ：</p>\n<ul>\n<li>首先假设深拷贝这个方法已经完成，为 deepClo</li>\n<li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li>\n</ul>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">deepClo</span><span class=\"params\">(o1, o2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let k in o2) &#123;</span><br><span class=\"line\">        if (typeof o2[k] === 'object') &#123;</span><br><span class=\"line\">            o1[k] = &#123;&#125;;</span><br><span class=\"line\">            deepClo(o1[k], o2[k]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            o1[k] = o2[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    c: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let emptyObj = Object.create(null);</span><br><span class=\"line\">deepClo(emptyObj, obj);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(emptyObj.a == obj.a);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(emptyObj.b == obj.b);</span><br></pre></td></tr></table></figure>\n<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。</p>\n<hr>\n<h3 id=\"求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项\"><a href=\"#求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项\" class=\"headerlink\" title=\"求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项\"></a>求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：</span><br><span class=\"line\"> let count = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"function\">function <span class=\"title\">fn</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    let cache = &#123;&#125;;</span><br><span class=\"line\">    function _fn(n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache[n]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let prev = _fn(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        cache[n - <span class=\"number\">1</span>] = prev;</span><br><span class=\"line\">        let next = _fn(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">        cache[n - <span class=\"number\">2</span>] = next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev + next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _fn(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">fn2</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    count2++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn2(n - <span class=\"number\">1</span>) + fn2(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(fn(<span class=\"number\">20</span>), count); <span class=\"comment\">// 6765 20</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(fn2(<span class=\"number\">20</span>), count2); <span class=\"comment\">// 6765 13529</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"算法的效率\"><a href=\"#算法的效率\" class=\"headerlink\" title=\"算法的效率\"></a>算法的效率</h3><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。<br>常见的时间复杂度有：</p>\n<ul>\n<li>常数阶 O(1)</li>\n<li>对数阶 O(logN)</li>\n<li>线性阶 O(n)</li>\n<li>线性对数阶 O(nlogN)</li>\n<li>平方阶 O(n^2)</li>\n<li>立方阶 O(n^3)</li>\n<li>!k次方阶 O(n^k)</li>\n<li>指数阶 O(2^n)</li>\n</ul>\n<p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。<br>一般做算法复杂度分析的时候，遵循下面的技巧：</p>\n<ul>\n<li>看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推</li>\n<li>如果有二分，则为O(logN)</li>\n<li>保留最高项，去除常数项</li>\n</ul>\n<p>题目：分析下面代码的算法复杂度</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let i =<span class=\"number\">0</span>; <span class=\"comment\">// 语句执行一次 </span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; n) &#123; <span class=\"comment\">// 语句执行 n 次 </span></span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(`Current i is $&#123;i&#125;`); <span class=\"comment\">//语句执行 n 次</span></span><br><span class=\"line\">  i++; <span class=\"comment\">// 语句执行 n 次</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">根据注释可以得到，算法复杂度为<span class=\"number\">1</span> + n + n + n = <span class=\"number\">1</span> + <span class=\"number\">3</span>n，去除常数项，为O(n)。</span><br></pre></td></tr></table></figure>\n<p>更多阅读：<br><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18\" target=\"_blank\" rel=\"noopener\">在 JavaScript 中学习数据结构与算法</a><br><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension\" target=\"_blank\" rel=\"noopener\">我接触过的前端数据结构与算法</a></p>\n","site":{"data":{}},"excerpt":"<p>这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png\" alt=\"js\"></p>","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>一些更新从最新的开始</p>\n</blockquote>\n<h1 id=\"Ract\"><a href=\"#Ract\" class=\"headerlink\" title=\"Ract\"></a>Ract</h1><h2 id=\"React生命周期\"><a href=\"#React生命周期\" class=\"headerlink\" title=\"React生命周期?\"></a>React生命周期?</h2><h3 id=\"React-生命周期分为三种状态-1-初始化-2-更新-3-销毁\"><a href=\"#React-生命周期分为三种状态-1-初始化-2-更新-3-销毁\" class=\"headerlink\" title=\"React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁\"></a>React 生命周期分为三种状态 <code>1. 初始化</code> <code>2.更新</code> <code>3.销毁</code></h3><p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png\" alt=\"react生命周期\"></p>\n<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->\n<blockquote>\n<p>初始化</p>\n</blockquote>\n<p>1、<code>getDefaultProps()</code> 设置默认的props，也可以使用<code>dufaultProps</code>设置组件的默认属性<br>2、<code>getInitialState()</code>在es6的class语法里是没有这个函数的，可直接在<code>construction</code>里去定义<code>this.state</code>也就可以访问到<code>this.props</code><br>3、<code>compontentWillMount()</code>整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改<code>state</code>值<br>4、<code>render</code> 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了<br>5、<code>compontentDidMount()</code> 组件渲染完成之后调用，且只调用一次</p>\n<blockquote>\n<p>更新</p>\n</blockquote>\n<p>6、<code>componentWillReceiverProps(nextProps)</code> 在组件初始化的时候不会触发，组件接收到新的<code>props</code>时触发<br>7、<code>shouldCompontUpdate(nextProps, nextState)</code> 这里是<code>React</code>性能优化非常重要的生命周期。在组件接收到新的<code>props</code>或者<code>state</code>时可以触发这个生命周期，可以对比前后<code>props</code>和<code>state</code>是否一样，如果相同一样则返回<code>false</code>去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行<code>diff</code>算法对比，极大地节省性能。<br>8、<code>componentWillUpdate(nextProps, nextState)</code> 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改<code>state</code><br>9、<code>render()</code> 渲染组件<br>10、 <code>componentDidUpdate()</code> 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取<code>dom</code>节点</p>\n<blockquote>\n<p>卸载</p>\n</blockquote>\n<p>11、<code>componentWillUnmount()</code> 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等</p>\n<hr>\n<h1 id=\"前端的一些知识模块\"><a href=\"#前端的一些知识模块\" class=\"headerlink\" title=\"前端的一些知识模块\"></a>前端的一些知识模块</h1><p><strong> HTML </strong><br>对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储</p>\n<p><strong> CSS </strong><br>flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性</p>\n<p><strong> JavaScript </strong><br>数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE</p>\n<p><strong> 其他 </strong><br>移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作</p>\n<p>作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。</p>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><h2 id=\"Doctype作用？标准模式与兼容模式各有什么区别\"><a href=\"#Doctype作用？标准模式与兼容模式各有什么区别\" class=\"headerlink\" title=\"Doctype作用？标准模式与兼容模式各有什么区别?\"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h2><p>1、<code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于 <code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现。</p>\n<p>2、<code>标准模式的排版</code> 和 <code>JS运作模式</code>都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。</p>\n<hr>\n<h2 id=\"HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\"><a href=\"#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\" class=\"headerlink\" title=\"HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？\"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h2><p>HTML5不基于<code>SGML</code>,所以不需要对DTD进行引用，但是他也需要<code>DOCTYPE</code>来规范浏览器的行为。</p>\n<hr>\n<h2 id=\"常见的浏览器有哪些，及其浏览器的内核是啥？\"><a href=\"#常见的浏览器有哪些，及其浏览器的内核是啥？\" class=\"headerlink\" title=\"常见的浏览器有哪些，及其浏览器的内核是啥？\"></a>常见的浏览器有哪些，及其浏览器的内核是啥？</h2><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]</p>\n<hr>\n<h2 id=\"浏览器内核的理解？\"><a href=\"#浏览器内核的理解？\" class=\"headerlink\" title=\"浏览器内核的理解？\"></a>浏览器内核的理解？</h2><p>主要分为两部分：<code>渲染引擎（Layout engineer或Rendering Engine）</code>和<code>JS引擎</code></p>\n<blockquote>\n<p>渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。</p>\n</blockquote>\n<blockquote>\n<p>JS引擎：解析和执行JavaScript实现网页动态效果。</p>\n</blockquote>\n<hr>\n<h2 id=\"页面样式引入，link与-import-的区别？\"><a href=\"#页面样式引入，link与-import-的区别？\" class=\"headerlink\" title=\"页面样式引入，link与@import`的区别？\"></a>页面样式引入，<code>link</code>与<code></code>@import`的区别？</h2><p>1、<code>link</code>属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<br>2、<code>@import</code>是CSS提供的，只能用于加载CSS;<br>3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>4、<code>import</code>是CSS2.1 提出的，只在IE5以上才能被识别，而<code>link</code>是XHTML标签，<code>无兼容问题</code>;</p>\n<hr>\n<h2 id=\"行内元素有哪些，块级元素有哪些，空元素有哪些？\"><a href=\"#行内元素有哪些，块级元素有哪些，空元素有哪些？\" class=\"headerlink\" title=\"行内元素有哪些，块级元素有哪些，空元素有哪些？\"></a>行内元素有哪些，块级元素有哪些，空元素有哪些？</h2><blockquote>\n<p>CSS规范规定，每个元素都有<code>display</code>属性，确定该元素的类型，每个元素都有默认的<code>display</code>值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p>\n</blockquote>\n<p>行内元素: <code>a b span img input select strong(强调的语气)</code><br>块级元素：<code>div p ul ol li dl dt dd h1 h2 h3 h4 ...</code><br>常见的空元素: <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>和<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p>\n<hr>\n<h2 id=\"HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？\"><a href=\"#HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？\" class=\"headerlink\" title=\"HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\"></a>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class=\"line\">    - 绘画 canvas;</span><br><span class=\"line\">    - 用于媒介回放的 video 和 audio 元素;</span><br><span class=\"line\">    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class=\"line\">    - sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class=\"line\">    - 语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class=\"line\">    - 表单控件，calendar、date、time、email、url、search;</span><br><span class=\"line\">    - 新的技术webworker, websocket, Geolocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    - 移除的元素：</span><br><span class=\"line\">        纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class=\"line\">        对可用性产生负面影响的元素：frame，frameset，noframes；</span><br><span class=\"line\"></span><br><span class=\"line\">   - 支持HTML5新标签：</span><br><span class=\"line\">        IE8/IE7/IE6支持通过document.createElement方法产生的标签，</span><br><span class=\"line\">        可以利用这一特性让这些浏览器支持HTML5新标签，</span><br><span class=\"line\">        浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">        当然也可以直接使用成熟的框架、比如html5shim;</span><br><span class=\"line\">        &lt;!--[<span class=\"keyword\">if</span> lt IE <span class=\"number\">9</span>]&gt;</span><br><span class=\"line\">            &lt;script&gt; src=<span class=\"string\">\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</span>&lt;/script&gt;</span><br><span class=\"line\">        &lt;![endif]--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"简述一下你对HTML语义化的理解？\"><a href=\"#简述一下你对HTML语义化的理解？\" class=\"headerlink\" title=\"简述一下你对HTML语义化的理解？\"></a>简述一下你对HTML语义化的理解？</h2><p><code>用正确的标签做正确的事情。</code><br>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>\n<hr>\n<h2 id=\"HTML5的离线储存怎么使用，工作原理能不能解释一下？\"><a href=\"#HTML5的离线储存怎么使用，工作原理能不能解释一下？\" class=\"headerlink\" title=\"HTML5的离线储存怎么使用，工作原理能不能解释一下？\"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下？</h2><blockquote>\n<p> 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n</blockquote>\n<p>如何使用：<br>1、页面头部像下面一样加入一个<code>manifest</code>的属性；<br>2、在<code>cache.manifest</code>文件的编写离线存储的资源；<br>    <code>CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html</code><br>3、在离线状态时，操作<code>window.applicationCache</code>进行需求实现。</p>\n<p>详细的使用请参考：<a href=\"http://yanhaijing.com/html/2014/12/28/html5-manifest/\" target=\"_blank\" rel=\"noopener\">HTML5 离线缓存-manifest简介</a>,<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n<hr>\n<h2 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。<br>详细请参考：<a href=\"http://segmentfault.com/a/1190000000732617\" target=\"_blank\" rel=\"noopener\">有趣的HTML5：离线存储</a></p>\n<hr>\n<h2 id=\"描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？\"><a href=\"#描述一下-Cookies，SessionStorage-和-LocalStorage-的区别？\" class=\"headerlink\" title=\"描述一下 Cookies，SessionStorage 和 LocalStorage 的区别？\"></a>描述一下 <code>Cookies</code>，<code>SessionStorage</code> 和 <code>LocalStorage</code> 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。<br>存储大小：</p>\n<ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n</ul>\n<p>有期时间：</p>\n<ul>\n<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>\n<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li>\n<li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<hr>\n<h2 id=\"Iframe有那些缺点？\"><a href=\"#Iframe有那些缺点？\" class=\"headerlink\" title=\"Iframe有那些缺点？\"></a><strong>Iframe有那些缺点？</strong></h2><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>\n<p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>\n<blockquote>\n<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>\n</blockquote>\n<hr>\n<h2 id=\"Label的作用是什么？是怎么用的？\"><a href=\"#Label的作用是什么？是怎么用的？\" class=\"headerlink\" title=\"Label的作用是什么？是怎么用的？\"></a>Label的作用是什么？是怎么用的？</h2><blockquote>\n<p><code>label</code>标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><h2 id=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"><a href=\"#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>（1）有两种， <code>IE 盒子模型</code>、<code>W3C 盒子模型</code>；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;</p>\n<hr>\n<h1 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h1><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>思路:</p>\n<ul>\n<li>随机选择数组中的一个数 A，以这个数为基准</li>\n<li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li>\n<li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li>\n<li>这时候将左边和右边的数再递归上面的过程<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Arr = [<span class=\"number\">85</span>, <span class=\"number\">24</span>, <span class=\"number\">63</span>, <span class=\"number\">45</span>, <span class=\"number\">17</span>, <span class=\"number\">31</span>, <span class=\"number\">96</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">quickSort</span><span class=\"params\">(arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let pivotIndex = Math.<span class=\"built_in\">floor</span>(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    let pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    let left = [];</span><br><span class=\"line\">    let right = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">            left.push(arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(quickSort(Arr));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ps:<br>这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。<br>其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。</p>\n<p>这里是不同的声音： <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40\" target=\"_blank\" rel=\"noopener\">面试官：阮一峰版的快速排序完全是错的</a></p>\n<hr>\n<h3 id=\"二分排序法\"><a href=\"#二分排序法\" class=\"headerlink\" title=\"二分排序法\"></a>二分排序法</h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。<br>二分查找是一种「分治」思想的算法，大概流程如下：</p>\n<ul>\n<li>数组中排在中间的数字 A，与要找的数字比较大小</li>\n<li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A</li>\n<li>较小则说明应该从查找数字的后半部分查找</li>\n<li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li>\n</ul>\n<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">Find</span><span class=\"params\">(target, <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">    let i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    let j = <span class=\"built_in\">array</span>[i].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"built_in\">array</span>.length &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i][j] &lt; target) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i][j] &gt; target) &#123;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试用例</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(Find(<span class=\"number\">10</span>, [</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], </span><br><span class=\"line\">    [<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>], </span><br><span class=\"line\">    [<span class=\"number\">13</span>, <span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\">    ])</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"解析url后的参数\"><a href=\"#解析url后的参数\" class=\"headerlink\" title=\"解析url后的参数\"></a>解析url后的参数</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">parseParam</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">  let obj = &#123;&#125;;</span><br><span class=\"line\">  let arr = url.split(<span class=\"string\">\"?\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123; <span class=\"comment\">//判断没有问号</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"无参数\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let total = arr[<span class=\"number\">1</span>].split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; total.length; i++) &#123;</span><br><span class=\"line\">    let single = total[i].split(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">    if (single[0] == '') &#123; //判断有？但是没有参数</span><br><span class=\"line\">      return '无参数'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!single[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      obj[single[<span class=\"number\">0</span>]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj[single[<span class=\"number\">0</span>]]) &#123;</span><br><span class=\"line\">        let concat</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Array.isArray(obj[single[<span class=\"number\">0</span>]])) &#123; <span class=\"comment\">//判断是否数组</span></span><br><span class=\"line\">          concat = [obj[single[<span class=\"number\">0</span>]]]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          concat = obj[single[<span class=\"number\">0</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        concat.push(single[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        concat = <span class=\"keyword\">new</span> Set(concat);</span><br><span class=\"line\">        concat = Array.from(concat) <span class=\"comment\">//数组去重</span></span><br><span class=\"line\">        obj[single[<span class=\"number\">0</span>]] = concat</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj[single[<span class=\"number\">0</span>]] = decodeURI(single[<span class=\"number\">1</span>]) <span class=\"comment\">//进行转码</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var url = 'http://www.baidu.com/?user=huixin&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled';</span><br><span class=\"line\"></span><br><span class=\"line\">var params = parseParam(url)</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(params)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"实现一个简单的模版引擎：\"><a href=\"#实现一个简单的模版引擎：\" class=\"headerlink\" title=\"实现一个简单的模版引擎：\"></a>实现一个简单的模版引擎：</h3><p>例如：我叫a,年龄b，性别c； let data = { name: ‘小明’, age: 18, } 没有定义的返回undefined</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let template = '我是&#123;name&#125;，年龄&#123;age&#125;，性别&#123;sex&#125;';</span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\">    name: '小明',</span><br><span class=\"line\">    age: <span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span>  reg= /(&#123;([a-zA-Z]+)&#125;)/g;</span><br><span class=\"line\">var r= '',regrounp=&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">while</span>( r = reg.exec(<span class=\"keyword\">template</span>) )&#123;</span><br><span class=\"line\">    Object.defineProperty(regrounp,r[<span class=\"number\">2</span>],&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">        value:r[<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var render = (<span class=\"keyword\">template</span>,regrounp)=&gt;&#123;</span><br><span class=\"line\">    var result='';</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( key in regrounp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data[key] == undefined)&#123;</span><br><span class=\"line\">            result  = (result || <span class=\"keyword\">template</span>).replace(<span class=\"keyword\">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class=\"string\">\"g\"</span>),undefined);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;\t\t</span><br><span class=\"line\">            result  = (result || <span class=\"keyword\">template</span>).replace(<span class=\"keyword\">new</span> RegExp(`&#123;$&#123;regrounp[key]&#125;&#125;`,<span class=\"string\">\"g\"</span>),data[key]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let newtemple = render(<span class=\"keyword\">template</span>, regrounp);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(newtemple) <span class=\"comment\">// 结果： 我是小明，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>\n<p>对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。</p>\n<p>这里有一片很好的文章 推荐 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46\" target=\"_blank\" rel=\"noopener\">编写一个简单的JavaScript模板引擎</a></p>\n<hr>\n<h3 id=\"如何快速让字符串变成已千为精度的数字\"><a href=\"#如何快速让字符串变成已千为精度的数字\" class=\"headerlink\" title=\"如何快速让字符串变成已千为精度的数字\"></a>如何快速让字符串变成已千为精度的数字</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">exchange</span><span class=\"params\">(num)</span> </span>&#123;</span><br><span class=\"line\">    num += ''; //转成字符串</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num.length &lt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    num = num.replace(/\\d&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;(?=(\\d&#123;<span class=\"number\">3</span>&#125;)+$)/g, (v) =&gt; &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v + <span class=\"string\">','</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(exchange(<span class=\"number\">1234567</span>));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"实现-JS-对象的深拷贝\"><a href=\"#实现-JS-对象的深拷贝\" class=\"headerlink\" title=\"实现 JS 对象的深拷贝\"></a>实现 JS 对象的深拷贝</h3><p>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。<br>分析下怎么做 深拷贝 ：</p>\n<ul>\n<li>首先假设深拷贝这个方法已经完成，为 deepClo</li>\n<li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li>\n</ul>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">deepClo</span><span class=\"params\">(o1, o2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let k in o2) &#123;</span><br><span class=\"line\">        if (typeof o2[k] === 'object') &#123;</span><br><span class=\"line\">            o1[k] = &#123;&#125;;</span><br><span class=\"line\">            deepClo(o1[k], o2[k]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            o1[k] = o2[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    c: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let emptyObj = Object.create(null);</span><br><span class=\"line\">deepClo(emptyObj, obj);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(emptyObj.a == obj.a);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(emptyObj.b == obj.b);</span><br></pre></td></tr></table></figure>\n<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。</p>\n<hr>\n<h3 id=\"求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项\"><a href=\"#求斐波那契数列（兔子数列）-1-1-2-3-5-8-13-21-34-55-89…中的第-n-项\" class=\"headerlink\" title=\"求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项\"></a>求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：</span><br><span class=\"line\"> let count = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"function\">function <span class=\"title\">fn</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    let cache = &#123;&#125;;</span><br><span class=\"line\">    function _fn(n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache[n]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let prev = _fn(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        cache[n - <span class=\"number\">1</span>] = prev;</span><br><span class=\"line\">        let next = _fn(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">        cache[n - <span class=\"number\">2</span>] = next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev + next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _fn(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">fn2</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    count2++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn2(n - <span class=\"number\">1</span>) + fn2(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(fn(<span class=\"number\">20</span>), count); <span class=\"comment\">// 6765 20</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(fn2(<span class=\"number\">20</span>), count2); <span class=\"comment\">// 6765 13529</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"算法的效率\"><a href=\"#算法的效率\" class=\"headerlink\" title=\"算法的效率\"></a>算法的效率</h3><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。<br>常见的时间复杂度有：</p>\n<ul>\n<li>常数阶 O(1)</li>\n<li>对数阶 O(logN)</li>\n<li>线性阶 O(n)</li>\n<li>线性对数阶 O(nlogN)</li>\n<li>平方阶 O(n^2)</li>\n<li>立方阶 O(n^3)</li>\n<li>!k次方阶 O(n^k)</li>\n<li>指数阶 O(2^n)</li>\n</ul>\n<p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。<br>一般做算法复杂度分析的时候，遵循下面的技巧：</p>\n<ul>\n<li>看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推</li>\n<li>如果有二分，则为O(logN)</li>\n<li>保留最高项，去除常数项</li>\n</ul>\n<p>题目：分析下面代码的算法复杂度</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let i =<span class=\"number\">0</span>; <span class=\"comment\">// 语句执行一次 </span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; n) &#123; <span class=\"comment\">// 语句执行 n 次 </span></span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(`Current i is $&#123;i&#125;`); <span class=\"comment\">//语句执行 n 次</span></span><br><span class=\"line\">  i++; <span class=\"comment\">// 语句执行 n 次</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">根据注释可以得到，算法复杂度为<span class=\"number\">1</span> + n + n + n = <span class=\"number\">1</span> + <span class=\"number\">3</span>n，去除常数项，为O(n)。</span><br></pre></td></tr></table></figure>\n<p>更多阅读：<br><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18\" target=\"_blank\" rel=\"noopener\">在 JavaScript 中学习数据结构与算法</a><br><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension\" target=\"_blank\" rel=\"noopener\">我接触过的前端数据结构与算法</a></p>"},{"title":"在PHP里使用ImageMagick生成base64图片","date":"2018-09-04T16:08:37.000Z","description":null,"copyright":true,"top":null,"_content":"\n最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg)\n\n<!-- more -->\n\n> 一些需要的知识点\n\n# PHP将图片转base64编码以及base64图片转换为图片并保存代码\n\n## 图片转base64编码\n\n```h\n\n/*图片转换为 base64格式编码*/\n$img = 'uploads/about.png';\n$base64_img = base64EncodeImage($img);\necho '<img src=\"' . $base64_img . '\" />';\n \nfunction base64EncodeImage ($image_file) {\n    $base64_image = '';\n    $image_info = getimagesize($image_file);\n    $image_data = fread(fopen($image_file, 'r'), filesize($image_file));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n    return $base64_image;\n}\n```\n\n## base64图片转换为图片并保存\n\n```h\n/*  base64格式编码转换为图片并保存对应文件夹 */\nfunction base64_image_content($base64_image_content,$path){\n    //匹配出图片的格式\n    if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $base64_image_content, $result)){\n        $type = $result[2];\n        $new_file = $path.\"/\".date('Ymd',time()).\"/\";\n        if(!file_exists($new_file)){\n            //检查是否有该文件夹，如果没有就创建，并给予最高权限\n            mkdir($new_file, 0700);\n        }\n        $new_file = $new_file.time().\".{$type}\";\n        if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content)))){\n            return '/'.$new_file;\n        }else{\n            return false;\n        }\n    }else{\n        return false;\n    }\n}\n \necho base64_image_content($base64_img,\"uploads/\");\n```\n# base64\n\nBase64是一种用64个字符来表示任意二进制数据的方法。\nBase64的原理很简单，首先，准备一个包含64个字符的数组：\n\n`['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']`\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit\n\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n\n\n\n使用jpg图片体积要比png小\n使用PHP的Imagick类进行图像的操作\n\n# 具体操作\n\n## (1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片\n```h\n// 初始化一个画板\n        $img =new Imagick();\n        $img->newImage(750,1046,'white','jpg') ; \n        \n```\n\n## (2).在底图上添加需求图片\n前提是我们已经知道了需要合并的图片链接地址\n```h\n$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'\n\n第一步：实例化图片\n$imgtwo = new Imagick($item_img);\n\n第二步：设置添加图片的大小\n$imgtwo->resizeImage(750,764,Imagick::FILTER_LANCZOS,1);\n\n关于resizeImage参数说明\n    bool Imagick::resizeImage ( int $columns , int $rows , int $filter , float $blur [, bool $bestfit = false ] )\n\n参数：\n  ● columns 图片的宽度\n  ● rows 图片高度\n  ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定\n  ● blur blur=1 为虚化， blur =-1 为锐化\n\n第三步：与底图合并\n$img->compositeImage($imgtwo,$imgtwo->getImageCompose(),0,0);\n\n使用compositeImage();\n    bool Imagick::compositeImage ( Imagick $composite_object , int $composite , int $x , int $y [, int $channel = Imagick::CHANNEL_ALL ] )\n\n参数：\n  ● composite_object ：用于合并的图片的Imagick对象\n  ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表\n  ● x：相对图像顶点左上位置（0,0）的横坐标\n  ● y：相对图像顶点左上位置（0,0）的纵坐标\n  ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。\n\n到这里就可以得到一个合并的图片了\n1、加一个header信息，可以直接在网页上查看图片\n    header(\"Content-Type: img/png\");\n    echo $img;\n2、可以把图片在指定目录中生成，在指定目录下生成为img.png\n\t$file=\"./img.png\";\n\t$img->writeImage($file);\n\n\n我这里是这样处理：\n    header ( 'Content-type: ' . strtolower ($img->getImageFormat ()) );\n    $type = strtolower($img->getImageFormat());\n    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type;    //要生成的图片的路径，随机生成图片名称\n\n\n```\n\n\n## (3).图片上拼接文字\n写入文字以添加店铺文字为例，逐步完成文字的写入。\n```h\n    $shop_title='测试店铺'；\n    // 添加店铺文字\n    $drawQr = new ImagickDraw(); // 实例化ImagickDraw\n    $drawQr -> setFillColor(new ImagickPixel('#999999')); // 颜色\n    $drawQr -> setFontSize('24'); // 大小\n    $drawQr -> setFont('../../conf/Microsoftyahei.ttf'); // 字体\n    $drawQr -> setTextAlignment(Imagick::ALIGN_LEFT); // 字体方向\n    // ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间\n    $drawQr -> setTextEncoding(\"utf-8\"); // 字体编码\n    $drawQr -> annotation(114,990,$shop_title); // 画出文字\n    $img -> drawImage($drawQr);  // 画在地板上\n```\n\n详细解读：\n - 1、实例化ImagickDraw类：\n    `$drawQr = new ImagickDraw(); ` \n - 2、设置字体颜色\n`$drawQr -> setFillColor(new ImagickPixel('#999999')); `\n - 3、设置字体大小\n`$drawQr -> setFontSize('24'); `\n - 4、设置字体格式\n`$drawQr -> setFont('../../conf/Microsoftyahei.ttf');`\n - 5、设置字体方向\n`$draw->setTextAlignment(Imagick::ALIGN_RIGHT);`\n> ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间\n - 6、设置字体编码\n`$drawQr -> setTextEncoding(\"utf-8\");`\n - 7、画出文字\n`$drawQr -> annotation(114,990,$shop_title); `\n - 8、在底图上写入字体\n`$img -> drawImage($drawQr);`\n\n写入文字这个地方的一些坑：\n\n没有设置字体格式时，中文字会解析错误\n（英文没有问题）\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_1.png)\n\n（汉字解析失败）\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_2.png)\n\n(设置字体格式正常显示)\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_3.png)\n\n\n## (4).图片base64导出\n最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。\n```h\n    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径\n    $Return = array();\n    // *图片转换为 base64格式编码*\n    $base64_image = '';\n    $image_info = getimagesize($dest_img);\n    $image_data = fread(fopen($dest_img, 'r'), filesize($dest_img));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n    $Return['data']=$base64_image;\n    return  $Return;\n```\n`$base64_image`就是base64格式的图片。\n\n需要注意的是前端得到的额base64数据里包含有`'\\r\\n'`回车字符，需要特殊处理才可以正确显示图片。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_4.png)\n\n（最后得到的合并图片）\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_5.png)\n\n(调整拼接图片大小得到不同的图片)\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_6.png)\n","source":"_posts/在PHP里很好的使用ImageMagick.md","raw":"---\ntitle: 在PHP里使用ImageMagick生成base64图片\ndate: 2018-09-05 00:08:37\ntags: [PHP,编程,后端]\ndescription: \ncopyright: true\ncategories: 后端\ntop: \n---\n\n最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg)\n\n<!-- more -->\n\n> 一些需要的知识点\n\n# PHP将图片转base64编码以及base64图片转换为图片并保存代码\n\n## 图片转base64编码\n\n```h\n\n/*图片转换为 base64格式编码*/\n$img = 'uploads/about.png';\n$base64_img = base64EncodeImage($img);\necho '<img src=\"' . $base64_img . '\" />';\n \nfunction base64EncodeImage ($image_file) {\n    $base64_image = '';\n    $image_info = getimagesize($image_file);\n    $image_data = fread(fopen($image_file, 'r'), filesize($image_file));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n    return $base64_image;\n}\n```\n\n## base64图片转换为图片并保存\n\n```h\n/*  base64格式编码转换为图片并保存对应文件夹 */\nfunction base64_image_content($base64_image_content,$path){\n    //匹配出图片的格式\n    if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $base64_image_content, $result)){\n        $type = $result[2];\n        $new_file = $path.\"/\".date('Ymd',time()).\"/\";\n        if(!file_exists($new_file)){\n            //检查是否有该文件夹，如果没有就创建，并给予最高权限\n            mkdir($new_file, 0700);\n        }\n        $new_file = $new_file.time().\".{$type}\";\n        if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content)))){\n            return '/'.$new_file;\n        }else{\n            return false;\n        }\n    }else{\n        return false;\n    }\n}\n \necho base64_image_content($base64_img,\"uploads/\");\n```\n# base64\n\nBase64是一种用64个字符来表示任意二进制数据的方法。\nBase64的原理很简单，首先，准备一个包含64个字符的数组：\n\n`['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']`\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit\n\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n\n\n\n使用jpg图片体积要比png小\n使用PHP的Imagick类进行图像的操作\n\n# 具体操作\n\n## (1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片\n```h\n// 初始化一个画板\n        $img =new Imagick();\n        $img->newImage(750,1046,'white','jpg') ; \n        \n```\n\n## (2).在底图上添加需求图片\n前提是我们已经知道了需要合并的图片链接地址\n```h\n$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'\n\n第一步：实例化图片\n$imgtwo = new Imagick($item_img);\n\n第二步：设置添加图片的大小\n$imgtwo->resizeImage(750,764,Imagick::FILTER_LANCZOS,1);\n\n关于resizeImage参数说明\n    bool Imagick::resizeImage ( int $columns , int $rows , int $filter , float $blur [, bool $bestfit = false ] )\n\n参数：\n  ● columns 图片的宽度\n  ● rows 图片高度\n  ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定\n  ● blur blur=1 为虚化， blur =-1 为锐化\n\n第三步：与底图合并\n$img->compositeImage($imgtwo,$imgtwo->getImageCompose(),0,0);\n\n使用compositeImage();\n    bool Imagick::compositeImage ( Imagick $composite_object , int $composite , int $x , int $y [, int $channel = Imagick::CHANNEL_ALL ] )\n\n参数：\n  ● composite_object ：用于合并的图片的Imagick对象\n  ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表\n  ● x：相对图像顶点左上位置（0,0）的横坐标\n  ● y：相对图像顶点左上位置（0,0）的纵坐标\n  ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。\n\n到这里就可以得到一个合并的图片了\n1、加一个header信息，可以直接在网页上查看图片\n    header(\"Content-Type: img/png\");\n    echo $img;\n2、可以把图片在指定目录中生成，在指定目录下生成为img.png\n\t$file=\"./img.png\";\n\t$img->writeImage($file);\n\n\n我这里是这样处理：\n    header ( 'Content-type: ' . strtolower ($img->getImageFormat ()) );\n    $type = strtolower($img->getImageFormat());\n    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type;    //要生成的图片的路径，随机生成图片名称\n\n\n```\n\n\n## (3).图片上拼接文字\n写入文字以添加店铺文字为例，逐步完成文字的写入。\n```h\n    $shop_title='测试店铺'；\n    // 添加店铺文字\n    $drawQr = new ImagickDraw(); // 实例化ImagickDraw\n    $drawQr -> setFillColor(new ImagickPixel('#999999')); // 颜色\n    $drawQr -> setFontSize('24'); // 大小\n    $drawQr -> setFont('../../conf/Microsoftyahei.ttf'); // 字体\n    $drawQr -> setTextAlignment(Imagick::ALIGN_LEFT); // 字体方向\n    // ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间\n    $drawQr -> setTextEncoding(\"utf-8\"); // 字体编码\n    $drawQr -> annotation(114,990,$shop_title); // 画出文字\n    $img -> drawImage($drawQr);  // 画在地板上\n```\n\n详细解读：\n - 1、实例化ImagickDraw类：\n    `$drawQr = new ImagickDraw(); ` \n - 2、设置字体颜色\n`$drawQr -> setFillColor(new ImagickPixel('#999999')); `\n - 3、设置字体大小\n`$drawQr -> setFontSize('24'); `\n - 4、设置字体格式\n`$drawQr -> setFont('../../conf/Microsoftyahei.ttf');`\n - 5、设置字体方向\n`$draw->setTextAlignment(Imagick::ALIGN_RIGHT);`\n> ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间\n - 6、设置字体编码\n`$drawQr -> setTextEncoding(\"utf-8\");`\n - 7、画出文字\n`$drawQr -> annotation(114,990,$shop_title); `\n - 8、在底图上写入字体\n`$img -> drawImage($drawQr);`\n\n写入文字这个地方的一些坑：\n\n没有设置字体格式时，中文字会解析错误\n（英文没有问题）\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_1.png)\n\n（汉字解析失败）\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_2.png)\n\n(设置字体格式正常显示)\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_3.png)\n\n\n## (4).图片base64导出\n最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。\n```h\n    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径\n    $Return = array();\n    // *图片转换为 base64格式编码*\n    $base64_image = '';\n    $image_info = getimagesize($dest_img);\n    $image_data = fread(fopen($dest_img, 'r'), filesize($dest_img));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n    $Return['data']=$base64_image;\n    return  $Return;\n```\n`$base64_image`就是base64格式的图片。\n\n需要注意的是前端得到的额base64数据里包含有`'\\r\\n'`回车字符，需要特殊处理才可以正确显示图片。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_4.png)\n\n（最后得到的合并图片）\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_5.png)\n\n(调整拼接图片大小得到不同的图片)\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_6.png)\n","slug":"在PHP里很好的使用ImageMagick","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnet0032kt89nnz5i1to","content":"<p>最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg\" alt=\"PHP\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>一些需要的知识点</p>\n</blockquote>\n<h1 id=\"PHP将图片转base64编码以及base64图片转换为图片并保存代码\"><a href=\"#PHP将图片转base64编码以及base64图片转换为图片并保存代码\" class=\"headerlink\" title=\"PHP将图片转base64编码以及base64图片转换为图片并保存代码\"></a>PHP将图片转base64编码以及base64图片转换为图片并保存代码</h1><h2 id=\"图片转base64编码\"><a href=\"#图片转base64编码\" class=\"headerlink\" title=\"图片转base64编码\"></a>图片转base64编码</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片转换为 base64格式编码*/</span></span><br><span class=\"line\">$img = 'uploads/about.png';</span><br><span class=\"line\">$base64_img = base64EncodeImage($img);</span><br><span class=\"line\">echo '&lt;img src=\"' . $base64_img . '\" /&gt;';</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">base64EncodeImage</span> <span class=\"params\">($image_file)</span> </span>&#123;</span><br><span class=\"line\">    $base64_image = '';</span><br><span class=\"line\">    $image_info = getimagesize($image_file);</span><br><span class=\"line\">    $image_data = fread(fopen($image_file, <span class=\"string\">'r'</span>), filesize($image_file));</span><br><span class=\"line\">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> $base64_image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"base64图片转换为图片并保存\"><a href=\"#base64图片转换为图片并保存\" class=\"headerlink\" title=\"base64图片转换为图片并保存\"></a>base64图片转换为图片并保存</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  base64格式编码转换为图片并保存对应文件夹 */</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">base64_image_content</span><span class=\"params\">($base64_image_content,$path)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//匹配出图片的格式</span></span><br><span class=\"line\">    if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $base64_image_content, $result))&#123;</span><br><span class=\"line\">        $type = $result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        $new_file = $path.\"/\".date('Ymd',time()).\"/\";</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!file_exists($new_file))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否有该文件夹，如果没有就创建，并给予最高权限</span></span><br><span class=\"line\">            mkdir($new_file, <span class=\"number\">0700</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $new_file = $new_file.time().<span class=\"string\">\".&#123;$type&#125;\"</span>;</span><br><span class=\"line\">        if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content))))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'/'</span>.$new_file;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">echo <span class=\"title\">base64_image_content</span><span class=\"params\">($base64_img,<span class=\"string\">\"uploads/\"</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。<br>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>\n<p><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code><br>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit</p>\n<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>\n<p>使用jpg图片体积要比png小<br>使用PHP的Imagick类进行图像的操作</p>\n<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><h2 id=\"1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片\"><a href=\"#1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片\" class=\"headerlink\" title=\"(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片\"></a>(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个画板</span></span><br><span class=\"line\">        $img =<span class=\"keyword\">new</span> Imagick();</span><br><span class=\"line\">        $img-&gt;newImage(750,1046,'white','jpg') ;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-在底图上添加需求图片\"><a href=\"#2-在底图上添加需求图片\" class=\"headerlink\" title=\"(2).在底图上添加需求图片\"></a>(2).在底图上添加需求图片</h2><p>前提是我们已经知道了需要合并的图片链接地址<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'</span><br><span class=\"line\"></span><br><span class=\"line\">第一步：实例化图片</span><br><span class=\"line\">$imgtwo = <span class=\"keyword\">new</span> Imagick($item_img);</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：设置添加图片的大小</span><br><span class=\"line\">$imgtwo-&gt;resizeImage(<span class=\"number\">750</span>,<span class=\"number\">764</span>,Imagick::FILTER_LANCZOS,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">关于resizeImage参数说明</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Imagick::resizeImage ( <span class=\"keyword\">int</span> $columns , <span class=\"keyword\">int</span> $rows , <span class=\"keyword\">int</span> $filter , <span class=\"keyword\">float</span> $blur [, <span class=\"keyword\">bool</span> $bestfit = <span class=\"literal\">false</span> ] )</span><br><span class=\"line\"></span><br><span class=\"line\">参数：</span><br><span class=\"line\">  ● columns 图片的宽度</span><br><span class=\"line\">  ● rows 图片高度</span><br><span class=\"line\">  ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定</span><br><span class=\"line\">  ● blur blur=<span class=\"number\">1</span> 为虚化， blur =<span class=\"number\">-1</span> 为锐化</span><br><span class=\"line\"></span><br><span class=\"line\">第三步：与底图合并</span><br><span class=\"line\">$img-&gt;compositeImage($imgtwo,$imgtwo-&gt;getImageCompose(),<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">使用compositeImage();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Imagick::compositeImage ( Imagick $composite_object , <span class=\"keyword\">int</span> $composite , <span class=\"keyword\">int</span> $x , <span class=\"keyword\">int</span> $y [, <span class=\"keyword\">int</span> $channel = Imagick::CHANNEL_ALL ] )</span><br><span class=\"line\"></span><br><span class=\"line\">参数：</span><br><span class=\"line\">  ● composite_object ：用于合并的图片的Imagick对象</span><br><span class=\"line\">  ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表</span><br><span class=\"line\">  ● x：相对图像顶点左上位置（<span class=\"number\">0</span>,<span class=\"number\">0</span>）的横坐标</span><br><span class=\"line\">  ● y：相对图像顶点左上位置（<span class=\"number\">0</span>,<span class=\"number\">0</span>）的纵坐标</span><br><span class=\"line\">  ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。</span><br><span class=\"line\"></span><br><span class=\"line\">到这里就可以得到一个合并的图片了</span><br><span class=\"line\"><span class=\"number\">1</span>、加一个header信息，可以直接在网页上查看图片</span><br><span class=\"line\">    header(<span class=\"string\">\"Content-Type: img/png\"</span>);</span><br><span class=\"line\">    echo $img;</span><br><span class=\"line\"><span class=\"number\">2</span>、可以把图片在指定目录中生成，在指定目录下生成为img.png</span><br><span class=\"line\">\t$file=<span class=\"string\">\"./img.png\"</span>;</span><br><span class=\"line\">\t$img-&gt;writeImage($file);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">我这里是这样处理：</span><br><span class=\"line\">    header ( 'Content-type: ' . strtolower ($img-&gt;getImageFormat ()) );</span><br><span class=\"line\">    $type = strtolower($img-&gt;getImageFormat());</span><br><span class=\"line\">    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type;    //要生成的图片的路径，随机生成图片名称</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-图片上拼接文字\"><a href=\"#3-图片上拼接文字\" class=\"headerlink\" title=\"(3).图片上拼接文字\"></a>(3).图片上拼接文字</h2><p>写入文字以添加店铺文字为例，逐步完成文字的写入。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$shop_title='测试店铺'；</span><br><span class=\"line\"><span class=\"comment\">// 添加店铺文字</span></span><br><span class=\"line\">$drawQr = <span class=\"keyword\">new</span> ImagickDraw(); <span class=\"comment\">// 实例化ImagickDraw</span></span><br><span class=\"line\">$drawQr -&gt; setFillColor(new ImagickPixel('#999999')); // 颜色</span><br><span class=\"line\">$drawQr -&gt; setFontSize('24'); // 大小</span><br><span class=\"line\">$drawQr -&gt; setFont('../../conf/Microsoftyahei.ttf'); // 字体</span><br><span class=\"line\">$drawQr -&gt; setTextAlignment(Imagick::ALIGN_LEFT); <span class=\"comment\">// 字体方向</span></span><br><span class=\"line\"><span class=\"comment\">// ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</span></span><br><span class=\"line\">$drawQr -&gt; setTextEncoding(<span class=\"string\">\"utf-8\"</span>); <span class=\"comment\">// 字体编码</span></span><br><span class=\"line\">$drawQr -&gt; annotation(<span class=\"number\">114</span>,<span class=\"number\">990</span>,$shop_title); <span class=\"comment\">// 画出文字</span></span><br><span class=\"line\">$img -&gt; drawImage($drawQr);  <span class=\"comment\">// 画在地板上</span></span><br></pre></td></tr></table></figure></p>\n<p>详细解读：</p>\n<ul>\n<li>1、实例化ImagickDraw类：<br> <code>$drawQr = new ImagickDraw();</code> </li>\n<li>2、设置字体颜色<br><code>$drawQr -&gt; setFillColor(new ImagickPixel(&#39;#999999&#39;));</code></li>\n<li>3、设置字体大小<br><code>$drawQr -&gt; setFontSize(&#39;24&#39;);</code></li>\n<li>4、设置字体格式<br><code>$drawQr -&gt; setFont(&#39;../../conf/Microsoftyahei.ttf&#39;);</code></li>\n<li>5、设置字体方向<br><code>$draw-&gt;setTextAlignment(Imagick::ALIGN_RIGHT);</code><blockquote>\n<p>ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</p>\n</blockquote>\n</li>\n<li>6、设置字体编码<br><code>$drawQr -&gt; setTextEncoding(&quot;utf-8&quot;);</code></li>\n<li>7、画出文字<br><code>$drawQr -&gt; annotation(114,990,$shop_title);</code></li>\n<li>8、在底图上写入字体<br><code>$img -&gt; drawImage($drawQr);</code></li>\n</ul>\n<p>写入文字这个地方的一些坑：</p>\n<p>没有设置字体格式时，中文字会解析错误<br>（英文没有问题）<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_1.png\" alt=\"PHP\"></p>\n<p>（汉字解析失败）</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_2.png\" alt=\"PHP\"></p>\n<p>(设置字体格式正常显示)</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_3.png\" alt=\"PHP\"></p>\n<h2 id=\"4-图片base64导出\"><a href=\"#4-图片base64导出\" class=\"headerlink\" title=\"(4).图片base64导出\"></a>(4).图片base64导出</h2><p>最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径</span><br><span class=\"line\">$Return = <span class=\"built_in\">array</span>();</span><br><span class=\"line\"><span class=\"comment\">// *图片转换为 base64格式编码*</span></span><br><span class=\"line\">$base64_image = '';</span><br><span class=\"line\">$image_info = getimagesize($dest_img);</span><br><span class=\"line\">$image_data = fread(fopen($dest_img, <span class=\"string\">'r'</span>), filesize($dest_img));</span><br><span class=\"line\">$base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\">$Return['data']=$base64_image;</span><br><span class=\"line\"><span class=\"keyword\">return</span>  $Return;</span><br></pre></td></tr></table></figure></p>\n<p><code>$base64_image</code>就是base64格式的图片。</p>\n<p>需要注意的是前端得到的额base64数据里包含有<code>&#39;\\r\\n&#39;</code>回车字符，需要特殊处理才可以正确显示图片。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_4.png\" alt=\"PHP\"></p>\n<p>（最后得到的合并图片）</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_5.png\" alt=\"PHP\"></p>\n<p>(调整拼接图片大小得到不同的图片)<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_6.png\" alt=\"PHP\"></p>\n","site":{"data":{}},"excerpt":"<p>最近的PHP项目中，需要用到画图和图片拼接效果，这里是一些开发过程里用到的一些点还有就是一些踩过的坑。通过ImageMagick生成base64图片格式，为前端所使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg\" alt=\"PHP\"></p>","more":"<blockquote>\n<p>一些需要的知识点</p>\n</blockquote>\n<h1 id=\"PHP将图片转base64编码以及base64图片转换为图片并保存代码\"><a href=\"#PHP将图片转base64编码以及base64图片转换为图片并保存代码\" class=\"headerlink\" title=\"PHP将图片转base64编码以及base64图片转换为图片并保存代码\"></a>PHP将图片转base64编码以及base64图片转换为图片并保存代码</h1><h2 id=\"图片转base64编码\"><a href=\"#图片转base64编码\" class=\"headerlink\" title=\"图片转base64编码\"></a>图片转base64编码</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片转换为 base64格式编码*/</span></span><br><span class=\"line\">$img = 'uploads/about.png';</span><br><span class=\"line\">$base64_img = base64EncodeImage($img);</span><br><span class=\"line\">echo '&lt;img src=\"' . $base64_img . '\" /&gt;';</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">base64EncodeImage</span> <span class=\"params\">($image_file)</span> </span>&#123;</span><br><span class=\"line\">    $base64_image = '';</span><br><span class=\"line\">    $image_info = getimagesize($image_file);</span><br><span class=\"line\">    $image_data = fread(fopen($image_file, <span class=\"string\">'r'</span>), filesize($image_file));</span><br><span class=\"line\">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> $base64_image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"base64图片转换为图片并保存\"><a href=\"#base64图片转换为图片并保存\" class=\"headerlink\" title=\"base64图片转换为图片并保存\"></a>base64图片转换为图片并保存</h2><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  base64格式编码转换为图片并保存对应文件夹 */</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">base64_image_content</span><span class=\"params\">($base64_image_content,$path)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//匹配出图片的格式</span></span><br><span class=\"line\">    if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $base64_image_content, $result))&#123;</span><br><span class=\"line\">        $type = $result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        $new_file = $path.\"/\".date('Ymd',time()).\"/\";</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!file_exists($new_file))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否有该文件夹，如果没有就创建，并给予最高权限</span></span><br><span class=\"line\">            mkdir($new_file, <span class=\"number\">0700</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $new_file = $new_file.time().<span class=\"string\">\".&#123;$type&#125;\"</span>;</span><br><span class=\"line\">        if (file_put_contents($new_file, base64_decode(str_replace($result[1], '', $base64_image_content))))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'/'</span>.$new_file;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">echo <span class=\"title\">base64_image_content</span><span class=\"params\">($base64_img,<span class=\"string\">\"uploads/\"</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。<br>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>\n<p><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code><br>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit</p>\n<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>\n<p>使用jpg图片体积要比png小<br>使用PHP的Imagick类进行图像的操作</p>\n<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><h2 id=\"1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片\"><a href=\"#1-创建一个底图-宽750px，高1046px，白色背景，格式为jpg的图片\" class=\"headerlink\" title=\"(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片\"></a>(1).创建一个底图,宽750px，高1046px，白色背景，格式为jpg的图片</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个画板</span></span><br><span class=\"line\">        $img =<span class=\"keyword\">new</span> Imagick();</span><br><span class=\"line\">        $img-&gt;newImage(750,1046,'white','jpg') ;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-在底图上添加需求图片\"><a href=\"#2-在底图上添加需求图片\" class=\"headerlink\" title=\"(2).在底图上添加需求图片\"></a>(2).在底图上添加需求图片</h2><p>前提是我们已经知道了需要合并的图片链接地址<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg'</span><br><span class=\"line\"></span><br><span class=\"line\">第一步：实例化图片</span><br><span class=\"line\">$imgtwo = <span class=\"keyword\">new</span> Imagick($item_img);</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：设置添加图片的大小</span><br><span class=\"line\">$imgtwo-&gt;resizeImage(<span class=\"number\">750</span>,<span class=\"number\">764</span>,Imagick::FILTER_LANCZOS,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">关于resizeImage参数说明</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Imagick::resizeImage ( <span class=\"keyword\">int</span> $columns , <span class=\"keyword\">int</span> $rows , <span class=\"keyword\">int</span> $filter , <span class=\"keyword\">float</span> $blur [, <span class=\"keyword\">bool</span> $bestfit = <span class=\"literal\">false</span> ] )</span><br><span class=\"line\"></span><br><span class=\"line\">参数：</span><br><span class=\"line\">  ● columns 图片的宽度</span><br><span class=\"line\">  ● rows 图片高度</span><br><span class=\"line\">  ● filter 过滤器，用于过滤图片，有高斯filte根据情况而定</span><br><span class=\"line\">  ● blur blur=<span class=\"number\">1</span> 为虚化， blur =<span class=\"number\">-1</span> 为锐化</span><br><span class=\"line\"></span><br><span class=\"line\">第三步：与底图合并</span><br><span class=\"line\">$img-&gt;compositeImage($imgtwo,$imgtwo-&gt;getImageCompose(),<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">使用compositeImage();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Imagick::compositeImage ( Imagick $composite_object , <span class=\"keyword\">int</span> $composite , <span class=\"keyword\">int</span> $x , <span class=\"keyword\">int</span> $y [, <span class=\"keyword\">int</span> $channel = Imagick::CHANNEL_ALL ] )</span><br><span class=\"line\"></span><br><span class=\"line\">参数：</span><br><span class=\"line\">  ● composite_object ：用于合并的图片的Imagick对象</span><br><span class=\"line\">  ● composite：合并操作，定义操作常量。 具体请查看 合并操作常量列表</span><br><span class=\"line\">  ● x：相对图像顶点左上位置（<span class=\"number\">0</span>,<span class=\"number\">0</span>）的横坐标</span><br><span class=\"line\">  ● y：相对图像顶点左上位置（<span class=\"number\">0</span>,<span class=\"number\">0</span>）的纵坐标</span><br><span class=\"line\">  ● channel：通过传入一个通道常量，来开启通道模式。为了支持多个通道，可以通过二进制运算的操作来合并多个通道常量。</span><br><span class=\"line\"></span><br><span class=\"line\">到这里就可以得到一个合并的图片了</span><br><span class=\"line\"><span class=\"number\">1</span>、加一个header信息，可以直接在网页上查看图片</span><br><span class=\"line\">    header(<span class=\"string\">\"Content-Type: img/png\"</span>);</span><br><span class=\"line\">    echo $img;</span><br><span class=\"line\"><span class=\"number\">2</span>、可以把图片在指定目录中生成，在指定目录下生成为img.png</span><br><span class=\"line\">\t$file=<span class=\"string\">\"./img.png\"</span>;</span><br><span class=\"line\">\t$img-&gt;writeImage($file);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">我这里是这样处理：</span><br><span class=\"line\">    header ( 'Content-type: ' . strtolower ($img-&gt;getImageFormat ()) );</span><br><span class=\"line\">    $type = strtolower($img-&gt;getImageFormat());</span><br><span class=\"line\">    $dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type;    //要生成的图片的路径，随机生成图片名称</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-图片上拼接文字\"><a href=\"#3-图片上拼接文字\" class=\"headerlink\" title=\"(3).图片上拼接文字\"></a>(3).图片上拼接文字</h2><p>写入文字以添加店铺文字为例，逐步完成文字的写入。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$shop_title='测试店铺'；</span><br><span class=\"line\"><span class=\"comment\">// 添加店铺文字</span></span><br><span class=\"line\">$drawQr = <span class=\"keyword\">new</span> ImagickDraw(); <span class=\"comment\">// 实例化ImagickDraw</span></span><br><span class=\"line\">$drawQr -&gt; setFillColor(new ImagickPixel('#999999')); // 颜色</span><br><span class=\"line\">$drawQr -&gt; setFontSize('24'); // 大小</span><br><span class=\"line\">$drawQr -&gt; setFont('../../conf/Microsoftyahei.ttf'); // 字体</span><br><span class=\"line\">$drawQr -&gt; setTextAlignment(Imagick::ALIGN_LEFT); <span class=\"comment\">// 字体方向</span></span><br><span class=\"line\"><span class=\"comment\">// ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</span></span><br><span class=\"line\">$drawQr -&gt; setTextEncoding(<span class=\"string\">\"utf-8\"</span>); <span class=\"comment\">// 字体编码</span></span><br><span class=\"line\">$drawQr -&gt; annotation(<span class=\"number\">114</span>,<span class=\"number\">990</span>,$shop_title); <span class=\"comment\">// 画出文字</span></span><br><span class=\"line\">$img -&gt; drawImage($drawQr);  <span class=\"comment\">// 画在地板上</span></span><br></pre></td></tr></table></figure></p>\n<p>详细解读：</p>\n<ul>\n<li>1、实例化ImagickDraw类：<br> <code>$drawQr = new ImagickDraw();</code> </li>\n<li>2、设置字体颜色<br><code>$drawQr -&gt; setFillColor(new ImagickPixel(&#39;#999999&#39;));</code></li>\n<li>3、设置字体大小<br><code>$drawQr -&gt; setFontSize(&#39;24&#39;);</code></li>\n<li>4、设置字体格式<br><code>$drawQr -&gt; setFont(&#39;../../conf/Microsoftyahei.ttf&#39;);</code></li>\n<li>5、设置字体方向<br><code>$draw-&gt;setTextAlignment(Imagick::ALIGN_RIGHT);</code><blockquote>\n<p>ps： Imagick::ALIGN_RIGHT 朝右边    Imagick::ALIGN_LEFT 左边   Imagick::ALIGN_CENTER 中间</p>\n</blockquote>\n</li>\n<li>6、设置字体编码<br><code>$drawQr -&gt; setTextEncoding(&quot;utf-8&quot;);</code></li>\n<li>7、画出文字<br><code>$drawQr -&gt; annotation(114,990,$shop_title);</code></li>\n<li>8、在底图上写入字体<br><code>$img -&gt; drawImage($drawQr);</code></li>\n</ul>\n<p>写入文字这个地方的一些坑：</p>\n<p>没有设置字体格式时，中文字会解析错误<br>（英文没有问题）<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_1.png\" alt=\"PHP\"></p>\n<p>（汉字解析失败）</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_2.png\" alt=\"PHP\"></p>\n<p>(设置字体格式正常显示)</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_3.png\" alt=\"PHP\"></p>\n<h2 id=\"4-图片base64导出\"><a href=\"#4-图片base64导出\" class=\"headerlink\" title=\"(4).图片base64导出\"></a>(4).图片base64导出</h2><p>最终得到的图片我们组要以base64的格式传递给前端，进行以下操作，把我们最后拼接的到的图片base64转换输出。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dest_img='/data/tmp/' . md5(microtime(true)).'.'.$type; //要生成的图片的路径</span><br><span class=\"line\">$Return = <span class=\"built_in\">array</span>();</span><br><span class=\"line\"><span class=\"comment\">// *图片转换为 base64格式编码*</span></span><br><span class=\"line\">$base64_image = '';</span><br><span class=\"line\">$image_info = getimagesize($dest_img);</span><br><span class=\"line\">$image_data = fread(fopen($dest_img, <span class=\"string\">'r'</span>), filesize($dest_img));</span><br><span class=\"line\">$base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\">$Return['data']=$base64_image;</span><br><span class=\"line\"><span class=\"keyword\">return</span>  $Return;</span><br></pre></td></tr></table></figure></p>\n<p><code>$base64_image</code>就是base64格式的图片。</p>\n<p>需要注意的是前端得到的额base64数据里包含有<code>&#39;\\r\\n&#39;</code>回车字符，需要特殊处理才可以正确显示图片。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_4.png\" alt=\"PHP\"></p>\n<p>（最后得到的合并图片）</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_5.png\" alt=\"PHP\"></p>\n<p>(调整拼接图片大小得到不同的图片)<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_megick_6.png\" alt=\"PHP\"></p>"},{"title":"在PHP里很好的使用ImageMagick---convert篇","date":"2018-09-17T16:15:54.000Z","description":null,"copyright":true,"top":null,"_content":"\nImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是----convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg)\n\n<!-- more -->\n\n# 基本命令与格式\n\n## 1、基本命令\n\n* `magick:` 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。\n* `convert:` 等同于 magick 命令。\n* `identify:` 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。\n* `mogrify:` 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。\n* `composite:` 将一个图片或多个图片组合成新图片。\n* `montage:` 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。\n\n* `compare:` 从数学和视觉角度比较源图像与重建图像之间的差异。\n* `display: `在任何 X server 上显示一个图像或图像序列。\n* `animate:` 在任何 X server 上显示图像序列。\n* `import:` 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。\n* `conjure: `解释并执行 MSL ( Magick Scripting Language ) 写的脚本。\n* `stream:` 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。\n\n\n## 2、命令格式\n\n基本命令的使用，遵循 Unix 风格的标准格式，例如  `command [options] input_image output_image`\n\n> 将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用\n\n```h\nconvert -resize 200x200 goods.png goods.jpg\n\n```\n***\n\n\n\n# 开始绘制生成图片\n\n## 一些前期参数\n\n### 1、入参\n\n```h\n\n$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';\n$item_title='测试字体';\n$shop_title='测试店铺';\n$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';\n$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';\n$numid_share='0000000';\n$qr_title='长按识别二维码';\n\n// 对宝贝标题裁剪\n$drawtitone=mb_substr($item_title,0,13, 'utf-8');\n$drawtittow=mb_substr($item_title,13,13, 'utf-8');\n$drawtitthree=mb_substr($item_title,26,13, 'utf-8');\n$time_date = time(); // 时间戳\n$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径---->指定一个文件夹保存生成图片过程里的图片\n\n```\n\n### 2、先下载素材文件\n\n我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。\n```h\n\n$item_img_down = $workDir.'/itemimage.jpg';\n$shop_img_down = $workDir.'/shopimage.jpg';\n$qr_img_down = $workDir.'/qrimage.jpg';\n// 下载宝贝主图\n\\NetworkUtils::curlDownload($item_img, $item_img_down);\n// 下载店铺图片\n\\NetworkUtils::curlDownload($shop_img, $shop_img_down);\n// 下载二维码\n\\NetworkUtils::curlDownload($qr_img, $qr_img_down);\n\n```\n\n`\\NetworkUtils::curlDownload($item_img, $item_img_down);` 下载`$item_img`保存在目标路径文件夹下的`$workDir.'/itemimage.jpg'`路径。\n\n\n### 3、指定字体和颜色\n\n```h\n$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';\n$fontColor = '#333333';\n$fontColor_shoptitle = '#999999';\n$fontColor_qrtitlt = '#666666';\n```\n\n### 4、创建一个底图\n创建一个`750x1046`白色的底图，我们可以在上面绘制文字\n\n```h\n// 创建一个底图(并且加上一些文字)\n\n$back_img=$workDir.'/bg.jpg'; //要生成的图片的路径---->可以在服务器端看到\n$back_cmds=\"convert 'xc:[750x1046!]' -background white -font {$fontFamily} -draw 'text 580,994 \\\"{$qr_title}\\\"' -fill \\\"{$fontColor_qrtitlt}\\\" \n            -pointsize 20 -draw 'text 114,990 \\\"{$shop_title}\\\"' -font {$fontFamily} -pointsize 22 -fill '#999999' {$workDir}/bg.jpg\";\n$result_back_cmds = \\SystemCommon::runningCmd($back_cmds);  \n\n```\n> 这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。\n> `-font {$fontFamily} -draw 'text 580,994 \\\"{$qr_title}\\\"' -fill \\\"{$fontColor_qrtitlt}\\\" -pointsize 20`\n\n解释一下：\n* `xc:[100x40!]`: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !\n* `-fill 'rgba(0, 0, 0, 0)'`：设置了文本的填充颜色\n* `text 114,990`: 对文字进行定位\n* `-font`：指定字体\n* `-pointsize`：指定文本的字体大小\n* `-draw`：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )\n  \n\n继续添加文字：\n\n```h\n$back_img_shoptitle=$workDir.'/btitle.jpg'; //要生成的图片的路径\n$back_cmds_shoptitle=\"convert -draw 'text 40,820 \\\"{$drawtitone}\\\"' -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\" -draw 'text 40,866 \\\"{$drawtittow}\\\"' \n                    -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\" -draw 'text 40,912 \\\"{$drawtitthree}\\\"' -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\"  \n                    {$back_img} {$workDir}/btitle.jpg\";\n$result_back_cmds_shoptitle = \\SystemCommon::runningCmd($back_cmds_shoptitle);  \n\n```\n效果：\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_6.png)\n\n\n### 5、拼接图片\n现在就可以在之前得到的图片上拼接所需要的图片了\n\n```h\n // 在底图上合并商品主图\n$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg';  //要生成的图片的路径\n$geometryX = \"+\" . 0; // 定位\n$geometryY = \"+\" . 0; // 定位\n$customPicPos = \"northwest\";\n$back_cmds_itemimg = \"convert {$back_img_shoptitle} {$workDir}/item_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryX}{$geometryY} \n                    -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result.jpg\";\n$result_back_cmds_itemimg = \\SystemCommon::runningCmd($back_cmds_itemimg); \n\n```\n解释一下：\n* `-geometry`: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写\n* `composite`: 将一个图片或多个图片组合成新图片。\n\n这里是把`{$workDir}/item_img_mag.jpg`路径的图片绘制到之前绘制文字的图片上`$back_img_shoptitle`，最终得到的图片保存路径是在`{$workDir}/result.jpg`\n\n让我们继续操作图片\n\n```h\n// 合并二维码 \n$geometryXshop = \"+\" . 40;\n$geometryYshop = \"+\" . 950;\n$back_cmds_shopimg = \"convert {$workDir}/result.jpg {$workDir}/shop_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryXshop}{$geometryYshop} -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result1.jpg\";\n$result_back_cmds_shopimg = \\SystemCommon::runningCmd($back_cmds_shopimg);  \n\n// 合并店铺图标\n$geometryXqr = \"+\" . 520;\n$geometryYqr = \"+\" . 784;\n$back_cmds_qrimg = \"convert {$workDir}/result1.jpg {$workDir}/qr_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryXqr}{$geometryYqr} -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result2.jpg\";\n$result_back_cmds_qrimg = \\SystemCommon::runningCmd($back_cmds_qrimg);  \n\n```\n\n效果：\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_7.png)\n\n发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。\n\n### 6、放大拼接图片尺寸\n\n需要对多拼接的图片都进行操作\n\n```h\n // 看来需要先放大主图\n$item_img_m=\"convert -resize '750x766!' {$item_img_down} {$workDir}/item_img_mag.jpg\";\n$item_img_mag = \\SystemCommon::runningCmd($item_img_m);  \n// 看来需要先放大二维码\n$shop_img_m=\"convert -resize 64x64 {$shop_img_down} {$workDir}/shop_img_mag.jpg\";\n$shop_img_mag = \\SystemCommon::runningCmd($shop_img_m);  \n// 看来需要先放大店铺图标\n$qr_img_m=\"convert -resize 200x200 {$qr_img_down} {$workDir}/qr_img_mag.jpg\";\n$qr_img_mag = \\SystemCommon::runningCmd($qr_img_m);  \n\n```\n\n> -resize 延伸解读\n\n IamgeMagick 提供了几种符号来定义缩放\n\n ```h\n convert -resize '150x100!' goods.jpg thumbnail.jpg\n\n convert -resize '150x100>' goods.jpg thumbnail.jpg\n\n convert -resize '150x100<' goods.jpg thumbnail.jpg\n\n ```\n * `!`：不管图片宽高如何，都缩放成 150x100 这样的尺寸。\n * `>`：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。\n * `<`：与 > 功能相反\n\n缩放对比\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_1.png)\n\n\n这样的结果也不是我们需要的\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_4.png)\n\n只有`convert -resize '750x766!' {$item_img_down} {$workDir}/item_img_mag.jpg`这样固定尺寸之后可以得到：\n\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_5.png)\n\n\n### 7、图片转换为 base64格式\n\n我们最后同样的以base64格式输出给前端\n\n```h\n$stdout = trim($result_back_cmds_qrimg[\"stdout\"]);\n$Return = array();\nif (empty($stdout) || strpos($result_back_cmds_qrimg[\"stderr\"], \"identify\") != false) {  // runningCmd执行成功\n    $dest_img = $workDir.'/result2.jpg';\n    // /*图片转换为 base64格式编码*/\n    $base64_image = '';\n    $image_info = getimagesize($dest_img);\n    $image_data = fread(fopen($dest_img, 'r'), filesize($dest_img));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n\n    $Return['data']=$base64_image;\n    $Return['dest_img']=$dest_img;\n    $Return['type']='success';\n    $Return['msg']=1;\n    return $Return;\n}\n$Return['data']='';\n$Return['msg']=2;\nreturn $Return;\n\n```\n\n`$workDir.'/result2.jpg`是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。\n\n（小姐姐拼接图）\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_8.png)\n\n\n这次`convert命令`的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。\n\n欢迎光顾个人[Blog](https://duanruilong.github.io/blog)\n\n\n","source":"_posts/在PHP里很好的使用ImageMagick-convert篇.md","raw":"---\ntitle: 在PHP里很好的使用ImageMagick---convert篇\ndate: 2018-09-18 00:15:54\ntags: [PHP,编程,后端]\ndescription: \ncopyright: true\ncategories: 后端\ntop: \n---\n\nImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是----convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。\n\n![PHP](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg)\n\n<!-- more -->\n\n# 基本命令与格式\n\n## 1、基本命令\n\n* `magick:` 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。\n* `convert:` 等同于 magick 命令。\n* `identify:` 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。\n* `mogrify:` 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。\n* `composite:` 将一个图片或多个图片组合成新图片。\n* `montage:` 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。\n\n* `compare:` 从数学和视觉角度比较源图像与重建图像之间的差异。\n* `display: `在任何 X server 上显示一个图像或图像序列。\n* `animate:` 在任何 X server 上显示图像序列。\n* `import:` 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。\n* `conjure: `解释并执行 MSL ( Magick Scripting Language ) 写的脚本。\n* `stream:` 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。\n\n\n## 2、命令格式\n\n基本命令的使用，遵循 Unix 风格的标准格式，例如  `command [options] input_image output_image`\n\n> 将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用\n\n```h\nconvert -resize 200x200 goods.png goods.jpg\n\n```\n***\n\n\n\n# 开始绘制生成图片\n\n## 一些前期参数\n\n### 1、入参\n\n```h\n\n$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';\n$item_title='测试字体';\n$shop_title='测试店铺';\n$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';\n$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';\n$numid_share='0000000';\n$qr_title='长按识别二维码';\n\n// 对宝贝标题裁剪\n$drawtitone=mb_substr($item_title,0,13, 'utf-8');\n$drawtittow=mb_substr($item_title,13,13, 'utf-8');\n$drawtitthree=mb_substr($item_title,26,13, 'utf-8');\n$time_date = time(); // 时间戳\n$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径---->指定一个文件夹保存生成图片过程里的图片\n\n```\n\n### 2、先下载素材文件\n\n我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。\n```h\n\n$item_img_down = $workDir.'/itemimage.jpg';\n$shop_img_down = $workDir.'/shopimage.jpg';\n$qr_img_down = $workDir.'/qrimage.jpg';\n// 下载宝贝主图\n\\NetworkUtils::curlDownload($item_img, $item_img_down);\n// 下载店铺图片\n\\NetworkUtils::curlDownload($shop_img, $shop_img_down);\n// 下载二维码\n\\NetworkUtils::curlDownload($qr_img, $qr_img_down);\n\n```\n\n`\\NetworkUtils::curlDownload($item_img, $item_img_down);` 下载`$item_img`保存在目标路径文件夹下的`$workDir.'/itemimage.jpg'`路径。\n\n\n### 3、指定字体和颜色\n\n```h\n$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';\n$fontColor = '#333333';\n$fontColor_shoptitle = '#999999';\n$fontColor_qrtitlt = '#666666';\n```\n\n### 4、创建一个底图\n创建一个`750x1046`白色的底图，我们可以在上面绘制文字\n\n```h\n// 创建一个底图(并且加上一些文字)\n\n$back_img=$workDir.'/bg.jpg'; //要生成的图片的路径---->可以在服务器端看到\n$back_cmds=\"convert 'xc:[750x1046!]' -background white -font {$fontFamily} -draw 'text 580,994 \\\"{$qr_title}\\\"' -fill \\\"{$fontColor_qrtitlt}\\\" \n            -pointsize 20 -draw 'text 114,990 \\\"{$shop_title}\\\"' -font {$fontFamily} -pointsize 22 -fill '#999999' {$workDir}/bg.jpg\";\n$result_back_cmds = \\SystemCommon::runningCmd($back_cmds);  \n\n```\n> 这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。\n> `-font {$fontFamily} -draw 'text 580,994 \\\"{$qr_title}\\\"' -fill \\\"{$fontColor_qrtitlt}\\\" -pointsize 20`\n\n解释一下：\n* `xc:[100x40!]`: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !\n* `-fill 'rgba(0, 0, 0, 0)'`：设置了文本的填充颜色\n* `text 114,990`: 对文字进行定位\n* `-font`：指定字体\n* `-pointsize`：指定文本的字体大小\n* `-draw`：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )\n  \n\n继续添加文字：\n\n```h\n$back_img_shoptitle=$workDir.'/btitle.jpg'; //要生成的图片的路径\n$back_cmds_shoptitle=\"convert -draw 'text 40,820 \\\"{$drawtitone}\\\"' -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\" -draw 'text 40,866 \\\"{$drawtittow}\\\"' \n                    -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\" -draw 'text 40,912 \\\"{$drawtitthree}\\\"' -font {$fontFamily} -pointsize 32 -fill \\\"{$fontColor}\\\"  \n                    {$back_img} {$workDir}/btitle.jpg\";\n$result_back_cmds_shoptitle = \\SystemCommon::runningCmd($back_cmds_shoptitle);  \n\n```\n效果：\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_6.png)\n\n\n### 5、拼接图片\n现在就可以在之前得到的图片上拼接所需要的图片了\n\n```h\n // 在底图上合并商品主图\n$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg';  //要生成的图片的路径\n$geometryX = \"+\" . 0; // 定位\n$geometryY = \"+\" . 0; // 定位\n$customPicPos = \"northwest\";\n$back_cmds_itemimg = \"convert {$back_img_shoptitle} {$workDir}/item_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryX}{$geometryY} \n                    -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result.jpg\";\n$result_back_cmds_itemimg = \\SystemCommon::runningCmd($back_cmds_itemimg); \n\n```\n解释一下：\n* `-geometry`: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写\n* `composite`: 将一个图片或多个图片组合成新图片。\n\n这里是把`{$workDir}/item_img_mag.jpg`路径的图片绘制到之前绘制文字的图片上`$back_img_shoptitle`，最终得到的图片保存路径是在`{$workDir}/result.jpg`\n\n让我们继续操作图片\n\n```h\n// 合并二维码 \n$geometryXshop = \"+\" . 40;\n$geometryYshop = \"+\" . 950;\n$back_cmds_shopimg = \"convert {$workDir}/result.jpg {$workDir}/shop_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryXshop}{$geometryYshop} -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result1.jpg\";\n$result_back_cmds_shopimg = \\SystemCommon::runningCmd($back_cmds_shopimg);  \n\n// 合并店铺图标\n$geometryXqr = \"+\" . 520;\n$geometryYqr = \"+\" . 784;\n$back_cmds_qrimg = \"convert {$workDir}/result1.jpg {$workDir}/qr_img_mag.jpg -gravity {$customPicPos} -geometry {$geometryXqr}{$geometryYqr} -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB {$workDir}/result2.jpg\";\n$result_back_cmds_qrimg = \\SystemCommon::runningCmd($back_cmds_qrimg);  \n\n```\n\n效果：\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_7.png)\n\n发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。\n\n### 6、放大拼接图片尺寸\n\n需要对多拼接的图片都进行操作\n\n```h\n // 看来需要先放大主图\n$item_img_m=\"convert -resize '750x766!' {$item_img_down} {$workDir}/item_img_mag.jpg\";\n$item_img_mag = \\SystemCommon::runningCmd($item_img_m);  \n// 看来需要先放大二维码\n$shop_img_m=\"convert -resize 64x64 {$shop_img_down} {$workDir}/shop_img_mag.jpg\";\n$shop_img_mag = \\SystemCommon::runningCmd($shop_img_m);  \n// 看来需要先放大店铺图标\n$qr_img_m=\"convert -resize 200x200 {$qr_img_down} {$workDir}/qr_img_mag.jpg\";\n$qr_img_mag = \\SystemCommon::runningCmd($qr_img_m);  \n\n```\n\n> -resize 延伸解读\n\n IamgeMagick 提供了几种符号来定义缩放\n\n ```h\n convert -resize '150x100!' goods.jpg thumbnail.jpg\n\n convert -resize '150x100>' goods.jpg thumbnail.jpg\n\n convert -resize '150x100<' goods.jpg thumbnail.jpg\n\n ```\n * `!`：不管图片宽高如何，都缩放成 150x100 这样的尺寸。\n * `>`：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。\n * `<`：与 > 功能相反\n\n缩放对比\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_1.png)\n\n\n这样的结果也不是我们需要的\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_4.png)\n\n只有`convert -resize '750x766!' {$item_img_down} {$workDir}/item_img_mag.jpg`这样固定尺寸之后可以得到：\n\n\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_5.png)\n\n\n### 7、图片转换为 base64格式\n\n我们最后同样的以base64格式输出给前端\n\n```h\n$stdout = trim($result_back_cmds_qrimg[\"stdout\"]);\n$Return = array();\nif (empty($stdout) || strpos($result_back_cmds_qrimg[\"stderr\"], \"identify\") != false) {  // runningCmd执行成功\n    $dest_img = $workDir.'/result2.jpg';\n    // /*图片转换为 base64格式编码*/\n    $base64_image = '';\n    $image_info = getimagesize($dest_img);\n    $image_data = fread(fopen($dest_img, 'r'), filesize($dest_img));\n    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));\n\n    $Return['data']=$base64_image;\n    $Return['dest_img']=$dest_img;\n    $Return['type']='success';\n    $Return['msg']=1;\n    return $Return;\n}\n$Return['data']='';\n$Return['msg']=2;\nreturn $Return;\n\n```\n\n`$workDir.'/result2.jpg`是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。\n\n（小姐姐拼接图）\n![convert](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_8.png)\n\n\n这次`convert命令`的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。\n\n欢迎光顾个人[Blog](https://duanruilong.github.io/blog)\n\n\n","slug":"在PHP里很好的使用ImageMagick-convert篇","published":1,"updated":"2018-09-18T14:16:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctneu0035kt89pzunw278","content":"<p>ImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是—-convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg\" alt=\"PHP\"></p>\n<a id=\"more\"></a>\n<h1 id=\"基本命令与格式\"><a href=\"#基本命令与格式\" class=\"headerlink\" title=\"基本命令与格式\"></a>基本命令与格式</h1><h2 id=\"1、基本命令\"><a href=\"#1、基本命令\" class=\"headerlink\" title=\"1、基本命令\"></a>1、基本命令</h2><ul>\n<li><code>magick:</code> 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。</li>\n<li><code>convert:</code> 等同于 magick 命令。</li>\n<li><code>identify:</code> 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。</li>\n<li><code>mogrify:</code> 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。</li>\n<li><code>composite:</code> 将一个图片或多个图片组合成新图片。</li>\n<li><p><code>montage:</code> 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。</p>\n</li>\n<li><p><code>compare:</code> 从数学和视觉角度比较源图像与重建图像之间的差异。</p>\n</li>\n<li><code>display:</code>在任何 X server 上显示一个图像或图像序列。</li>\n<li><code>animate:</code> 在任何 X server 上显示图像序列。</li>\n<li><code>import:</code> 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。</li>\n<li><code>conjure:</code>解释并执行 MSL ( Magick Scripting Language ) 写的脚本。</li>\n<li><code>stream:</code> 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。</li>\n</ul>\n<h2 id=\"2、命令格式\"><a href=\"#2、命令格式\" class=\"headerlink\" title=\"2、命令格式\"></a>2、命令格式</h2><p>基本命令的使用，遵循 Unix 风格的标准格式，例如  <code>command [options] input_image output_image</code></p>\n<blockquote>\n<p>将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">convert -resize <span class=\"number\">200</span>x200 goods.png goods.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"开始绘制生成图片\"><a href=\"#开始绘制生成图片\" class=\"headerlink\" title=\"开始绘制生成图片\"></a>开始绘制生成图片</h1><h2 id=\"一些前期参数\"><a href=\"#一些前期参数\" class=\"headerlink\" title=\"一些前期参数\"></a>一些前期参数</h2><h3 id=\"1、入参\"><a href=\"#1、入参\" class=\"headerlink\" title=\"1、入参\"></a>1、入参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';</span><br><span class=\"line\">$item_title='测试字体';</span><br><span class=\"line\">$shop_title='测试店铺';</span><br><span class=\"line\">$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';</span><br><span class=\"line\">$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';</span><br><span class=\"line\">$numid_share='0000000';</span><br><span class=\"line\">$qr_title='长按识别二维码';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对宝贝标题裁剪</span></span><br><span class=\"line\">$drawtitone=mb_substr($item_title,0,13, 'utf-8');</span><br><span class=\"line\">$drawtittow=mb_substr($item_title,13,13, 'utf-8');</span><br><span class=\"line\">$drawtitthree=mb_substr($item_title,26,13, 'utf-8');</span><br><span class=\"line\">$time_date = time(); <span class=\"comment\">// 时间戳</span></span><br><span class=\"line\">$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径----&gt;指定一个文件夹保存生成图片过程里的图片</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、先下载素材文件\"><a href=\"#2、先下载素材文件\" class=\"headerlink\" title=\"2、先下载素材文件\"></a>2、先下载素材文件</h3><p>我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$item_img_down = $workDir<span class=\"number\">.'</span>/itemimage.jpg';</span><br><span class=\"line\">$shop_img_down = $workDir<span class=\"number\">.'</span>/shopimage.jpg';</span><br><span class=\"line\">$qr_img_down = $workDir<span class=\"number\">.'</span>/qrimage.jpg';</span><br><span class=\"line\"><span class=\"comment\">// 下载宝贝主图</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($item_img, $item_img_down);</span><br><span class=\"line\"><span class=\"comment\">// 下载店铺图片</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($shop_img, $shop_img_down);</span><br><span class=\"line\"><span class=\"comment\">// 下载二维码</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($qr_img, $qr_img_down);</span><br></pre></td></tr></table></figure></p>\n<p><code>\\NetworkUtils::curlDownload($item_img, $item_img_down);</code> 下载<code>$item_img</code>保存在目标路径文件夹下的<code>$workDir.&#39;/itemimage.jpg&#39;</code>路径。</p>\n<h3 id=\"3、指定字体和颜色\"><a href=\"#3、指定字体和颜色\" class=\"headerlink\" title=\"3、指定字体和颜色\"></a>3、指定字体和颜色</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';</span><br><span class=\"line\">$fontColor = '#333333';</span><br><span class=\"line\">$fontColor_shoptitle = '#999999';</span><br><span class=\"line\">$fontColor_qrtitlt = '#666666';</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、创建一个底图\"><a href=\"#4、创建一个底图\" class=\"headerlink\" title=\"4、创建一个底图\"></a>4、创建一个底图</h3><p>创建一个<code>750x1046</code>白色的底图，我们可以在上面绘制文字</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个底图(并且加上一些文字)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$back_img=$workDir<span class=\"number\">.'</span>/bg.jpg'; <span class=\"comment\">//要生成的图片的路径----&gt;可以在服务器端看到</span></span><br><span class=\"line\">$back_cmds=<span class=\"string\">\"convert 'xc:[750x1046!]' -background white -font &#123;$fontFamily&#125; -draw 'text 580,994 \\\"&#123;$qr_title&#125;\\\"' -fill \\\"&#123;$fontColor_qrtitlt&#125;\\\" </span></span><br><span class=\"line\"><span class=\"string\">            -pointsize 20 -draw 'text 114,990 \\\"&#123;$shop_title&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 22 -fill '#999999' &#123;$workDir&#125;/bg.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds = \\SystemCommon::runningCmd($back_cmds);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。<br><code>-font {$fontFamily} -draw &#39;text 580,994 \\&quot;{$qr_title}\\&quot;&#39; -fill \\&quot;{$fontColor_qrtitlt}\\&quot; -pointsize 20</code></p>\n</blockquote>\n<p>解释一下：</p>\n<ul>\n<li><code>xc:[100x40!]</code>: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !</li>\n<li><code>-fill &#39;rgba(0, 0, 0, 0)&#39;</code>：设置了文本的填充颜色</li>\n<li><code>text 114,990</code>: 对文字进行定位</li>\n<li><code>-font</code>：指定字体</li>\n<li><code>-pointsize</code>：指定文本的字体大小</li>\n<li><code>-draw</code>：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )</li>\n</ul>\n<p>继续添加文字：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$back_img_shoptitle=$workDir<span class=\"number\">.'</span>/btitle.jpg'; <span class=\"comment\">//要生成的图片的路径</span></span><br><span class=\"line\">$back_cmds_shoptitle=<span class=\"string\">\"convert -draw 'text 40,820 \\\"&#123;$drawtitone&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\" -draw 'text 40,866 \\\"&#123;$drawtittow&#125;\\\"' </span></span><br><span class=\"line\"><span class=\"string\">                    -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\" -draw 'text 40,912 \\\"&#123;$drawtitthree&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\"  </span></span><br><span class=\"line\"><span class=\"string\">                    &#123;$back_img&#125; &#123;$workDir&#125;/btitle.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_shoptitle = \\SystemCommon::runningCmd($back_cmds_shoptitle);</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_6.png\" alt=\"convert\"></p>\n<h3 id=\"5、拼接图片\"><a href=\"#5、拼接图片\" class=\"headerlink\" title=\"5、拼接图片\"></a>5、拼接图片</h3><p>现在就可以在之前得到的图片上拼接所需要的图片了</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 在底图上合并商品主图</span></span><br><span class=\"line\">$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg';  //要生成的图片的路径</span><br><span class=\"line\">$geometryX = <span class=\"string\">\"+\"</span> . <span class=\"number\">0</span>; <span class=\"comment\">// 定位</span></span><br><span class=\"line\">$geometryY = <span class=\"string\">\"+\"</span> . <span class=\"number\">0</span>; <span class=\"comment\">// 定位</span></span><br><span class=\"line\">$customPicPos = <span class=\"string\">\"northwest\"</span>;</span><br><span class=\"line\">$back_cmds_itemimg = <span class=\"string\">\"convert &#123;$back_img_shoptitle&#125; &#123;$workDir&#125;/item_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryX&#125;&#123;$geometryY&#125; </span></span><br><span class=\"line\"><span class=\"string\">                    -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_itemimg = \\SystemCommon::runningCmd($back_cmds_itemimg);</span><br></pre></td></tr></table></figure>\n<p>解释一下：</p>\n<ul>\n<li><code>-geometry</code>: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写</li>\n<li><code>composite</code>: 将一个图片或多个图片组合成新图片。</li>\n</ul>\n<p>这里是把<code>{$workDir}/item_img_mag.jpg</code>路径的图片绘制到之前绘制文字的图片上<code>$back_img_shoptitle</code>，最终得到的图片保存路径是在<code>{$workDir}/result.jpg</code></p>\n<p>让我们继续操作图片</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 合并二维码 </span></span><br><span class=\"line\">$geometryXshop = <span class=\"string\">\"+\"</span> . <span class=\"number\">40</span>;</span><br><span class=\"line\">$geometryYshop = <span class=\"string\">\"+\"</span> . <span class=\"number\">950</span>;</span><br><span class=\"line\">$back_cmds_shopimg = <span class=\"string\">\"convert &#123;$workDir&#125;/result.jpg &#123;$workDir&#125;/shop_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXshop&#125;&#123;$geometryYshop&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result1.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_shopimg = \\SystemCommon::runningCmd($back_cmds_shopimg);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并店铺图标</span></span><br><span class=\"line\">$geometryXqr = <span class=\"string\">\"+\"</span> . <span class=\"number\">520</span>;</span><br><span class=\"line\">$geometryYqr = <span class=\"string\">\"+\"</span> . <span class=\"number\">784</span>;</span><br><span class=\"line\">$back_cmds_qrimg = <span class=\"string\">\"convert &#123;$workDir&#125;/result1.jpg &#123;$workDir&#125;/qr_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXqr&#125;&#123;$geometryYqr&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result2.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_qrimg = \\SystemCommon::runningCmd($back_cmds_qrimg);</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_7.png\" alt=\"convert\"></p>\n<p>发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。</p>\n<h3 id=\"6、放大拼接图片尺寸\"><a href=\"#6、放大拼接图片尺寸\" class=\"headerlink\" title=\"6、放大拼接图片尺寸\"></a>6、放大拼接图片尺寸</h3><p>需要对多拼接的图片都进行操作</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 看来需要先放大主图</span></span><br><span class=\"line\">$item_img_m=<span class=\"string\">\"convert -resize '750x766!' &#123;$item_img_down&#125; &#123;$workDir&#125;/item_img_mag.jpg\"</span>;</span><br><span class=\"line\">$item_img_mag = \\SystemCommon::runningCmd($item_img_m);  </span><br><span class=\"line\"><span class=\"comment\">// 看来需要先放大二维码</span></span><br><span class=\"line\">$shop_img_m=<span class=\"string\">\"convert -resize 64x64 &#123;$shop_img_down&#125; &#123;$workDir&#125;/shop_img_mag.jpg\"</span>;</span><br><span class=\"line\">$shop_img_mag = \\SystemCommon::runningCmd($shop_img_m);  </span><br><span class=\"line\"><span class=\"comment\">// 看来需要先放大店铺图标</span></span><br><span class=\"line\">$qr_img_m=<span class=\"string\">\"convert -resize 200x200 &#123;$qr_img_down&#125; &#123;$workDir&#125;/qr_img_mag.jpg\"</span>;</span><br><span class=\"line\">$qr_img_mag = \\SystemCommon::runningCmd($qr_img_m);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-resize 延伸解读</p>\n</blockquote>\n<p> IamgeMagick 提供了几种符号来定义缩放</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">convert -resize '150x100!' goods.jpg thumbnail.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">convert -resize '150x100&gt;' goods.jpg thumbnail.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">convert -resize '150x100&lt;' goods.jpg thumbnail.jpg</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>!</code>：不管图片宽高如何，都缩放成 150x100 这样的尺寸。</li>\n<li><code>&gt;</code>：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。</li>\n<li><code>&lt;</code>：与 &gt; 功能相反</li>\n</ul>\n<p>缩放对比</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_1.png\" alt=\"convert\"></p>\n<p>这样的结果也不是我们需要的<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_4.png\" alt=\"convert\"></p>\n<p>只有<code>convert -resize &#39;750x766!&#39; {$item_img_down} {$workDir}/item_img_mag.jpg</code>这样固定尺寸之后可以得到：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_5.png\" alt=\"convert\"></p>\n<h3 id=\"7、图片转换为-base64格式\"><a href=\"#7、图片转换为-base64格式\" class=\"headerlink\" title=\"7、图片转换为 base64格式\"></a>7、图片转换为 base64格式</h3><p>我们最后同样的以base64格式输出给前端</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$<span class=\"built_in\">stdout</span> = trim($result_back_cmds_qrimg[<span class=\"string\">\"stdout\"</span>]);</span><br><span class=\"line\">$Return = <span class=\"built_in\">array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (empty($<span class=\"built_in\">stdout</span>) || strpos($result_back_cmds_qrimg[<span class=\"string\">\"stderr\"</span>], <span class=\"string\">\"identify\"</span>) != <span class=\"literal\">false</span>) &#123;  <span class=\"comment\">// runningCmd执行成功</span></span><br><span class=\"line\">    $dest_img = $workDir<span class=\"number\">.'</span>/result2.jpg';</span><br><span class=\"line\">    <span class=\"comment\">// /*图片转换为 base64格式编码*/</span></span><br><span class=\"line\">    $base64_image = '';</span><br><span class=\"line\">    $image_info = getimagesize($dest_img);</span><br><span class=\"line\">    $image_data = fread(fopen($dest_img, <span class=\"string\">'r'</span>), filesize($dest_img));</span><br><span class=\"line\">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\"></span><br><span class=\"line\">    $Return['data']=$base64_image;</span><br><span class=\"line\">    $Return['dest_img']=$dest_img;</span><br><span class=\"line\">    $Return['type']='success';</span><br><span class=\"line\">    $Return['msg']=1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> $Return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$Return['data']='';</span><br><span class=\"line\">$Return['msg']=2;</span><br><span class=\"line\"><span class=\"keyword\">return</span> $Return;</span><br></pre></td></tr></table></figure>\n<p><code>$workDir.&#39;/result2.jpg</code>是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。</p>\n<p>（小姐姐拼接图）<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_8.png\" alt=\"convert\"></p>\n<p>这次<code>convert命令</code>的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。</p>\n<p>欢迎光顾个人<a href=\"https://duanruilong.github.io/blog\">Blog</a></p>\n","site":{"data":{}},"excerpt":"<p>ImageMagick 包括一组命令行工具来操作图片，之前的ImageMagick实现base64图片的逻辑在服务器端可能会造成溢出的事故，所以在接下的文章里会介绍另外一种好的实现方式就是—-convert命令。使用命令格式的形式去生成图片和大小的裁剪数据格式的转换。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/php.jpg\" alt=\"PHP\"></p>","more":"<h1 id=\"基本命令与格式\"><a href=\"#基本命令与格式\" class=\"headerlink\" title=\"基本命令与格式\"></a>基本命令与格式</h1><h2 id=\"1、基本命令\"><a href=\"#1、基本命令\" class=\"headerlink\" title=\"1、基本命令\"></a>1、基本命令</h2><ul>\n<li><code>magick:</code> 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。</li>\n<li><code>convert:</code> 等同于 magick 命令。</li>\n<li><code>identify:</code> 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。</li>\n<li><code>mogrify:</code> 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。</li>\n<li><code>composite:</code> 将一个图片或多个图片组合成新图片。</li>\n<li><p><code>montage:</code> 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。</p>\n</li>\n<li><p><code>compare:</code> 从数学和视觉角度比较源图像与重建图像之间的差异。</p>\n</li>\n<li><code>display:</code>在任何 X server 上显示一个图像或图像序列。</li>\n<li><code>animate:</code> 在任何 X server 上显示图像序列。</li>\n<li><code>import:</code> 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。</li>\n<li><code>conjure:</code>解释并执行 MSL ( Magick Scripting Language ) 写的脚本。</li>\n<li><code>stream:</code> 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。</li>\n</ul>\n<h2 id=\"2、命令格式\"><a href=\"#2、命令格式\" class=\"headerlink\" title=\"2、命令格式\"></a>2、命令格式</h2><p>基本命令的使用，遵循 Unix 风格的标准格式，例如  <code>command [options] input_image output_image</code></p>\n<blockquote>\n<p>将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">convert -resize <span class=\"number\">200</span>x200 goods.png goods.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"开始绘制生成图片\"><a href=\"#开始绘制生成图片\" class=\"headerlink\" title=\"开始绘制生成图片\"></a>开始绘制生成图片</h1><h2 id=\"一些前期参数\"><a href=\"#一些前期参数\" class=\"headerlink\" title=\"一些前期参数\"></a>一些前期参数</h2><h3 id=\"1、入参\"><a href=\"#1、入参\" class=\"headerlink\" title=\"1、入参\"></a>1、入参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$item_img='https://img.alicdn.com/bao/uploaded/i1/1750208593/TB1rgM3hhtnkeRjSZSgXXXAuXXa_!!0-item_pic.jpg';</span><br><span class=\"line\">$item_title='测试字体';</span><br><span class=\"line\">$shop_title='测试店铺';</span><br><span class=\"line\">$shop_img='http://q.aiyongbao.com/item/web/images/qap_img/mobile/userAvatar.png';</span><br><span class=\"line\">$qr_img='https://img.alicdn.com/tfscom/TB1uJDStYZnBKNjSZFKwu3GOVXa.png';</span><br><span class=\"line\">$numid_share='0000000';</span><br><span class=\"line\">$qr_title='长按识别二维码';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对宝贝标题裁剪</span></span><br><span class=\"line\">$drawtitone=mb_substr($item_title,0,13, 'utf-8');</span><br><span class=\"line\">$drawtittow=mb_substr($item_title,13,13, 'utf-8');</span><br><span class=\"line\">$drawtitthree=mb_substr($item_title,26,13, 'utf-8');</span><br><span class=\"line\">$time_date = time(); <span class=\"comment\">// 时间戳</span></span><br><span class=\"line\">$workDir = '/data/tmp/'.$numid_share.'_con'.$time_date; // 目标路径----&gt;指定一个文件夹保存生成图片过程里的图片</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、先下载素材文件\"><a href=\"#2、先下载素材文件\" class=\"headerlink\" title=\"2、先下载素材文件\"></a>2、先下载素材文件</h3><p>我们这里需要一个拼接图片的链接，所以先下载到之前的创建的文件夹下，因为这些素材图片只是为了最后的拼接，最后可以完全删除。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$item_img_down = $workDir<span class=\"number\">.'</span>/itemimage.jpg';</span><br><span class=\"line\">$shop_img_down = $workDir<span class=\"number\">.'</span>/shopimage.jpg';</span><br><span class=\"line\">$qr_img_down = $workDir<span class=\"number\">.'</span>/qrimage.jpg';</span><br><span class=\"line\"><span class=\"comment\">// 下载宝贝主图</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($item_img, $item_img_down);</span><br><span class=\"line\"><span class=\"comment\">// 下载店铺图片</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($shop_img, $shop_img_down);</span><br><span class=\"line\"><span class=\"comment\">// 下载二维码</span></span><br><span class=\"line\">\\NetworkUtils::curlDownload($qr_img, $qr_img_down);</span><br></pre></td></tr></table></figure></p>\n<p><code>\\NetworkUtils::curlDownload($item_img, $item_img_down);</code> 下载<code>$item_img</code>保存在目标路径文件夹下的<code>$workDir.&#39;/itemimage.jpg&#39;</code>路径。</p>\n<h3 id=\"3、指定字体和颜色\"><a href=\"#3、指定字体和颜色\" class=\"headerlink\" title=\"3、指定字体和颜色\"></a>3、指定字体和颜色</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$fontFamily = '/usr/share/fonts/chinese/msyh.ttf';</span><br><span class=\"line\">$fontColor = '#333333';</span><br><span class=\"line\">$fontColor_shoptitle = '#999999';</span><br><span class=\"line\">$fontColor_qrtitlt = '#666666';</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、创建一个底图\"><a href=\"#4、创建一个底图\" class=\"headerlink\" title=\"4、创建一个底图\"></a>4、创建一个底图</h3><p>创建一个<code>750x1046</code>白色的底图，我们可以在上面绘制文字</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个底图(并且加上一些文字)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$back_img=$workDir<span class=\"number\">.'</span>/bg.jpg'; <span class=\"comment\">//要生成的图片的路径----&gt;可以在服务器端看到</span></span><br><span class=\"line\">$back_cmds=<span class=\"string\">\"convert 'xc:[750x1046!]' -background white -font &#123;$fontFamily&#125; -draw 'text 580,994 \\\"&#123;$qr_title&#125;\\\"' -fill \\\"&#123;$fontColor_qrtitlt&#125;\\\" </span></span><br><span class=\"line\"><span class=\"string\">            -pointsize 20 -draw 'text 114,990 \\\"&#123;$shop_title&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 22 -fill '#999999' &#123;$workDir&#125;/bg.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds = \\SystemCommon::runningCmd($back_cmds);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意一下文字的绘制命令顺序，否则会出现没有生效的问题。<br><code>-font {$fontFamily} -draw &#39;text 580,994 \\&quot;{$qr_title}\\&quot;&#39; -fill \\&quot;{$fontColor_qrtitlt}\\&quot; -pointsize 20</code></p>\n</blockquote>\n<p>解释一下：</p>\n<ul>\n<li><code>xc:[100x40!]</code>: 设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !</li>\n<li><code>-fill &#39;rgba(0, 0, 0, 0)&#39;</code>：设置了文本的填充颜色</li>\n<li><code>text 114,990</code>: 对文字进行定位</li>\n<li><code>-font</code>：指定字体</li>\n<li><code>-pointsize</code>：指定文本的字体大小</li>\n<li><code>-draw</code>：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值，绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )</li>\n</ul>\n<p>继续添加文字：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$back_img_shoptitle=$workDir<span class=\"number\">.'</span>/btitle.jpg'; <span class=\"comment\">//要生成的图片的路径</span></span><br><span class=\"line\">$back_cmds_shoptitle=<span class=\"string\">\"convert -draw 'text 40,820 \\\"&#123;$drawtitone&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\" -draw 'text 40,866 \\\"&#123;$drawtittow&#125;\\\"' </span></span><br><span class=\"line\"><span class=\"string\">                    -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\" -draw 'text 40,912 \\\"&#123;$drawtitthree&#125;\\\"' -font &#123;$fontFamily&#125; -pointsize 32 -fill \\\"&#123;$fontColor&#125;\\\"  </span></span><br><span class=\"line\"><span class=\"string\">                    &#123;$back_img&#125; &#123;$workDir&#125;/btitle.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_shoptitle = \\SystemCommon::runningCmd($back_cmds_shoptitle);</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_6.png\" alt=\"convert\"></p>\n<h3 id=\"5、拼接图片\"><a href=\"#5、拼接图片\" class=\"headerlink\" title=\"5、拼接图片\"></a>5、拼接图片</h3><p>现在就可以在之前得到的图片上拼接所需要的图片了</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 在底图上合并商品主图</span></span><br><span class=\"line\">$back_img_itemimg='/data/tmp/' . md5(microtime(true)).'.jpg';  //要生成的图片的路径</span><br><span class=\"line\">$geometryX = <span class=\"string\">\"+\"</span> . <span class=\"number\">0</span>; <span class=\"comment\">// 定位</span></span><br><span class=\"line\">$geometryY = <span class=\"string\">\"+\"</span> . <span class=\"number\">0</span>; <span class=\"comment\">// 定位</span></span><br><span class=\"line\">$customPicPos = <span class=\"string\">\"northwest\"</span>;</span><br><span class=\"line\">$back_cmds_itemimg = <span class=\"string\">\"convert &#123;$back_img_shoptitle&#125; &#123;$workDir&#125;/item_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryX&#125;&#123;$geometryY&#125; </span></span><br><span class=\"line\"><span class=\"string\">                    -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_itemimg = \\SystemCommon::runningCmd($back_cmds_itemimg);</span><br></pre></td></tr></table></figure>\n<p>解释一下：</p>\n<ul>\n<li><code>-geometry</code>: 设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写</li>\n<li><code>composite</code>: 将一个图片或多个图片组合成新图片。</li>\n</ul>\n<p>这里是把<code>{$workDir}/item_img_mag.jpg</code>路径的图片绘制到之前绘制文字的图片上<code>$back_img_shoptitle</code>，最终得到的图片保存路径是在<code>{$workDir}/result.jpg</code></p>\n<p>让我们继续操作图片</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 合并二维码 </span></span><br><span class=\"line\">$geometryXshop = <span class=\"string\">\"+\"</span> . <span class=\"number\">40</span>;</span><br><span class=\"line\">$geometryYshop = <span class=\"string\">\"+\"</span> . <span class=\"number\">950</span>;</span><br><span class=\"line\">$back_cmds_shopimg = <span class=\"string\">\"convert &#123;$workDir&#125;/result.jpg &#123;$workDir&#125;/shop_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXshop&#125;&#123;$geometryYshop&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result1.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_shopimg = \\SystemCommon::runningCmd($back_cmds_shopimg);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并店铺图标</span></span><br><span class=\"line\">$geometryXqr = <span class=\"string\">\"+\"</span> . <span class=\"number\">520</span>;</span><br><span class=\"line\">$geometryYqr = <span class=\"string\">\"+\"</span> . <span class=\"number\">784</span>;</span><br><span class=\"line\">$back_cmds_qrimg = <span class=\"string\">\"convert &#123;$workDir&#125;/result1.jpg &#123;$workDir&#125;/qr_img_mag.jpg -gravity &#123;$customPicPos&#125; -geometry &#123;$geometryXqr&#125;&#123;$geometryYqr&#125; -compose over -composite -antialias -set colorspace sRGB -colorspace sRGB &#123;$workDir&#125;/result2.jpg\"</span>;</span><br><span class=\"line\">$result_back_cmds_qrimg = \\SystemCommon::runningCmd($back_cmds_qrimg);</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_7.png\" alt=\"convert\"></p>\n<p>发现图片并不是我们预期的效果，拼接我们也设置了图片的大小，但是没有起作用，尝试过不同的方案后决定在拼接之前把图片统一放大为需要拼接的尺寸来操作。</p>\n<h3 id=\"6、放大拼接图片尺寸\"><a href=\"#6、放大拼接图片尺寸\" class=\"headerlink\" title=\"6、放大拼接图片尺寸\"></a>6、放大拼接图片尺寸</h3><p>需要对多拼接的图片都进行操作</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 看来需要先放大主图</span></span><br><span class=\"line\">$item_img_m=<span class=\"string\">\"convert -resize '750x766!' &#123;$item_img_down&#125; &#123;$workDir&#125;/item_img_mag.jpg\"</span>;</span><br><span class=\"line\">$item_img_mag = \\SystemCommon::runningCmd($item_img_m);  </span><br><span class=\"line\"><span class=\"comment\">// 看来需要先放大二维码</span></span><br><span class=\"line\">$shop_img_m=<span class=\"string\">\"convert -resize 64x64 &#123;$shop_img_down&#125; &#123;$workDir&#125;/shop_img_mag.jpg\"</span>;</span><br><span class=\"line\">$shop_img_mag = \\SystemCommon::runningCmd($shop_img_m);  </span><br><span class=\"line\"><span class=\"comment\">// 看来需要先放大店铺图标</span></span><br><span class=\"line\">$qr_img_m=<span class=\"string\">\"convert -resize 200x200 &#123;$qr_img_down&#125; &#123;$workDir&#125;/qr_img_mag.jpg\"</span>;</span><br><span class=\"line\">$qr_img_mag = \\SystemCommon::runningCmd($qr_img_m);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-resize 延伸解读</p>\n</blockquote>\n<p> IamgeMagick 提供了几种符号来定义缩放</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">convert -resize '150x100!' goods.jpg thumbnail.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">convert -resize '150x100&gt;' goods.jpg thumbnail.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">convert -resize '150x100&lt;' goods.jpg thumbnail.jpg</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>!</code>：不管图片宽高如何，都缩放成 150x100 这样的尺寸。</li>\n<li><code>&gt;</code>：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。</li>\n<li><code>&lt;</code>：与 &gt; 功能相反</li>\n</ul>\n<p>缩放对比</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_1.png\" alt=\"convert\"></p>\n<p>这样的结果也不是我们需要的<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_4.png\" alt=\"convert\"></p>\n<p>只有<code>convert -resize &#39;750x766!&#39; {$item_img_down} {$workDir}/item_img_mag.jpg</code>这样固定尺寸之后可以得到：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_5.png\" alt=\"convert\"></p>\n<h3 id=\"7、图片转换为-base64格式\"><a href=\"#7、图片转换为-base64格式\" class=\"headerlink\" title=\"7、图片转换为 base64格式\"></a>7、图片转换为 base64格式</h3><p>我们最后同样的以base64格式输出给前端</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$<span class=\"built_in\">stdout</span> = trim($result_back_cmds_qrimg[<span class=\"string\">\"stdout\"</span>]);</span><br><span class=\"line\">$Return = <span class=\"built_in\">array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (empty($<span class=\"built_in\">stdout</span>) || strpos($result_back_cmds_qrimg[<span class=\"string\">\"stderr\"</span>], <span class=\"string\">\"identify\"</span>) != <span class=\"literal\">false</span>) &#123;  <span class=\"comment\">// runningCmd执行成功</span></span><br><span class=\"line\">    $dest_img = $workDir<span class=\"number\">.'</span>/result2.jpg';</span><br><span class=\"line\">    <span class=\"comment\">// /*图片转换为 base64格式编码*/</span></span><br><span class=\"line\">    $base64_image = '';</span><br><span class=\"line\">    $image_info = getimagesize($dest_img);</span><br><span class=\"line\">    $image_data = fread(fopen($dest_img, <span class=\"string\">'r'</span>), filesize($dest_img));</span><br><span class=\"line\">    $base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));</span><br><span class=\"line\"></span><br><span class=\"line\">    $Return['data']=$base64_image;</span><br><span class=\"line\">    $Return['dest_img']=$dest_img;</span><br><span class=\"line\">    $Return['type']='success';</span><br><span class=\"line\">    $Return['msg']=1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> $Return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$Return['data']='';</span><br><span class=\"line\">$Return['msg']=2;</span><br><span class=\"line\"><span class=\"keyword\">return</span> $Return;</span><br></pre></td></tr></table></figure>\n<p><code>$workDir.&#39;/result2.jpg</code>是我们最终的拼接图片，至于文件夹下的其他图片，可以选择删除。我们只要得到结果就好了。</p>\n<p>（小姐姐拼接图）<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/php/php_convert_8.png\" alt=\"convert\"></p>\n<p>这次<code>convert命令</code>的介绍是以解读整个方法的形式，对拼接的开始进行到结尾生成最终的图片，希望对大家有力所能及的帮助。</p>\n<p>欢迎光顾个人<a href=\"https://duanruilong.github.io/blog\">Blog</a></p>"},{"title":"小程序之旅(七)","date":"2018-08-08T15:56:51.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考[flex 阮一峰](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n# Num1\n\n简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。\n\nlist.wxml\n\n```h\n<!--pages/list/list.wxml-->\n<view class=\"box\">\n <text class=\"list_header\">每日一看</text>\n  <view class=\"list\" wx:for=\"{{list}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n\n```\nlist.wxss\n```h\n/* pages/list/list.wxss */\n/*整个容器*/\n.box{\ndisplay: flex;\nflex-direction: column;/*竖直排列*/\n}\n/*title文字*/\n.list_header{\nfont-size: 32rpx;\nfont-weight: bold;\ncolor: #444;\npadding:20rpx;\nborder-bottom: 2rpx solid #ccc;\n}\n/*列表项容器*/\n.list{\ndisplay:flex;\nflex-direction: row;/*横向排列*/\nalign-content: center;\nborder-bottom:1rpx solid #ccc;\n\n}\n\n/*图片容器*/\n.list_img{\ndisplay: flex;\nalign-content: center;\npadding:20rpx 10rpx;\n}\n/*图片*/\n.avatar{\nwidth:130rpx;\nheight:130rpx;\nborder-radius: 4rpx;\nborder: 1rpx solid #F2F2F2;\n}\n/*文字容器，包含标题和内容*/\n.list_main{\ndisplay: flex;\nflex-direction: column;/*文字竖直排列*/\nalign-content: center;\npadding:40rpx 20rpx;\noverflow: hidden;\n}\n.list_title{\nfont-size: 28rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_content{\nfont-size: 24rpx;\ncolor: #999;\n}\n```\nlist.js里的数据先写成假数据。\n```h\n// pages/list/list.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    list:[{\n      img: 'http://localhost:9999/image/a1.jpg',\n      title: '美丽的大海啊！',\n      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n    },\n      {\n        img: 'http://localhost:9999/image/a2.jpg',\n        title: '回不去的那叫从前',\n        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n      },\n      {\n        img: 'http://localhost:9999/image/a3.jpg',\n        title: '森林生存恐怖游戏',\n        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n      },\n        ]\n  },\n```\n（也可以使用本地node服务）\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list', function (req, res) {\n    res.send({\n        code: 200,\n        data: [{\n                img: 'http://localhost:9999/image/a1.jpg',\n                title: '美丽的大海啊！',\n                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n            },\n            {\n                img: 'http://localhost:9999/image/a2.jpg',\n                title: '回不去的那叫从前',\n                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n            },\n            {\n                img: 'http://localhost:9999/image/a3.jpg',\n                title: '森林生存恐怖游戏',\n                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n            },\n        ]\n    });\n\n});\napp.listen(9999); //监听端口\n\n```\n\n\n\n# Num2\n\n接下来是img在头部，下方是文字内容。\n\nlist.wxml\n\n```h\n<!--pages/listview/listview.wxml-->\n<view class=\"box\">\n <text class=\"list_header\">每日一看</text>\n  <view class=\"list\" wx:for=\"{{list}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.address}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n\n```\nlist.wxss\n```h\n/* pages/listview/listview.wxss */\n/*整个容器*/\n.box{\ndisplay: flex;\nbackground: #ccc;\nflex-direction: column;/*竖直排列*/\nalign-content: center;\n}\n\n/*列表项容器*/\n.list{\nbackground: #FFF;\ndisplay:flex;\nflex-direction: column;/*竖直排列*/\nalign-content: center;\nwidth:90%;\nmargin:20rpx auto;/*居中对齐*/\n\n\n}\n\n/*图片容器*/\n.list_img{\ndisplay: flex;\nalign-content: center;\nwidth:100%;\npadding:20rpx 0rpx;\n}\n/*图片*/\n.avatar{\nwidth:100%;\nheight:400rpx;\nborder-radius: 4rpx;\nborder: 1rpx solid #F2F2F2;\n}\n/*文字容器，包含标题和内容*/\n.list_main{\ndisplay: flex;\nflex-direction: column;/*文字竖直排列*/\nalign-content: center;\npadding:20rpx;\noverflow: hidden;\n}\n.list_title{\nfont-size: 28rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_address{\nfont-size: 24rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_content{\nfont-size: 24rpx;\ncolor: #999;\n}\n```\nlist.js里的数据先写成假数据。\n```h\n// pages/list/list.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    list:[{\n      img: 'http://localhost:9999/image/a1.jpg',\n      title: '美丽的大海啊！',\n      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n    },\n      {\n        img: 'http://localhost:9999/image/a2.jpg',\n        title: '回不去的那叫从前',\n        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n      },\n      {\n        img: 'http://localhost:9999/image/a3.jpg',\n        title: '森林生存恐怖游戏',\n        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n      },\n        ]\n  },\n```\n（也可以使用本地node服务）\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list', function (req, res) {\n    res.send({\n        code: 200,\n        data: [{\n                img: 'http://localhost:9999/image/a1.jpg',\n                title: '美丽的大海啊！',\n                address: '1美丽的大海啊！',\n                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n            },\n            {\n                img: 'http://localhost:9999/image/a2.jpg',\n                title: '回不去的那叫从前',\n                address: '1回不去的那叫从前',\n                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n            },\n            {\n                img: 'http://localhost:9999/image/a3.jpg',\n                title: '森林生存恐怖游戏',\n                address: '1森林生存恐怖游戏',\n                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n            },\n        ]\n    });\n\n});\napp.listen(9999); //监听端口\n\n```\n# Num3\n\n上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。\n\n主要点：\n```h\n\nlist.json配置:\n\n\"enablePullDownRefresh\": true\n\n需要捕获这两个事件：\n\nonReachBottom（滚动到底部事件）\nonPullDownRefresh（下拉刷新事件）\n\n```\n\n本地服务：\n\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list/:num',function(req,res){\nvar num = req.params.num;//页码\nvar arr = [];\n(function(){\nfor(var i=(num*5-5);i<(num*5);i++){\nvar obj = {id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'};\narr.push(obj);\n}\n})();\n\nres.send({\ncode: 200,\npage:num,\ndata: arr\n});\n\n});\napp.listen(9999);//监听端口\n```\n\n```h\n<!--pages/listview/listview.wxml-->\n\n<loading hidden=\"{{isLoading}}\">加载中...</loading>\n\n\n<view class=\"box\">\n  <view wx:if=\"{{isRefesh}}\">\n   <icon type='waiting' size='45'></icon>\n   <text>刷新中...</text>\n  </view>\n\n  <view class=\"list\" wx:for=\"{{list}}\" id=\"{{page}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.address}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n```\n\n```h\n<!-- listview.json -->\n\n{\"enablePullDownRefresh\": true}\n```\n\n```h\n// pages/listview/listview.js\nPage({\n  data: {\n    list: [],//列表项数据\n    page: 1,//页码\n    isRefesh: false,//是否刷新\n    isLoading: true//正在加载\n  },\n  //下拉刷新\n  onPullDownRefresh: function () {\n    var that = this;\n    that.setData({ isRefesh: true });//刷新条出现\n    wx.request({\n      url: 'http://localhost:9999/list/1',\n      method: 'GET',\n      success: function (res) {\n        var listdata = res.data.data;\n        setTimeout(function () {\n          wx.stopPullDownRefresh;//停止下拉刷新效果\n          that.setData({ page: 1 });//重置页码\n          that.setData({ list: listdata, isRefesh: false });//重新设置列表项和刷新条消失\n        }, 1000);\n\n      }\n    });\n  },\n  //滑到底部加载\n  onReachBottom: function () {\n    var that = this;\n    var page = that.data.page + 1;\n    var oldData = this.data.list;//老数据\n    that.setData({ isLoading: false });//loading出现\n    wx.request({\n      url: 'http://localhost:9999/list/' + page,\n      method: 'GET',\n      success: function (res) {\n        var allData = [];\n        var listdata = res.data.data;//新数据\n        allData = oldData.concat(listdata);//老数据和新数据合并\n        that.setData({ list: allData, page: page });//重新设置列表项和页码\n        setTimeout(function () {\n          that.setData({ isLoading: true });//loading消失\n        }, 1000);\n      }\n    })\n  },\n  //页码初始化\n  onLoad: function (options) {\n    var that = this;\n    that.setData({ isLoading: false });//loading出现\n    wx.request({\n      url: 'http://localhost:9999/list/1',\n      method: 'GET',\n      success: function (res) {\n        var listdata = res.data.data;\n        that.setData({ list: listdata });\n        setTimeout(function () {\n          that.setData({ isLoading: true });//loading消失\n        }, 1000);\n      }\n    })\n  }\n\n})\n\n```\n","source":"_posts/小程序之旅-七.md","raw":"---\ntitle: 小程序之旅(七)\ndate: 2018-08-08 23:56:51\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考[flex 阮一峰](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n# Num1\n\n简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。\n\nlist.wxml\n\n```h\n<!--pages/list/list.wxml-->\n<view class=\"box\">\n <text class=\"list_header\">每日一看</text>\n  <view class=\"list\" wx:for=\"{{list}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n\n```\nlist.wxss\n```h\n/* pages/list/list.wxss */\n/*整个容器*/\n.box{\ndisplay: flex;\nflex-direction: column;/*竖直排列*/\n}\n/*title文字*/\n.list_header{\nfont-size: 32rpx;\nfont-weight: bold;\ncolor: #444;\npadding:20rpx;\nborder-bottom: 2rpx solid #ccc;\n}\n/*列表项容器*/\n.list{\ndisplay:flex;\nflex-direction: row;/*横向排列*/\nalign-content: center;\nborder-bottom:1rpx solid #ccc;\n\n}\n\n/*图片容器*/\n.list_img{\ndisplay: flex;\nalign-content: center;\npadding:20rpx 10rpx;\n}\n/*图片*/\n.avatar{\nwidth:130rpx;\nheight:130rpx;\nborder-radius: 4rpx;\nborder: 1rpx solid #F2F2F2;\n}\n/*文字容器，包含标题和内容*/\n.list_main{\ndisplay: flex;\nflex-direction: column;/*文字竖直排列*/\nalign-content: center;\npadding:40rpx 20rpx;\noverflow: hidden;\n}\n.list_title{\nfont-size: 28rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_content{\nfont-size: 24rpx;\ncolor: #999;\n}\n```\nlist.js里的数据先写成假数据。\n```h\n// pages/list/list.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    list:[{\n      img: 'http://localhost:9999/image/a1.jpg',\n      title: '美丽的大海啊！',\n      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n    },\n      {\n        img: 'http://localhost:9999/image/a2.jpg',\n        title: '回不去的那叫从前',\n        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n      },\n      {\n        img: 'http://localhost:9999/image/a3.jpg',\n        title: '森林生存恐怖游戏',\n        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n      },\n        ]\n  },\n```\n（也可以使用本地node服务）\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list', function (req, res) {\n    res.send({\n        code: 200,\n        data: [{\n                img: 'http://localhost:9999/image/a1.jpg',\n                title: '美丽的大海啊！',\n                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n            },\n            {\n                img: 'http://localhost:9999/image/a2.jpg',\n                title: '回不去的那叫从前',\n                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n            },\n            {\n                img: 'http://localhost:9999/image/a3.jpg',\n                title: '森林生存恐怖游戏',\n                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n            },\n        ]\n    });\n\n});\napp.listen(9999); //监听端口\n\n```\n\n\n\n# Num2\n\n接下来是img在头部，下方是文字内容。\n\nlist.wxml\n\n```h\n<!--pages/listview/listview.wxml-->\n<view class=\"box\">\n <text class=\"list_header\">每日一看</text>\n  <view class=\"list\" wx:for=\"{{list}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.address}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n\n```\nlist.wxss\n```h\n/* pages/listview/listview.wxss */\n/*整个容器*/\n.box{\ndisplay: flex;\nbackground: #ccc;\nflex-direction: column;/*竖直排列*/\nalign-content: center;\n}\n\n/*列表项容器*/\n.list{\nbackground: #FFF;\ndisplay:flex;\nflex-direction: column;/*竖直排列*/\nalign-content: center;\nwidth:90%;\nmargin:20rpx auto;/*居中对齐*/\n\n\n}\n\n/*图片容器*/\n.list_img{\ndisplay: flex;\nalign-content: center;\nwidth:100%;\npadding:20rpx 0rpx;\n}\n/*图片*/\n.avatar{\nwidth:100%;\nheight:400rpx;\nborder-radius: 4rpx;\nborder: 1rpx solid #F2F2F2;\n}\n/*文字容器，包含标题和内容*/\n.list_main{\ndisplay: flex;\nflex-direction: column;/*文字竖直排列*/\nalign-content: center;\npadding:20rpx;\noverflow: hidden;\n}\n.list_title{\nfont-size: 28rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_address{\nfont-size: 24rpx;\ncolor: #717171;\nfont-weight: bold;\npadding-bottom: 10rpx;\n}\n.list_content{\nfont-size: 24rpx;\ncolor: #999;\n}\n```\nlist.js里的数据先写成假数据。\n```h\n// pages/list/list.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    list:[{\n      img: 'http://localhost:9999/image/a1.jpg',\n      title: '美丽的大海啊！',\n      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n    },\n      {\n        img: 'http://localhost:9999/image/a2.jpg',\n        title: '回不去的那叫从前',\n        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n      },\n      {\n        img: 'http://localhost:9999/image/a3.jpg',\n        title: '森林生存恐怖游戏',\n        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n      },\n        ]\n  },\n```\n（也可以使用本地node服务）\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list', function (req, res) {\n    res.send({\n        code: 200,\n        data: [{\n                img: 'http://localhost:9999/image/a1.jpg',\n                title: '美丽的大海啊！',\n                address: '1美丽的大海啊！',\n                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'\n            },\n            {\n                img: 'http://localhost:9999/image/a2.jpg',\n                title: '回不去的那叫从前',\n                address: '1回不去的那叫从前',\n                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'\n            },\n            {\n                img: 'http://localhost:9999/image/a3.jpg',\n                title: '森林生存恐怖游戏',\n                address: '1森林生存恐怖游戏',\n                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'\n            },\n        ]\n    });\n\n});\napp.listen(9999); //监听端口\n\n```\n# Num3\n\n上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。\n\n主要点：\n```h\n\nlist.json配置:\n\n\"enablePullDownRefresh\": true\n\n需要捕获这两个事件：\n\nonReachBottom（滚动到底部事件）\nonPullDownRefresh（下拉刷新事件）\n\n```\n\n本地服务：\n\n```h\nvar express = require('express');\nvar fs = require('fs');\nvar app = express();\n//处理静态资源\napp.use(express.static('./'));\napp.get('/list/:num',function(req,res){\nvar num = req.params.num;//页码\nvar arr = [];\n(function(){\nfor(var i=(num*5-5);i<(num*5);i++){\nvar obj = {id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'};\narr.push(obj);\n}\n})();\n\nres.send({\ncode: 200,\npage:num,\ndata: arr\n});\n\n});\napp.listen(9999);//监听端口\n```\n\n```h\n<!--pages/listview/listview.wxml-->\n\n<loading hidden=\"{{isLoading}}\">加载中...</loading>\n\n\n<view class=\"box\">\n  <view wx:if=\"{{isRefesh}}\">\n   <icon type='waiting' size='45'></icon>\n   <text>刷新中...</text>\n  </view>\n\n  <view class=\"list\" wx:for=\"{{list}}\" id=\"{{page}}\">\n    <view class='list_img'>\n      <image src=\"{{item.img}}\" class='avatar'></image>\n    </view>\n    <view class='list_main'>\n      <view class='list_title'>{{item.title}}</view>\n      <view class='list_content'>{{item.address}}</view>\n      <view class='list_content'>{{item.content}}</view>\n    </view>\n  </view>\n</view>\n```\n\n```h\n<!-- listview.json -->\n\n{\"enablePullDownRefresh\": true}\n```\n\n```h\n// pages/listview/listview.js\nPage({\n  data: {\n    list: [],//列表项数据\n    page: 1,//页码\n    isRefesh: false,//是否刷新\n    isLoading: true//正在加载\n  },\n  //下拉刷新\n  onPullDownRefresh: function () {\n    var that = this;\n    that.setData({ isRefesh: true });//刷新条出现\n    wx.request({\n      url: 'http://localhost:9999/list/1',\n      method: 'GET',\n      success: function (res) {\n        var listdata = res.data.data;\n        setTimeout(function () {\n          wx.stopPullDownRefresh;//停止下拉刷新效果\n          that.setData({ page: 1 });//重置页码\n          that.setData({ list: listdata, isRefesh: false });//重新设置列表项和刷新条消失\n        }, 1000);\n\n      }\n    });\n  },\n  //滑到底部加载\n  onReachBottom: function () {\n    var that = this;\n    var page = that.data.page + 1;\n    var oldData = this.data.list;//老数据\n    that.setData({ isLoading: false });//loading出现\n    wx.request({\n      url: 'http://localhost:9999/list/' + page,\n      method: 'GET',\n      success: function (res) {\n        var allData = [];\n        var listdata = res.data.data;//新数据\n        allData = oldData.concat(listdata);//老数据和新数据合并\n        that.setData({ list: allData, page: page });//重新设置列表项和页码\n        setTimeout(function () {\n          that.setData({ isLoading: true });//loading消失\n        }, 1000);\n      }\n    })\n  },\n  //页码初始化\n  onLoad: function (options) {\n    var that = this;\n    that.setData({ isLoading: false });//loading出现\n    wx.request({\n      url: 'http://localhost:9999/list/1',\n      method: 'GET',\n      success: function (res) {\n        var listdata = res.data.data;\n        that.setData({ list: listdata });\n        setTimeout(function () {\n          that.setData({ isLoading: true });//loading消失\n        }, 1000);\n      }\n    })\n  }\n\n})\n\n```\n","slug":"小程序之旅-七","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnev0039kt89yvuj6u7i","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<p>这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">flex 阮一峰</a></p>\n<h1 id=\"Num1\"><a href=\"#Num1\" class=\"headerlink\" title=\"Num1\"></a>Num1</h1><p>简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。</p>\n<p>list.wxml</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/<span class=\"built_in\">list</span>/<span class=\"built_in\">list</span>.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">box</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\"> &lt;text class=\"list_header\"&gt;每日一看&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"list\" wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_img'&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_main'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>list.wxss<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pages/list/list.wxss */</span></span><br><span class=\"line\"><span class=\"comment\">/*整个容器*/</span></span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*title文字*/</span></span><br><span class=\"line\">.list_header&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">32</span>rpx;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">color: #<span class=\"number\">444</span>;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx;</span><br><span class=\"line\">border-bottom: <span class=\"number\">2</span>rpx solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*列表项容器*/</span></span><br><span class=\"line\">.<span class=\"built_in\">list</span>&#123;</span><br><span class=\"line\">display:flex;</span><br><span class=\"line\">flex-direction: row;<span class=\"comment\">/*横向排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">border-bottom:<span class=\"number\">1</span>rpx solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片容器*/</span></span><br><span class=\"line\">.list_img&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*图片*/</span></span><br><span class=\"line\">.avatar&#123;</span><br><span class=\"line\">width:<span class=\"number\">130</span>rpx;</span><br><span class=\"line\">height:<span class=\"number\">130</span>rpx;</span><br><span class=\"line\">border-radius: <span class=\"number\">4</span>rpx;</span><br><span class=\"line\">border: <span class=\"number\">1</span>rpx solid #F2F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*文字容器，包含标题和内容*/</span></span><br><span class=\"line\">.list_main&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*文字竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">40</span>rpx <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_title&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_content&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list.js里的数据先写成假数据。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/list/list.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>:[&#123;</span><br><span class=\"line\">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">      title: '美丽的大海啊！',</span><br><span class=\"line\">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">        title: '回不去的那叫从前',</span><br><span class=\"line\">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">        title: '森林生存恐怖游戏',</span><br><span class=\"line\">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>（也可以使用本地node服务）<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list', function (req, res) &#123;</span><br><span class=\"line\">    res.send(&#123;</span><br><span class=\"line\">        code: <span class=\"number\">200</span>,</span><br><span class=\"line\">        data: [&#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">                title: '美丽的大海啊！',</span><br><span class=\"line\">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">                title: '回不去的那叫从前',</span><br><span class=\"line\">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">                title: '森林生存恐怖游戏',</span><br><span class=\"line\">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>); <span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Num2\"><a href=\"#Num2\" class=\"headerlink\" title=\"Num2\"></a>Num2</h1><p>接下来是img在头部，下方是文字内容。</p>\n<p>list.wxml</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">box</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\"> &lt;text class=\"list_header\"&gt;每日一看&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"list\" wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_img'&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_main'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>list.wxss<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pages/listview/listview.wxss */</span></span><br><span class=\"line\"><span class=\"comment\">/*整个容器*/</span></span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">background: <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*列表项容器*/</span></span><br><span class=\"line\">.<span class=\"built_in\">list</span>&#123;</span><br><span class=\"line\">background: #FFF;</span><br><span class=\"line\">display:flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">width:<span class=\"number\">90</span>%;</span><br><span class=\"line\">margin:<span class=\"number\">20</span>rpx <span class=\"keyword\">auto</span>;<span class=\"comment\">/*居中对齐*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片容器*/</span></span><br><span class=\"line\">.list_img&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">width:<span class=\"number\">100</span>%;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx <span class=\"number\">0</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*图片*/</span></span><br><span class=\"line\">.avatar&#123;</span><br><span class=\"line\">width:<span class=\"number\">100</span>%;</span><br><span class=\"line\">height:<span class=\"number\">400</span>rpx;</span><br><span class=\"line\">border-radius: <span class=\"number\">4</span>rpx;</span><br><span class=\"line\">border: <span class=\"number\">1</span>rpx solid #F2F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*文字容器，包含标题和内容*/</span></span><br><span class=\"line\">.list_main&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*文字竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx;</span><br><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_title&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_address&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_content&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list.js里的数据先写成假数据。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/list/list.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>:[&#123;</span><br><span class=\"line\">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">      title: '美丽的大海啊！',</span><br><span class=\"line\">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">        title: '回不去的那叫从前',</span><br><span class=\"line\">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">        title: '森林生存恐怖游戏',</span><br><span class=\"line\">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>（也可以使用本地node服务）<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list', function (req, res) &#123;</span><br><span class=\"line\">    res.send(&#123;</span><br><span class=\"line\">        code: <span class=\"number\">200</span>,</span><br><span class=\"line\">        data: [&#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">                title: '美丽的大海啊！',</span><br><span class=\"line\">                address: '1美丽的大海啊！',</span><br><span class=\"line\">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">                title: '回不去的那叫从前',</span><br><span class=\"line\">                address: '1回不去的那叫从前',</span><br><span class=\"line\">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">                title: '森林生存恐怖游戏',</span><br><span class=\"line\">                address: '1森林生存恐怖游戏',</span><br><span class=\"line\">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>); <span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Num3\"><a href=\"#Num3\" class=\"headerlink\" title=\"Num3\"></a>Num3</h1><p>上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。</p>\n<p>主要点：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">list</span>.json配置:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"enablePullDownRefresh\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">需要捕获这两个事件：</span><br><span class=\"line\"></span><br><span class=\"line\">onReachBottom（滚动到底部事件）</span><br><span class=\"line\">onPullDownRefresh（下拉刷新事件）</span><br></pre></td></tr></table></figure></p>\n<p>本地服务：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list/:num',function(req,res)&#123;</span><br><span class=\"line\">var num = req.params.num;<span class=\"comment\">//页码</span></span><br><span class=\"line\">var arr = [];</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=(num*<span class=\"number\">5</span><span class=\"number\">-5</span>);i&lt;(num*<span class=\"number\">5</span>);i++)&#123;</span><br><span class=\"line\">var obj = &#123;id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'&#125;;</span><br><span class=\"line\">arr.push(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">res.send(&#123;</span><br><span class=\"line\">code: <span class=\"number\">200</span>,</span><br><span class=\"line\">page:num,</span><br><span class=\"line\">data: arr</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>);<span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;loading hidden=<span class=\"string\">\"&#123;&#123;isLoading&#125;&#125;\"</span>&gt;加载中...&lt;/loading&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;view class=<span class=\"string\">\"box\"</span>&gt;</span><br><span class=\"line\">  &lt;view wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;isRefesh&#125;&#125;\"</span>&gt;</span><br><span class=\"line\">   &lt;icon type='waiting' size='45'&gt;&lt;/icon&gt;</span><br><span class=\"line\">   &lt;text&gt;刷新中...&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">list</span>\" <span class=\"title\">wx</span>:</span><span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;list&#125;&#125;\"</span> id=<span class=\"string\">\"&#123;&#123;page&#125;&#125;\"</span>&gt;</span><br><span class=\"line\">    &lt;view class='list_img'&gt;</span><br><span class=\"line\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;view <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">list_main</span>'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- listview.json --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"enablePullDownRefresh\"</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/listview/listview.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>: [],<span class=\"comment\">//列表项数据</span></span><br><span class=\"line\">    page: <span class=\"number\">1</span>,<span class=\"comment\">//页码</span></span><br><span class=\"line\">    isRefesh: <span class=\"literal\">false</span>,<span class=\"comment\">//是否刷新</span></span><br><span class=\"line\">    isLoading: <span class=\"literal\">true</span><span class=\"comment\">//正在加载</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//下拉刷新</span></span><br><span class=\"line\">  onPullDownRefresh: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    that.setData(&#123; isRefesh: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//刷新条出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/1',</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var listdata = res.data.data;</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          wx.stopPullDownRefresh;<span class=\"comment\">//停止下拉刷新效果</span></span><br><span class=\"line\">          that.setData(&#123; page: <span class=\"number\">1</span> &#125;);<span class=\"comment\">//重置页码</span></span><br><span class=\"line\">          that.setData(&#123; <span class=\"built_in\">list</span>: listdata, isRefesh: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//重新设置列表项和刷新条消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//滑到底部加载</span></span><br><span class=\"line\">  onReachBottom: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    var page = that.data.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">    var oldData = <span class=\"keyword\">this</span>.data.<span class=\"built_in\">list</span>;<span class=\"comment\">//老数据</span></span><br><span class=\"line\">    that.setData(&#123; isLoading: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//loading出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/' + page,</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var allData = [];</span><br><span class=\"line\">        var listdata = res.data.data;<span class=\"comment\">//新数据</span></span><br><span class=\"line\">        allData = oldData.concat(listdata);<span class=\"comment\">//老数据和新数据合并</span></span><br><span class=\"line\">        that.setData(&#123; <span class=\"built_in\">list</span>: allData, page: page &#125;);<span class=\"comment\">//重新设置列表项和页码</span></span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          that.setData(&#123; isLoading: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//loading消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//页码初始化</span></span><br><span class=\"line\">  onLoad: function (options) &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    that.setData(&#123; isLoading: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//loading出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/1',</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var listdata = res.data.data;</span><br><span class=\"line\">        that.setData(&#123; <span class=\"built_in\">list</span>: listdata &#125;);</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          that.setData(&#123; isLoading: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//loading消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的动态加载一个列表页小栗子。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<p>这里的列表布局方式，采用flex弹性布局实现，具体内容可以参考<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">flex 阮一峰</a></p>\n<h1 id=\"Num1\"><a href=\"#Num1\" class=\"headerlink\" title=\"Num1\"></a>Num1</h1><p>简单说一下布局，头部是一个title，下面是一个list，list是由一个一个的card组成，而对于card布局，主要是外部一个box，里面分左右img和内容。</p>\n<p>list.wxml</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/<span class=\"built_in\">list</span>/<span class=\"built_in\">list</span>.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">box</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\"> &lt;text class=\"list_header\"&gt;每日一看&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"list\" wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_img'&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_main'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>list.wxss<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pages/list/list.wxss */</span></span><br><span class=\"line\"><span class=\"comment\">/*整个容器*/</span></span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*title文字*/</span></span><br><span class=\"line\">.list_header&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">32</span>rpx;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">color: #<span class=\"number\">444</span>;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx;</span><br><span class=\"line\">border-bottom: <span class=\"number\">2</span>rpx solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*列表项容器*/</span></span><br><span class=\"line\">.<span class=\"built_in\">list</span>&#123;</span><br><span class=\"line\">display:flex;</span><br><span class=\"line\">flex-direction: row;<span class=\"comment\">/*横向排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">border-bottom:<span class=\"number\">1</span>rpx solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片容器*/</span></span><br><span class=\"line\">.list_img&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*图片*/</span></span><br><span class=\"line\">.avatar&#123;</span><br><span class=\"line\">width:<span class=\"number\">130</span>rpx;</span><br><span class=\"line\">height:<span class=\"number\">130</span>rpx;</span><br><span class=\"line\">border-radius: <span class=\"number\">4</span>rpx;</span><br><span class=\"line\">border: <span class=\"number\">1</span>rpx solid #F2F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*文字容器，包含标题和内容*/</span></span><br><span class=\"line\">.list_main&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*文字竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">40</span>rpx <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_title&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_content&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list.js里的数据先写成假数据。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/list/list.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>:[&#123;</span><br><span class=\"line\">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">      title: '美丽的大海啊！',</span><br><span class=\"line\">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">        title: '回不去的那叫从前',</span><br><span class=\"line\">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">        title: '森林生存恐怖游戏',</span><br><span class=\"line\">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>（也可以使用本地node服务）<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list', function (req, res) &#123;</span><br><span class=\"line\">    res.send(&#123;</span><br><span class=\"line\">        code: <span class=\"number\">200</span>,</span><br><span class=\"line\">        data: [&#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">                title: '美丽的大海啊！',</span><br><span class=\"line\">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">                title: '回不去的那叫从前',</span><br><span class=\"line\">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">                title: '森林生存恐怖游戏',</span><br><span class=\"line\">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>); <span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Num2\"><a href=\"#Num2\" class=\"headerlink\" title=\"Num2\"></a>Num2</h1><p>接下来是img在头部，下方是文字内容。</p>\n<p>list.wxml</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">box</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\"> &lt;text class=\"list_header\"&gt;每日一看&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"list\" wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_img'&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class='list_main'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>list.wxss<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pages/listview/listview.wxss */</span></span><br><span class=\"line\"><span class=\"comment\">/*整个容器*/</span></span><br><span class=\"line\">.box&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">background: <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*列表项容器*/</span></span><br><span class=\"line\">.<span class=\"built_in\">list</span>&#123;</span><br><span class=\"line\">background: #FFF;</span><br><span class=\"line\">display:flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">width:<span class=\"number\">90</span>%;</span><br><span class=\"line\">margin:<span class=\"number\">20</span>rpx <span class=\"keyword\">auto</span>;<span class=\"comment\">/*居中对齐*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*图片容器*/</span></span><br><span class=\"line\">.list_img&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">width:<span class=\"number\">100</span>%;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx <span class=\"number\">0</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*图片*/</span></span><br><span class=\"line\">.avatar&#123;</span><br><span class=\"line\">width:<span class=\"number\">100</span>%;</span><br><span class=\"line\">height:<span class=\"number\">400</span>rpx;</span><br><span class=\"line\">border-radius: <span class=\"number\">4</span>rpx;</span><br><span class=\"line\">border: <span class=\"number\">1</span>rpx solid #F2F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*文字容器，包含标题和内容*/</span></span><br><span class=\"line\">.list_main&#123;</span><br><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction: column;<span class=\"comment\">/*文字竖直排列*/</span></span><br><span class=\"line\">align-content: center;</span><br><span class=\"line\">padding:<span class=\"number\">20</span>rpx;</span><br><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_title&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_address&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">717171</span>;</span><br><span class=\"line\">font-weight: bold;</span><br><span class=\"line\">padding-bottom: <span class=\"number\">10</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list_content&#123;</span><br><span class=\"line\">font-size: <span class=\"number\">24</span>rpx;</span><br><span class=\"line\">color: #<span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list.js里的数据先写成假数据。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/list/list.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>:[&#123;</span><br><span class=\"line\">      img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">      title: '美丽的大海啊！',</span><br><span class=\"line\">      content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">        title: '回不去的那叫从前',</span><br><span class=\"line\">        content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">        title: '森林生存恐怖游戏',</span><br><span class=\"line\">        content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>（也可以使用本地node服务）<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list', function (req, res) &#123;</span><br><span class=\"line\">    res.send(&#123;</span><br><span class=\"line\">        code: <span class=\"number\">200</span>,</span><br><span class=\"line\">        data: [&#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a1.jpg',</span><br><span class=\"line\">                title: '美丽的大海啊！',</span><br><span class=\"line\">                address: '1美丽的大海啊！',</span><br><span class=\"line\">                content: '大海啊全是水，美丽的海景让人赏心悦目！海景壁纸请欣赏！'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a2.jpg',</span><br><span class=\"line\">                title: '回不去的那叫从前',</span><br><span class=\"line\">                address: '1回不去的那叫从前',</span><br><span class=\"line\">                content: '回不去的那叫从前，到不了的才是远方；不保留的那叫青春，不完美的才是人生。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                img: 'http://localhost:9999/image/a3.jpg',</span><br><span class=\"line\">                title: '森林生存恐怖游戏',</span><br><span class=\"line\">                address: '1森林生存恐怖游戏',</span><br><span class=\"line\">                content: '《森林》是一款PC平台开放世界生存恐怖游戏，游戏中玩家必须建造设施，探索世界，生存下去。《森林》将打造一个活生生的，气候多变，植被动态生长凋零，地下洞穴错综复杂的森林，等待玩家探索。'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>); <span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Num3\"><a href=\"#Num3\" class=\"headerlink\" title=\"Num3\"></a>Num3</h1><p>上面的样式都是很常见的列表页，我们最终的用户交互效果这样是很不友好的，那就在里面加入下拉刷新，底部加载更多，这样才符合用户的操作习惯。</p>\n<p>主要点：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">list</span>.json配置:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"enablePullDownRefresh\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">需要捕获这两个事件：</span><br><span class=\"line\"></span><br><span class=\"line\">onReachBottom（滚动到底部事件）</span><br><span class=\"line\">onPullDownRefresh（下拉刷新事件）</span><br></pre></td></tr></table></figure></p>\n<p>本地服务：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"><span class=\"comment\">//处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\">app.get('/list/:num',function(req,res)&#123;</span><br><span class=\"line\">var num = req.params.num;<span class=\"comment\">//页码</span></span><br><span class=\"line\">var arr = [];</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=(num*<span class=\"number\">5</span><span class=\"number\">-5</span>);i&lt;(num*<span class=\"number\">5</span>);i++)&#123;</span><br><span class=\"line\">var obj = &#123;id:i+1,img:'http://localhost:9999/image/1.jpg',title:'这是第'+(i+1)+'条数据',address:'韩国，济州岛',content:'据说半个亚洲的女生都想去权志龙的咖啡厅上班。要是你也想去济州岛的蓝天白云下喝咖啡，偶遇权志龙，那么将是一件非常令人兴奋的事情！'&#125;;</span><br><span class=\"line\">arr.push(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">res.send(&#123;</span><br><span class=\"line\">code: <span class=\"number\">200</span>,</span><br><span class=\"line\">page:num,</span><br><span class=\"line\">data: arr</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">9999</span>);<span class=\"comment\">//监听端口</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/listview/listview.wxml--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;loading hidden=<span class=\"string\">\"&#123;&#123;isLoading&#125;&#125;\"</span>&gt;加载中...&lt;/loading&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;view class=<span class=\"string\">\"box\"</span>&gt;</span><br><span class=\"line\">  &lt;view wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;isRefesh&#125;&#125;\"</span>&gt;</span><br><span class=\"line\">   &lt;icon type='waiting' size='45'&gt;&lt;/icon&gt;</span><br><span class=\"line\">   &lt;text&gt;刷新中...&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">list</span>\" <span class=\"title\">wx</span>:</span><span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;list&#125;&#125;\"</span> id=<span class=\"string\">\"&#123;&#123;page&#125;&#125;\"</span>&gt;</span><br><span class=\"line\">    &lt;view class='list_img'&gt;</span><br><span class=\"line\">      &lt;image src=\"&#123;&#123;item.img&#125;&#125;\" class='avatar'&gt;&lt;/image&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;view <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">list_main</span>'&gt;</span></span><br><span class=\"line\">      &lt;view class='list_title'&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.address&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;view class='list_content'&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- listview.json --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"enablePullDownRefresh\"</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/listview/listview.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>: [],<span class=\"comment\">//列表项数据</span></span><br><span class=\"line\">    page: <span class=\"number\">1</span>,<span class=\"comment\">//页码</span></span><br><span class=\"line\">    isRefesh: <span class=\"literal\">false</span>,<span class=\"comment\">//是否刷新</span></span><br><span class=\"line\">    isLoading: <span class=\"literal\">true</span><span class=\"comment\">//正在加载</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//下拉刷新</span></span><br><span class=\"line\">  onPullDownRefresh: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    that.setData(&#123; isRefesh: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//刷新条出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/1',</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var listdata = res.data.data;</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          wx.stopPullDownRefresh;<span class=\"comment\">//停止下拉刷新效果</span></span><br><span class=\"line\">          that.setData(&#123; page: <span class=\"number\">1</span> &#125;);<span class=\"comment\">//重置页码</span></span><br><span class=\"line\">          that.setData(&#123; <span class=\"built_in\">list</span>: listdata, isRefesh: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//重新设置列表项和刷新条消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//滑到底部加载</span></span><br><span class=\"line\">  onReachBottom: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    var page = that.data.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">    var oldData = <span class=\"keyword\">this</span>.data.<span class=\"built_in\">list</span>;<span class=\"comment\">//老数据</span></span><br><span class=\"line\">    that.setData(&#123; isLoading: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//loading出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/' + page,</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var allData = [];</span><br><span class=\"line\">        var listdata = res.data.data;<span class=\"comment\">//新数据</span></span><br><span class=\"line\">        allData = oldData.concat(listdata);<span class=\"comment\">//老数据和新数据合并</span></span><br><span class=\"line\">        that.setData(&#123; <span class=\"built_in\">list</span>: allData, page: page &#125;);<span class=\"comment\">//重新设置列表项和页码</span></span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          that.setData(&#123; isLoading: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//loading消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//页码初始化</span></span><br><span class=\"line\">  onLoad: function (options) &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    that.setData(&#123; isLoading: <span class=\"literal\">false</span> &#125;);<span class=\"comment\">//loading出现</span></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: 'http://localhost:9999/list/1',</span><br><span class=\"line\">      method: 'GET',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var listdata = res.data.data;</span><br><span class=\"line\">        that.setData(&#123; <span class=\"built_in\">list</span>: listdata &#125;);</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">          that.setData(&#123; isLoading: <span class=\"literal\">true</span> &#125;);<span class=\"comment\">//loading消失</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"小程序之旅(三)","date":"2018-06-19T15:40:53.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 修改导航栏信息\n先从修改导航栏信息开始，主要修改的文件是`app.json`文件，在里面可以定义一些样式\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_2.png)\n\n# 定义底部tab导航栏\n\n可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在`app.json`文件里操作。\n\n> app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。\n\n简单说一下这个配置各个项的含义:\n\n1、`pages字段` —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。\n2、`window字段` —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。\n其他配置项细节可以参考文档 [小程序的配置 app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) 。\n\n以下是一个包含了所有配置选项的 app.json ：\n[参考地址](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)\n```h\n{\n  \"pages\": [\n    \"pages/index/index\",\n    \"pages/logs/index\"\n  ],\n  \"window\": {\n    \"navigationBarTitleText\": \"Demo\"\n  },\n  \"tabBar\": {\n    \"list\": [{\n      \"pagePath\": \"pages/index/index\",\n      \"text\": \"首页\"\n    }, {\n      \"pagePath\": \"pages/logs/logs\",\n      \"text\": \"日志\"\n    }]\n  },\n  \"networkTimeout\": {\n    \"request\": 10000,\n    \"downloadFile\": 10000\n  },\n  \"debug\": true\n}\n```\n\napp.json 配置项列表\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_3.png)\n\ntabBar的配置参数可以在`list`里面配置，包括icon的设置，可以去[iconfont]()去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_4.png)\n\niconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_5.png)\n\n\n# 抽离公共部分\n\n把头像和昵称抽离成公共部分共用，小程序提供了`import`和`include`两种方式，微信头像和昵称，显然是异步获取的。\n为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到`app.wxss`全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。\n\n把`index.wxss`里的用户样式移动到`app.wxss`下：\n```h\n/**index.wxss用户信息样式**/\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 128rpx;\n  height: 128rpx;\n  margin: 20rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\n\n.usermotto {\n  margin-top: 200px;\n}\n```\n\n接下来新建`common`目录，新建文件`header.wxml`\n\n```h\n<!-- 在这个文件里把index页面的用户信息移动过来 -->\n\n<view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n</view>\n\n```\n\n在 `index.wxml`合适位置引入文件：\n\n```h\n<include src=\"../common/header.wxml\"/>\n\n```\n在 `index.js`合适位置缓存本地：\n\n```h\n// 缓存本地\nwx.setStorageSync('userData', this.data.userInfo)\n\n```\n\n\n在需要展示的页面就可以引入公共模块，和数据具体配置：\n\n```h\n <include src=\"../common/header.wxml\"/>\n\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_6.png)\n\n同时小程序还提供了`template`模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。\n接下来可以试着加入一个`footer.wxml`公共组件文件吧。\n\nfooter.wxml：\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_7.png)\n\n需要引入的文件配置：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_8.png)\n\n注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。\n\n# 生命周期\n\n`app.js`文件,就是个`App()`函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有`var app = getApp()`这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。\n再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。\n这个object，除了`getUserInfo`这个自定义函数，还有`onLaunch`是内置的函数，那么onLaunch是啥意思呢？\n先来说下生命周期的概念。\n生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：`初始化，渲染前，渲染中，渲染后，销毁`等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。\n以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_9.png)\n\n> 1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。\n> 2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。\n> 3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。\n> 4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。\n> 5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。\n> 6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。\n> 7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。\n\n正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。\n小程序生命周期，分为注册App和注册Page两段。\n其实也简单。App可以比作浏览器，Page可以比作网页。\n那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已.\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_10.png)\n\nonShow和onHide，也就是前台和后台的定义。\n 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。\n当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。\n而对于onError和其他选项，一般不经常使用。\n\n\nPage（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_11.png)\n这里也有`onShow`和`onHide`，那么这俩哥们又是啥时候触发呢？\nonShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。\n啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？\n\n> 页面跳转分两种情况：\n   > 1、wx.navigateTo保留当前页面，跳转\n   > 2、wx.redirectTo关闭当前页面，跳转\n\n\n这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。\n\n```h\n<button open-type=\"getUserInfo\" bindtap=\"keepJump\">保留当前页面并跳转 </button>\n<button open-type=\"getUserInfo\" bindtap=\"closeJump\">关闭当前页面并跳转 </button>\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_12.png)\n","source":"_posts/小程序之旅-三.md","raw":"---\ntitle: 小程序之旅(三)\ndate: 2018-06-19 23:40:53\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 修改导航栏信息\n先从修改导航栏信息开始，主要修改的文件是`app.json`文件，在里面可以定义一些样式\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_2.png)\n\n# 定义底部tab导航栏\n\n可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在`app.json`文件里操作。\n\n> app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。\n\n简单说一下这个配置各个项的含义:\n\n1、`pages字段` —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。\n2、`window字段` —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。\n其他配置项细节可以参考文档 [小程序的配置 app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) 。\n\n以下是一个包含了所有配置选项的 app.json ：\n[参考地址](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)\n```h\n{\n  \"pages\": [\n    \"pages/index/index\",\n    \"pages/logs/index\"\n  ],\n  \"window\": {\n    \"navigationBarTitleText\": \"Demo\"\n  },\n  \"tabBar\": {\n    \"list\": [{\n      \"pagePath\": \"pages/index/index\",\n      \"text\": \"首页\"\n    }, {\n      \"pagePath\": \"pages/logs/logs\",\n      \"text\": \"日志\"\n    }]\n  },\n  \"networkTimeout\": {\n    \"request\": 10000,\n    \"downloadFile\": 10000\n  },\n  \"debug\": true\n}\n```\n\napp.json 配置项列表\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_3.png)\n\ntabBar的配置参数可以在`list`里面配置，包括icon的设置，可以去[iconfont]()去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_4.png)\n\niconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_5.png)\n\n\n# 抽离公共部分\n\n把头像和昵称抽离成公共部分共用，小程序提供了`import`和`include`两种方式，微信头像和昵称，显然是异步获取的。\n为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到`app.wxss`全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。\n\n把`index.wxss`里的用户样式移动到`app.wxss`下：\n```h\n/**index.wxss用户信息样式**/\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 128rpx;\n  height: 128rpx;\n  margin: 20rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\n\n.usermotto {\n  margin-top: 200px;\n}\n```\n\n接下来新建`common`目录，新建文件`header.wxml`\n\n```h\n<!-- 在这个文件里把index页面的用户信息移动过来 -->\n\n<view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n</view>\n\n```\n\n在 `index.wxml`合适位置引入文件：\n\n```h\n<include src=\"../common/header.wxml\"/>\n\n```\n在 `index.js`合适位置缓存本地：\n\n```h\n// 缓存本地\nwx.setStorageSync('userData', this.data.userInfo)\n\n```\n\n\n在需要展示的页面就可以引入公共模块，和数据具体配置：\n\n```h\n <include src=\"../common/header.wxml\"/>\n\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_6.png)\n\n同时小程序还提供了`template`模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。\n接下来可以试着加入一个`footer.wxml`公共组件文件吧。\n\nfooter.wxml：\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_7.png)\n\n需要引入的文件配置：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_8.png)\n\n注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。\n\n# 生命周期\n\n`app.js`文件,就是个`App()`函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有`var app = getApp()`这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。\n再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。\n这个object，除了`getUserInfo`这个自定义函数，还有`onLaunch`是内置的函数，那么onLaunch是啥意思呢？\n先来说下生命周期的概念。\n生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：`初始化，渲染前，渲染中，渲染后，销毁`等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。\n以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_9.png)\n\n> 1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。\n> 2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。\n> 3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。\n> 4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。\n> 5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。\n> 6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。\n> 7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。\n\n正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。\n小程序生命周期，分为注册App和注册Page两段。\n其实也简单。App可以比作浏览器，Page可以比作网页。\n那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已.\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_10.png)\n\nonShow和onHide，也就是前台和后台的定义。\n 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。\n当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。\n而对于onError和其他选项，一般不经常使用。\n\n\nPage（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_11.png)\n这里也有`onShow`和`onHide`，那么这俩哥们又是啥时候触发呢？\nonShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。\n啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？\n\n> 页面跳转分两种情况：\n   > 1、wx.navigateTo保留当前页面，跳转\n   > 2、wx.redirectTo关闭当前页面，跳转\n\n\n这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。\n\n```h\n<button open-type=\"getUserInfo\" bindtap=\"keepJump\">保留当前页面并跳转 </button>\n<button open-type=\"getUserInfo\" bindtap=\"closeJump\">关闭当前页面并跳转 </button>\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_12.png)\n","slug":"小程序之旅-三","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnew003dkt8980f2ag28","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<h1 id=\"修改导航栏信息\"><a href=\"#修改导航栏信息\" class=\"headerlink\" title=\"修改导航栏信息\"></a>修改导航栏信息</h1><p>先从修改导航栏信息开始，主要修改的文件是<code>app.json</code>文件，在里面可以定义一些样式</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_2.png\" alt=\"微信小程序\"></p>\n<h1 id=\"定义底部tab导航栏\"><a href=\"#定义底部tab导航栏\" class=\"headerlink\" title=\"定义底部tab导航栏\"></a>定义底部tab导航栏</h1><p>可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在<code>app.json</code>文件里操作。</p>\n<blockquote>\n<p>app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。</p>\n</blockquote>\n<p>简单说一下这个配置各个项的含义:</p>\n<p>1、<code>pages字段</code> —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。<br>2、<code>window字段</code> —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。<br>其他配置项细节可以参考文档 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">小程序的配置 app.json</a> 。</p>\n<p>以下是一个包含了所有配置选项的 app.json ：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">参考地址</a><br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs/index\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"window\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTitleText\"</span>: <span class=\"string\">\"Demo\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tabBar\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"list\"</span>: [&#123;</span><br><span class=\"line\">      <span class=\"string\">\"pagePath\"</span>: <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"text\"</span>: <span class=\"string\">\"首页\"</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"pagePath\"</span>: <span class=\"string\">\"pages/logs/logs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"text\"</span>: <span class=\"string\">\"日志\"</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"networkTimeout\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"request\"</span>: <span class=\"number\">10000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"downloadFile\"</span>: <span class=\"number\">10000</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"debug\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>app.json 配置项列表</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_3.png\" alt=\"微信小程序\"></p>\n<p>tabBar的配置参数可以在<code>list</code>里面配置，包括icon的设置，可以去<a href=\"\">iconfont</a>去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_4.png\" alt=\"微信小程序\"></p>\n<p>iconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_5.png\" alt=\"微信小程序\"></p>\n<h1 id=\"抽离公共部分\"><a href=\"#抽离公共部分\" class=\"headerlink\" title=\"抽离公共部分\"></a>抽离公共部分</h1><p>把头像和昵称抽离成公共部分共用，小程序提供了<code>import</code>和<code>include</code>两种方式，微信头像和昵称，显然是异步获取的。<br>为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到<code>app.wxss</code>全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。</p>\n<p>把<code>index.wxss</code>里的用户样式移动到<code>app.wxss</code>下：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**index.wxss用户信息样式**/</span></span><br><span class=\"line\">.userinfo &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-avatar &#123;</span><br><span class=\"line\">  width: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  height: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  margin: <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">  border-radius: <span class=\"number\">50</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-nickname &#123;</span><br><span class=\"line\">  color: <span class=\"meta\">#aaa;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.usermotto &#123;</span><br><span class=\"line\">  margin-top: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来新建<code>common</code>目录，新建文件<code>header.wxml</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在这个文件里把index页面的用户信息移动过来 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">userinfo</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>在 <code>index.wxml</code>合适位置引入文件：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include src=<span class=\"string\">\"../common/header.wxml\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>在 <code>index.js</code>合适位置缓存本地：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存本地</span></span><br><span class=\"line\">wx.setStorageSync('userData', this.data.userInfo)</span><br></pre></td></tr></table></figure>\n<p>在需要展示的页面就可以引入公共模块，和数据具体配置：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include src=<span class=\"string\">\"../common/header.wxml\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_6.png\" alt=\"微信小程序\"></p>\n<p>同时小程序还提供了<code>template</code>模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。<br>接下来可以试着加入一个<code>footer.wxml</code>公共组件文件吧。</p>\n<p>footer.wxml：<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_7.png\" alt=\"微信小程序\"></p>\n<p>需要引入的文件配置：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_8.png\" alt=\"微信小程序\"></p>\n<p>注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。</p>\n<h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><p><code>app.js</code>文件,就是个<code>App()</code>函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有<code>var app = getApp()</code>这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。<br>再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。<br>这个object，除了<code>getUserInfo</code>这个自定义函数，还有<code>onLaunch</code>是内置的函数，那么onLaunch是啥意思呢？<br>先来说下生命周期的概念。<br>生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：<code>初始化，渲染前，渲染中，渲染后，销毁</code>等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。<br>以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_9.png\" alt=\"微信小程序\"></p>\n<blockquote>\n<p>1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。<br>2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。<br>3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。<br>4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。<br>5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。<br>6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。<br>7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。</p>\n</blockquote>\n<p>正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。<br>小程序生命周期，分为注册App和注册Page两段。<br>其实也简单。App可以比作浏览器，Page可以比作网页。<br>那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已.</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_10.png\" alt=\"微信小程序\"></p>\n<p>onShow和onHide，也就是前台和后台的定义。<br> 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。<br>当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。<br>而对于onError和其他选项，一般不经常使用。</p>\n<p>Page（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_11.png\" alt=\"微信小程序\"><br>这里也有<code>onShow</code>和<code>onHide</code>，那么这俩哥们又是啥时候触发呢？<br>onShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。<br>啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？</p>\n<blockquote>\n<p>页面跳转分两种情况：<br>1、wx.navigateTo保留当前页面，跳转<br>2、wx.redirectTo关闭当前页面，跳转</p>\n</blockquote>\n<p>这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getUserInfo\"</span> bindtap=<span class=\"string\">\"keepJump\"</span>&gt;保留当前页面并跳转 &lt;/button&gt;</span><br><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getUserInfo\"</span> bindtap=<span class=\"string\">\"closeJump\"</span>&gt;关闭当前页面并跳转 &lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_12.png\" alt=\"微信小程序\"></p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序生命周期和模板的引用之旅。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<h1 id=\"修改导航栏信息\"><a href=\"#修改导航栏信息\" class=\"headerlink\" title=\"修改导航栏信息\"></a>修改导航栏信息</h1><p>先从修改导航栏信息开始，主要修改的文件是<code>app.json</code>文件，在里面可以定义一些样式</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_2.png\" alt=\"微信小程序\"></p>\n<h1 id=\"定义底部tab导航栏\"><a href=\"#定义底部tab导航栏\" class=\"headerlink\" title=\"定义底部tab导航栏\"></a>定义底部tab导航栏</h1><p>可以根据自己需求自定义底部导航栏的样式和icon，这些操作同样是在<code>app.json</code>文件里操作。</p>\n<blockquote>\n<p>app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。</p>\n</blockquote>\n<p>简单说一下这个配置各个项的含义:</p>\n<p>1、<code>pages字段</code> —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。<br>2、<code>window字段</code> —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。<br>其他配置项细节可以参考文档 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">小程序的配置 app.json</a> 。</p>\n<p>以下是一个包含了所有配置选项的 app.json ：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">参考地址</a><br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs/index\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"window\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTitleText\"</span>: <span class=\"string\">\"Demo\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tabBar\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"list\"</span>: [&#123;</span><br><span class=\"line\">      <span class=\"string\">\"pagePath\"</span>: <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"text\"</span>: <span class=\"string\">\"首页\"</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"pagePath\"</span>: <span class=\"string\">\"pages/logs/logs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"text\"</span>: <span class=\"string\">\"日志\"</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"networkTimeout\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"request\"</span>: <span class=\"number\">10000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"downloadFile\"</span>: <span class=\"number\">10000</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"debug\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>app.json 配置项列表</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_3.png\" alt=\"微信小程序\"></p>\n<p>tabBar的配置参数可以在<code>list</code>里面配置，包括icon的设置，可以去<a href=\"\">iconfont</a>去下载，把下载好的icon图片放到images文件夹下，正确引用图片就好了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_4.png\" alt=\"微信小程序\"></p>\n<p>iconPath与selectedIconPath就可以实现选中与没有选中效果。具体配置参考下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_5.png\" alt=\"微信小程序\"></p>\n<h1 id=\"抽离公共部分\"><a href=\"#抽离公共部分\" class=\"headerlink\" title=\"抽离公共部分\"></a>抽离公共部分</h1><p>把头像和昵称抽离成公共部分共用，小程序提供了<code>import</code>和<code>include</code>两种方式，微信头像和昵称，显然是异步获取的。<br>为避免重复请求数据，可以利用缓存，在首页获取一次数据后，缓存到本地保存起来，在其他页面直接调取缓存的数据就可以了。为避免每个页面都写一遍样式，可以把展示头像和昵称相关的样式，统一写到<code>app.wxss</code>全局样式表文件中。退出的时候，销毁本地存储，保证数据的准确性。</p>\n<p>把<code>index.wxss</code>里的用户样式移动到<code>app.wxss</code>下：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**index.wxss用户信息样式**/</span></span><br><span class=\"line\">.userinfo &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-avatar &#123;</span><br><span class=\"line\">  width: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  height: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  margin: <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">  border-radius: <span class=\"number\">50</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-nickname &#123;</span><br><span class=\"line\">  color: <span class=\"meta\">#aaa;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.usermotto &#123;</span><br><span class=\"line\">  margin-top: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来新建<code>common</code>目录，新建文件<code>header.wxml</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在这个文件里把index页面的用户信息移动过来 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">userinfo</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p>在 <code>index.wxml</code>合适位置引入文件：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include src=<span class=\"string\">\"../common/header.wxml\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>在 <code>index.js</code>合适位置缓存本地：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存本地</span></span><br><span class=\"line\">wx.setStorageSync('userData', this.data.userInfo)</span><br></pre></td></tr></table></figure>\n<p>在需要展示的页面就可以引入公共模块，和数据具体配置：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include src=<span class=\"string\">\"../common/header.wxml\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_6.png\" alt=\"微信小程序\"></p>\n<p>同时小程序还提供了<code>template</code>模板组件，可以在模板里自定义代码片段，在不同的需要的地方调用。<br>接下来可以试着加入一个<code>footer.wxml</code>公共组件文件吧。</p>\n<p>footer.wxml：<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_7.png\" alt=\"微信小程序\"></p>\n<p>需要引入的文件配置：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_8.png\" alt=\"微信小程序\"></p>\n<p>注意name 与 is 的对应关系，也可以自己定义出多个name模板适应不同的环境。</p>\n<h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><p><code>app.js</code>文件,就是个<code>App()</code>函数,App()函数的意思，其实就是注册一个小程序。看到index.js文件中，会有<code>var app = getApp()</code>这样的代码出现，这是获取小程序实例的意思。其实这是配套的。只有先注册了小程序，后面才能获得小程序的实例。<br>再来看下App()的使用方法。就是接收了一个object参数而已。这个对象参数你可以把它拆出来，单独用个变量命名。<br>这个object，除了<code>getUserInfo</code>这个自定义函数，还有<code>onLaunch</code>是内置的函数，那么onLaunch是啥意思呢？<br>先来说下生命周期的概念。<br>生命周期，就是程序从创建到销毁的全过程。比如react的生命周期，大体分为：<code>初始化，渲染前，渲染中，渲染后，销毁</code>等情景，这个主要是考虑web网页的特性划分的；而小程序本身并不是网页，它的生命周期，更像是app。<br>以安卓的Activity(可以理解为视图)为例,app的生命周期是下图示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_9.png\" alt=\"微信小程序\"></p>\n<blockquote>\n<p>1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。<br>2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。<br>3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。<br>4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。<br>5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。<br>6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。<br>7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。</p>\n</blockquote>\n<p>正常一个app的生命周期还是十分繁琐的，有很多的使用场景都得考虑到。<br>小程序生命周期，分为注册App和注册Page两段。<br>其实也简单。App可以比作浏览器，Page可以比作网页。<br>那么App的生命周期呢，就是你双击浏览器打开的过程，也就是：创建、展示、隐藏，区区三个而已.</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_10.png\" alt=\"微信小程序\"></p>\n<p>onShow和onHide，也就是前台和后台的定义。<br> 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台(onHide)；当再次进入微信或再次打开小程序，又会从后台进入前台(onShow)。<br>当onShow的动作执行完毕后，紧接着就进入Page的生命周期了（onLoad）。<br>而对于onError和其他选项，一般不经常使用。</p>\n<p>Page（网页）的生命周期。Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_11.png\" alt=\"微信小程序\"><br>这里也有<code>onShow</code>和<code>onHide</code>，那么这俩哥们又是啥时候触发呢？<br>onShow是页面加载（onLoad）后马上触发的，也就展示页面的意思。但是，展示并不代表渲染完成，所以还有个监听渲染是否完成（onReady）的过程；当跳到另外一个页面后，就触发了onHide隐藏页面，最后当页面关闭时，就触发了onUnload事件。<br>啥叫页面关闭呢？小程序不是网页啊，也没关闭按钮，怎么关闭呢？</p>\n<blockquote>\n<p>页面跳转分两种情况：<br>1、wx.navigateTo保留当前页面，跳转<br>2、wx.redirectTo关闭当前页面，跳转</p>\n</blockquote>\n<p>这二者的区别就是是否能够返回上一个页面。如果是关闭了当前页面跳转，就无法返回了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getUserInfo\"</span> bindtap=<span class=\"string\">\"keepJump\"</span>&gt;保留当前页面并跳转 &lt;/button&gt;</span><br><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getUserInfo\"</span> bindtap=<span class=\"string\">\"closeJump\"</span>&gt;关闭当前页面并跳转 &lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_12.png\" alt=\"微信小程序\"></p>"},{"title":"小程序之旅(二)","date":"2018-06-14T17:00:05.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于`form`组件、本地存储和页面的跳转和回退的小程序之旅。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n介绍下 `form`组件、本地存储和页面的跳转和回退\n\n# 表单组件和数据存储功能\n\n新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能\n\n在`pages`下新增一个`login`文件夹。\n\n> 操作步骤为：pages文件夹右键->新建->目录，\n\n\n然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。\n\n配置代码：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2.png)\n\nlogin.wxml:\n```h\n<!--login.wxml-->\n<form bindsubmit=\"formSubmit\">\n  <view class=\"container\">\n\n    <input name=\"userName\" type=\"text\" class=\"myinput\" placeholder=\"请输入用户名\" value=\"{{userName}}\"/>\n\n    <input name=\"userPass\" type=\"text\" class=\"myinput\" password placeholder=\"请输入密码\" value=\"{{userPass}}\"/>\n\n    <button formType=\"submit\">标记我</button>\n </view>\n</form>\n```\n\n\nlogin.js:\n\n```h\n//login.js\nPage({\n  data: {\n    userName: '',//用户名\n    userPass: '',//密码\n  },\n  //表单提交函数，每个input需要有name，否则获取不到值。\n  formSubmit: function (e) {\n    console.log(e.detail.value);//返回格式：Object {userName: \"hello\", userPass: \"123\"}\n    var obj = e.detail.value;\n    if (obj.userName && obj.userPass) {\n      //本地存储用户名和密码\n      wx.setStorageSync('userName', obj.userName);\n      wx.setStorageSync('userPass', obj.userPass);\n    }\n  },\n  //加载事件，如果判断有缓存信息，就读取并显示在input里。\n  onLoad: function () {\n    var name = wx.getStorageSync('userName');\n    var password = wx.getStorageSync('userPass');\n    if (name) {\n      this.setData({ userName: name });\n    }\n    if (password) {\n      this.setData({ userPass: password });\n    }\n  }\n})\n```\n\nlogin.wxsss:\n\n```h\n.myinput{\n  border:1px solid cyan;\n  border-radius: 40px;\n  margin-bottom: 10px;\n}\n```\n\n可以在首页创建一个按钮，然后利用`wx.navigateTo`组件跳转一下即可，直接看一下效果：\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m1.gif)\n\n\n小程序的表单，默认是异步提交的。它在`form`上全局绑定一个事件，然后根据`name`去寻找表单元素的值。所以每个`input`输入框一定要跟上`name`，否则找不到。这里只是input，至于其他的表单元素可以再去看看。\n还有就是有关数据存储，要用小程序提供的api：\n> wx.setStorage(OBJ)：异步存储内容。\n> wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。\n> wx.getStorage(OBJ)：异步获取内容。\n> wx.getStorageSync(key)：同步获取内容。\n\n一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。\n而异步存储的话，要注意其`OBJ参数`的书写格式，它包括：\n\n> key，data，success回调函数，fail回调函数等参数的对象\n\n\n小程序的本地数据存储也有大小限制：`不能超过10MB`\n\n# 异步存储登录页的用户名和密码\n\n在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。\n\nlogin.js：\n\n```h\n//login.js\nPage({\n  data: {\n    userName: null,\n    userPass: null\n  },\n  //表单提交函数，每个input需要有name，否则获取不到值。\n  formSubmit: function (e) {\n    console.log(e.detail.value);//返回格式：Object {userName: \"hello\", userPass: \"123\"}\n    var obj = e.detail.value;\n    if (obj.userName && obj.userPass) {\n      //异步存储\n      wx.setStorage({\n        key: 'userInfo',\n        data: obj,\n        success: function (res) {\n          // success\n          wx.navigateBack({\n            delta: 1, // 回退前 delta(默认为1) 页面\n          });\n        },\n        fail: function () {\n          // fail\n          console.log('error');\n        },\n        complete: function () {\n          // complete\n          console.log('complete');\n        }\n      })\n\n    }\n\n  },\n\n  //加载事件，如果判断有缓存信息，就读取并显示在input里。\n  onLoad: function () {\n    var that = this;\n    wx.getStorage({\n      key: 'userInfo',\n      success: function (res) {\n        // success\n        that.setData({ userName: res.data.userName });\n        that.setData({ userPass: res.data.userPass });\n      },\n      fail: function () {\n        // fail\n        console.log('error');\n      },\n      complete: function () {\n        // complete\n        console.log('complete');\n      }\n    })\n\n  }\n})\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m2.gif)\n\n\n还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api：\n> wx.removeStorage(OBJ)：异步移除某条数据。\n> wx.removeStorageSync(key)：同步移除某条数据。\n> wx.clearStorage()：异步清除所有数据。\n> wx.clearStorageSync()：同步清除所有数据。\n\n\n在之前的页面里加入一个清除本地缓存数据的一个按钮\n\n\nindex.js:\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: {\n    motto: 'Hello World',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function () {\n    wx.navigateTo({\n      url: '../logs/logs'\n    })\n  },\n  //页面跳转事件处理函数\n  bindViewLogin: function () {\n    wx.navigateTo({\n      url: '../login/login'\n    })\n  },\n  clearData: function () {\n    //清除所有数据\n    wx.clearStorageSync();\n  },\n  onLoad: function () {\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) {\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_1.png)\n\n# 总结 \n以上就是表单和本地数据存储的一些练习。","source":"_posts/小程序之旅-二.md","raw":"---\ntitle: 小程序之旅(二)\ndate: 2018-06-15 01:00:05\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于`form`组件、本地存储和页面的跳转和回退的小程序之旅。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n介绍下 `form`组件、本地存储和页面的跳转和回退\n\n# 表单组件和数据存储功能\n\n新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能\n\n在`pages`下新增一个`login`文件夹。\n\n> 操作步骤为：pages文件夹右键->新建->目录，\n\n\n然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。\n\n配置代码：\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2.png)\n\nlogin.wxml:\n```h\n<!--login.wxml-->\n<form bindsubmit=\"formSubmit\">\n  <view class=\"container\">\n\n    <input name=\"userName\" type=\"text\" class=\"myinput\" placeholder=\"请输入用户名\" value=\"{{userName}}\"/>\n\n    <input name=\"userPass\" type=\"text\" class=\"myinput\" password placeholder=\"请输入密码\" value=\"{{userPass}}\"/>\n\n    <button formType=\"submit\">标记我</button>\n </view>\n</form>\n```\n\n\nlogin.js:\n\n```h\n//login.js\nPage({\n  data: {\n    userName: '',//用户名\n    userPass: '',//密码\n  },\n  //表单提交函数，每个input需要有name，否则获取不到值。\n  formSubmit: function (e) {\n    console.log(e.detail.value);//返回格式：Object {userName: \"hello\", userPass: \"123\"}\n    var obj = e.detail.value;\n    if (obj.userName && obj.userPass) {\n      //本地存储用户名和密码\n      wx.setStorageSync('userName', obj.userName);\n      wx.setStorageSync('userPass', obj.userPass);\n    }\n  },\n  //加载事件，如果判断有缓存信息，就读取并显示在input里。\n  onLoad: function () {\n    var name = wx.getStorageSync('userName');\n    var password = wx.getStorageSync('userPass');\n    if (name) {\n      this.setData({ userName: name });\n    }\n    if (password) {\n      this.setData({ userPass: password });\n    }\n  }\n})\n```\n\nlogin.wxsss:\n\n```h\n.myinput{\n  border:1px solid cyan;\n  border-radius: 40px;\n  margin-bottom: 10px;\n}\n```\n\n可以在首页创建一个按钮，然后利用`wx.navigateTo`组件跳转一下即可，直接看一下效果：\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m1.gif)\n\n\n小程序的表单，默认是异步提交的。它在`form`上全局绑定一个事件，然后根据`name`去寻找表单元素的值。所以每个`input`输入框一定要跟上`name`，否则找不到。这里只是input，至于其他的表单元素可以再去看看。\n还有就是有关数据存储，要用小程序提供的api：\n> wx.setStorage(OBJ)：异步存储内容。\n> wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。\n> wx.getStorage(OBJ)：异步获取内容。\n> wx.getStorageSync(key)：同步获取内容。\n\n一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。\n而异步存储的话，要注意其`OBJ参数`的书写格式，它包括：\n\n> key，data，success回调函数，fail回调函数等参数的对象\n\n\n小程序的本地数据存储也有大小限制：`不能超过10MB`\n\n# 异步存储登录页的用户名和密码\n\n在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。\n\nlogin.js：\n\n```h\n//login.js\nPage({\n  data: {\n    userName: null,\n    userPass: null\n  },\n  //表单提交函数，每个input需要有name，否则获取不到值。\n  formSubmit: function (e) {\n    console.log(e.detail.value);//返回格式：Object {userName: \"hello\", userPass: \"123\"}\n    var obj = e.detail.value;\n    if (obj.userName && obj.userPass) {\n      //异步存储\n      wx.setStorage({\n        key: 'userInfo',\n        data: obj,\n        success: function (res) {\n          // success\n          wx.navigateBack({\n            delta: 1, // 回退前 delta(默认为1) 页面\n          });\n        },\n        fail: function () {\n          // fail\n          console.log('error');\n        },\n        complete: function () {\n          // complete\n          console.log('complete');\n        }\n      })\n\n    }\n\n  },\n\n  //加载事件，如果判断有缓存信息，就读取并显示在input里。\n  onLoad: function () {\n    var that = this;\n    wx.getStorage({\n      key: 'userInfo',\n      success: function (res) {\n        // success\n        that.setData({ userName: res.data.userName });\n        that.setData({ userPass: res.data.userPass });\n      },\n      fail: function () {\n        // fail\n        console.log('error');\n      },\n      complete: function () {\n        // complete\n        console.log('complete');\n      }\n    })\n\n  }\n})\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m2.gif)\n\n\n还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api：\n> wx.removeStorage(OBJ)：异步移除某条数据。\n> wx.removeStorageSync(key)：同步移除某条数据。\n> wx.clearStorage()：异步清除所有数据。\n> wx.clearStorageSync()：同步清除所有数据。\n\n\n在之前的页面里加入一个清除本地缓存数据的一个按钮\n\n\nindex.js:\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: {\n    motto: 'Hello World',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function () {\n    wx.navigateTo({\n      url: '../logs/logs'\n    })\n  },\n  //页面跳转事件处理函数\n  bindViewLogin: function () {\n    wx.navigateTo({\n      url: '../login/login'\n    })\n  },\n  clearData: function () {\n    //清除所有数据\n    wx.clearStorageSync();\n  },\n  onLoad: function () {\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) {\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n```\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_1.png)\n\n# 总结 \n以上就是表单和本地数据存储的一些练习。","slug":"小程序之旅-二","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnex003gkt89rgoliccq","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于<code>form</code>组件、本地存储和页面的跳转和回退的小程序之旅。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<p>介绍下 <code>form</code>组件、本地存储和页面的跳转和回退</p>\n<h1 id=\"表单组件和数据存储功能\"><a href=\"#表单组件和数据存储功能\" class=\"headerlink\" title=\"表单组件和数据存储功能\"></a>表单组件和数据存储功能</h1><p>新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能</p>\n<p>在<code>pages</code>下新增一个<code>login</code>文件夹。</p>\n<blockquote>\n<p>操作步骤为：pages文件夹右键-&gt;新建-&gt;目录，</p>\n</blockquote>\n<p>然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。</p>\n<p>配置代码：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2.png\" alt=\"微信小程序\"></p>\n<p>login.wxml:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--login.wxml--&gt;</span><br><span class=\"line\">&lt;form bindsubmit=<span class=\"string\">\"formSubmit\"</span>&gt;</span><br><span class=\"line\">  &lt;view class=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input name=<span class=\"string\">\"userName\"</span> type=<span class=\"string\">\"text\"</span> class=<span class=\"string\">\"myinput\"</span> placeholder=<span class=\"string\">\"请输入用户名\"</span> value=<span class=\"string\">\"&#123;&#123;userName&#125;&#125;\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input name=<span class=\"string\">\"userPass\"</span> type=<span class=\"string\">\"text\"</span> class=<span class=\"string\">\"myinput\"</span> password placeholder=<span class=\"string\">\"请输入密码\"</span> value=<span class=\"string\">\"&#123;&#123;userPass&#125;&#125;\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;button formType=<span class=\"string\">\"submit\"</span>&gt;标记我&lt;/button&gt;</span><br><span class=\"line\"> &lt;/view&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>\n<p>login.js:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//login.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    userName: '',//用户名</span><br><span class=\"line\">    userPass: '',//密码</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class=\"line\">  formSubmit: function (e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e.detail.value);<span class=\"comment\">//返回格式：Object &#123;userName: \"hello\", userPass: \"123\"&#125;</span></span><br><span class=\"line\">    var obj = e.detail.value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//本地存储用户名和密码</span></span><br><span class=\"line\">      wx.setStorageSync('userName', obj.userName);</span><br><span class=\"line\">      wx.setStorageSync('userPass', obj.userPass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    var name = wx.getStorageSync('userName');</span><br><span class=\"line\">    var password = wx.getStorageSync('userPass');</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123; userName: name &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123; userPass: password &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>login.wxsss:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.myinput&#123;</span><br><span class=\"line\">  border:<span class=\"number\">1</span>px solid cyan;</span><br><span class=\"line\">  border-radius: <span class=\"number\">40</span>px;</span><br><span class=\"line\">  margin-bottom: <span class=\"number\">10</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以在首页创建一个按钮，然后利用<code>wx.navigateTo</code>组件跳转一下即可，直接看一下效果：<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m1.gif\" alt=\"微信小程序\"></p>\n<p>小程序的表单，默认是异步提交的。它在<code>form</code>上全局绑定一个事件，然后根据<code>name</code>去寻找表单元素的值。所以每个<code>input</code>输入框一定要跟上<code>name</code>，否则找不到。这里只是input，至于其他的表单元素可以再去看看。<br>还有就是有关数据存储，要用小程序提供的api：</p>\n<blockquote>\n<p>wx.setStorage(OBJ)：异步存储内容。<br>wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。<br>wx.getStorage(OBJ)：异步获取内容。<br>wx.getStorageSync(key)：同步获取内容。</p>\n</blockquote>\n<p>一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。<br>而异步存储的话，要注意其<code>OBJ参数</code>的书写格式，它包括：</p>\n<blockquote>\n<p>key，data，success回调函数，fail回调函数等参数的对象</p>\n</blockquote>\n<p>小程序的本地数据存储也有大小限制：<code>不能超过10MB</code></p>\n<h1 id=\"异步存储登录页的用户名和密码\"><a href=\"#异步存储登录页的用户名和密码\" class=\"headerlink\" title=\"异步存储登录页的用户名和密码\"></a>异步存储登录页的用户名和密码</h1><p>在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。</p>\n<p>login.js：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//login.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    userName: null,</span><br><span class=\"line\">    userPass: null</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class=\"line\">  formSubmit: function (e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e.detail.value);<span class=\"comment\">//返回格式：Object &#123;userName: \"hello\", userPass: \"123\"&#125;</span></span><br><span class=\"line\">    var obj = e.detail.value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//异步存储</span></span><br><span class=\"line\">      wx.setStorage(&#123;</span><br><span class=\"line\">        key: 'userInfo',</span><br><span class=\"line\">        data: obj,</span><br><span class=\"line\">        success: function (res) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// success</span></span><br><span class=\"line\">          wx.navigateBack(&#123;</span><br><span class=\"line\">            delta: <span class=\"number\">1</span>, <span class=\"comment\">// 回退前 delta(默认为1) 页面</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail: function () &#123;</span><br><span class=\"line\">          <span class=\"comment\">// fail</span></span><br><span class=\"line\">          console.log('error');</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        complete: function () &#123;</span><br><span class=\"line\">          <span class=\"comment\">// complete</span></span><br><span class=\"line\">          console.log('complete');</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.getStorage(&#123;</span><br><span class=\"line\">      key: 'userInfo',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success</span></span><br><span class=\"line\">        that.setData(&#123; userName: res.data.userName &#125;);</span><br><span class=\"line\">        that.setData(&#123; userPass: res.data.userPass &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail: function () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// fail</span></span><br><span class=\"line\">        console.log('error');</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      complete: function () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// complete</span></span><br><span class=\"line\">        console.log('complete');</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m2.gif\" alt=\"微信小程序\"></p>\n<p>还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api：</p>\n<blockquote>\n<p>wx.removeStorage(OBJ)：异步移除某条数据。<br>wx.removeStorageSync(key)：同步移除某条数据。<br>wx.clearStorage()：异步清除所有数据。<br>wx.clearStorageSync()：同步清除所有数据。</p>\n</blockquote>\n<p>在之前的页面里加入一个清除本地缓存数据的一个按钮</p>\n<p>index.js:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    motto: 'Hello World',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function () &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//页面跳转事件处理函数</span></span><br><span class=\"line\">  bindViewLogin: function () &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../login/login'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  clearData: function () &#123;</span><br><span class=\"line\">    <span class=\"comment\">//清除所有数据</span></span><br><span class=\"line\">    wx.clearStorageSync();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_1.png\" alt=\"微信小程序\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>以上就是表单和本地数据存储的一些练习。</p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于<code>form</code>组件、本地存储和页面的跳转和回退的小程序之旅。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<p>介绍下 <code>form</code>组件、本地存储和页面的跳转和回退</p>\n<h1 id=\"表单组件和数据存储功能\"><a href=\"#表单组件和数据存储功能\" class=\"headerlink\" title=\"表单组件和数据存储功能\"></a>表单组件和数据存储功能</h1><p>新建一个登录页面，表单里面包括姓名、密码、按钮。点击按钮需保存数据。可以了解到表单组件和数据存储功能</p>\n<p>在<code>pages</code>下新增一个<code>login</code>文件夹。</p>\n<blockquote>\n<p>操作步骤为：pages文件夹右键-&gt;新建-&gt;目录，</p>\n</blockquote>\n<p>然后新建三个基本文件,在入口app.json的pages数组中，添加上新加的页面路径。</p>\n<p>配置代码：</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2.png\" alt=\"微信小程序\"></p>\n<p>login.wxml:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--login.wxml--&gt;</span><br><span class=\"line\">&lt;form bindsubmit=<span class=\"string\">\"formSubmit\"</span>&gt;</span><br><span class=\"line\">  &lt;view class=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input name=<span class=\"string\">\"userName\"</span> type=<span class=\"string\">\"text\"</span> class=<span class=\"string\">\"myinput\"</span> placeholder=<span class=\"string\">\"请输入用户名\"</span> value=<span class=\"string\">\"&#123;&#123;userName&#125;&#125;\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input name=<span class=\"string\">\"userPass\"</span> type=<span class=\"string\">\"text\"</span> class=<span class=\"string\">\"myinput\"</span> password placeholder=<span class=\"string\">\"请输入密码\"</span> value=<span class=\"string\">\"&#123;&#123;userPass&#125;&#125;\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;button formType=<span class=\"string\">\"submit\"</span>&gt;标记我&lt;/button&gt;</span><br><span class=\"line\"> &lt;/view&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>\n<p>login.js:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//login.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    userName: '',//用户名</span><br><span class=\"line\">    userPass: '',//密码</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class=\"line\">  formSubmit: function (e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e.detail.value);<span class=\"comment\">//返回格式：Object &#123;userName: \"hello\", userPass: \"123\"&#125;</span></span><br><span class=\"line\">    var obj = e.detail.value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//本地存储用户名和密码</span></span><br><span class=\"line\">      wx.setStorageSync('userName', obj.userName);</span><br><span class=\"line\">      wx.setStorageSync('userPass', obj.userPass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    var name = wx.getStorageSync('userName');</span><br><span class=\"line\">    var password = wx.getStorageSync('userPass');</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123; userName: name &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123; userPass: password &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>login.wxsss:</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.myinput&#123;</span><br><span class=\"line\">  border:<span class=\"number\">1</span>px solid cyan;</span><br><span class=\"line\">  border-radius: <span class=\"number\">40</span>px;</span><br><span class=\"line\">  margin-bottom: <span class=\"number\">10</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以在首页创建一个按钮，然后利用<code>wx.navigateTo</code>组件跳转一下即可，直接看一下效果：<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m1.gif\" alt=\"微信小程序\"></p>\n<p>小程序的表单，默认是异步提交的。它在<code>form</code>上全局绑定一个事件，然后根据<code>name</code>去寻找表单元素的值。所以每个<code>input</code>输入框一定要跟上<code>name</code>，否则找不到。这里只是input，至于其他的表单元素可以再去看看。<br>还有就是有关数据存储，要用小程序提供的api：</p>\n<blockquote>\n<p>wx.setStorage(OBJ)：异步存储内容。<br>wx.setStorageSync(key,data)：同步存储内容。data可以是string或object。<br>wx.getStorage(OBJ)：异步获取内容。<br>wx.getStorageSync(key)：同步获取内容。</p>\n</blockquote>\n<p>一般来说，同步存储的比较常用，因为不涉及到回调，比较简单。<br>而异步存储的话，要注意其<code>OBJ参数</code>的书写格式，它包括：</p>\n<blockquote>\n<p>key，data，success回调函数，fail回调函数等参数的对象</p>\n</blockquote>\n<p>小程序的本地数据存储也有大小限制：<code>不能超过10MB</code></p>\n<h1 id=\"异步存储登录页的用户名和密码\"><a href=\"#异步存储登录页的用户名和密码\" class=\"headerlink\" title=\"异步存储登录页的用户名和密码\"></a>异步存储登录页的用户名和密码</h1><p>在异步存储登录页的用户名和密码之后存储成功，返回到上一个页面，这里有异步存储和内容获取。</p>\n<p>login.js：</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//login.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    userName: null,</span><br><span class=\"line\">    userPass: null</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//表单提交函数，每个input需要有name，否则获取不到值。</span></span><br><span class=\"line\">  formSubmit: function (e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e.detail.value);<span class=\"comment\">//返回格式：Object &#123;userName: \"hello\", userPass: \"123\"&#125;</span></span><br><span class=\"line\">    var obj = e.detail.value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.userName &amp;&amp; obj.userPass) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//异步存储</span></span><br><span class=\"line\">      wx.setStorage(&#123;</span><br><span class=\"line\">        key: 'userInfo',</span><br><span class=\"line\">        data: obj,</span><br><span class=\"line\">        success: function (res) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// success</span></span><br><span class=\"line\">          wx.navigateBack(&#123;</span><br><span class=\"line\">            delta: <span class=\"number\">1</span>, <span class=\"comment\">// 回退前 delta(默认为1) 页面</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail: function () &#123;</span><br><span class=\"line\">          <span class=\"comment\">// fail</span></span><br><span class=\"line\">          console.log('error');</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        complete: function () &#123;</span><br><span class=\"line\">          <span class=\"comment\">// complete</span></span><br><span class=\"line\">          console.log('complete');</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//加载事件，如果判断有缓存信息，就读取并显示在input里。</span></span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.getStorage(&#123;</span><br><span class=\"line\">      key: 'userInfo',</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success</span></span><br><span class=\"line\">        that.setData(&#123; userName: res.data.userName &#125;);</span><br><span class=\"line\">        that.setData(&#123; userPass: res.data.userPass &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail: function () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// fail</span></span><br><span class=\"line\">        console.log('error');</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      complete: function () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// complete</span></span><br><span class=\"line\">        console.log('complete');</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_m2.gif\" alt=\"微信小程序\"></p>\n<p>还有就是对于存储的数据要怎么销毁呢？小程序同样提供了api：</p>\n<blockquote>\n<p>wx.removeStorage(OBJ)：异步移除某条数据。<br>wx.removeStorageSync(key)：同步移除某条数据。<br>wx.clearStorage()：异步清除所有数据。<br>wx.clearStorageSync()：同步清除所有数据。</p>\n</blockquote>\n<p>在之前的页面里加入一个清除本地缓存数据的一个按钮</p>\n<p>index.js:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    motto: 'Hello World',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function () &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//页面跳转事件处理函数</span></span><br><span class=\"line\">  bindViewLogin: function () &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../login/login'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  clearData: function () &#123;</span><br><span class=\"line\">    <span class=\"comment\">//清除所有数据</span></span><br><span class=\"line\">    wx.clearStorageSync();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_2_1.png\" alt=\"微信小程序\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>以上就是表单和本地数据存储的一些练习。</p>"},{"title":"小程序之旅(五)","date":"2018-07-22T15:54:08.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 前言\n数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。\n而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！\n\n那么来看个需求：\n- 做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。\n\n# 准备工作\n\n- wx.chooseImage：选择图片\n- wx.saveFile(OBJ)：将临时图片保存在本地\n- wx.setStorage(OBJ)：保存图片的路径。\n\n当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。\n好了，理顺了思路，我们看一下代码：\n\n```h\n\n// <!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" mode=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n    <button bindtap='keepImg'>保存图片</button>\n    <button bindtap='deleteImg'>删除图片</button>\n    <image src='{{imgPath}}'></image>\n  </view>\n</view>\n\n```\n\n```h\n\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: {\n    motto: 'Hello World',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo'),\n    imgPath:''\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({\n      url: '../logs/logs'\n    })\n  },\n  keepImg:function(){\n    var that = this;\n    // 浏览文件\n    wx.chooseImage({\n      count:1,\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有\n      success: function(res) {\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\n        var tempFilePaths = res.tempFilePaths;\n        console.log(tempFilePaths)\n        //将本地照片保存在小程序内\n        wx.saveFile({\n          tempFilePath: tempFilePaths[0],\n          success:function(res){\n            var savedFilePath = res.savedFilePath; // 图片成功之后存储在本地的路径\n            console.log(savedFilePath)\n\n            if (!wx.getStorageSync('storageImgPath')) { //数据存储，保存图片的路径\n              wx.setStorageSync('storageImgPath', savedFilePath)\n            }\n            that.setData({ imgPath: wx.getStorageSync('storageImgPath')})\n          }\n        })\n      },\n    })\n  },\n  deleteImg:function(){\n    wx.removeStorageSync('storageImgPath'); //从数据缓存中删除\n    var that = this;\n    wx.getSavedFileList({ //获取本地的文件列表\n      success:function(res){\n        console.log(res.errMsg);\n        var files = res.fileList;\n        if(res.fileList.length>0){\n          // 删除第一张\n          wx.removeSavedFile({\n            filePath:res.fileList[0].filePath,\n            success:function(res){\n              // 提示语\n              wx.showToast({\n                title: '删除成功',\n                icon:'success',\n                duration:2000\n              })\n            }\n          })\n        }\n      }\n    })\n  },\n  onLoad: function () {\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) {\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n\n```\n# 效果\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_05.png)\n\n","source":"_posts/小程序之旅-五.md","raw":"---\ntitle: 小程序之旅(五)\ndate: 2018-07-22 23:54:08\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 前言\n数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。\n而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！\n\n那么来看个需求：\n- 做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。\n\n# 准备工作\n\n- wx.chooseImage：选择图片\n- wx.saveFile(OBJ)：将临时图片保存在本地\n- wx.setStorage(OBJ)：保存图片的路径。\n\n当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。\n好了，理顺了思路，我们看一下代码：\n\n```h\n\n// <!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" mode=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n    <button bindtap='keepImg'>保存图片</button>\n    <button bindtap='deleteImg'>删除图片</button>\n    <image src='{{imgPath}}'></image>\n  </view>\n</view>\n\n```\n\n```h\n\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: {\n    motto: 'Hello World',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo'),\n    imgPath:''\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({\n      url: '../logs/logs'\n    })\n  },\n  keepImg:function(){\n    var that = this;\n    // 浏览文件\n    wx.chooseImage({\n      count:1,\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有\n      success: function(res) {\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\n        var tempFilePaths = res.tempFilePaths;\n        console.log(tempFilePaths)\n        //将本地照片保存在小程序内\n        wx.saveFile({\n          tempFilePath: tempFilePaths[0],\n          success:function(res){\n            var savedFilePath = res.savedFilePath; // 图片成功之后存储在本地的路径\n            console.log(savedFilePath)\n\n            if (!wx.getStorageSync('storageImgPath')) { //数据存储，保存图片的路径\n              wx.setStorageSync('storageImgPath', savedFilePath)\n            }\n            that.setData({ imgPath: wx.getStorageSync('storageImgPath')})\n          }\n        })\n      },\n    })\n  },\n  deleteImg:function(){\n    wx.removeStorageSync('storageImgPath'); //从数据缓存中删除\n    var that = this;\n    wx.getSavedFileList({ //获取本地的文件列表\n      success:function(res){\n        console.log(res.errMsg);\n        var files = res.fileList;\n        if(res.fileList.length>0){\n          // 删除第一张\n          wx.removeSavedFile({\n            filePath:res.fileList[0].filePath,\n            success:function(res){\n              // 提示语\n              wx.showToast({\n                title: '删除成功',\n                icon:'success',\n                duration:2000\n              })\n            }\n          })\n        }\n      }\n    })\n  },\n  onLoad: function () {\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) {\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n\n```\n# 效果\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_05.png)\n\n","slug":"小程序之旅-五","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctney003lkt89skyuijsa","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。<br>而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！</p>\n<p>那么来看个需求：</p>\n<ul>\n<li>做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。</li>\n</ul>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li>wx.chooseImage：选择图片</li>\n<li>wx.saveFile(OBJ)：将临时图片保存在本地</li>\n<li>wx.setStorage(OBJ)：保存图片的路径。</li>\n</ul>\n<p>当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。<br>好了，理顺了思路，我们看一下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &lt;!--index.wxml--&gt;</span></span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" mode=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;button bindtap='keepImg'&gt;保存图片&lt;/button&gt;</span><br><span class=\"line\">    &lt;button bindtap='deleteImg'&gt;删除图片&lt;/button&gt;</span><br><span class=\"line\">    &lt;image src='&#123;&#123;imgPath&#125;&#125;'&gt;&lt;/image&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    motto: 'Hello World',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo'),</span><br><span class=\"line\">    imgPath:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  keepImg:function()&#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 浏览文件</span></span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count:<span class=\"number\">1</span>,</span><br><span class=\"line\">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class=\"line\">      sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有</span><br><span class=\"line\">      success: function(res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(tempFilePaths)</span><br><span class=\"line\">        <span class=\"comment\">//将本地照片保存在小程序内</span></span><br><span class=\"line\">        wx.saveFile(&#123;</span><br><span class=\"line\">          tempFilePath: tempFilePaths[<span class=\"number\">0</span>],</span><br><span class=\"line\">          success:function(res)&#123;</span><br><span class=\"line\">            var savedFilePath = res.savedFilePath; <span class=\"comment\">// 图片成功之后存储在本地的路径</span></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(savedFilePath)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!wx.getStorageSync('storageImgPath')) &#123; //数据存储，保存图片的路径</span><br><span class=\"line\">              wx.setStorageSync('storageImgPath', savedFilePath)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            that.setData(&#123; imgPath: wx.getStorageSync('storageImgPath')&#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  deleteImg:function()&#123;</span><br><span class=\"line\">    wx.removeStorageSync('storageImgPath'); //从数据缓存中删除</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.getSavedFileList(&#123; <span class=\"comment\">//获取本地的文件列表</span></span><br><span class=\"line\">      success:function(res)&#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(res.errMsg);</span><br><span class=\"line\">        var files = res.fileList;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.fileList.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 删除第一张</span></span><br><span class=\"line\">          wx.removeSavedFile(&#123;</span><br><span class=\"line\">            filePath:res.fileList[<span class=\"number\">0</span>].filePath,</span><br><span class=\"line\">            success:function(res)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 提示语</span></span><br><span class=\"line\">              wx.showToast(&#123;</span><br><span class=\"line\">                title: '删除成功',</span><br><span class=\"line\">                icon:'success',</span><br><span class=\"line\">                duration:<span class=\"number\">2000</span></span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_05.png\" alt=\"微信小程序\"></p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储的旅行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>数据存储是非常重要的一个功能，比如页面之间的切换，参数保存是必不可少的。html5的本地存储其实不怎么好使，因为它只支持存储字符串，对于object对象，就只能用序列化的方式来回折腾，俩字——麻烦。<br>而自从有了小程序的数据存储，写代码的效率明显上来了，这可都是咱小程序的数据存储的功劳哇！</p>\n<p>那么来看个需求：</p>\n<ul>\n<li>做一个按钮。要求点击按钮后可以浏览相册，选择一张图片，可以保存在小程序里。当下次打开小程序时，这张图片还存在。</li>\n</ul>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li>wx.chooseImage：选择图片</li>\n<li>wx.saveFile(OBJ)：将临时图片保存在本地</li>\n<li>wx.setStorage(OBJ)：保存图片的路径。</li>\n</ul>\n<p>当我们预览完一张图片并选中后，首先要将这个临时文件保存在本地，成功后会返回图片的本地保存路径了，然后我们就保存这个路径，下次进来时直接读取就行了。<br>好了，理顺了思路，我们看一下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &lt;!--index.wxml--&gt;</span></span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" mode=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;button bindtap='keepImg'&gt;保存图片&lt;/button&gt;</span><br><span class=\"line\">    &lt;button bindtap='deleteImg'&gt;删除图片&lt;/button&gt;</span><br><span class=\"line\">    &lt;image src='&#123;&#123;imgPath&#125;&#125;'&gt;&lt;/image&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    motto: 'Hello World',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo'),</span><br><span class=\"line\">    imgPath:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  keepImg:function()&#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 浏览文件</span></span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count:<span class=\"number\">1</span>,</span><br><span class=\"line\">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class=\"line\">      sourceType: ['album', 'camera'], //// 可以指定来源是相册还是相机，默认二者都有</span><br><span class=\"line\">      success: function(res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(tempFilePaths)</span><br><span class=\"line\">        <span class=\"comment\">//将本地照片保存在小程序内</span></span><br><span class=\"line\">        wx.saveFile(&#123;</span><br><span class=\"line\">          tempFilePath: tempFilePaths[<span class=\"number\">0</span>],</span><br><span class=\"line\">          success:function(res)&#123;</span><br><span class=\"line\">            var savedFilePath = res.savedFilePath; <span class=\"comment\">// 图片成功之后存储在本地的路径</span></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(savedFilePath)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!wx.getStorageSync('storageImgPath')) &#123; //数据存储，保存图片的路径</span><br><span class=\"line\">              wx.setStorageSync('storageImgPath', savedFilePath)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            that.setData(&#123; imgPath: wx.getStorageSync('storageImgPath')&#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  deleteImg:function()&#123;</span><br><span class=\"line\">    wx.removeStorageSync('storageImgPath'); //从数据缓存中删除</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.getSavedFileList(&#123; <span class=\"comment\">//获取本地的文件列表</span></span><br><span class=\"line\">      success:function(res)&#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(res.errMsg);</span><br><span class=\"line\">        var files = res.fileList;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.fileList.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 删除第一张</span></span><br><span class=\"line\">          wx.removeSavedFile(&#123;</span><br><span class=\"line\">            filePath:res.fileList[<span class=\"number\">0</span>].filePath,</span><br><span class=\"line\">            success:function(res)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 提示语</span></span><br><span class=\"line\">              wx.showToast(&#123;</span><br><span class=\"line\">                title: '删除成功',</span><br><span class=\"line\">                icon:'success',</span><br><span class=\"line\">                duration:<span class=\"number\">2000</span></span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/wechat/wechat_05.png\" alt=\"微信小程序\"></p>"},{"title":"小程序之旅(六)","date":"2018-07-31T15:32:25.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。\n那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的`wx.uploadFile(obj)`\n\n```h\nnpm install express\nnpm install formidable\n```\n\nNode-server文件\n\n```h\nvar express = require('express');\n//处理post需要引入这个中间件,处理的是form-data\nvar formidable = require('formidable');\nvar fs = require('fs');\nvar app = express();\n\n// 处理静态资源\napp.use(express.static('./'));\n// 处理post的form-data 类型\n\napp.post('/postformdata',function (req,res) {\n    var form = new formidable.IncomingForm(); // 输入流\n    form.encoding = 'utf-8';\n    form.uploadDir = 'upload'; //这里设置上传目录\n    form.parse(req,function(err,fields,files){ // 这里解析请求\n        if (err) {\n            res.send(err);\n            return;\n        }\n        var avatarName = Date.now() + '.jpg'; // 以时间作为名字\n        var newPath = form.uploadDir + avatarName;\n        fs.renameSync(files.my_upload.path,newPath); // my_upload是前端设置的name，把图片储存下来并且重新命名\n        res.send({\n            code:200,\n            path:'http:localhost:9998/'+newPath\n        })\n    })\n})\napp.listen(9998); // 监听端口\n```\n# Num 1\n\n> 第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。\n\n在upload文件目录下操作\n\n```h\n<!--pages/upload/upload.wxml-->\n<view class='container'>\n  <button type='primary' bindtap='uploadImg'>上传图片</button>\n    <view class=\"imginfo\" wx:for=\"{{imglist}}\" wx:for-index=\"id\" wx:for-item=\"item\">\n      <image src='{{item}}' bindtap='previewImg' data-imgid=\"{{id}}\" class='myimg'></image>\n    </view>\n</view>\n```\n```h\n\n/* pages/upload/upload.wxss */\n.imginfo{\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.myimg{\n  width: 70px;\n  height: 70px;\n  border:1px solid #ccc;\n}\n\n\n```\n\n```h\n// pages/upload/upload.js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    imgList:[] // 图片列表\n  },\n  // 上传图片\n  uploadImg:function(){\n    var that = this;\n    wx.chooseImage({\n      success: function(res) {\n        var tempFilePaths = res.tempFilePaths;\n        wx.uploadFile({\n          url: 'http://localhost:9998/postformdata', //nodeJS数据接口\n          filePath: tempFilePaths[0],\n          name: 'my_upload',//这个前后台名称需要保持一致，别乱写。\n          formData: {\n            'user': 'test'\n          },\n          success:function(res){\n            var data = JSON.parse(res.data);//返回来的是字符串格式。\n            var arr = that.data.imgList;\n            arr.push(data.path);\n            that.setData({ imgList: arr });//只有这种方式才能更新视图\n            console.log(that.data.imgList);\n            wx.showToast({\n              title: '文件上传成功',\n              icon: 'success',\n              duration: 2000\n            })\n          }\n        })\n      }\n    })\n  },\n  //预览图片\n  previewImg: function (e) {\n    var index = e.target.dataset.imgid;//获取图片的id\n    var that = this;\n    console.log(index);\n    wx.previewImage({\n      current: that.data.imgList[index],//当前的图片\n      urls: that.data.imgList // 需要预览的图片http链接列表\n    });\n  },\n  ```\n以上就是不要的步骤。\n\n\n\n\n\n\n\n","source":"_posts/小程序之旅-六.md","raw":"---\ntitle: 小程序之旅(六)\ndate: 2018-07-31 23:32:25\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。\n那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的`wx.uploadFile(obj)`\n\n```h\nnpm install express\nnpm install formidable\n```\n\nNode-server文件\n\n```h\nvar express = require('express');\n//处理post需要引入这个中间件,处理的是form-data\nvar formidable = require('formidable');\nvar fs = require('fs');\nvar app = express();\n\n// 处理静态资源\napp.use(express.static('./'));\n// 处理post的form-data 类型\n\napp.post('/postformdata',function (req,res) {\n    var form = new formidable.IncomingForm(); // 输入流\n    form.encoding = 'utf-8';\n    form.uploadDir = 'upload'; //这里设置上传目录\n    form.parse(req,function(err,fields,files){ // 这里解析请求\n        if (err) {\n            res.send(err);\n            return;\n        }\n        var avatarName = Date.now() + '.jpg'; // 以时间作为名字\n        var newPath = form.uploadDir + avatarName;\n        fs.renameSync(files.my_upload.path,newPath); // my_upload是前端设置的name，把图片储存下来并且重新命名\n        res.send({\n            code:200,\n            path:'http:localhost:9998/'+newPath\n        })\n    })\n})\napp.listen(9998); // 监听端口\n```\n# Num 1\n\n> 第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。\n\n在upload文件目录下操作\n\n```h\n<!--pages/upload/upload.wxml-->\n<view class='container'>\n  <button type='primary' bindtap='uploadImg'>上传图片</button>\n    <view class=\"imginfo\" wx:for=\"{{imglist}}\" wx:for-index=\"id\" wx:for-item=\"item\">\n      <image src='{{item}}' bindtap='previewImg' data-imgid=\"{{id}}\" class='myimg'></image>\n    </view>\n</view>\n```\n```h\n\n/* pages/upload/upload.wxss */\n.imginfo{\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.myimg{\n  width: 70px;\n  height: 70px;\n  border:1px solid #ccc;\n}\n\n\n```\n\n```h\n// pages/upload/upload.js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    imgList:[] // 图片列表\n  },\n  // 上传图片\n  uploadImg:function(){\n    var that = this;\n    wx.chooseImage({\n      success: function(res) {\n        var tempFilePaths = res.tempFilePaths;\n        wx.uploadFile({\n          url: 'http://localhost:9998/postformdata', //nodeJS数据接口\n          filePath: tempFilePaths[0],\n          name: 'my_upload',//这个前后台名称需要保持一致，别乱写。\n          formData: {\n            'user': 'test'\n          },\n          success:function(res){\n            var data = JSON.parse(res.data);//返回来的是字符串格式。\n            var arr = that.data.imgList;\n            arr.push(data.path);\n            that.setData({ imgList: arr });//只有这种方式才能更新视图\n            console.log(that.data.imgList);\n            wx.showToast({\n              title: '文件上传成功',\n              icon: 'success',\n              duration: 2000\n            })\n          }\n        })\n      }\n    })\n  },\n  //预览图片\n  previewImg: function (e) {\n    var index = e.target.dataset.imgid;//获取图片的id\n    var that = this;\n    console.log(index);\n    wx.previewImage({\n      current: that.data.imgList[index],//当前的图片\n      urls: that.data.imgList // 需要预览的图片http链接列表\n    });\n  },\n  ```\n以上就是不要的步骤。\n\n\n\n\n\n\n\n","slug":"小程序之旅-六","published":1,"updated":"2018-09-18T12:25:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnez003okt89ph4gjgfz","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<p>有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。<br>那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的<code>wx.uploadFile(obj)</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express</span><br><span class=\"line\">npm install formidable</span><br></pre></td></tr></table></figure>\n<p>Node-server文件</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\"><span class=\"comment\">//处理post需要引入这个中间件,处理的是form-data</span></span><br><span class=\"line\">var formidable = require('formidable');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\"><span class=\"comment\">// 处理post的form-data 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.post('/postformdata',function (req,res) &#123;</span><br><span class=\"line\">    var form = <span class=\"keyword\">new</span> formidable.IncomingForm(); <span class=\"comment\">// 输入流</span></span><br><span class=\"line\">    form.encoding = 'utf-8';</span><br><span class=\"line\">    form.uploadDir = 'upload'; //这里设置上传目录</span><br><span class=\"line\">    form.parse(req,function(err,fields,files)&#123; <span class=\"comment\">// 这里解析请求</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            res.send(err);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var avatarName = Date.now() + '.jpg'; // 以时间作为名字</span><br><span class=\"line\">        var newPath = form.uploadDir + avatarName;</span><br><span class=\"line\">        fs.renameSync(files.my_upload.path,newPath); <span class=\"comment\">// my_upload是前端设置的name，把图片储存下来并且重新命名</span></span><br><span class=\"line\">        res.send(&#123;</span><br><span class=\"line\">            code:<span class=\"number\">200</span>,</span><br><span class=\"line\">            path:'http:localhost:9998/'+newPath</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(<span class=\"number\">9998</span>); <span class=\"comment\">// 监听端口</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Num-1\"><a href=\"#Num-1\" class=\"headerlink\" title=\"Num 1\"></a>Num 1</h1><blockquote>\n<p>第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。</p>\n</blockquote>\n<p>在upload文件目录下操作</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/upload/upload.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">container</span>'&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;button type='primary' bindtap='uploadImg'&gt;上传图片&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class=\"imginfo\" wx:for=\"&#123;&#123;imglist&#125;&#125;\" wx:for-index=\"id\" wx:for-item=\"item\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src='&#123;&#123;item&#125;&#125;' bindtap='previewImg' data-imgid=\"&#123;&#123;id&#125;&#125;\" class='myimg'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pages/upload/upload.wxss */</span></span><br><span class=\"line\">.imginfo&#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.myimg&#123;</span><br><span class=\"line\">  width: <span class=\"number\">70</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">70</span>px;</span><br><span class=\"line\">  border:<span class=\"number\">1</span>px solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/upload/upload.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    imgList:[] <span class=\"comment\">// 图片列表</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 上传图片</span></span><br><span class=\"line\">  uploadImg:function()&#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      success: function(res) &#123;</span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths;</span><br><span class=\"line\">        wx.uploadFile(&#123;</span><br><span class=\"line\">          url: 'http://localhost:9998/postformdata', //nodeJS数据接口</span><br><span class=\"line\">          filePath: tempFilePaths[<span class=\"number\">0</span>],</span><br><span class=\"line\">          name: 'my_upload',//这个前后台名称需要保持一致，别乱写。</span><br><span class=\"line\">          formData: &#123;</span><br><span class=\"line\">            'user': 'test'</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          success:function(res)&#123;</span><br><span class=\"line\">            var data = JSON.parse(res.data);<span class=\"comment\">//返回来的是字符串格式。</span></span><br><span class=\"line\">            var arr = that.data.imgList;</span><br><span class=\"line\">            arr.push(data.path);</span><br><span class=\"line\">            that.setData(&#123; imgList: arr &#125;);<span class=\"comment\">//只有这种方式才能更新视图</span></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(that.data.imgList);</span><br><span class=\"line\">            wx.showToast(&#123;</span><br><span class=\"line\">              title: '文件上传成功',</span><br><span class=\"line\">              icon: 'success',</span><br><span class=\"line\">              duration: <span class=\"number\">2000</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//预览图片</span></span><br><span class=\"line\">  previewImg: function (e) &#123;</span><br><span class=\"line\">    var index = e.target.dataset.imgid;<span class=\"comment\">//获取图片的id</span></span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(index);</span><br><span class=\"line\">    wx.previewImage(&#123;</span><br><span class=\"line\">      current: that.data.imgList[index],<span class=\"comment\">//当前的图片</span></span><br><span class=\"line\">      urls: that.data.imgList <span class=\"comment\">// 需要预览的图片http链接列表</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>以上就是不要的步骤。</p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序的数据本地存储进一步的认识，比如很多图片和视频旅行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<p>有时候的需求就是不单单只是保存到你自己的手机上就可以了，要考虑到多场景的应用。还有文件的内容广度上也要拓展。<br>那么这就需要一些准备工作，比如服务器，使用Nodejs来实现服务器的东西，至于API主要是官方的<code>wx.uploadFile(obj)</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express</span><br><span class=\"line\">npm install formidable</span><br></pre></td></tr></table></figure>\n<p>Node-server文件</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require('express');</span><br><span class=\"line\"><span class=\"comment\">//处理post需要引入这个中间件,处理的是form-data</span></span><br><span class=\"line\">var formidable = require('formidable');</span><br><span class=\"line\">var fs = require('fs');</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理静态资源</span></span><br><span class=\"line\">app.use(express.static('./'));</span><br><span class=\"line\"><span class=\"comment\">// 处理post的form-data 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.post('/postformdata',function (req,res) &#123;</span><br><span class=\"line\">    var form = <span class=\"keyword\">new</span> formidable.IncomingForm(); <span class=\"comment\">// 输入流</span></span><br><span class=\"line\">    form.encoding = 'utf-8';</span><br><span class=\"line\">    form.uploadDir = 'upload'; //这里设置上传目录</span><br><span class=\"line\">    form.parse(req,function(err,fields,files)&#123; <span class=\"comment\">// 这里解析请求</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">            res.send(err);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var avatarName = Date.now() + '.jpg'; // 以时间作为名字</span><br><span class=\"line\">        var newPath = form.uploadDir + avatarName;</span><br><span class=\"line\">        fs.renameSync(files.my_upload.path,newPath); <span class=\"comment\">// my_upload是前端设置的name，把图片储存下来并且重新命名</span></span><br><span class=\"line\">        res.send(&#123;</span><br><span class=\"line\">            code:<span class=\"number\">200</span>,</span><br><span class=\"line\">            path:'http:localhost:9998/'+newPath</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(<span class=\"number\">9998</span>); <span class=\"comment\">// 监听端口</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Num-1\"><a href=\"#Num-1\" class=\"headerlink\" title=\"Num 1\"></a>Num 1</h1><blockquote>\n<p>第一个例子，选择本地图片，然后保存到服务器，上传成功之后可以看到缩略图，但是 点击每一张图片又可以幻灯片式预览。</p>\n</blockquote>\n<p>在upload文件目录下操作</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/upload/upload.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">container</span>'&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;button type='primary' bindtap='uploadImg'&gt;上传图片&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;view class=\"imginfo\" wx:for=\"&#123;&#123;imglist&#125;&#125;\" wx:for-index=\"id\" wx:for-item=\"item\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image src='&#123;&#123;item&#125;&#125;' bindtap='previewImg' data-imgid=\"&#123;&#123;id&#125;&#125;\" class='myimg'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pages/upload/upload.wxss */</span></span><br><span class=\"line\">.imginfo&#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.myimg&#123;</span><br><span class=\"line\">  width: <span class=\"number\">70</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">70</span>px;</span><br><span class=\"line\">  border:<span class=\"number\">1</span>px solid <span class=\"meta\">#ccc;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/upload/upload.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 页面的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    imgList:[] <span class=\"comment\">// 图片列表</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 上传图片</span></span><br><span class=\"line\">  uploadImg:function()&#123;</span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      success: function(res) &#123;</span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths;</span><br><span class=\"line\">        wx.uploadFile(&#123;</span><br><span class=\"line\">          url: 'http://localhost:9998/postformdata', //nodeJS数据接口</span><br><span class=\"line\">          filePath: tempFilePaths[<span class=\"number\">0</span>],</span><br><span class=\"line\">          name: 'my_upload',//这个前后台名称需要保持一致，别乱写。</span><br><span class=\"line\">          formData: &#123;</span><br><span class=\"line\">            'user': 'test'</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          success:function(res)&#123;</span><br><span class=\"line\">            var data = JSON.parse(res.data);<span class=\"comment\">//返回来的是字符串格式。</span></span><br><span class=\"line\">            var arr = that.data.imgList;</span><br><span class=\"line\">            arr.push(data.path);</span><br><span class=\"line\">            that.setData(&#123; imgList: arr &#125;);<span class=\"comment\">//只有这种方式才能更新视图</span></span><br><span class=\"line\">            console.<span class=\"built_in\">log</span>(that.data.imgList);</span><br><span class=\"line\">            wx.showToast(&#123;</span><br><span class=\"line\">              title: '文件上传成功',</span><br><span class=\"line\">              icon: 'success',</span><br><span class=\"line\">              duration: <span class=\"number\">2000</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//预览图片</span></span><br><span class=\"line\">  previewImg: function (e) &#123;</span><br><span class=\"line\">    var index = e.target.dataset.imgid;<span class=\"comment\">//获取图片的id</span></span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(index);</span><br><span class=\"line\">    wx.previewImage(&#123;</span><br><span class=\"line\">      current: that.data.imgList[index],<span class=\"comment\">//当前的图片</span></span><br><span class=\"line\">      urls: that.data.imgList <span class=\"comment\">// 需要预览的图片http链接列表</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>以上就是不要的步骤。</p>"},{"title":"小程序之旅(四)","date":"2018-06-27T16:23:57.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序`websocket`之旅。`websocket`是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 一个小栗子\n\n以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用`ajax`轮询（`setinterval`函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。\n对于`websocket`技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。`websocket`很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。\n\n> 快速生成标准文件\n\n以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。\n\n```h\n<!-- app.json文件 -->\n\n{\n  \"pages\":[\n    \"pages/index/index\",\n    \"pages/logs/logs\",\n    \"pages/charts/charts\"\n  ],\n  \"window\":{\n    \"backgroundTextStyle\":\"light\",\n    \"navigationBarBackgroundColor\": \"#fff\",\n    \"navigationBarTitleText\": \"WeChat\",\n    \"navigationBarTextStyle\":\"black\"\n  }\n}\n```\n\n# 前期准备\n\n## 1、小栗子试图插件\n图表类的插件一般就是`echarts`和`highcharts`,而在小程序里，我们可以使用`wxcharts`,`wxcharts`的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，[下载链接](https://raw.githubusercontent.com/jiangzy27/how_to_react/master/tools/wxcharts.js)\n\n\n## 2、数据接口支持\n\n这里的数据支持使用的是`Nodejs`，还要了解一下`websocket`,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。\n\nNodejs有个插件封装了socket，叫`nodejs-websocket`。使用npm安装一下:\n`npm install nodejs-websocket`\n\n```h\n➜  ~ npm i nodejs-websocket -g\n/usr/local/lib\n└── nodejs-websocket@1.7.1\n\n```\n\n\n> server.js\n\n\n```h\nvar ws = require('nodejs-websocket');\n\n// 创建server\n\nvar server = ws.createServer(function(conn){\n    conn.on(\"text\",function(str){ // 监听文本输入\n        if (str == \"stock\") {\n            setInterval(function(){\n                var arr=[];\n                for (let i = 0; i < 6; i++) {\n                    var count = (Math.ceil((Math.random()*100))/100).toFixed(2);\n                    arr.push(count)\n                }\n                var obj = {data:arr}\n                conn.send(JSON.stringify(obj))\n            },2000);\n        }\n    })\n}).listen(8000)\n\n```\n`websocket`建立专用通道后，服务端只要监听到客户端发来的文本内容是\"stock\",就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。\n\n> 注意\n\n利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。\nws就相当于http，wss就相当于https，所以正确的写法应该是：`ws://localhost:8000`\n\n\n> 微信客户端\n\n使用websocket很容易，主要就是你这几个步骤：\n\n* 建立连接\n* 发送数据\n* 接收数据\n* 结束\n\n> charts.js\n\n```h\n// pages/charts/charts.js\nvar wxCharts = require('wxcharts.js');\nPage({\n  data: {},\n  onLoad: function (options) {\n    // var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8];\n    // var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94];\n\n    //建立连接\n    wx.connectSocket({\n      url: 'ws://localhost:8000',//这里连接的就是服务端的socket\n\n    });\n    //连接成功监听\n    wx.onSocketOpen(function (res) {\n      //发送信息\n      wx.sendSocketMessage({\n        data: \"stock\"\n      });\n      console.log('WebSocket连接已打开！')\n    });\n    //连接失败监听\n    wx.onSocketError(function (res) {\n      console.log('WebSocket连接打开失败，请检查！')\n    });\n    //接收数据\n    wx.onSocketMessage(function (res) {\n      //收到的信息\n      console.log('收到服务器内容：' + res.data);\n      var obj = JSON.parse(res.data);\n      console.log(obj);\n      //绘制图表，利用canvas绘图技术。\n      new wxCharts({\n        canvasId: 'lineCanvas',//指定canvas的id\n        type: 'line',//类型是线形图\n        categories: ['2012', '2013', '2014', '2015', '2016', '2017'],\n\n        series: [{\n          name: '成交量1',\n          data: obj.data,//websocket接收到的数据\n          format: function (val) {\n            if (typeof val == \"string\") {\n              val = parseFloat(val);\n            }\n            return val.toFixed(2) + '万';\n          }\n        },\n        {\n          name: '成交量2',\n          data: [0.30, 0.37, 0.65, 0.78, 0.69, 0.94],\n          format: function (val) {\n            return val.toFixed(2) + '万';\n          }\n        }],\n        yAxis: {\n          title: '成交金额 (万元)',\n          format: function (val) {\n            return val.toFixed(2);\n          },\n          min: 0\n        },\n        width: 320,\n        height: 200\n      });\n    });\n\n\n  }\n\n})\n```\n\n> charts.wxml:\n\n```h\n<!--pages/charts/charts.wxml-->\n<canvas style=\"width: 100%; height: 200px;border:1px solid #ccc;\" canvas-id=\"lineCanvas\">\n</canvas>\n\n```\n![websocket请](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gj5uzrzPwcpeEniaAXGSYSiaUZI3g7gZqlZaeoAROMHB9MVjgqfrL68JHQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。\n下面通过控制台，看下websocket请求的特征：\n\n![websocket请](http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gjeNlDTTIGia8eLvAy3zWjAOV9WTicDFbBONETA7BHvwSpMsK4A5k7Jw8A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)","source":"_posts/小程序之旅-四.md","raw":"---\ntitle: 小程序之旅(四)\ndate: 2018-06-28 00:23:57\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序`websocket`之旅。`websocket`是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 一个小栗子\n\n以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用`ajax`轮询（`setinterval`函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。\n对于`websocket`技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。`websocket`很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。\n\n> 快速生成标准文件\n\n以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。\n\n```h\n<!-- app.json文件 -->\n\n{\n  \"pages\":[\n    \"pages/index/index\",\n    \"pages/logs/logs\",\n    \"pages/charts/charts\"\n  ],\n  \"window\":{\n    \"backgroundTextStyle\":\"light\",\n    \"navigationBarBackgroundColor\": \"#fff\",\n    \"navigationBarTitleText\": \"WeChat\",\n    \"navigationBarTextStyle\":\"black\"\n  }\n}\n```\n\n# 前期准备\n\n## 1、小栗子试图插件\n图表类的插件一般就是`echarts`和`highcharts`,而在小程序里，我们可以使用`wxcharts`,`wxcharts`的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，[下载链接](https://raw.githubusercontent.com/jiangzy27/how_to_react/master/tools/wxcharts.js)\n\n\n## 2、数据接口支持\n\n这里的数据支持使用的是`Nodejs`，还要了解一下`websocket`,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。\n\nNodejs有个插件封装了socket，叫`nodejs-websocket`。使用npm安装一下:\n`npm install nodejs-websocket`\n\n```h\n➜  ~ npm i nodejs-websocket -g\n/usr/local/lib\n└── nodejs-websocket@1.7.1\n\n```\n\n\n> server.js\n\n\n```h\nvar ws = require('nodejs-websocket');\n\n// 创建server\n\nvar server = ws.createServer(function(conn){\n    conn.on(\"text\",function(str){ // 监听文本输入\n        if (str == \"stock\") {\n            setInterval(function(){\n                var arr=[];\n                for (let i = 0; i < 6; i++) {\n                    var count = (Math.ceil((Math.random()*100))/100).toFixed(2);\n                    arr.push(count)\n                }\n                var obj = {data:arr}\n                conn.send(JSON.stringify(obj))\n            },2000);\n        }\n    })\n}).listen(8000)\n\n```\n`websocket`建立专用通道后，服务端只要监听到客户端发来的文本内容是\"stock\",就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。\n\n> 注意\n\n利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。\nws就相当于http，wss就相当于https，所以正确的写法应该是：`ws://localhost:8000`\n\n\n> 微信客户端\n\n使用websocket很容易，主要就是你这几个步骤：\n\n* 建立连接\n* 发送数据\n* 接收数据\n* 结束\n\n> charts.js\n\n```h\n// pages/charts/charts.js\nvar wxCharts = require('wxcharts.js');\nPage({\n  data: {},\n  onLoad: function (options) {\n    // var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8];\n    // var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94];\n\n    //建立连接\n    wx.connectSocket({\n      url: 'ws://localhost:8000',//这里连接的就是服务端的socket\n\n    });\n    //连接成功监听\n    wx.onSocketOpen(function (res) {\n      //发送信息\n      wx.sendSocketMessage({\n        data: \"stock\"\n      });\n      console.log('WebSocket连接已打开！')\n    });\n    //连接失败监听\n    wx.onSocketError(function (res) {\n      console.log('WebSocket连接打开失败，请检查！')\n    });\n    //接收数据\n    wx.onSocketMessage(function (res) {\n      //收到的信息\n      console.log('收到服务器内容：' + res.data);\n      var obj = JSON.parse(res.data);\n      console.log(obj);\n      //绘制图表，利用canvas绘图技术。\n      new wxCharts({\n        canvasId: 'lineCanvas',//指定canvas的id\n        type: 'line',//类型是线形图\n        categories: ['2012', '2013', '2014', '2015', '2016', '2017'],\n\n        series: [{\n          name: '成交量1',\n          data: obj.data,//websocket接收到的数据\n          format: function (val) {\n            if (typeof val == \"string\") {\n              val = parseFloat(val);\n            }\n            return val.toFixed(2) + '万';\n          }\n        },\n        {\n          name: '成交量2',\n          data: [0.30, 0.37, 0.65, 0.78, 0.69, 0.94],\n          format: function (val) {\n            return val.toFixed(2) + '万';\n          }\n        }],\n        yAxis: {\n          title: '成交金额 (万元)',\n          format: function (val) {\n            return val.toFixed(2);\n          },\n          min: 0\n        },\n        width: 320,\n        height: 200\n      });\n    });\n\n\n  }\n\n})\n```\n\n> charts.wxml:\n\n```h\n<!--pages/charts/charts.wxml-->\n<canvas style=\"width: 100%; height: 200px;border:1px solid #ccc;\" canvas-id=\"lineCanvas\">\n</canvas>\n\n```\n![websocket请](http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gj5uzrzPwcpeEniaAXGSYSiaUZI3g7gZqlZaeoAROMHB9MVjgqfrL68JHQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。\n下面通过控制台，看下websocket请求的特征：\n\n![websocket请](http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gjeNlDTTIGia8eLvAy3zWjAOV9WTicDFbBONETA7BHvwSpMsK4A5k7Jw8A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)","slug":"小程序之旅-四","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnf1003tkt89b7q4kn3f","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序<code>websocket</code>之旅。<code>websocket</code>是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<h1 id=\"一个小栗子\"><a href=\"#一个小栗子\" class=\"headerlink\" title=\"一个小栗子\"></a>一个小栗子</h1><p>以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用<code>ajax</code>轮询（<code>setinterval</code>函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。<br>对于<code>websocket</code>技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。<code>websocket</code>很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。</p>\n<blockquote>\n<p>快速生成标准文件</p>\n</blockquote>\n<p>以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- app.json文件 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>:[</span><br><span class=\"line\">    <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs/logs\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/charts/charts\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"window\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"backgroundTextStyle\"</span>:<span class=\"string\">\"light\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarBackgroundColor\"</span>: <span class=\"string\">\"#fff\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTitleText\"</span>: <span class=\"string\">\"WeChat\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTextStyle\"</span>:<span class=\"string\">\"black\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><h2 id=\"1、小栗子试图插件\"><a href=\"#1、小栗子试图插件\" class=\"headerlink\" title=\"1、小栗子试图插件\"></a>1、小栗子试图插件</h2><p>图表类的插件一般就是<code>echarts</code>和<code>highcharts</code>,而在小程序里，我们可以使用<code>wxcharts</code>,<code>wxcharts</code>的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，<a href=\"https://raw.githubusercontent.com/jiangzy27/how_to_react/master/tools/wxcharts.js\" target=\"_blank\" rel=\"noopener\">下载链接</a></p>\n<h2 id=\"2、数据接口支持\"><a href=\"#2、数据接口支持\" class=\"headerlink\" title=\"2、数据接口支持\"></a>2、数据接口支持</h2><p>这里的数据支持使用的是<code>Nodejs</code>，还要了解一下<code>websocket</code>,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。</p>\n<p>Nodejs有个插件封装了socket，叫<code>nodejs-websocket</code>。使用npm安装一下:<br><code>npm install nodejs-websocket</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ npm i nodejs-websocket -g</span><br><span class=\"line\">/usr/local/lib</span><br><span class=\"line\">└── nodejs-websocket@<span class=\"number\">1.7</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>server.js</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = require('nodejs-websocket');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建server</span></span><br><span class=\"line\"></span><br><span class=\"line\">var server = ws.createServer(function(conn)&#123;</span><br><span class=\"line\">    conn.on(<span class=\"string\">\"text\"</span>,function(str)&#123; <span class=\"comment\">// 监听文本输入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"string\">\"stock\"</span>) &#123;</span><br><span class=\"line\">            setInterval(function()&#123;</span><br><span class=\"line\">                var arr=[];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">                    var count = (Math.<span class=\"built_in\">ceil</span>((Math.random()*<span class=\"number\">100</span>))/<span class=\"number\">100</span>).toFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    arr.push(count)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                var obj = &#123;data:arr&#125;</span><br><span class=\"line\">                conn.send(JSON.stringify(obj))</span><br><span class=\"line\">            &#125;,<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p><code>websocket</code>建立专用通道后，服务端只要监听到客户端发来的文本内容是”stock”,就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。</p>\n<blockquote>\n<p>注意</p>\n</blockquote>\n<p>利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。<br>ws就相当于http，wss就相当于https，所以正确的写法应该是：<code>ws://localhost:8000</code></p>\n<blockquote>\n<p>微信客户端</p>\n</blockquote>\n<p>使用websocket很容易，主要就是你这几个步骤：</p>\n<ul>\n<li>建立连接</li>\n<li>发送数据</li>\n<li>接收数据</li>\n<li>结束</li>\n</ul>\n<blockquote>\n<p>charts.js</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/charts/charts.js</span></span><br><span class=\"line\">var wxCharts = require('wxcharts.js');</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  onLoad: function (options) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8];</span></span><br><span class=\"line\">    <span class=\"comment\">// var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94];</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立连接</span></span><br><span class=\"line\">    wx.connectSocket(&#123;</span><br><span class=\"line\">      url: 'ws://localhost:8000',//这里连接的就是服务端的socket</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//连接成功监听</span></span><br><span class=\"line\">    wx.onSocketOpen(function (res) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//发送信息</span></span><br><span class=\"line\">      wx.sendSocketMessage(&#123;</span><br><span class=\"line\">        data: <span class=\"string\">\"stock\"</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      console.log('WebSocket连接已打开！')</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//连接失败监听</span></span><br><span class=\"line\">    wx.onSocketError(function (res) &#123;</span><br><span class=\"line\">      console.log('WebSocket连接打开失败，请检查！')</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//接收数据</span></span><br><span class=\"line\">    wx.onSocketMessage(function (res) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//收到的信息</span></span><br><span class=\"line\">      console.log('收到服务器内容：' + res.data);</span><br><span class=\"line\">      var obj = JSON.parse(res.data);</span><br><span class=\"line\">      console.<span class=\"built_in\">log</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">//绘制图表，利用canvas绘图技术。</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> wxCharts(&#123;</span><br><span class=\"line\">        canvasId: 'lineCanvas',//指定canvas的id</span><br><span class=\"line\">        type: 'line',//类型是线形图</span><br><span class=\"line\">        categories: ['2012', '2013', '2014', '2015', '2016', '2017'],</span><br><span class=\"line\"></span><br><span class=\"line\">        series: [&#123;</span><br><span class=\"line\">          name: '成交量1',</span><br><span class=\"line\">          data: obj.data,<span class=\"comment\">//websocket接收到的数据</span></span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeof val == <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">              val = parseFloat(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>) + <span class=\"string\">'万'</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          name: '成交量2',</span><br><span class=\"line\">          data: [<span class=\"number\">0.30</span>, <span class=\"number\">0.37</span>, <span class=\"number\">0.65</span>, <span class=\"number\">0.78</span>, <span class=\"number\">0.69</span>, <span class=\"number\">0.94</span>],</span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>) + <span class=\"string\">'万'</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        yAxis: &#123;</span><br><span class=\"line\">          title: '成交金额 (万元)',</span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          min: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        width: <span class=\"number\">320</span>,</span><br><span class=\"line\">        height: <span class=\"number\">200</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>charts.wxml:</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/charts/charts.wxml--&gt;</span><br><span class=\"line\">&lt;canvas style=<span class=\"string\">\"width: 100%; height: 200px;border:1px solid #ccc;\"</span> canvas-id=<span class=\"string\">\"lineCanvas\"</span>&gt;</span><br><span class=\"line\">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gj5uzrzPwcpeEniaAXGSYSiaUZI3g7gZqlZaeoAROMHB9MVjgqfrL68JHQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"websocket请\"></p>\n<p>看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。<br>下面通过控制台，看下websocket请求的特征：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gjeNlDTTIGia8eLvAy3zWjAOV9WTicDFbBONETA7BHvwSpMsK4A5k7Jw8A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"websocket请\"></p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。这是关于小程序<code>websocket</code>之旅。<code>websocket</code>是html5定义的一种新协议，原理就是在客户端(浏览器)和服务器之间建立一条专用通道连接，二者可以实时通信，类似于我们日常里的打电话一样。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<h1 id=\"一个小栗子\"><a href=\"#一个小栗子\" class=\"headerlink\" title=\"一个小栗子\"></a>一个小栗子</h1><p>以实现一个股票走势图的功能为例，我们都知道股票这个东西的实时性和准确性是很重要的，一般可以使用<code>ajax</code>轮询（<code>setinterval</code>函数）的方式来解决，可以每半秒轮询一次数据接口，再渲染页面视图。但是这个方式是有一些缺点的，比如，浏览器要时刻不断的向服务器发送数据请求并且接受数据，这样很消耗带宽，还很容易把服务器给搞卡死了。<br>对于<code>websocket</code>技术来说，客户端就与服务器之间建立了一个专用通道，他们之间的数据通信就不需要轮询可以一直进行数据交互，服务器不再是被动的返回数据，而是有了新数据之后就会主动的推送给客户端。<code>websocket</code>很适合对实时性要求的场景，实时性不高还是用ajax就可以实现了。</p>\n<blockquote>\n<p>快速生成标准文件</p>\n</blockquote>\n<p>以charts为例，只需要在app.json文件下添加路劲，保存之后就会自动生成文件夹。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- app.json文件 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>:[</span><br><span class=\"line\">    <span class=\"string\">\"pages/index/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs/logs\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/charts/charts\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"window\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"backgroundTextStyle\"</span>:<span class=\"string\">\"light\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarBackgroundColor\"</span>: <span class=\"string\">\"#fff\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTitleText\"</span>: <span class=\"string\">\"WeChat\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"navigationBarTextStyle\"</span>:<span class=\"string\">\"black\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><h2 id=\"1、小栗子试图插件\"><a href=\"#1、小栗子试图插件\" class=\"headerlink\" title=\"1、小栗子试图插件\"></a>1、小栗子试图插件</h2><p>图表类的插件一般就是<code>echarts</code>和<code>highcharts</code>,而在小程序里，我们可以使用<code>wxcharts</code>,<code>wxcharts</code>的实现方式是canvas,小程序本身也是支持的。把js文件放到charts文件下，<a href=\"https://raw.githubusercontent.com/jiangzy27/how_to_react/master/tools/wxcharts.js\" target=\"_blank\" rel=\"noopener\">下载链接</a></p>\n<h2 id=\"2、数据接口支持\"><a href=\"#2、数据接口支持\" class=\"headerlink\" title=\"2、数据接口支持\"></a>2、数据接口支持</h2><p>这里的数据支持使用的是<code>Nodejs</code>，还要了解一下<code>websocket</code>,它其实就是web版的socket技术。因为浏览器支持的javascript语言并不支持socket，所以在html5技术标准中新添加了这项特性。用通俗的话语解释就是：socket其实就是在浏览器和服务端各开辟一个专门的端口，双方都监听这个端口，然后互相发送和接收数据。</p>\n<p>Nodejs有个插件封装了socket，叫<code>nodejs-websocket</code>。使用npm安装一下:<br><code>npm install nodejs-websocket</code></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ npm i nodejs-websocket -g</span><br><span class=\"line\">/usr/local/lib</span><br><span class=\"line\">└── nodejs-websocket@<span class=\"number\">1.7</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>server.js</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = require('nodejs-websocket');</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建server</span></span><br><span class=\"line\"></span><br><span class=\"line\">var server = ws.createServer(function(conn)&#123;</span><br><span class=\"line\">    conn.on(<span class=\"string\">\"text\"</span>,function(str)&#123; <span class=\"comment\">// 监听文本输入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"string\">\"stock\"</span>) &#123;</span><br><span class=\"line\">            setInterval(function()&#123;</span><br><span class=\"line\">                var arr=[];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">                    var count = (Math.<span class=\"built_in\">ceil</span>((Math.random()*<span class=\"number\">100</span>))/<span class=\"number\">100</span>).toFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    arr.push(count)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                var obj = &#123;data:arr&#125;</span><br><span class=\"line\">                conn.send(JSON.stringify(obj))</span><br><span class=\"line\">            &#125;,<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p><code>websocket</code>建立专用通道后，服务端只要监听到客户端发来的文本内容是”stock”,就每隔2s修改一次数据，修改后的数据，客户端（浏览器）马上就会监听到，利用这种方式来模拟股票数据的变化。</p>\n<blockquote>\n<p>注意</p>\n</blockquote>\n<p>利用webstorm的run或使用命令行运行脚本后，websocket的协议是ws协议和wss协议。<br>ws就相当于http，wss就相当于https，所以正确的写法应该是：<code>ws://localhost:8000</code></p>\n<blockquote>\n<p>微信客户端</p>\n</blockquote>\n<p>使用websocket很容易，主要就是你这几个步骤：</p>\n<ul>\n<li>建立连接</li>\n<li>发送数据</li>\n<li>接收数据</li>\n<li>结束</li>\n</ul>\n<blockquote>\n<p>charts.js</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/charts/charts.js</span></span><br><span class=\"line\">var wxCharts = require('wxcharts.js');</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  onLoad: function (options) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// var data1 = [0.15, 0.2, 0.45, 0.37, 0.4, 0.8];</span></span><br><span class=\"line\">    <span class=\"comment\">// var data2 = [0.30, 0.37, 0.65, 0.78, 0.69, 0.94];</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立连接</span></span><br><span class=\"line\">    wx.connectSocket(&#123;</span><br><span class=\"line\">      url: 'ws://localhost:8000',//这里连接的就是服务端的socket</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//连接成功监听</span></span><br><span class=\"line\">    wx.onSocketOpen(function (res) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//发送信息</span></span><br><span class=\"line\">      wx.sendSocketMessage(&#123;</span><br><span class=\"line\">        data: <span class=\"string\">\"stock\"</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      console.log('WebSocket连接已打开！')</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//连接失败监听</span></span><br><span class=\"line\">    wx.onSocketError(function (res) &#123;</span><br><span class=\"line\">      console.log('WebSocket连接打开失败，请检查！')</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//接收数据</span></span><br><span class=\"line\">    wx.onSocketMessage(function (res) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//收到的信息</span></span><br><span class=\"line\">      console.log('收到服务器内容：' + res.data);</span><br><span class=\"line\">      var obj = JSON.parse(res.data);</span><br><span class=\"line\">      console.<span class=\"built_in\">log</span>(obj);</span><br><span class=\"line\">      <span class=\"comment\">//绘制图表，利用canvas绘图技术。</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> wxCharts(&#123;</span><br><span class=\"line\">        canvasId: 'lineCanvas',//指定canvas的id</span><br><span class=\"line\">        type: 'line',//类型是线形图</span><br><span class=\"line\">        categories: ['2012', '2013', '2014', '2015', '2016', '2017'],</span><br><span class=\"line\"></span><br><span class=\"line\">        series: [&#123;</span><br><span class=\"line\">          name: '成交量1',</span><br><span class=\"line\">          data: obj.data,<span class=\"comment\">//websocket接收到的数据</span></span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeof val == <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">              val = parseFloat(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>) + <span class=\"string\">'万'</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          name: '成交量2',</span><br><span class=\"line\">          data: [<span class=\"number\">0.30</span>, <span class=\"number\">0.37</span>, <span class=\"number\">0.65</span>, <span class=\"number\">0.78</span>, <span class=\"number\">0.69</span>, <span class=\"number\">0.94</span>],</span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>) + <span class=\"string\">'万'</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        yAxis: &#123;</span><br><span class=\"line\">          title: '成交金额 (万元)',</span><br><span class=\"line\">          format: function (val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val.toFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          min: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        width: <span class=\"number\">320</span>,</span><br><span class=\"line\">        height: <span class=\"number\">200</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>charts.wxml:</p>\n</blockquote>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--pages/charts/charts.wxml--&gt;</span><br><span class=\"line\">&lt;canvas style=<span class=\"string\">\"width: 100%; height: 200px;border:1px solid #ccc;\"</span> canvas-id=<span class=\"string\">\"lineCanvas\"</span>&gt;</span><br><span class=\"line\">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gj5uzrzPwcpeEniaAXGSYSiaUZI3g7gZqlZaeoAROMHB9MVjgqfrL68JHQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"websocket请\"></p>\n<p>看下控制台，只有一次请求而已，没有像轮询那样一坨一坨的发请求了。<br>下面通过控制台，看下websocket请求的特征：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/amhuPdMsm1nHiaOW0568UbEodbWhIZ4gjeNlDTTIGia8eLvAy3zWjAOV9WTicDFbBONETA7BHvwSpMsK4A5k7Jw8A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"websocket请\"></p>"},{"title":"小程序之旅—认识一下","date":"2018-05-22T15:19:02.000Z","description":null,"copyright":true,"top":null,"_content":"\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 目录结构\n\n* page --- 项目所有的页面模板\n* utils --- 公共js工具\n* app.js --- 启动入口文件\n* app.wxss --- 项目的全局样式文件\n* app.json --- 项目的配置文件\n\n在`app.json`里我们可以看到`page`下面就是我们可以配置的页面路径，`pages/index/index`这个路径就可以访问`index.wxml`下的东西，每一个页面都有“三大件”---`js、wxml、wxss`组成。\n\n![小程序](小程序之旅—-认识一下/xcx1.png)\n下面开始我们小栗子：\n\n新增一个view，`wxml`与`wxss`就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。\n\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text class=\"demo\">这是一个测试小栗子</text>\n  </view>\n</view>\n```\n\n```h\n/**index.wxss**/\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 128rpx;\n  height: 128rpx;\n  margin: 20rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\n\n.usermotto {\n  margin-top: 200px;\n}\n/*新增加的  */\n.demo{\n  color:blueviolet\n}\n```\n保存好就可以看到效果了。\n接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({  // 页面跳转函数\n      url: '../logs/logs'\n    })\n  },\n  onLoad: function () {  // 加载页面时触发函数集合\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) { //获取用户信息\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n```\n具体函数对应含义也可以参考[微信公众平台开发](https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject)。\n\n先去wxml文件下增加一个按`<button class='primary' bindtap='changeDemo'>点击改变状态</button>`,接着去js文件下添加初始数据，和点击的事件函数。\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text class=\"demo\">{{demotext}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n\n</view>\n```\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({  // 页面跳转函数\n      url: '../logs/logs'\n    })\n  },\n  //新增加的事件\n  changeDemo:function(){\n    this.setDate({\n      demotext: '点击之后就改变了我的状态',\n    })\n  },\n  onLoad: function () {  // 加载页面时触发函数集合\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) { //获取用户信息\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n```\n![小程序](小程序之旅—-认识一下/xcx1-1.png)\n![小程序](小程序之旅—-认识一下/xcx1-2.png)\n\n\n在wxml文件里加入`if-else`的判断：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n\n</view>\n```\n```h\n// index.js\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    demovalue:'if判断的数据',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n })\n```\n\n接下来是`for`循环遍历数据：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n  <view wx:for=\"{{fordata}}\" wx:for-index=\"id\" wx:for-item=\"itemvalue\">\n    ID:{{id}}姓名：{{itemvalue.name}}----数量：{{itemvalue.num}}\n  </view>\n</view>\n```\n```h\n// index.js\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    demovalue:'if判断的数据',\n    fordata: [{ name: '测试1', num: 12 }, { name: '测试2', num: 22 }, { name: '测试3', num: 32 }],\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n })\n```\n本地数据都没有问题了，那么接下来就是`Ajax 跨域请求`,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求[wx.request(OBJECT)](https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject)\n\n示例代码：\n```h\nwx.request({\n  url: 'test.php', //仅为示例，并非真实的接口地址\n  data: {\n     x: '' ,\n     y: ''\n  },\n  header: {\n      'content-type': 'application/json' // 默认值\n  },\n  success: function(res) {\n    console.log(res.data)\n  }\n})\n```\n最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册[wx.chooseImage(OBJECT)](https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject),在js文件里新增一个方法。\n```h\nonLoad: function () {  // 加载页面时触发函数集合\n    var that = this;\n    wx.chooseImage({ // 获取本地图片\n      count: 1, // 默认9\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n      success: function (res) {\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\n        var tempFilePaths = res.tempFilePaths\n        console.log(tempFilePaths)\n        that.setData({\n          demoImg: tempFilePaths\n        });\n      }\n    })\n}\n   \n```\nwxml文件：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image wx:if=\"{{demoImg!=null}}\" src='{{demoImg}}'></image>\n      <image wx:else bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n  <view wx:key=\"id\" wx:for=\"{{fordata}}\" wx:for-index=\"id\" wx:for-item=\"itemvalue\">\n    ID:{{id}}姓名：{{itemvalue.name}}----数量：{{itemvalue.num}}\n  </view>\n</view>\n\n```\n# 总结\n这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。\n","source":"_posts/小程序之旅—-认识一下.md","raw":"---\ntitle: 小程序之旅—认识一下\ndate: 2018-05-22 23:19:02\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n\n\n小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n# 目录结构\n\n* page --- 项目所有的页面模板\n* utils --- 公共js工具\n* app.js --- 启动入口文件\n* app.wxss --- 项目的全局样式文件\n* app.json --- 项目的配置文件\n\n在`app.json`里我们可以看到`page`下面就是我们可以配置的页面路径，`pages/index/index`这个路径就可以访问`index.wxml`下的东西，每一个页面都有“三大件”---`js、wxml、wxss`组成。\n\n![小程序](小程序之旅—-认识一下/xcx1.png)\n下面开始我们小栗子：\n\n新增一个view，`wxml`与`wxss`就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。\n\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text class=\"demo\">这是一个测试小栗子</text>\n  </view>\n</view>\n```\n\n```h\n/**index.wxss**/\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 128rpx;\n  height: 128rpx;\n  margin: 20rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\n\n.usermotto {\n  margin-top: 200px;\n}\n/*新增加的  */\n.demo{\n  color:blueviolet\n}\n```\n保存好就可以看到效果了。\n接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({  // 页面跳转函数\n      url: '../logs/logs'\n    })\n  },\n  onLoad: function () {  // 加载页面时触发函数集合\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) { //获取用户信息\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n\n```\n具体函数对应含义也可以参考[微信公众平台开发](https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject)。\n\n先去wxml文件下增加一个按`<button class='primary' bindtap='changeDemo'>点击改变状态</button>`,接着去js文件下添加初始数据，和点击的事件函数。\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text class=\"demo\">{{demotext}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n\n</view>\n```\n```h\n//index.js\n//获取应用实例\nconst app = getApp()\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n  //事件处理函数\n  bindViewTap: function() {\n    wx.navigateTo({  // 页面跳转函数\n      url: '../logs/logs'\n    })\n  },\n  //新增加的事件\n  changeDemo:function(){\n    this.setDate({\n      demotext: '点击之后就改变了我的状态',\n    })\n  },\n  onLoad: function () {  // 加载页面时触发函数集合\n    if (app.globalData.userInfo) {\n      this.setData({\n        userInfo: app.globalData.userInfo,\n        hasUserInfo: true\n      })\n    } else if (this.data.canIUse){\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\n      // 所以此处加入 callback 以防止这种情况\n      app.userInfoReadyCallback = res => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n      }\n    } else {\n      // 在没有 open-type=getUserInfo 版本的兼容处理\n      wx.getUserInfo({\n        success: res => {\n          app.globalData.userInfo = res.userInfo\n          this.setData({\n            userInfo: res.userInfo,\n            hasUserInfo: true\n          })\n        }\n      })\n    }\n  },\n  getUserInfo: function(e) { //获取用户信息\n    console.log(e)\n    app.globalData.userInfo = e.detail.userInfo\n    this.setData({\n      userInfo: e.detail.userInfo,\n      hasUserInfo: true\n    })\n  }\n})\n```\n![小程序](小程序之旅—-认识一下/xcx1-1.png)\n![小程序](小程序之旅—-认识一下/xcx1-2.png)\n\n\n在wxml文件里加入`if-else`的判断：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n\n</view>\n```\n```h\n// index.js\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    demovalue:'if判断的数据',\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n })\n```\n\n接下来是`for`循环遍历数据：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n  <view wx:for=\"{{fordata}}\" wx:for-index=\"id\" wx:for-item=\"itemvalue\">\n    ID:{{id}}姓名：{{itemvalue.name}}----数量：{{itemvalue.num}}\n  </view>\n</view>\n```\n```h\n// index.js\n\nPage({\n  data: { // 当前页面的所有数据\n    motto: '我们的第一个小程序。',\n    demotext:'当前我的状态', // 新增初始值\n    demovalue:'if判断的数据',\n    fordata: [{ name: '测试1', num: 12 }, { name: '测试2', num: 22 }, { name: '测试3', num: 32 }],\n    userInfo: {},\n    hasUserInfo: false,\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\n  },\n })\n```\n本地数据都没有问题了，那么接下来就是`Ajax 跨域请求`,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求[wx.request(OBJECT)](https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject)\n\n示例代码：\n```h\nwx.request({\n  url: 'test.php', //仅为示例，并非真实的接口地址\n  data: {\n     x: '' ,\n     y: ''\n  },\n  header: {\n      'content-type': 'application/json' // 默认值\n  },\n  success: function(res) {\n    console.log(res.data)\n  }\n})\n```\n最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册[wx.chooseImage(OBJECT)](https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject),在js文件里新增一个方法。\n```h\nonLoad: function () {  // 加载页面时触发函数集合\n    var that = this;\n    wx.chooseImage({ // 获取本地图片\n      count: 1, // 默认9\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n      success: function (res) {\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\n        var tempFilePaths = res.tempFilePaths\n        console.log(tempFilePaths)\n        that.setData({\n          demoImg: tempFilePaths\n        });\n      }\n    })\n}\n   \n```\nwxml文件：\n```h\n<!--index.wxml-->\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image wx:if=\"{{demoImg!=null}}\" src='{{demoImg}}'></image>\n      <image wx:else bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n  <view>\n    <text wx:if=\"{{demotext=='当前我的状态'}}\" class=\"demo\">{{demotext}}</text>\n    <text wx:else class=\"demo\">{{demovalue}}</text>\n  </view>\n  <button class='primary' bindtap='changeDemo'>点击改变状态</button>\n  <view wx:key=\"id\" wx:for=\"{{fordata}}\" wx:for-index=\"id\" wx:for-item=\"itemvalue\">\n    ID:{{id}}姓名：{{itemvalue.name}}----数量：{{itemvalue.num}}\n  </view>\n</view>\n\n```\n# 总结\n这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。\n","slug":"小程序之旅—-认识一下","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnf2003vkt89uv06x72r","content":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<h1 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h1><ul>\n<li>page — 项目所有的页面模板</li>\n<li>utils — 公共js工具</li>\n<li>app.js — 启动入口文件</li>\n<li>app.wxss — 项目的全局样式文件</li>\n<li>app.json — 项目的配置文件</li>\n</ul>\n<p>在<code>app.json</code>里我们可以看到<code>page</code>下面就是我们可以配置的页面路径，<code>pages/index/index</code>这个路径就可以访问<code>index.wxml</code>下的东西，每一个页面都有“三大件”—<code>js、wxml、wxss</code>组成。</p>\n<p><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1.png\" alt=\"小程序\"><br>下面开始我们小栗子：</p>\n<p>新增一个view，<code>wxml</code>与<code>wxss</code>就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">demo</span>\"&gt;这是一个测试小栗子&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**index.wxss**/</span></span><br><span class=\"line\">.userinfo &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-avatar &#123;</span><br><span class=\"line\">  width: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  height: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  margin: <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">  border-radius: <span class=\"number\">50</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-nickname &#123;</span><br><span class=\"line\">  color: <span class=\"meta\">#aaa;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.usermotto &#123;</span><br><span class=\"line\">  margin-top: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*新增加的  */</span></span><br><span class=\"line\">.demo&#123;</span><br><span class=\"line\">  color:blueviolet</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保存好就可以看到效果了。<br>接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;  <span class=\"comment\">// 页面跳转函数</span></span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123; <span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>具体函数对应含义也可以参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\" target=\"_blank\" rel=\"noopener\">微信公众平台开发</a>。</p>\n<p>先去wxml文件下增加一个按<code>&lt;button class=&#39;primary&#39; bindtap=&#39;changeDemo&#39;&gt;点击改变状态&lt;/button&gt;</code>,接着去js文件下添加初始数据，和点击的事件函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text class=\"demo\"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">primary</span>' <span class=\"title\">bindtap</span>='<span class=\"title\">changeDemo</span>'&gt;点击改变状态&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;  <span class=\"comment\">// 页面跳转函数</span></span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//新增加的事件</span></span><br><span class=\"line\">  changeDemo:function()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setDate(&#123;</span><br><span class=\"line\">      demotext: '点击之后就改变了我的状态',</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123; <span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1-1.png\" alt=\"小程序\"><br><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1-2.png\" alt=\"小程序\"></p>\n<p>在wxml文件里加入<code>if-else</code>的判断：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    demovalue:'if判断的数据',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>接下来是<code>for</code>循环遍历数据：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\">  &lt;view wx:<span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;fordata&#125;&#125;\"</span> wx:<span class=\"keyword\">for</span>-index=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>-item=<span class=\"string\">\"itemvalue\"</span>&gt;</span><br><span class=\"line\">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    demovalue:'if判断的数据',</span><br><span class=\"line\">    fordata: [&#123; name: '测试1', num: 12 &#125;, &#123; name: '测试2', num: 22 &#125;, &#123; name: '测试3', num: 32 &#125;],</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>本地数据都没有问题了，那么接下来就是<code>Ajax 跨域请求</code>,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject\" target=\"_blank\" rel=\"noopener\">wx.request(OBJECT)</a></p>\n<p>示例代码：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.request(&#123;</span><br><span class=\"line\">  url: 'test.php', //仅为示例，并非真实的接口地址</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">     x: '' ,</span><br><span class=\"line\">     y: <span class=\"string\">''</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">      'content-type': 'application/json' // 默认值</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  success: function(res) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(res.data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject\" target=\"_blank\" rel=\"noopener\">wx.chooseImage(OBJECT)</a>,在js文件里新增一个方法。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.chooseImage(&#123; <span class=\"comment\">// 获取本地图片</span></span><br><span class=\"line\">      count: <span class=\"number\">1</span>, <span class=\"comment\">// 默认9</span></span><br><span class=\"line\">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class=\"line\">      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(tempFilePaths)</span><br><span class=\"line\">        that.setData(&#123;</span><br><span class=\"line\">          demoImg: tempFilePaths</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>wxml文件：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image wx:if=\"&#123;&#123;demoImg!=null&#125;&#125;\" src='&#123;&#123;demoImg&#125;&#125;'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image wx:else bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\">  &lt;view wx:key=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;fordata&#125;&#125;\"</span> wx:<span class=\"keyword\">for</span>-index=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>-item=<span class=\"string\">\"itemvalue\"</span>&gt;</span><br><span class=\"line\">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。</p>\n","site":{"data":{}},"excerpt":"<p>小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<h1 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h1><ul>\n<li>page — 项目所有的页面模板</li>\n<li>utils — 公共js工具</li>\n<li>app.js — 启动入口文件</li>\n<li>app.wxss — 项目的全局样式文件</li>\n<li>app.json — 项目的配置文件</li>\n</ul>\n<p>在<code>app.json</code>里我们可以看到<code>page</code>下面就是我们可以配置的页面路径，<code>pages/index/index</code>这个路径就可以访问<code>index.wxml</code>下的东西，每一个页面都有“三大件”—<code>js、wxml、wxss</code>组成。</p>\n<p><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1.png\" alt=\"小程序\"><br>下面开始我们小栗子：</p>\n<p>新增一个view，<code>wxml</code>与<code>wxss</code>就是我们的HTML和css,需要增加和修改样式的话就直接修改就好了。</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">demo</span>\"&gt;这是一个测试小栗子&lt;/text&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;/view&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**index.wxss**/</span></span><br><span class=\"line\">.userinfo &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-avatar &#123;</span><br><span class=\"line\">  width: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  height: <span class=\"number\">128</span>rpx;</span><br><span class=\"line\">  margin: <span class=\"number\">20</span>rpx;</span><br><span class=\"line\">  border-radius: <span class=\"number\">50</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.userinfo-nickname &#123;</span><br><span class=\"line\">  color: <span class=\"meta\">#aaa;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.usermotto &#123;</span><br><span class=\"line\">  margin-top: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*新增加的  */</span></span><br><span class=\"line\">.demo&#123;</span><br><span class=\"line\">  color:blueviolet</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保存好就可以看到效果了。<br>接下来我们试一下动态改变内容，先来介绍下js文件下的一些函数模块是什么意思：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;  <span class=\"comment\">// 页面跳转函数</span></span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123; <span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>具体函数对应含义也可以参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\" target=\"_blank\" rel=\"noopener\">微信公众平台开发</a>。</p>\n<p>先去wxml文件下增加一个按<code>&lt;button class=&#39;primary&#39; bindtap=&#39;changeDemo&#39;&gt;点击改变状态&lt;/button&gt;</code>,接着去js文件下添加初始数据，和点击的事件函数。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text class=\"demo\"&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button <span class=\"class\"><span class=\"keyword\">class</span>='<span class=\"title\">primary</span>' <span class=\"title\">bindtap</span>='<span class=\"title\">changeDemo</span>'&gt;点击改变状态&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//事件处理函数</span></span><br><span class=\"line\">  bindViewTap: function() &#123;</span><br><span class=\"line\">    wx.navigateTo(&#123;  <span class=\"comment\">// 页面跳转函数</span></span><br><span class=\"line\">      url: '../logs/logs'</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//新增加的事件</span></span><br><span class=\"line\">  changeDemo:function()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setDate(&#123;</span><br><span class=\"line\">      demotext: '点击之后就改变了我的状态',</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.globalData.userInfo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">        userInfo: app.globalData.userInfo,</span><br><span class=\"line\">        hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.data.canIUse)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class=\"line\">      <span class=\"comment\">// 所以此处加入 callback 以防止这种情况</span></span><br><span class=\"line\">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">          userInfo: res.userInfo,</span><br><span class=\"line\">          hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class=\"line\">      wx.getUserInfo(&#123;</span><br><span class=\"line\">        success: res =&gt; &#123;</span><br><span class=\"line\">          app.globalData.userInfo = res.userInfo</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">            userInfo: res.userInfo,</span><br><span class=\"line\">            hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUserInfo: function(e) &#123; <span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(e)</span><br><span class=\"line\">    app.globalData.userInfo = e.detail.userInfo</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">      userInfo: e.detail.userInfo,</span><br><span class=\"line\">      hasUserInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1-1.png\" alt=\"小程序\"><br><img src=\"/blog/2018/05/22/小程序之旅—-认识一下/xcx1-2.png\" alt=\"小程序\"></p>\n<p>在wxml文件里加入<code>if-else</code>的判断：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    demovalue:'if判断的数据',</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>接下来是<code>for</code>循环遍历数据：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\">  &lt;view wx:<span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;fordata&#125;&#125;\"</span> wx:<span class=\"keyword\">for</span>-index=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>-item=<span class=\"string\">\"itemvalue\"</span>&gt;</span><br><span class=\"line\">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"comment\">// 当前页面的所有数据</span></span><br><span class=\"line\">    motto: '我们的第一个小程序。',</span><br><span class=\"line\">    demotext:'当前我的状态', // 新增初始值</span><br><span class=\"line\">    demovalue:'if判断的数据',</span><br><span class=\"line\">    fordata: [&#123; name: '测试1', num: 12 &#125;, &#123; name: '测试2', num: 22 &#125;, &#123; name: '测试3', num: 32 &#125;],</span><br><span class=\"line\">    userInfo: &#123;&#125;,</span><br><span class=\"line\">    hasUserInfo: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    canIUse: wx.canIUse('button.open-type.getUserInfo')</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>本地数据都没有问题了，那么接下来就是<code>Ajax 跨域请求</code>,在小程序里面我们不用考虑那么多，因为他们已经为我们封装了一套方法，我们只需要调用就好了，参考发起网络请求<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html#wxrequestobject\" target=\"_blank\" rel=\"noopener\">wx.request(OBJECT)</a></p>\n<p>示例代码：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.request(&#123;</span><br><span class=\"line\">  url: 'test.php', //仅为示例，并非真实的接口地址</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">     x: '' ,</span><br><span class=\"line\">     y: <span class=\"string\">''</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">      'content-type': 'application/json' // 默认值</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  success: function(res) &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(res.data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>最后我们来一个动态获取本地图片上传，使用文档提供的方法获取本地相册<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media-picture.html#wxchooseimageobject\" target=\"_blank\" rel=\"noopener\">wx.chooseImage(OBJECT)</a>,在js文件里新增一个方法。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onLoad: function () &#123;  <span class=\"comment\">// 加载页面时触发函数集合</span></span><br><span class=\"line\">    var that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    wx.chooseImage(&#123; <span class=\"comment\">// 获取本地图片</span></span><br><span class=\"line\">      count: <span class=\"number\">1</span>, <span class=\"comment\">// 默认9</span></span><br><span class=\"line\">      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有</span><br><span class=\"line\">      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class=\"line\">        var tempFilePaths = res.tempFilePaths</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(tempFilePaths)</span><br><span class=\"line\">        that.setData(&#123;</span><br><span class=\"line\">          demoImg: tempFilePaths</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>wxml文件：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--index.wxml--&gt;</span><br><span class=\"line\">&lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">container</span>\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">  &lt;view class=\"userinfo\"&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;block wx:else&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image wx:if=\"&#123;&#123;demoImg!=null&#125;&#125;\" src='&#123;&#123;demoImg&#125;&#125;'&gt;&lt;/image&gt;</span></span><br><span class=\"line\"><span class=\"class\">      &lt;image wx:else bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt;</span></span><br><span class=\"line\">      &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;/block&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">usermotto</span>\"&gt;</span></span><br><span class=\"line\">    &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;view&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">if</span>=<span class=\"string\">\"&#123;&#123;demotext=='当前我的状态'&#125;&#125;\"</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demotext&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">    &lt;text wx:<span class=\"keyword\">else</span> class=<span class=\"string\">\"demo\"</span>&gt;&#123;&#123;demovalue&#125;&#125;&lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;button class='primary' bindtap='changeDemo'&gt;点击改变状态&lt;/button&gt;</span><br><span class=\"line\">  &lt;view wx:key=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>=<span class=\"string\">\"&#123;&#123;fordata&#125;&#125;\"</span> wx:<span class=\"keyword\">for</span>-index=<span class=\"string\">\"id\"</span> wx:<span class=\"keyword\">for</span>-item=<span class=\"string\">\"itemvalue\"</span>&gt;</span><br><span class=\"line\">    ID:&#123;&#123;id&#125;&#125;姓名：&#123;&#123;itemvalue.name&#125;&#125;----数量：&#123;&#123;itemvalue.num&#125;&#125;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这些都是简单的页面数据操作和获取，遇到真实场景需要特殊对待，接下就以实例为主。</p>"},{"title":"小程序之旅——个人申请","date":"2018-05-14T16:47:28.000Z","description":null,"copyright":true,"top":null,"_content":"开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！\n\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n[小程序开发注册传送门](https://developers.weixin.qq.com/miniprogram/dev/index.html)，按照步骤完成注册认证就可以开始开发咯。\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx.png)\n\n注册完之后就登录进入开发\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_1.png)\n\n填写个人资料\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_4.png)\n\n填写个人资料\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_3.png)\n\n> 注意事项：\n\n* 1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。\n\n* 2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。\n\n* 3.每次登录都需要扫码认证，确认成功后就可以正常登录了。\n\n\n个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_2.png)\n\n我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_5.png)\n\n新建一个项目文件，输入自己的APPID，确定\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_6.png)\n\n进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_7.png)\n\n\n> 注意事项：\n\n* 1.每次登录都需要扫码登录\n\n* 2.需要输入自己的APPID\n\n* 3.每次修改完代码都要编译\n\n# 总结\n是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！\n微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。","source":"_posts/小程序之旅——个人申请.md","raw":"---\ntitle: 小程序之旅——个人申请\ndate: 2018-05-15 00:47:28\ntags: [小程序,编程,Javascript]\ndescription: \ncopyright: true\ncategories: 小程序\ntop:\n---\n开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！\n\n\n![微信小程序](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png)\n\n<!-- more -->\n\n[小程序开发注册传送门](https://developers.weixin.qq.com/miniprogram/dev/index.html)，按照步骤完成注册认证就可以开始开发咯。\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx.png)\n\n注册完之后就登录进入开发\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_1.png)\n\n填写个人资料\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_4.png)\n\n填写个人资料\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_3.png)\n\n> 注意事项：\n\n* 1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。\n\n* 2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。\n\n* 3.每次登录都需要扫码认证，确认成功后就可以正常登录了。\n\n\n个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_2.png)\n\n我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_5.png)\n\n新建一个项目文件，输入自己的APPID，确定\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_6.png)\n\n进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！\n\n![小程序之旅——个人申请](小程序之旅——个人申请/xcx_7.png)\n\n\n> 注意事项：\n\n* 1.每次登录都需要扫码登录\n\n* 2.需要输入自己的APPID\n\n* 3.每次修改完代码都要编译\n\n# 总结\n是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！\n微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。","slug":"小程序之旅——个人申请","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnf50040kt89nic2y5rf","content":"<p>开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>\n<a id=\"more\"></a>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/index.html\" target=\"_blank\" rel=\"noopener\">小程序开发注册传送门</a>，按照步骤完成注册认证就可以开始开发咯。</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>注册完之后就登录进入开发<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_1.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>填写个人资料<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_4.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>填写个人资料<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_3.png\" alt=\"小程序之旅——个人申请\"></p>\n<blockquote>\n<p>注意事项：</p>\n</blockquote>\n<ul>\n<li><p>1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。</p>\n</li>\n<li><p>2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。</p>\n</li>\n<li><p>3.每次登录都需要扫码认证，确认成功后就可以正常登录了。</p>\n</li>\n</ul>\n<p>个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_2.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_5.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>新建一个项目文件，输入自己的APPID，确定</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_6.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_7.png\" alt=\"小程序之旅——个人申请\"></p>\n<blockquote>\n<p>注意事项：</p>\n</blockquote>\n<ul>\n<li><p>1.每次登录都需要扫码登录</p>\n</li>\n<li><p>2.需要输入自己的APPID</p>\n</li>\n<li><p>3.每次修改完代码都要编译</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！<br>微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。</p>\n","site":{"data":{}},"excerpt":"<p>开始小程序的学习打卡，倒腾一门新的技术就要积极参与进去，从搭建初始的开发环境开始，从简单demo开时，逐渐深入，多敲代码，多尝试，多参考，还要自我思考，举一反三。是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/wechat_d.png\" alt=\"微信小程序\"></p>","more":"<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/index.html\" target=\"_blank\" rel=\"noopener\">小程序开发注册传送门</a>，按照步骤完成注册认证就可以开始开发咯。</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>注册完之后就登录进入开发<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_1.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>填写个人资料<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_4.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>填写个人资料<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_3.png\" alt=\"小程序之旅——个人申请\"></p>\n<blockquote>\n<p>注意事项：</p>\n</blockquote>\n<ul>\n<li><p>1.个人信息登记时，组织名称和组织机构代码可随便填，而组织机构代码证，可以直接随便搜一张图片上传即可。</p>\n</li>\n<li><p>2.管理员信息登记，这信息要填写你的真实信息，有身份证实名验证的，还需要开通微信支付的用户，扫码确认才可以继续下一步的信息填写。</p>\n</li>\n<li><p>3.每次登录都需要扫码认证，确认成功后就可以正常登录了。</p>\n</li>\n</ul>\n<p>个人开发只有自己支付注册费用，有公司报销那是再好不过了，之后就是下载开发者工具：<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_2.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>我们扫码登录后会有2个选择:小程序项目和公众号网页项目，我们这里选择第一个小程序项目<br><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_5.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>新建一个项目文件，输入自己的APPID，确定</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_6.png\" alt=\"小程序之旅——个人申请\"></p>\n<p>进入开发调试界面，界面还是越来越适应开发，真的是越来越兼顾开发与优美界面，开启属于自己的小程序之旅吧！</p>\n<p><img src=\"/blog/2018/05/15/小程序之旅——个人申请/xcx_7.png\" alt=\"小程序之旅——个人申请\"></p>\n<blockquote>\n<p>注意事项：</p>\n</blockquote>\n<ul>\n<li><p>1.每次登录都需要扫码登录</p>\n</li>\n<li><p>2.需要输入自己的APPID</p>\n</li>\n<li><p>3.每次修改完代码都要编译</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>是时候开始撸一下微信小程序了，那么好的用户基础，怎么能放弃这么好的一个开发与用户体验的机会。那么，就让我们从申请小程序开始吧！<br>微信小程序功能非常强大，是IDE和调试界面结合的模式，省去各种浏览器的调试烦恼，还有就是他的轻便与发展前景。</p>"},{"title":"开发小锦囊","date":"2018-07-29T16:30:40.000Z","description":null,"copyright":true,"top":null,"_content":"\n这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png)\n\n<!-- more -->\n\n{% note danger %} `JavaScript` {% endnote %}\n\n# JavaScript\n\n## 1、js 判断字符串中是否包含某个字符串\n\n> String对象的方法\n\n方法一: indexOf()   (推荐)\n\n```h\nvar str = \"123\";\nconsole.log(str.indexOf(\"3\") != -1 );  // true\nindexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。\n\n```\n\n方法二: search() \n```h\nvar str = \"123\";\nconsole.log(str.search(\"3\") != -1 );  // true\nsearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。\n```\n \n方法三:match()\n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nif(str.match(reg)){\n    // 包含        \n}\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n```\n \n> RegExp 对象方法\n\n\n方法四:test() \n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nconsole.log(reg.test(str)); // true\ntest() 方法用于检索字符串中指定的值。返回 true 或 false。\n```\n \n\n方法五:exec()\n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nif(reg.exec(str)){\n    // 包含        \n}\nexec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\n```\n\n## 2、 JS中every()和some()的用法\n\n> every()与some()方法都是JS中数组的迭代方法。\n\nevery()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。\n\nsome()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。\n\n```h\nvar arr = [ 1, 2, 3, 4, 5, 6 ]; \n \nconsole.log( arr.some( function( item, index, array ){ \n    console.log( 'item=' + item + ',index='+index+',array='+array ); \n    return item > 3; \n})); \n \nconsole.log( arr.every( function( item, index, array ){ \n    console.log( 'item=' + item + ',index='+index+',array='+array ); \n    return item > 3; \n}));\n```\n\n## 3、 用Set为数组去重\n```h\nvar arr = [1,2,2,3,4] // 需要去重的数组\n\nvar set = new Set(arr) // {1,2,3,4}\nvar newArr = Array.from(set) // 再把set转变成array\n\nconsole.log(newArr) // [1,2,3,4]\n```\n## 4、 删除数组尾部元素\n一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。\n```h\nconst arr = [11, 22, 33, 44, 55, 66];\n// truncanting\narr.length = 3;\nconsole.log(arr); //=> [11, 22, 33]\n// clearing\narr.length = 0;\nconsole.log(arr); //=> []\nconsole.log(arr[2]); //=> undefined\n```\n## 5、 平铺多维数组\n使用Spread操作，可以很容易去平铺嵌套多维数组：  \n```h\nconst arr = [11, [22, 33], [44, 55], 66];\nconst flatArr = [].concat(...arr); //=> [11, 22, 33, 44, 55, 66]\n```\n可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。\n```h\nunction flattenArray(arr) {\n  const flattened = [].concat(...arr);\n  return flattened.some(item => Array.isArray(item)) ? \n    flattenArray(flattened) : flattened;\n}\n\nconst arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];\nconst flatArr = flattenArray(arr); \n//=> [11, 22, 33, 44, 55, 66, 77, 88, 99]\n```\n## 6、 格式化JSON代码\nJSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。\n```h\nconst obj = { \n  foo: { bar: [11, 22, 33, 44], baz: { bing: true, boom: 'Hello' } } \n};\n// The third parameter is the number of spaces used to \n// beautify the JSON output.\nJSON.stringify(obj, null, 4); \n// =>\"{\n// =>    \"foo\": {\n// =>        \"bar\": [\n// =>            11,\n// =>            22,\n// =>            33,\n// =>            44\n// =>        ],\n// =>        \"baz\": {\n// =>            \"bing\": true,\n// =>            \"boom\": \"Hello\"\n// =>        }\n// =>    }\n// =>}\"\n```\n## 7、 await多个async函数\n\n在使用async/await的时候，可以使用Promise.all来await多个async函数。\n```h\nawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()])\n```\n## 8、JSON对象和JSON数组添加删除元素\n\n```h\n\n（1）纯JSON文本可以这样\n\n\nvar json={\n   id:\"id1\",\n   name:\"开心\"\n};\n \n//添加\njson[\"gender\"]=\"男\"\njson[\"age\"]=26;\nalert(json.age);\n \n//删除\ndelete json[\"age\"];\nalert(json.age);\nalert(json.gender);\n\n\n正常对象的删除：\nvar o = new Object;\no.name = \"David\";\nalert(o.name); //输出 \"David\"\ndelete o.name;\nalert(o.name); //输出 \"undefined\"\n\n\n（2纯json对象的话就把以上的var json先json1 = JSON.parse(json)就可以了\n\n（3)如果用JSON数组文本的话可以这样\n\n\nvar mainArray = [\n    {\"tag\" :\"任务\",\"num\":2},\n    {\"tag\" :\"工作\" ,\"num\":6}\n];\n \nmainArray .push({\n   \"tag\":\"开会\",\"num\":3\n});\n \n\nmainArray.shift();//删除数组头元素\nmainArray.pop();//删除数组尾元素\n \n \n----------------------由object创建json文本格式的方法----------------------\n\n<p id=\"a\">ssss</p>\n<script>\nvar data = new Object();\ndata.name = \"airuikun\";\ndata.sex = \"man\";\nvar s = JSON.stringify(data);\ndocument.getElementById(\"a\").innerHTML = s;\n</script>\n\n```\n\n\n***\n\n\n\n\n\n{% note primary %} ` React ` {% endnote %}\n# React\n***\n\n## 1、 关于this.setState更新的问题\nthis.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法:\n\n1.回调函数callback\n```h\nthis.setState({\n  val: this.state.val+1\n}, () => {\n  console.log(this.state.val)\n});\n```\n\n2.componentDidUpdate\n\n```h\ncomponentDidUpdate(){\n    console.log(this.state.val);\n}\n```\n在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新\n\n3.将this.setState放入setTimeout函数中\n```h\nlet self = this;\nsetTimeout(function () {\n  self.setState({\n    val:self.state.val+1\n  });\n  console.log(self.state.val);\n})\n```\n\n在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。\n\n\n***\n\n\n\n{% note warning %} `PHP` {% endnote %}\n# PHP\n\n## php 字符串中是否包含指定字符串的多种方法\n\n### 1. strstr\n\nstrstr() 函数搜索一个字符串在另一个字符串中的第一次出现。\n该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。\n\n代码如下:\n```h\n<?php\n /*如手册上的举例*/\n $email = 'user@example.com';\n $domain = strstr($email, '@');\n echo $domain;\n // prints @example.com\n?>\n```\n\n### 2. stristr\n\nstristr() 函数查找字符串在另一个字符串中第一次出现的位置。\n如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。\n\n它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写.\n\n### 3. strpos\n\nstrpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好.\n\n实例1\n```h\nif(strpos('www.jb51.net','jb51') !== false){ \n echo '包含jb51'; \n}else{\n echo '不包含jb51'; \n}\n```\n实例2\n```h\n$str= 'abc';\n$needle= 'a';\n$pos = strpos($str, $needle); // 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False\n```\n\n### 4. explode\n\n用explode进行判断PHP判断字符串的包含代码如下:\n```h\nfunction checkstr($str){\n $needle ='a';//判断是否包含a这个字符\n $tmparray = explode($needle,$str);\n if(count($tmparray)>1){\n  return true;\n } else{\n  return false;\n }\n}\n```\n### 5、substr例如我们需要判断最后一个字符是不是制定字符\n\n```h\n<?php\n/*\n$str1=\"<p>这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll</p>\";\nif(substr($str1,-8)==\".dll</p>\"){\necho substr($str1,0,-4);\n}\n```\n### 6、substr_count统计“子字符串”在“原始字符串中出现的次数”\n\nsubstr_count()函数本是一个小字符串在一个大字符串中出现的次数：\n$number = substr_count(big_string, small_string);\n正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle；\n\n查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：\n```h\nfunction check_str($str, $substr)\n{\n $nums=substr_count($str,$substr);\n  if ($nums>=1)\n  {\n   return true;\n  }\n  else\n  {\n   return false;\n  }\n}\n```\n\n***\n\n## php中数组和字符串的相互转换\n\n数组转字符串：\n```h\nimplode('!', $arr);//将一维数组以！分隔组合成一个字符串，参数一可以为\"\"\n```\n \n\n字符串转数组：\n```h\nexplode('!', $str);//将字符串以!分割为一个一维数组,参数一不可以为\"\"\n\nstr_split($str, 3);//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。\n\n```\n\n***\n\n## php的strpos() 函数判断字符串中是否包含某字符串的方法\n\n判断某字符串中是否包含某字符串的方法\n```h\nif(strpos('www.idc-gz.com','idc-gz') !== false){\n    echo '包含';\n}else{\n    echo '不包含';\n}\n\n```\n\n***\n\n## PHP中实现中文字串截取无乱码的方法\n在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。\n\n直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：\n```h\n1、使用mbstring扩展库的mb_substr截取就不会出现乱码了。\n\n2、自己书写截取函数，但效率不如用mbstring扩展库来得高。\n\n3、如果仅是为了输出截取的串，可用如下方式实现：substr($str, 0, 30).chr(0)。\n```\n\n=============================\n\nsubstr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。\n举个例子：\n```h\n<?php\necho mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');\n?>\n输出：这样一来我的字\n<?php\necho mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');\n?>\n输出：这样一\n从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。\n\n```\n\n***\n\n\n","source":"_posts/开发小锦囊.md","raw":"---\ntitle: 开发小锦囊\ndate: 2018-07-30 00:30:40\ntags: [Javascript,小程序,编程,React]\ndescription: \ncopyright: true\ncategories: 编程\ntop:\n---\n\n这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png)\n\n<!-- more -->\n\n{% note danger %} `JavaScript` {% endnote %}\n\n# JavaScript\n\n## 1、js 判断字符串中是否包含某个字符串\n\n> String对象的方法\n\n方法一: indexOf()   (推荐)\n\n```h\nvar str = \"123\";\nconsole.log(str.indexOf(\"3\") != -1 );  // true\nindexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。\n\n```\n\n方法二: search() \n```h\nvar str = \"123\";\nconsole.log(str.search(\"3\") != -1 );  // true\nsearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。\n```\n \n方法三:match()\n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nif(str.match(reg)){\n    // 包含        \n}\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n```\n \n> RegExp 对象方法\n\n\n方法四:test() \n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nconsole.log(reg.test(str)); // true\ntest() 方法用于检索字符串中指定的值。返回 true 或 false。\n```\n \n\n方法五:exec()\n```h\nvar str = \"123\";\nvar reg = RegExp(/3/);\nif(reg.exec(str)){\n    // 包含        \n}\nexec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\n```\n\n## 2、 JS中every()和some()的用法\n\n> every()与some()方法都是JS中数组的迭代方法。\n\nevery()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。\n\nsome()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。\n\n```h\nvar arr = [ 1, 2, 3, 4, 5, 6 ]; \n \nconsole.log( arr.some( function( item, index, array ){ \n    console.log( 'item=' + item + ',index='+index+',array='+array ); \n    return item > 3; \n})); \n \nconsole.log( arr.every( function( item, index, array ){ \n    console.log( 'item=' + item + ',index='+index+',array='+array ); \n    return item > 3; \n}));\n```\n\n## 3、 用Set为数组去重\n```h\nvar arr = [1,2,2,3,4] // 需要去重的数组\n\nvar set = new Set(arr) // {1,2,3,4}\nvar newArr = Array.from(set) // 再把set转变成array\n\nconsole.log(newArr) // [1,2,3,4]\n```\n## 4、 删除数组尾部元素\n一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。\n```h\nconst arr = [11, 22, 33, 44, 55, 66];\n// truncanting\narr.length = 3;\nconsole.log(arr); //=> [11, 22, 33]\n// clearing\narr.length = 0;\nconsole.log(arr); //=> []\nconsole.log(arr[2]); //=> undefined\n```\n## 5、 平铺多维数组\n使用Spread操作，可以很容易去平铺嵌套多维数组：  \n```h\nconst arr = [11, [22, 33], [44, 55], 66];\nconst flatArr = [].concat(...arr); //=> [11, 22, 33, 44, 55, 66]\n```\n可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。\n```h\nunction flattenArray(arr) {\n  const flattened = [].concat(...arr);\n  return flattened.some(item => Array.isArray(item)) ? \n    flattenArray(flattened) : flattened;\n}\n\nconst arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];\nconst flatArr = flattenArray(arr); \n//=> [11, 22, 33, 44, 55, 66, 77, 88, 99]\n```\n## 6、 格式化JSON代码\nJSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。\n```h\nconst obj = { \n  foo: { bar: [11, 22, 33, 44], baz: { bing: true, boom: 'Hello' } } \n};\n// The third parameter is the number of spaces used to \n// beautify the JSON output.\nJSON.stringify(obj, null, 4); \n// =>\"{\n// =>    \"foo\": {\n// =>        \"bar\": [\n// =>            11,\n// =>            22,\n// =>            33,\n// =>            44\n// =>        ],\n// =>        \"baz\": {\n// =>            \"bing\": true,\n// =>            \"boom\": \"Hello\"\n// =>        }\n// =>    }\n// =>}\"\n```\n## 7、 await多个async函数\n\n在使用async/await的时候，可以使用Promise.all来await多个async函数。\n```h\nawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()])\n```\n## 8、JSON对象和JSON数组添加删除元素\n\n```h\n\n（1）纯JSON文本可以这样\n\n\nvar json={\n   id:\"id1\",\n   name:\"开心\"\n};\n \n//添加\njson[\"gender\"]=\"男\"\njson[\"age\"]=26;\nalert(json.age);\n \n//删除\ndelete json[\"age\"];\nalert(json.age);\nalert(json.gender);\n\n\n正常对象的删除：\nvar o = new Object;\no.name = \"David\";\nalert(o.name); //输出 \"David\"\ndelete o.name;\nalert(o.name); //输出 \"undefined\"\n\n\n（2纯json对象的话就把以上的var json先json1 = JSON.parse(json)就可以了\n\n（3)如果用JSON数组文本的话可以这样\n\n\nvar mainArray = [\n    {\"tag\" :\"任务\",\"num\":2},\n    {\"tag\" :\"工作\" ,\"num\":6}\n];\n \nmainArray .push({\n   \"tag\":\"开会\",\"num\":3\n});\n \n\nmainArray.shift();//删除数组头元素\nmainArray.pop();//删除数组尾元素\n \n \n----------------------由object创建json文本格式的方法----------------------\n\n<p id=\"a\">ssss</p>\n<script>\nvar data = new Object();\ndata.name = \"airuikun\";\ndata.sex = \"man\";\nvar s = JSON.stringify(data);\ndocument.getElementById(\"a\").innerHTML = s;\n</script>\n\n```\n\n\n***\n\n\n\n\n\n{% note primary %} ` React ` {% endnote %}\n# React\n***\n\n## 1、 关于this.setState更新的问题\nthis.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法:\n\n1.回调函数callback\n```h\nthis.setState({\n  val: this.state.val+1\n}, () => {\n  console.log(this.state.val)\n});\n```\n\n2.componentDidUpdate\n\n```h\ncomponentDidUpdate(){\n    console.log(this.state.val);\n}\n```\n在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新\n\n3.将this.setState放入setTimeout函数中\n```h\nlet self = this;\nsetTimeout(function () {\n  self.setState({\n    val:self.state.val+1\n  });\n  console.log(self.state.val);\n})\n```\n\n在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。\n\n\n***\n\n\n\n{% note warning %} `PHP` {% endnote %}\n# PHP\n\n## php 字符串中是否包含指定字符串的多种方法\n\n### 1. strstr\n\nstrstr() 函数搜索一个字符串在另一个字符串中的第一次出现。\n该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。\n\n代码如下:\n```h\n<?php\n /*如手册上的举例*/\n $email = 'user@example.com';\n $domain = strstr($email, '@');\n echo $domain;\n // prints @example.com\n?>\n```\n\n### 2. stristr\n\nstristr() 函数查找字符串在另一个字符串中第一次出现的位置。\n如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。\n\n它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写.\n\n### 3. strpos\n\nstrpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好.\n\n实例1\n```h\nif(strpos('www.jb51.net','jb51') !== false){ \n echo '包含jb51'; \n}else{\n echo '不包含jb51'; \n}\n```\n实例2\n```h\n$str= 'abc';\n$needle= 'a';\n$pos = strpos($str, $needle); // 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False\n```\n\n### 4. explode\n\n用explode进行判断PHP判断字符串的包含代码如下:\n```h\nfunction checkstr($str){\n $needle ='a';//判断是否包含a这个字符\n $tmparray = explode($needle,$str);\n if(count($tmparray)>1){\n  return true;\n } else{\n  return false;\n }\n}\n```\n### 5、substr例如我们需要判断最后一个字符是不是制定字符\n\n```h\n<?php\n/*\n$str1=\"<p>这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll</p>\";\nif(substr($str1,-8)==\".dll</p>\"){\necho substr($str1,0,-4);\n}\n```\n### 6、substr_count统计“子字符串”在“原始字符串中出现的次数”\n\nsubstr_count()函数本是一个小字符串在一个大字符串中出现的次数：\n$number = substr_count(big_string, small_string);\n正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle；\n\n查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：\n```h\nfunction check_str($str, $substr)\n{\n $nums=substr_count($str,$substr);\n  if ($nums>=1)\n  {\n   return true;\n  }\n  else\n  {\n   return false;\n  }\n}\n```\n\n***\n\n## php中数组和字符串的相互转换\n\n数组转字符串：\n```h\nimplode('!', $arr);//将一维数组以！分隔组合成一个字符串，参数一可以为\"\"\n```\n \n\n字符串转数组：\n```h\nexplode('!', $str);//将字符串以!分割为一个一维数组,参数一不可以为\"\"\n\nstr_split($str, 3);//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。\n\n```\n\n***\n\n## php的strpos() 函数判断字符串中是否包含某字符串的方法\n\n判断某字符串中是否包含某字符串的方法\n```h\nif(strpos('www.idc-gz.com','idc-gz') !== false){\n    echo '包含';\n}else{\n    echo '不包含';\n}\n\n```\n\n***\n\n## PHP中实现中文字串截取无乱码的方法\n在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。\n\n直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：\n```h\n1、使用mbstring扩展库的mb_substr截取就不会出现乱码了。\n\n2、自己书写截取函数，但效率不如用mbstring扩展库来得高。\n\n3、如果仅是为了输出截取的串，可用如下方式实现：substr($str, 0, 30).chr(0)。\n```\n\n=============================\n\nsubstr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。\n举个例子：\n```h\n<?php\necho mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');\n?>\n输出：这样一来我的字\n<?php\necho mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');\n?>\n输出：这样一\n从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。\n\n```\n\n***\n\n\n","slug":"开发小锦囊","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnf80042kt89yqk852c7","content":"<p>这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<div class=\"note danger\"><p><code>JavaScript</code> </p></div>\n\n# JavaScript\n\n## 1、js 判断字符串中是否包含某个字符串\n\n> String对象的方法\n\n方法一: indexOf()   (推荐)\n\nundefined\n\n方法二: search() \nundefined\n\n \n方法三:match()\nundefined\n\n \n> RegExp 对象方法\n\n\n方法四:test() \nundefined\n\n \n\n方法五:exec()\nundefined\n\n## 2、 JS中every()和some()的用法\n\n> every()与some()方法都是JS中数组的迭代方法。\n\nevery()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。\n\nsome()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。\n\nundefined\n\n## 3、 用Set为数组去重\nundefined\n\n## 4、 删除数组尾部元素\n一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。\nundefined\n\n## 5、 平铺多维数组\n使用Spread操作，可以很容易去平铺嵌套多维数组：  \nundefined\n\n可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。\nundefined\n\n## 6、 格式化JSON代码\nJSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。\nundefined\n\n## 7、 await多个async函数\n\n在使用async/await的时候，可以使用Promise.all来await多个async函数。\nundefined\n\n## 8、JSON对象和JSON数组添加删除元素\n\nundefined\n\n***\n\n\n\n\n\n<div class=\"note primary\"><p><code>React</code> </p></div>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><hr>\n<h2 id=\"1、-关于this-setState更新的问题\"><a href=\"#1、-关于this-setState更新的问题\" class=\"headerlink\" title=\"1、 关于this.setState更新的问题\"></a>1、 关于this.setState更新的问题</h2><p>this.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法:</p>\n<p>1.回调函数callback<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  val: <span class=\"keyword\">this</span>.state.val+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>.state.val)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>2.componentDidUpdate</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidUpdate()&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>.state.val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新</p>\n<p>3.将this.setState放入setTimeout函数中<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">  self.setState(&#123;</span><br><span class=\"line\">    val:self.state.val+<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(self.state.val);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。</p>\n<hr>\n<div class=\"note warning\"><p><code>PHP</code> </p></div>\n<h1 id=\"PHP\"><a href=\"#PHP\" class=\"headerlink\" title=\"PHP\"></a>PHP</h1><h2 id=\"php-字符串中是否包含指定字符串的多种方法\"><a href=\"#php-字符串中是否包含指定字符串的多种方法\" class=\"headerlink\" title=\"php 字符串中是否包含指定字符串的多种方法\"></a>php 字符串中是否包含指定字符串的多种方法</h2><h3 id=\"1-strstr\"><a href=\"#1-strstr\" class=\"headerlink\" title=\"1. strstr\"></a>1. strstr</h3><p>strstr() 函数搜索一个字符串在另一个字符串中的第一次出现。<br>该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。</p>\n<p>代码如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"> <span class=\"comment\">/*如手册上的举例*/</span></span><br><span class=\"line\"> $email = 'user@example.com';</span><br><span class=\"line\"> $domain = <span class=\"built_in\">strstr</span>($email, <span class=\"string\">'@'</span>);</span><br><span class=\"line\"> echo $domain;</span><br><span class=\"line\"> <span class=\"comment\">// prints @example.com</span></span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-stristr\"><a href=\"#2-stristr\" class=\"headerlink\" title=\"2. stristr\"></a>2. stristr</h3><p>stristr() 函数查找字符串在另一个字符串中第一次出现的位置。<br>如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。</p>\n<p>它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写.</p>\n<h3 id=\"3-strpos\"><a href=\"#3-strpos\" class=\"headerlink\" title=\"3. strpos\"></a>3. strpos</h3><p>strpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好.</p>\n<p>实例1<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(strpos('www.jb51.net','jb51') !== false)&#123; </span><br><span class=\"line\"> echo '包含jb51'; </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"> echo '不包含jb51'; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例2<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$str= 'abc';</span><br><span class=\"line\">$needle= <span class=\"string\">'a'</span>;</span><br><span class=\"line\">$pos = strpos($str, $needle); <span class=\"comment\">// 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-explode\"><a href=\"#4-explode\" class=\"headerlink\" title=\"4. explode\"></a>4. explode</h3><p>用explode进行判断PHP判断字符串的包含代码如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">checkstr</span><span class=\"params\">($str)</span></span>&#123;</span><br><span class=\"line\"> $needle =<span class=\"string\">'a'</span>;<span class=\"comment\">//判断是否包含a这个字符</span></span><br><span class=\"line\"> $tmparray = explode($needle,$str);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(count($tmparray)&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5、substr例如我们需要判断最后一个字符是不是制定字符\"><a href=\"#5、substr例如我们需要判断最后一个字符是不是制定字符\" class=\"headerlink\" title=\"5、substr例如我们需要判断最后一个字符是不是制定字符\"></a>5、substr例如我们需要判断最后一个字符是不是制定字符</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">$str1=\"&lt;p&gt;这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll&lt;/p&gt;\";</span></span><br><span class=\"line\"><span class=\"comment\">if(substr($str1,-8)==\".dll&lt;/p&gt;\")&#123;</span></span><br><span class=\"line\"><span class=\"comment\">echo substr($str1,0,-4);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6、substr-count统计“子字符串”在“原始字符串中出现的次数”\"><a href=\"#6、substr-count统计“子字符串”在“原始字符串中出现的次数”\" class=\"headerlink\" title=\"6、substr_count统计“子字符串”在“原始字符串中出现的次数”\"></a>6、substr_count统计“子字符串”在“原始字符串中出现的次数”</h3><p>substr_count()函数本是一个小字符串在一个大字符串中出现的次数：<br>$number = substr_count(big_string, small_string);<br>正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle；</p>\n<p>查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">check_str</span><span class=\"params\">($str, $substr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> $nums=substr_count($str,$substr);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($nums&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"php中数组和字符串的相互转换\"><a href=\"#php中数组和字符串的相互转换\" class=\"headerlink\" title=\"php中数组和字符串的相互转换\"></a>php中数组和字符串的相互转换</h2><p>数组转字符串：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implode(<span class=\"string\">'!'</span>, $arr);<span class=\"comment\">//将一维数组以！分隔组合成一个字符串，参数一可以为\"\"</span></span><br></pre></td></tr></table></figure></p>\n<p>字符串转数组：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explode(<span class=\"string\">'!'</span>, $str);<span class=\"comment\">//将字符串以!分割为一个一维数组,参数一不可以为\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">str_split($str, <span class=\"number\">3</span>);<span class=\"comment\">//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"php的strpos-函数判断字符串中是否包含某字符串的方法\"><a href=\"#php的strpos-函数判断字符串中是否包含某字符串的方法\" class=\"headerlink\" title=\"php的strpos() 函数判断字符串中是否包含某字符串的方法\"></a>php的strpos() 函数判断字符串中是否包含某字符串的方法</h2><p>判断某字符串中是否包含某字符串的方法<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(strpos('www.idc-gz.com','idc-gz') !== false)&#123;</span><br><span class=\"line\">    echo '包含';</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    echo '不包含';</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"PHP中实现中文字串截取无乱码的方法\"><a href=\"#PHP中实现中文字串截取无乱码的方法\" class=\"headerlink\" title=\"PHP中实现中文字串截取无乱码的方法\"></a>PHP中实现中文字串截取无乱码的方法</h2><p>在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。</p>\n<p>直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、使用mbstring扩展库的mb_substr截取就不会出现乱码了。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>、自己书写截取函数，但效率不如用mbstring扩展库来得高。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>、如果仅是为了输出截取的串，可用如下方式实现：substr($str, <span class=\"number\">0</span>, <span class=\"number\">30</span>).chr(<span class=\"number\">0</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>=============================</p>\n<p>substr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。<br>举个例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">输出：这样一来我的字</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">输出：这样一</span><br><span class=\"line\">从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。</span><br></pre></td></tr></table></figure></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>这里会收录一下遇到的，或者解决问题的方法。大家有好的见解也可以Git提交。<br><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webjingnang.png\" alt=\"js\"></p>","more":"<div class=\"note danger\"><p><code>JavaScript</code> </p></div>\n\n# JavaScript\n\n## 1、js 判断字符串中是否包含某个字符串\n\n> String对象的方法\n\n方法一: indexOf()   (推荐)\n\nundefined\n\n方法二: search() \nundefined\n\n \n方法三:match()\nundefined\n\n \n> RegExp 对象方法\n\n\n方法四:test() \nundefined\n\n \n\n方法五:exec()\nundefined\n\n## 2、 JS中every()和some()的用法\n\n> every()与some()方法都是JS中数组的迭代方法。\n\nevery()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。\n\nsome()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。\n\nundefined\n\n## 3、 用Set为数组去重\nundefined\n\n## 4、 删除数组尾部元素\n一个简单的用来清空或则删除数组尾部元素的简单方法就是改变数组的length属性值。\nundefined\n\n## 5、 平铺多维数组\n使用Spread操作，可以很容易去平铺嵌套多维数组：  \nundefined\n\n可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。\nundefined\n\n## 6、 格式化JSON代码\nJSON.stringify不止可以将一个对象字符化，还可以格式化输出JSON对象。\nundefined\n\n## 7、 await多个async函数\n\n在使用async/await的时候，可以使用Promise.all来await多个async函数。\nundefined\n\n## 8、JSON对象和JSON数组添加删除元素\n\nundefined\n\n***\n\n\n\n\n\n<div class=\"note primary\"><p><code>React</code> </p></div>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><hr>\n<h2 id=\"1、-关于this-setState更新的问题\"><a href=\"#1、-关于this-setState更新的问题\" class=\"headerlink\" title=\"1、 关于this.setState更新的问题\"></a>1、 关于this.setState更新的问题</h2><p>this.setState是异步，所以在this.setState之后立即调用this.state是获取不到最新的数据的，那么怎么获取最新的数据呢？下面介绍三个方法:</p>\n<p>1.回调函数callback<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  val: <span class=\"keyword\">this</span>.state.val+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>.state.val)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>2.componentDidUpdate</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidUpdate()&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>.state.val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在this.setState之后去componentDidUpdate函数中调用，此时的this.state已经更新</p>\n<p>3.将this.setState放入setTimeout函数中<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">  self.setState(&#123;</span><br><span class=\"line\">    val:self.state.val+<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(self.state.val);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在setTimeout函数中，在this.setState之后this.state是立即更新的，所以也可以获取到更新后的数据。</p>\n<hr>\n<div class=\"note warning\"><p><code>PHP</code> </p></div>\n<h1 id=\"PHP\"><a href=\"#PHP\" class=\"headerlink\" title=\"PHP\"></a>PHP</h1><h2 id=\"php-字符串中是否包含指定字符串的多种方法\"><a href=\"#php-字符串中是否包含指定字符串的多种方法\" class=\"headerlink\" title=\"php 字符串中是否包含指定字符串的多种方法\"></a>php 字符串中是否包含指定字符串的多种方法</h2><h3 id=\"1-strstr\"><a href=\"#1-strstr\" class=\"headerlink\" title=\"1. strstr\"></a>1. strstr</h3><p>strstr() 函数搜索一个字符串在另一个字符串中的第一次出现。<br>该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。</p>\n<p>代码如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"> <span class=\"comment\">/*如手册上的举例*/</span></span><br><span class=\"line\"> $email = 'user@example.com';</span><br><span class=\"line\"> $domain = <span class=\"built_in\">strstr</span>($email, <span class=\"string\">'@'</span>);</span><br><span class=\"line\"> echo $domain;</span><br><span class=\"line\"> <span class=\"comment\">// prints @example.com</span></span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-stristr\"><a href=\"#2-stristr\" class=\"headerlink\" title=\"2. stristr\"></a>2. stristr</h3><p>stristr() 函数查找字符串在另一个字符串中第一次出现的位置。<br>如果成功，则返回字符串的其余部分（从匹配点）。如果没有找到该字符串，则返回 false。</p>\n<p>它和strstr的使用方法完全一样.唯一的区别是stristr不区分大小写.</p>\n<h3 id=\"3-strpos\"><a href=\"#3-strpos\" class=\"headerlink\" title=\"3. strpos\"></a>3. strpos</h3><p>strpos函数返回boolean值.FALSE和TRUE不用多说.用 “===”进行判断.strpos在执行速度上都比以上两个函数快,另外strpos有一个参数指定判断的位置,但是默认为空.意思是判断整个字符串.缺点是对中文的支持不好.</p>\n<p>实例1<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(strpos('www.jb51.net','jb51') !== false)&#123; </span><br><span class=\"line\"> echo '包含jb51'; </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"> echo '不包含jb51'; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例2<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$str= 'abc';</span><br><span class=\"line\">$needle= <span class=\"string\">'a'</span>;</span><br><span class=\"line\">$pos = strpos($str, $needle); <span class=\"comment\">// 返回第一次找到改字符串的位置，这里返回为1，若查不到则返回False</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-explode\"><a href=\"#4-explode\" class=\"headerlink\" title=\"4. explode\"></a>4. explode</h3><p>用explode进行判断PHP判断字符串的包含代码如下:<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">checkstr</span><span class=\"params\">($str)</span></span>&#123;</span><br><span class=\"line\"> $needle =<span class=\"string\">'a'</span>;<span class=\"comment\">//判断是否包含a这个字符</span></span><br><span class=\"line\"> $tmparray = explode($needle,$str);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(count($tmparray)&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5、substr例如我们需要判断最后一个字符是不是制定字符\"><a href=\"#5、substr例如我们需要判断最后一个字符是不是制定字符\" class=\"headerlink\" title=\"5、substr例如我们需要判断最后一个字符是不是制定字符\"></a>5、substr例如我们需要判断最后一个字符是不是制定字符</h3><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">$str1=\"&lt;p&gt;这是个winrar专用的dll然后下哦啊不错的dll文件，QlogWin32.dll&lt;/p&gt;\";</span></span><br><span class=\"line\"><span class=\"comment\">if(substr($str1,-8)==\".dll&lt;/p&gt;\")&#123;</span></span><br><span class=\"line\"><span class=\"comment\">echo substr($str1,0,-4);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6、substr-count统计“子字符串”在“原始字符串中出现的次数”\"><a href=\"#6、substr-count统计“子字符串”在“原始字符串中出现的次数”\" class=\"headerlink\" title=\"6、substr_count统计“子字符串”在“原始字符串中出现的次数”\"></a>6、substr_count统计“子字符串”在“原始字符串中出现的次数”</h3><p>substr_count()函数本是一个小字符串在一个大字符串中出现的次数：<br>$number = substr_count(big_string, small_string);<br>正好今天需要一个查找字符串的函数，要实现判断字符串big_string是否包含字符串small_string，返回true或fasle；</p>\n<p>查了半天手册没有找到现成的函数，于是想到可以用substr_count函数来实现代码如下：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">check_str</span><span class=\"params\">($str, $substr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> $nums=substr_count($str,$substr);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($nums&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"php中数组和字符串的相互转换\"><a href=\"#php中数组和字符串的相互转换\" class=\"headerlink\" title=\"php中数组和字符串的相互转换\"></a>php中数组和字符串的相互转换</h2><p>数组转字符串：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implode(<span class=\"string\">'!'</span>, $arr);<span class=\"comment\">//将一维数组以！分隔组合成一个字符串，参数一可以为\"\"</span></span><br></pre></td></tr></table></figure></p>\n<p>字符串转数组：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explode(<span class=\"string\">'!'</span>, $str);<span class=\"comment\">//将字符串以!分割为一个一维数组,参数一不可以为\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">str_split($str, <span class=\"number\">3</span>);<span class=\"comment\">//将字符串分割成数组，参数二将字符串从左向右每3个字符分割一次，最后的不够3个了 有几个算几个。</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"php的strpos-函数判断字符串中是否包含某字符串的方法\"><a href=\"#php的strpos-函数判断字符串中是否包含某字符串的方法\" class=\"headerlink\" title=\"php的strpos() 函数判断字符串中是否包含某字符串的方法\"></a>php的strpos() 函数判断字符串中是否包含某字符串的方法</h2><p>判断某字符串中是否包含某字符串的方法<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(strpos('www.idc-gz.com','idc-gz') !== false)&#123;</span><br><span class=\"line\">    echo '包含';</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    echo '不包含';</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"PHP中实现中文字串截取无乱码的方法\"><a href=\"#PHP中实现中文字串截取无乱码的方法\" class=\"headerlink\" title=\"PHP中实现中文字串截取无乱码的方法\"></a>PHP中实现中文字串截取无乱码的方法</h2><p>在PHP中，substr()函数截取带有中文字符串的话，可能会出现乱码，这是因为中西文一个字节所占有的字节数不一样，而substr的长度参数是按照字节去算的，在GB2312编码时，一个中文占2个字节，英文为1个字节，而在UTF-8编码当中，一个中文可能占有2个或3个字节，英文或半角标点占1字节。</p>\n<p>直接使用PHP函数substr截取中文字符可能会出现乱码，主要是substr可能硬生生的将一个中文字符“锯”成两半。解决办法：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、使用mbstring扩展库的mb_substr截取就不会出现乱码了。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>、自己书写截取函数，但效率不如用mbstring扩展库来得高。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>、如果仅是为了输出截取的串，可用如下方式实现：substr($str, <span class=\"number\">0</span>, <span class=\"number\">30</span>).chr(<span class=\"number\">0</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>=============================</p>\n<p>substr()函数可以分割文字，但要分割的文字如果包括中文字符往往会遇到问题，这时可以用mb_substr()/mb_strcut这个函数，mb_substr()/mb_strcut的用法与substr()相似，只是在mb_substr()/mb_strcut最后要加入多一个参数，以设定字符串的编码，但是一般的服务器都没打开php_mbstring.dll，需要在php.ini在把php_mbstring.dll打开。<br>举个例子：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">输出：这样一来我的字</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">输出：这样一</span><br><span class=\"line\">从上面的例子可以看出，mb_substr是按字来切分字符，而mb_strcut是按字节来切分字符，但是都不会产生半个字符的现象。</span><br></pre></td></tr></table></figure></p>\n<hr>"},{"title":"怎样在JS里尽量少写for循环","date":"2018-07-29T15:39:15.000Z","description":null,"copyright":false,"top":null,"_content":" \n\"很多场景，for来的更直接，更明了。\"  \"最喜欢for循环了。想break就break。可能会多数据的还是for循环。\" \"for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响\",这是很多时候都会考虑的问题。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# 用好 filter，map，和其它 ES6 新增的高阶遍历函数\n\n问题一： 将数组中的空值去除\n```h\n\nconst arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, \"\"];\n\n答案：\n\nconst compact = arr => arr.filter(Boolean);\n\n```\n问题二： 将数组中的 VIP 用户余额加 10\n```h\n\nconst users = [\n  { username: \"Kelly\", isVIP: true, balance: 20 },\n  { username: \"Tom\", isVIP: false, balance: 19 },\n  { username: \"Stephanie\", isVIP: true, balance: 30 }\n];\n\n\n答案：\n\nusers.map(\n  user => (user.isVIP ? { ...user, balance: user.balance + 10 } : user)\n);\n\n\n补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。\n\n```\n问题三： 判断字符串中是否含有元音字母\n```h\n\nconst randomStr = \"hdjrwqpi\";\n\n答案：\n\nconst isVowel = char => [\"a\", \"e\", \"o\", \"i\", \"u\"].includes(char);\nconst containsVowel = str => [...str].some(isVowel);\n\ncontainsVowel(randomStr);\n\n\n```\n问题四： 判断用户是否全部是成年人\n```h\nconst users = [\n  { name: \"Jim\", age: 23 },\n  { name: \"Lily\", age: 17 },\n  { name: \"Will\", age: 25 }\n];\n\n答案：\n\nusers.every(user => user.age >= 18);\n\n\n```\n问题五： 找出上面用户中的未成年人\n```h\n\nconst users = [\n  { name: \"Jim\", age: 23 },\n  { name: \"Lily\", age: 17 },\n  { name: \"Will\", age: 25 }\n];\n答案：\n\nconst findTeen = users => users.find(user => user.age < 18);\n\nfindTeen(users);\n\n\n```\n问题六： 将数组中重复项清除\n```h\n\nconst dupArr = [1, 2, 3, 3, 3, 3, 6, 7];\n\n答案：\n\nconst uniq = arr => [...new Set(arr)];\n\nuniq(dupArr);\n\n```\n问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义\n```h\n答案：\nconst genNumArr = (length, limit) =>\n  Array.from({ length }, _ => Math.floor(Math.random() * limit));\n\ngenNumArr(10, 100);\n\n```\n# 理解和熟练使用 reduce\n\n问题一： 不借助原生高阶函数，定义 reduce\n```h\n答案：\nconst reduce = (f, acc, arr) => {\n  if (arr.length === 0) return acc;\n  const [head, ...tail] = arr;\n  return reduce(f, f(head, acc), tail);\n};\n\n```\n问题二： 将多层数组转换成一层数组\n```h\n\nconst nestedArr = [1, 2, [3, 4, [5, 6]]];\n\n答案：\n\nconst flatten = arr =>\n  arr.reduce(\n    (flat, next) => flat.concat(Array.isArray(next) ? flatten(next) : next),\n    []\n  );\n\n```\n问题三：将下面数组转成对象，key/value 对应里层数组的两个值\n```h\n\nconst objLikeArr = [[\"name\", \"Jim\"], [\"age\", 18], [\"single\", true]];\n\n答案：\n\nconst fromPairs = pairs =>\n  pairs.reduce((res, pair) => ((res[pair[0]] = pair[1]), res), {});\n\nfromPairs(objLikeArr);\n\n```\n问题四： 取出对象中的深层属性\n```h\n\nconst deepAttr = { a: { b: { c: 15 } } };\n\n答案：\n\nconst pluckDeep = path => obj =>\n  path.split(\".\").reduce((val, attr) => val[attr], obj);\n\npluckDeep(\"a.b.c\")(deepAttr);\n\n```\n问题五：将用户中的男性和女性分别放到不同的数组里：\n```h\n\nconst users = [\n  { name: \"Adam\", age: 30, sex: \"male\" },\n  { name: \"Helen\", age: 27, sex: \"female\" },\n  { name: \"Amy\", age: 25, sex: \"female\" },\n  { name: \"Anthony\", age: 23, sex: \"male\" },\n];\n\n答案：\n\nconst partition = (arr, isValid) =>\n  arr.reduce(\n    ([pass, fail], elem) =>\n      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],\n    [[], []],\n  );\n  \nconst isMale = person => person.sex === \"male\";\n\nconst [maleUser, femaleUser] = partition(users, isMale);\n\n```\n问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）\n\n```h\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed);\n    return res ? go(f, res[1], acc.concat(res[0])) : acc;\n  };\n  return go(f, seed, []);\n};\n根据这个 unfold 函数，定义一个 Python 里面的 range 函数。\n答案：\n\nconst range = (min, max, step = 1) =>\n  unfold(x => x < max && [x, x + step], min);\n\n```\n# 用递归代替循环（可以break！）\n\n\n问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。\n```h\n\nconst num1 = [3, 4, 5, 6, 7];\nconst num2 = [43, 23, 5, 67, 87, 3, 6];\n\n答案：\n\nconst zipWith = f => xs => ys => {\n  if (xs.length === 0 || ys.length === 0) return [];\n  const [xHead, ...xTail] = xs;\n  const [yHead, ...yTail] = ys;\n  return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];\n};\n\nconst add = x => y => x + y;\n\nzipWith(add)(num1)(num2);\n\n```\n问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。\n```h\n\nconst houses = [\n  \"Eddard Stark\",\n  \"Catelyn Stark\",\n  \"Rickard Stark\",\n  \"Brandon Stark\",\n  \"Rob Stark\",\n  \"Sansa Stark\",\n  \"Arya Stark\",\n  \"Bran Stark\",\n  \"Rickon Stark\",\n  \"Lyanna Stark\",\n  \"Tywin Lannister\",\n  \"Cersei Lannister\",\n  \"Jaime Lannister\",\n  \"Tyrion Lannister\",\n  \"Joffrey Baratheon\"\n];\n\n答案：\n\nconst takeWhile = f => ([head, ...tail]) =>\n  f(head) ? [head, ...takeWhile(f)(tail)] : [];\n\nconst isStark = name => name.toLowerCase().includes(\"stark\");\n\ntakeWhile(isStark)(houses);\n\n```\n问题二： 找出数组中的奇数，然后取出前4个：\n```h\n\nconst numList = [1, 3, 11, 4, 2, 5, 6, 7];\n\n答案：\n\nconst takeFirst = (limit, f, arr) => {\n  if (limit === 0 || arr.length === 0) return [];\n  const [head, ...tail] = arr;\n  return f(head)\n    ? [head, ...takeFirst(limit - 1, f, tail)]\n    : takeFirst(limit, f, tail);\n};\n\nconst isOdd = n => n % 2 === 1;\n\ntakeFirst(4, isOdd, numList);\n\n```\n# 使用高阶函数遍历数组时可能遇到的陷阱\n\n问题一：  从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3\n```h\n\n// 用我们刚刚定义的辅助函数来生成符合要求的数组\nconst bigArr = genNumArr(1e6, 100);\n\n答案：\n\nconst isEven = num => num % 2 === 0;\nconst triple = num => num * 3;\n\nbigArr.filter(isEven).map(triple);\n\n// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：\n\nconst results = [];\nfor (let i = 0; i < bigArr.length; i++) {\n  if (isEven(bigArr[i])) {\n    results.push(triple(bigArr[i]));\n  }\n}\n\n// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！\n\n# Transduce\n\n先用 reduce 来定义 filter 和 map，至于为什么这样做等下再解释。\n```h\nconst filter = (f, arr) =>\n  arr.reduce((acc, val) => (f(val) && acc.push(val), acc), []);\n\nconst map = (f, arr) => arr.reduce((acc, val) => (acc.push(f(val)), acc), []);\n```\n重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：\n```h\nconst filter = f => reducer => (acc, value) => {\n  if (f(value)) return reducer(acc, value);\n  return acc;\n};\n\nconst map = f => reducer => (acc, value) => reducer(acc, f(value));\n```\n现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。\n```h\nconst pushReducer = (acc, value) => (acc.push(value), acc);\n\nbigNum.reduce(map(triple)(filter(isEven)(pushReducer)), []);\n```\n但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：\n```h\nconst pipe = (...fns) => (...args) => fns.reduce((fx, fy) => fy(fx), ...args);\n```\n然后我们就可以优雅地组合函数了：\n```h\nbigNum.reduce(\n  pipe(\n    filter(isEven),\n    map(triple)\n  )(pushReducer),\n  []\n);\n```\n经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。\n这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 [transducers-js](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcognitect-labs%2Ftransducers-js)。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。\n\n# for 循环和 for ... of 循环的区别\nfor ... of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for ... of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for ... of 来遍历数组是会被禁止的。\n那么，for ... of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个：\n\n```\n问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。\n```h\n\nconst starks = [\n  \"Eddard Stark\",\n  \"Catelyn Stark\",\n  \"Rickard Stark\",\n  \"Brandon Stark\",\n  \"Rob Stark\",\n  \"Sansa Stark\",\n  \"Arya Stark\",\n  \"Bran Stark\",\n  \"Rickon Stark\",\n  \"Lyanna Stark\"\n];\n\n答案：\n\nfunction* repeatedArr(arr) {\n  let i = 0;\n  while (true) {\n    yield arr[i++ % arr.length];\n  }\n}\n\nconst infiniteNameList = repeatedArr(starks);\n\nconst wait = ms =>\n  new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n\n(async () => {\n  for (const name of infiniteNameList) {\n    await wait(1000);\n    console.log(name);\n  }\n})();\n\n```\n前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。","source":"_posts/怎样在JS里尽量少写for循环.md","raw":"---\ntitle: 怎样在JS里尽量少写for循环\ndate: 2018-07-29 23:39:15\ntags: [Javascript,编程]\ndescription: \ncopyright: false\ncategories: Javascript\ntop:\n---\n \n\"很多场景，for来的更直接，更明了。\"  \"最喜欢for循环了。想break就break。可能会多数据的还是for循环。\" \"for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响\",这是很多时候都会考虑的问题。\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png)\n\n<!-- more -->\n\n# 用好 filter，map，和其它 ES6 新增的高阶遍历函数\n\n问题一： 将数组中的空值去除\n```h\n\nconst arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, \"\"];\n\n答案：\n\nconst compact = arr => arr.filter(Boolean);\n\n```\n问题二： 将数组中的 VIP 用户余额加 10\n```h\n\nconst users = [\n  { username: \"Kelly\", isVIP: true, balance: 20 },\n  { username: \"Tom\", isVIP: false, balance: 19 },\n  { username: \"Stephanie\", isVIP: true, balance: 30 }\n];\n\n\n答案：\n\nusers.map(\n  user => (user.isVIP ? { ...user, balance: user.balance + 10 } : user)\n);\n\n\n补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。\n\n```\n问题三： 判断字符串中是否含有元音字母\n```h\n\nconst randomStr = \"hdjrwqpi\";\n\n答案：\n\nconst isVowel = char => [\"a\", \"e\", \"o\", \"i\", \"u\"].includes(char);\nconst containsVowel = str => [...str].some(isVowel);\n\ncontainsVowel(randomStr);\n\n\n```\n问题四： 判断用户是否全部是成年人\n```h\nconst users = [\n  { name: \"Jim\", age: 23 },\n  { name: \"Lily\", age: 17 },\n  { name: \"Will\", age: 25 }\n];\n\n答案：\n\nusers.every(user => user.age >= 18);\n\n\n```\n问题五： 找出上面用户中的未成年人\n```h\n\nconst users = [\n  { name: \"Jim\", age: 23 },\n  { name: \"Lily\", age: 17 },\n  { name: \"Will\", age: 25 }\n];\n答案：\n\nconst findTeen = users => users.find(user => user.age < 18);\n\nfindTeen(users);\n\n\n```\n问题六： 将数组中重复项清除\n```h\n\nconst dupArr = [1, 2, 3, 3, 3, 3, 6, 7];\n\n答案：\n\nconst uniq = arr => [...new Set(arr)];\n\nuniq(dupArr);\n\n```\n问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义\n```h\n答案：\nconst genNumArr = (length, limit) =>\n  Array.from({ length }, _ => Math.floor(Math.random() * limit));\n\ngenNumArr(10, 100);\n\n```\n# 理解和熟练使用 reduce\n\n问题一： 不借助原生高阶函数，定义 reduce\n```h\n答案：\nconst reduce = (f, acc, arr) => {\n  if (arr.length === 0) return acc;\n  const [head, ...tail] = arr;\n  return reduce(f, f(head, acc), tail);\n};\n\n```\n问题二： 将多层数组转换成一层数组\n```h\n\nconst nestedArr = [1, 2, [3, 4, [5, 6]]];\n\n答案：\n\nconst flatten = arr =>\n  arr.reduce(\n    (flat, next) => flat.concat(Array.isArray(next) ? flatten(next) : next),\n    []\n  );\n\n```\n问题三：将下面数组转成对象，key/value 对应里层数组的两个值\n```h\n\nconst objLikeArr = [[\"name\", \"Jim\"], [\"age\", 18], [\"single\", true]];\n\n答案：\n\nconst fromPairs = pairs =>\n  pairs.reduce((res, pair) => ((res[pair[0]] = pair[1]), res), {});\n\nfromPairs(objLikeArr);\n\n```\n问题四： 取出对象中的深层属性\n```h\n\nconst deepAttr = { a: { b: { c: 15 } } };\n\n答案：\n\nconst pluckDeep = path => obj =>\n  path.split(\".\").reduce((val, attr) => val[attr], obj);\n\npluckDeep(\"a.b.c\")(deepAttr);\n\n```\n问题五：将用户中的男性和女性分别放到不同的数组里：\n```h\n\nconst users = [\n  { name: \"Adam\", age: 30, sex: \"male\" },\n  { name: \"Helen\", age: 27, sex: \"female\" },\n  { name: \"Amy\", age: 25, sex: \"female\" },\n  { name: \"Anthony\", age: 23, sex: \"male\" },\n];\n\n答案：\n\nconst partition = (arr, isValid) =>\n  arr.reduce(\n    ([pass, fail], elem) =>\n      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],\n    [[], []],\n  );\n  \nconst isMale = person => person.sex === \"male\";\n\nconst [maleUser, femaleUser] = partition(users, isMale);\n\n```\n问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）\n\n```h\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed);\n    return res ? go(f, res[1], acc.concat(res[0])) : acc;\n  };\n  return go(f, seed, []);\n};\n根据这个 unfold 函数，定义一个 Python 里面的 range 函数。\n答案：\n\nconst range = (min, max, step = 1) =>\n  unfold(x => x < max && [x, x + step], min);\n\n```\n# 用递归代替循环（可以break！）\n\n\n问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。\n```h\n\nconst num1 = [3, 4, 5, 6, 7];\nconst num2 = [43, 23, 5, 67, 87, 3, 6];\n\n答案：\n\nconst zipWith = f => xs => ys => {\n  if (xs.length === 0 || ys.length === 0) return [];\n  const [xHead, ...xTail] = xs;\n  const [yHead, ...yTail] = ys;\n  return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];\n};\n\nconst add = x => y => x + y;\n\nzipWith(add)(num1)(num2);\n\n```\n问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。\n```h\n\nconst houses = [\n  \"Eddard Stark\",\n  \"Catelyn Stark\",\n  \"Rickard Stark\",\n  \"Brandon Stark\",\n  \"Rob Stark\",\n  \"Sansa Stark\",\n  \"Arya Stark\",\n  \"Bran Stark\",\n  \"Rickon Stark\",\n  \"Lyanna Stark\",\n  \"Tywin Lannister\",\n  \"Cersei Lannister\",\n  \"Jaime Lannister\",\n  \"Tyrion Lannister\",\n  \"Joffrey Baratheon\"\n];\n\n答案：\n\nconst takeWhile = f => ([head, ...tail]) =>\n  f(head) ? [head, ...takeWhile(f)(tail)] : [];\n\nconst isStark = name => name.toLowerCase().includes(\"stark\");\n\ntakeWhile(isStark)(houses);\n\n```\n问题二： 找出数组中的奇数，然后取出前4个：\n```h\n\nconst numList = [1, 3, 11, 4, 2, 5, 6, 7];\n\n答案：\n\nconst takeFirst = (limit, f, arr) => {\n  if (limit === 0 || arr.length === 0) return [];\n  const [head, ...tail] = arr;\n  return f(head)\n    ? [head, ...takeFirst(limit - 1, f, tail)]\n    : takeFirst(limit, f, tail);\n};\n\nconst isOdd = n => n % 2 === 1;\n\ntakeFirst(4, isOdd, numList);\n\n```\n# 使用高阶函数遍历数组时可能遇到的陷阱\n\n问题一：  从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3\n```h\n\n// 用我们刚刚定义的辅助函数来生成符合要求的数组\nconst bigArr = genNumArr(1e6, 100);\n\n答案：\n\nconst isEven = num => num % 2 === 0;\nconst triple = num => num * 3;\n\nbigArr.filter(isEven).map(triple);\n\n// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：\n\nconst results = [];\nfor (let i = 0; i < bigArr.length; i++) {\n  if (isEven(bigArr[i])) {\n    results.push(triple(bigArr[i]));\n  }\n}\n\n// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！\n\n# Transduce\n\n先用 reduce 来定义 filter 和 map，至于为什么这样做等下再解释。\n```h\nconst filter = (f, arr) =>\n  arr.reduce((acc, val) => (f(val) && acc.push(val), acc), []);\n\nconst map = (f, arr) => arr.reduce((acc, val) => (acc.push(f(val)), acc), []);\n```\n重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：\n```h\nconst filter = f => reducer => (acc, value) => {\n  if (f(value)) return reducer(acc, value);\n  return acc;\n};\n\nconst map = f => reducer => (acc, value) => reducer(acc, f(value));\n```\n现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。\n```h\nconst pushReducer = (acc, value) => (acc.push(value), acc);\n\nbigNum.reduce(map(triple)(filter(isEven)(pushReducer)), []);\n```\n但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：\n```h\nconst pipe = (...fns) => (...args) => fns.reduce((fx, fy) => fy(fx), ...args);\n```\n然后我们就可以优雅地组合函数了：\n```h\nbigNum.reduce(\n  pipe(\n    filter(isEven),\n    map(triple)\n  )(pushReducer),\n  []\n);\n```\n经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。\n这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 [transducers-js](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcognitect-labs%2Ftransducers-js)。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。\n\n# for 循环和 for ... of 循环的区别\nfor ... of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for ... of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for ... of 来遍历数组是会被禁止的。\n那么，for ... of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个：\n\n```\n问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。\n```h\n\nconst starks = [\n  \"Eddard Stark\",\n  \"Catelyn Stark\",\n  \"Rickard Stark\",\n  \"Brandon Stark\",\n  \"Rob Stark\",\n  \"Sansa Stark\",\n  \"Arya Stark\",\n  \"Bran Stark\",\n  \"Rickon Stark\",\n  \"Lyanna Stark\"\n];\n\n答案：\n\nfunction* repeatedArr(arr) {\n  let i = 0;\n  while (true) {\n    yield arr[i++ % arr.length];\n  }\n}\n\nconst infiniteNameList = repeatedArr(starks);\n\nconst wait = ms =>\n  new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n\n(async () => {\n  for (const name of infiniteNameList) {\n    await wait(1000);\n    console.log(name);\n  }\n})();\n\n```\n前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。","slug":"怎样在JS里尽量少写for循环","published":1,"updated":"2018-09-17T15:58:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnfa0047kt89dj7v17mx","content":"<p>“很多场景，for来的更直接，更明了。”  “最喜欢for循环了。想break就break。可能会多数据的还是for循环。” “for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响”,这是很多时候都会考虑的问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"用好-filter，map，和其它-ES6-新增的高阶遍历函数\"><a href=\"#用好-filter，map，和其它-ES6-新增的高阶遍历函数\" class=\"headerlink\" title=\"用好 filter，map，和其它 ES6 新增的高阶遍历函数\"></a>用好 filter，map，和其它 ES6 新增的高阶遍历函数</h1><p>问题一： 将数组中的空值去除<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrContainsEmptyVal = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, undefined, null, <span class=\"number\">0</span>, <span class=\"string\">\"\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compact = arr =&gt; arr.filter(Boolean);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将数组中的 VIP 用户余额加 10<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Kelly\"</span>, isVIP: <span class=\"literal\">true</span>, balance: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Tom\"</span>, isVIP: <span class=\"literal\">false</span>, balance: <span class=\"number\">19</span> &#125;,</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Stephanie\"</span>, isVIP: <span class=\"literal\">true</span>, balance: <span class=\"number\">30</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">users.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">  user =&gt; (user.isVIP ? &#123; ...user, balance: user.balance + <span class=\"number\">10</span> &#125; : user)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。</span><br></pre></td></tr></table></figure></p>\n<p>问题三： 判断字符串中是否含有元音字母<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> randomStr = <span class=\"string\">\"hdjrwqpi\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isVowel = <span class=\"keyword\">char</span> =&gt; [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"o\"</span>, <span class=\"string\">\"i\"</span>, <span class=\"string\">\"u\"</span>].includes(<span class=\"keyword\">char</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> containsVowel = str =&gt; [...str].some(isVowel);</span><br><span class=\"line\"></span><br><span class=\"line\">containsVowel(randomStr);</span><br></pre></td></tr></table></figure></p>\n<p>问题四： 判断用户是否全部是成年人<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Jim\"</span>, age: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Lily\"</span>, age: <span class=\"number\">17</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Will\"</span>, age: <span class=\"number\">25</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">users.every(user =&gt; user.age &gt;= <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure></p>\n<p>问题五： 找出上面用户中的未成年人<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Jim\"</span>, age: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Lily\"</span>, age: <span class=\"number\">17</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Will\"</span>, age: <span class=\"number\">25</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> findTeen = users =&gt; users.find(user =&gt; user.age &lt; <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">findTeen(users);</span><br></pre></td></tr></table></figure></p>\n<p>问题六： 将数组中重复项清除<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dupArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uniq = arr =&gt; [...<span class=\"keyword\">new</span> Set(arr)];</span><br><span class=\"line\"></span><br><span class=\"line\">uniq(dupArr);</span><br></pre></td></tr></table></figure></p>\n<p>问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案：</span><br><span class=\"line\"><span class=\"keyword\">const</span> genNumArr = (length, limit) =&gt;</span><br><span class=\"line\">  Array.from(&#123; length &#125;, _ =&gt; Math.<span class=\"built_in\">floor</span>(Math.random() * limit));</span><br><span class=\"line\"></span><br><span class=\"line\">genNumArr(<span class=\"number\">10</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"理解和熟练使用-reduce\"><a href=\"#理解和熟练使用-reduce\" class=\"headerlink\" title=\"理解和熟练使用 reduce\"></a>理解和熟练使用 reduce</h1><p>问题一： 不借助原生高阶函数，定义 reduce<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案：</span><br><span class=\"line\"><span class=\"keyword\">const</span> reduce = (f, acc, arr) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [head, ...tail] = arr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(f, f(head, acc), tail);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将多层数组转换成一层数组<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nestedArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = arr =&gt;</span><br><span class=\"line\">  arr.reduce(</span><br><span class=\"line\">    (flat, next) =&gt; flat.concat(Array.isArray(next) ? flatten(next) : next),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></p>\n<p>问题三：将下面数组转成对象，key/value 对应里层数组的两个值<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objLikeArr = [[<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jim\"</span>], [<span class=\"string\">\"age\"</span>, <span class=\"number\">18</span>], [<span class=\"string\">\"single\"</span>, <span class=\"literal\">true</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromPairs = pairs =&gt;</span><br><span class=\"line\">  pairs.reduce((res, pair) =&gt; ((res[pair[<span class=\"number\">0</span>]] = pair[<span class=\"number\">1</span>]), res), &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fromPairs(objLikeArr);</span><br></pre></td></tr></table></figure></p>\n<p>问题四： 取出对象中的深层属性<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> deepAttr = &#123; a: &#123; b: &#123; c: <span class=\"number\">15</span> &#125; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pluckDeep = path =&gt; obj =&gt;</span><br><span class=\"line\">  path.split(<span class=\"string\">\".\"</span>).reduce((val, attr) =&gt; val[attr], obj);</span><br><span class=\"line\"></span><br><span class=\"line\">pluckDeep(<span class=\"string\">\"a.b.c\"</span>)(deepAttr);</span><br></pre></td></tr></table></figure></p>\n<p>问题五：将用户中的男性和女性分别放到不同的数组里：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Adam\"</span>, age: <span class=\"number\">30</span>, sex: <span class=\"string\">\"male\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Helen\"</span>, age: <span class=\"number\">27</span>, sex: <span class=\"string\">\"female\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Amy\"</span>, age: <span class=\"number\">25</span>, sex: <span class=\"string\">\"female\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Anthony\"</span>, age: <span class=\"number\">23</span>, sex: <span class=\"string\">\"male\"</span> &#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partition = (arr, isValid) =&gt;</span><br><span class=\"line\">  arr.reduce(</span><br><span class=\"line\">    ([pass, fail], elem) =&gt;</span><br><span class=\"line\">      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],</span><br><span class=\"line\">    [[], []],</span><br><span class=\"line\">  );</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> isMale = person =&gt; person.sex === <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [maleUser, femaleUser] = partition(users, isMale);</span><br></pre></td></tr></table></figure></p>\n<p>问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> unfold = (f, seed) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> go = (f, seed, acc) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = f(seed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res ? go(f, res[<span class=\"number\">1</span>], acc.concat(res[<span class=\"number\">0</span>])) : acc;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> go(f, seed, []);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">根据这个 unfold 函数，定义一个 Python 里面的 range 函数。</span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> range = (min, max, step = <span class=\"number\">1</span>) =&gt;</span><br><span class=\"line\">  unfold(x =&gt; x &lt; max &amp;&amp; [x, x + step], min);</span><br></pre></td></tr></table></figure>\n<h1 id=\"用递归代替循环（可以break！）\"><a href=\"#用递归代替循环（可以break！）\" class=\"headerlink\" title=\"用递归代替循环（可以break！）\"></a>用递归代替循环（可以break！）</h1><p>问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> num1 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> num2 = [<span class=\"number\">43</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">67</span>, <span class=\"number\">87</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipWith = f =&gt; xs =&gt; ys =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xs.length === <span class=\"number\">0</span> || ys.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [xHead, ...xTail] = xs;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [yHead, ...yTail] = ys;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = x =&gt; y =&gt; x + y;</span><br><span class=\"line\"></span><br><span class=\"line\">zipWith(add)(num1)(num2);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> houses = [</span><br><span class=\"line\">  <span class=\"string\">\"Eddard Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Catelyn Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rickard Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Brandon Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rob Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Sansa Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Arya Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Bran Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rickon Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Lyanna Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tywin Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Cersei Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Jaime Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tyrion Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Joffrey Baratheon\"</span></span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> takeWhile = f =&gt; ([head, ...tail]) =&gt;</span><br><span class=\"line\">  f(head) ? [head, ...takeWhile(f)(tail)] : [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isStark = name =&gt; name.toLowerCase().includes(<span class=\"string\">\"stark\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">takeWhile(isStark)(houses);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 找出数组中的奇数，然后取出前4个：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numList = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> takeFirst = (limit, f, arr) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (limit === <span class=\"number\">0</span> || arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [head, ...tail] = arr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(head)</span><br><span class=\"line\">    ? [head, ...takeFirst(limit - <span class=\"number\">1</span>, f, tail)]</span><br><span class=\"line\">    : takeFirst(limit, f, tail);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = n =&gt; n % <span class=\"number\">2</span> === <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">takeFirst(<span class=\"number\">4</span>, isOdd, numList);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用高阶函数遍历数组时可能遇到的陷阱\"><a href=\"#使用高阶函数遍历数组时可能遇到的陷阱\" class=\"headerlink\" title=\"使用高阶函数遍历数组时可能遇到的陷阱\"></a>使用高阶函数遍历数组时可能遇到的陷阱</h1><p>问题一：  从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用我们刚刚定义的辅助函数来生成符合要求的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bigArr = genNumArr(<span class=\"number\">1e6</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isEven = num =&gt; num % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> triple = num =&gt; num * <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bigArr.filter(isEven).<span class=\"built_in\">map</span>(triple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> results = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; bigArr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isEven(bigArr[i])) &#123;</span><br><span class=\"line\">    results.push(triple(bigArr[i]));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Transduce</span><br><span class=\"line\"></span><br><span class=\"line\">先用 reduce 来定义 filter 和 <span class=\"built_in\">map</span>，至于为什么这样做等下再解释。</span><br><span class=\"line\">```h</span><br><span class=\"line\"><span class=\"keyword\">const</span> filter = (f, arr) =&gt;</span><br><span class=\"line\">  arr.reduce((acc, val) =&gt; (f(val) &amp;&amp; acc.push(val), acc), []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (acc.push(f(val)), acc), []);</span><br></pre></td></tr></table></figure></p>\n<p>重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = f =&gt; reducer =&gt; (acc, value) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f(value)) <span class=\"keyword\">return</span> reducer(acc, value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = f =&gt; reducer =&gt; (acc, value) =&gt; reducer(acc, f(value));</span><br></pre></td></tr></table></figure></p>\n<p>现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pushReducer = (acc, value) =&gt; (acc.push(value), acc);</span><br><span class=\"line\"></span><br><span class=\"line\">bigNum.reduce(<span class=\"built_in\">map</span>(triple)(filter(isEven)(pushReducer)), []);</span><br></pre></td></tr></table></figure></p>\n<p>但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = (...fns) =&gt; (...args) =&gt; fns.reduce((fx, fy) =&gt; fy(fx), ...args);</span><br></pre></td></tr></table></figure></p>\n<p>然后我们就可以优雅地组合函数了：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigNum.reduce(</span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(isEven),</span><br><span class=\"line\">    <span class=\"built_in\">map</span>(triple)</span><br><span class=\"line\">  )(pushReducer),</span><br><span class=\"line\">  []</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。<br>这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcognitect-labs%2Ftransducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a>。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。</p>\n<h1 id=\"for-循环和-for-…-of-循环的区别\"><a href=\"#for-循环和-for-…-of-循环的区别\" class=\"headerlink\" title=\"for 循环和 for … of 循环的区别\"></a>for 循环和 for … of 循环的区别</h1><p>for … of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for … of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for … of 来遍历数组是会被禁止的。<br>那么，for … of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。</span><br><span class=\"line\">```h</span><br><span class=\"line\"></span><br><span class=\"line\">const starks = [</span><br><span class=\"line\">  &quot;Eddard Stark&quot;,</span><br><span class=\"line\">  &quot;Catelyn Stark&quot;,</span><br><span class=\"line\">  &quot;Rickard Stark&quot;,</span><br><span class=\"line\">  &quot;Brandon Stark&quot;,</span><br><span class=\"line\">  &quot;Rob Stark&quot;,</span><br><span class=\"line\">  &quot;Sansa Stark&quot;,</span><br><span class=\"line\">  &quot;Arya Stark&quot;,</span><br><span class=\"line\">  &quot;Bran Stark&quot;,</span><br><span class=\"line\">  &quot;Rickon Stark&quot;,</span><br><span class=\"line\">  &quot;Lyanna Stark&quot;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">function* repeatedArr(arr) &#123;</span><br><span class=\"line\">  let i = 0;</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    yield arr[i++ % arr.length];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const infiniteNameList = repeatedArr(starks);</span><br><span class=\"line\"></span><br><span class=\"line\">const wait = ms =&gt;</span><br><span class=\"line\">  new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">(async () =&gt; &#123;</span><br><span class=\"line\">  for (const name of infiniteNameList) &#123;</span><br><span class=\"line\">    await wait(1000);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。</p>\n","site":{"data":{}},"excerpt":"<p>“很多场景，for来的更直接，更明了。”  “最喜欢for循环了。想break就break。可能会多数据的还是for循环。” “for循环灵活易用，高阶函数简洁明了，合适的用合适方式，还是不能限制的太死吧，不然思维也会受影响”,这是很多时候都会考虑的问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/js_d.png\" alt=\"js\"></p>","more":"<h1 id=\"用好-filter，map，和其它-ES6-新增的高阶遍历函数\"><a href=\"#用好-filter，map，和其它-ES6-新增的高阶遍历函数\" class=\"headerlink\" title=\"用好 filter，map，和其它 ES6 新增的高阶遍历函数\"></a>用好 filter，map，和其它 ES6 新增的高阶遍历函数</h1><p>问题一： 将数组中的空值去除<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrContainsEmptyVal = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, undefined, null, <span class=\"number\">0</span>, <span class=\"string\">\"\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compact = arr =&gt; arr.filter(Boolean);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将数组中的 VIP 用户余额加 10<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Kelly\"</span>, isVIP: <span class=\"literal\">true</span>, balance: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Tom\"</span>, isVIP: <span class=\"literal\">false</span>, balance: <span class=\"number\">19</span> &#125;,</span><br><span class=\"line\">  &#123; username: <span class=\"string\">\"Stephanie\"</span>, isVIP: <span class=\"literal\">true</span>, balance: <span class=\"number\">30</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">users.<span class=\"built_in\">map</span>(</span><br><span class=\"line\">  user =&gt; (user.isVIP ? &#123; ...user, balance: user.balance + <span class=\"number\">10</span> &#125; : user)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">补充：有人说很明显这里该用 forEach，你为了举例而举例！我比较无语。forEach 是用来执行副作用的好吗？你把原数据都改了。我的习惯是使用 Immutable 数据。你要改数据的话，开心就好。</span><br></pre></td></tr></table></figure></p>\n<p>问题三： 判断字符串中是否含有元音字母<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> randomStr = <span class=\"string\">\"hdjrwqpi\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isVowel = <span class=\"keyword\">char</span> =&gt; [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"o\"</span>, <span class=\"string\">\"i\"</span>, <span class=\"string\">\"u\"</span>].includes(<span class=\"keyword\">char</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> containsVowel = str =&gt; [...str].some(isVowel);</span><br><span class=\"line\"></span><br><span class=\"line\">containsVowel(randomStr);</span><br></pre></td></tr></table></figure></p>\n<p>问题四： 判断用户是否全部是成年人<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Jim\"</span>, age: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Lily\"</span>, age: <span class=\"number\">17</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Will\"</span>, age: <span class=\"number\">25</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">users.every(user =&gt; user.age &gt;= <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure></p>\n<p>问题五： 找出上面用户中的未成年人<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Jim\"</span>, age: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Lily\"</span>, age: <span class=\"number\">17</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Will\"</span>, age: <span class=\"number\">25</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> findTeen = users =&gt; users.find(user =&gt; user.age &lt; <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">findTeen(users);</span><br></pre></td></tr></table></figure></p>\n<p>问题六： 将数组中重复项清除<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dupArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uniq = arr =&gt; [...<span class=\"keyword\">new</span> Set(arr)];</span><br><span class=\"line\"></span><br><span class=\"line\">uniq(dupArr);</span><br></pre></td></tr></table></figure></p>\n<p>问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案：</span><br><span class=\"line\"><span class=\"keyword\">const</span> genNumArr = (length, limit) =&gt;</span><br><span class=\"line\">  Array.from(&#123; length &#125;, _ =&gt; Math.<span class=\"built_in\">floor</span>(Math.random() * limit));</span><br><span class=\"line\"></span><br><span class=\"line\">genNumArr(<span class=\"number\">10</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"理解和熟练使用-reduce\"><a href=\"#理解和熟练使用-reduce\" class=\"headerlink\" title=\"理解和熟练使用 reduce\"></a>理解和熟练使用 reduce</h1><p>问题一： 不借助原生高阶函数，定义 reduce<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案：</span><br><span class=\"line\"><span class=\"keyword\">const</span> reduce = (f, acc, arr) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [head, ...tail] = arr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(f, f(head, acc), tail);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将多层数组转换成一层数组<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nestedArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = arr =&gt;</span><br><span class=\"line\">  arr.reduce(</span><br><span class=\"line\">    (flat, next) =&gt; flat.concat(Array.isArray(next) ? flatten(next) : next),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></p>\n<p>问题三：将下面数组转成对象，key/value 对应里层数组的两个值<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objLikeArr = [[<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jim\"</span>], [<span class=\"string\">\"age\"</span>, <span class=\"number\">18</span>], [<span class=\"string\">\"single\"</span>, <span class=\"literal\">true</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromPairs = pairs =&gt;</span><br><span class=\"line\">  pairs.reduce((res, pair) =&gt; ((res[pair[<span class=\"number\">0</span>]] = pair[<span class=\"number\">1</span>]), res), &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fromPairs(objLikeArr);</span><br></pre></td></tr></table></figure></p>\n<p>问题四： 取出对象中的深层属性<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> deepAttr = &#123; a: &#123; b: &#123; c: <span class=\"number\">15</span> &#125; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pluckDeep = path =&gt; obj =&gt;</span><br><span class=\"line\">  path.split(<span class=\"string\">\".\"</span>).reduce((val, attr) =&gt; val[attr], obj);</span><br><span class=\"line\"></span><br><span class=\"line\">pluckDeep(<span class=\"string\">\"a.b.c\"</span>)(deepAttr);</span><br></pre></td></tr></table></figure></p>\n<p>问题五：将用户中的男性和女性分别放到不同的数组里：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> users = [</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Adam\"</span>, age: <span class=\"number\">30</span>, sex: <span class=\"string\">\"male\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Helen\"</span>, age: <span class=\"number\">27</span>, sex: <span class=\"string\">\"female\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Amy\"</span>, age: <span class=\"number\">25</span>, sex: <span class=\"string\">\"female\"</span> &#125;,</span><br><span class=\"line\">  &#123; name: <span class=\"string\">\"Anthony\"</span>, age: <span class=\"number\">23</span>, sex: <span class=\"string\">\"male\"</span> &#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partition = (arr, isValid) =&gt;</span><br><span class=\"line\">  arr.reduce(</span><br><span class=\"line\">    ([pass, fail], elem) =&gt;</span><br><span class=\"line\">      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],</span><br><span class=\"line\">    [[], []],</span><br><span class=\"line\">  );</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> isMale = person =&gt; person.sex === <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [maleUser, femaleUser] = partition(users, isMale);</span><br></pre></td></tr></table></figure></p>\n<p>问题六： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）</p>\n<figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> unfold = (f, seed) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> go = (f, seed, acc) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = f(seed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res ? go(f, res[<span class=\"number\">1</span>], acc.concat(res[<span class=\"number\">0</span>])) : acc;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> go(f, seed, []);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">根据这个 unfold 函数，定义一个 Python 里面的 range 函数。</span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> range = (min, max, step = <span class=\"number\">1</span>) =&gt;</span><br><span class=\"line\">  unfold(x =&gt; x &lt; max &amp;&amp; [x, x + step], min);</span><br></pre></td></tr></table></figure>\n<h1 id=\"用递归代替循环（可以break！）\"><a href=\"#用递归代替循环（可以break！）\" class=\"headerlink\" title=\"用递归代替循环（可以break！）\"></a>用递归代替循环（可以break！）</h1><p>问题一： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> num1 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> num2 = [<span class=\"number\">43</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">67</span>, <span class=\"number\">87</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipWith = f =&gt; xs =&gt; ys =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xs.length === <span class=\"number\">0</span> || ys.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [xHead, ...xTail] = xs;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [yHead, ...yTail] = ys;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = x =&gt; y =&gt; x + y;</span><br><span class=\"line\"></span><br><span class=\"line\">zipWith(add)(num1)(num2);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> houses = [</span><br><span class=\"line\">  <span class=\"string\">\"Eddard Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Catelyn Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rickard Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Brandon Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rob Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Sansa Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Arya Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Bran Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Rickon Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Lyanna Stark\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tywin Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Cersei Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Jaime Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tyrion Lannister\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Joffrey Baratheon\"</span></span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> takeWhile = f =&gt; ([head, ...tail]) =&gt;</span><br><span class=\"line\">  f(head) ? [head, ...takeWhile(f)(tail)] : [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isStark = name =&gt; name.toLowerCase().includes(<span class=\"string\">\"stark\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">takeWhile(isStark)(houses);</span><br></pre></td></tr></table></figure></p>\n<p>问题二： 找出数组中的奇数，然后取出前4个：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numList = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> takeFirst = (limit, f, arr) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (limit === <span class=\"number\">0</span> || arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [head, ...tail] = arr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(head)</span><br><span class=\"line\">    ? [head, ...takeFirst(limit - <span class=\"number\">1</span>, f, tail)]</span><br><span class=\"line\">    : takeFirst(limit, f, tail);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = n =&gt; n % <span class=\"number\">2</span> === <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">takeFirst(<span class=\"number\">4</span>, isOdd, numList);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用高阶函数遍历数组时可能遇到的陷阱\"><a href=\"#使用高阶函数遍历数组时可能遇到的陷阱\" class=\"headerlink\" title=\"使用高阶函数遍历数组时可能遇到的陷阱\"></a>使用高阶函数遍历数组时可能遇到的陷阱</h1><p>问题一：  从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用我们刚刚定义的辅助函数来生成符合要求的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bigArr = genNumArr(<span class=\"number\">1e6</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isEven = num =&gt; num % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> triple = num =&gt; num * <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bigArr.filter(isEven).<span class=\"built_in\">map</span>(triple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> results = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; bigArr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isEven(bigArr[i])) &#123;</span><br><span class=\"line\">    results.push(triple(bigArr[i]));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Transduce</span><br><span class=\"line\"></span><br><span class=\"line\">先用 reduce 来定义 filter 和 <span class=\"built_in\">map</span>，至于为什么这样做等下再解释。</span><br><span class=\"line\">```h</span><br><span class=\"line\"><span class=\"keyword\">const</span> filter = (f, arr) =&gt;</span><br><span class=\"line\">  arr.reduce((acc, val) =&gt; (f(val) &amp;&amp; acc.push(val), acc), []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (acc.push(f(val)), acc), []);</span><br></pre></td></tr></table></figure></p>\n<p>重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = f =&gt; reducer =&gt; (acc, value) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f(value)) <span class=\"keyword\">return</span> reducer(acc, value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = f =&gt; reducer =&gt; (acc, value) =&gt; reducer(acc, f(value));</span><br></pre></td></tr></table></figure></p>\n<p>现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pushReducer = (acc, value) =&gt; (acc.push(value), acc);</span><br><span class=\"line\"></span><br><span class=\"line\">bigNum.reduce(<span class=\"built_in\">map</span>(triple)(filter(isEven)(pushReducer)), []);</span><br></pre></td></tr></table></figure></p>\n<p>但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = (...fns) =&gt; (...args) =&gt; fns.reduce((fx, fy) =&gt; fy(fx), ...args);</span><br></pre></td></tr></table></figure></p>\n<p>然后我们就可以优雅地组合函数了：<br><figure class=\"highlight h\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigNum.reduce(</span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(isEven),</span><br><span class=\"line\">    <span class=\"built_in\">map</span>(triple)</span><br><span class=\"line\">  )(pushReducer),</span><br><span class=\"line\">  []</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。<br>这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcognitect-labs%2Ftransducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a>。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。</p>\n<h1 id=\"for-循环和-for-…-of-循环的区别\"><a href=\"#for-循环和-for-…-of-循环的区别\" class=\"headerlink\" title=\"for 循环和 for … of 循环的区别\"></a>for 循环和 for … of 循环的区别</h1><p>for … of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for … of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for … of 来遍历数组是会被禁止的。<br>那么，for … of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。</span><br><span class=\"line\">```h</span><br><span class=\"line\"></span><br><span class=\"line\">const starks = [</span><br><span class=\"line\">  &quot;Eddard Stark&quot;,</span><br><span class=\"line\">  &quot;Catelyn Stark&quot;,</span><br><span class=\"line\">  &quot;Rickard Stark&quot;,</span><br><span class=\"line\">  &quot;Brandon Stark&quot;,</span><br><span class=\"line\">  &quot;Rob Stark&quot;,</span><br><span class=\"line\">  &quot;Sansa Stark&quot;,</span><br><span class=\"line\">  &quot;Arya Stark&quot;,</span><br><span class=\"line\">  &quot;Bran Stark&quot;,</span><br><span class=\"line\">  &quot;Rickon Stark&quot;,</span><br><span class=\"line\">  &quot;Lyanna Stark&quot;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">答案：</span><br><span class=\"line\"></span><br><span class=\"line\">function* repeatedArr(arr) &#123;</span><br><span class=\"line\">  let i = 0;</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    yield arr[i++ % arr.length];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const infiniteNameList = repeatedArr(starks);</span><br><span class=\"line\"></span><br><span class=\"line\">const wait = ms =&gt;</span><br><span class=\"line\">  new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">(async () =&gt; &#123;</span><br><span class=\"line\">  for (const name of infiniteNameList) &#123;</span><br><span class=\"line\">    await wait(1000);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。</p>"},{"title":"我们第一次相遇","date":"2018-05-04T15:38:11.000Z","description":null,"copyright":true,"top":10,"_content":"\n欢迎来到我的blog，这里是我记录生活和一些事情的地方，这里会收录一些好的文章，值得学习的东西；也是一个随记的地方。我们的遇到就是缘分的开始，互相学习，互相认识。\n\n![wo](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/drlong.png)\n\n# 我\n\n{% note danger %} 来自七彩云南  {% endnote %}\n{% note danger %} 读书于古都西安{% endnote %}\n{% note warning %} 现在坐标上海  {% endnote %}\n<!-- more -->\n{% note danger %} 耕织于前端开发，菜鸟到大神的过程是漫长的，不断学习，不断进步，说不定哪一天......  {% endnote %}\n{% note default %} 路要一步一步走，知识也要慢慢啃  {% endnote %}\n{% note info %} 喜欢运动打篮球，欢迎各大球友结识，还喜欢搞搞摄影视频剪辑，喜欢看到的色彩，等等还要就是美食烹饪  {% endnote %}\n\n{% note primary %} 好吧就这样吧！  {% endnote %}\n\n","source":"_posts/第一篇blog.md","raw":"---\ntitle: 我们第一次相遇\ndate: 2018-05-04 23:38:11\ntags: 生活\ndescription: \ncopyright: true\ntop: 10\ncategories: 随记\n# photos: /blog/images/drl.png\n---\n\n欢迎来到我的blog，这里是我记录生活和一些事情的地方，这里会收录一些好的文章，值得学习的东西；也是一个随记的地方。我们的遇到就是缘分的开始，互相学习，互相认识。\n\n![wo](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/drlong.png)\n\n# 我\n\n{% note danger %} 来自七彩云南  {% endnote %}\n{% note danger %} 读书于古都西安{% endnote %}\n{% note warning %} 现在坐标上海  {% endnote %}\n<!-- more -->\n{% note danger %} 耕织于前端开发，菜鸟到大神的过程是漫长的，不断学习，不断进步，说不定哪一天......  {% endnote %}\n{% note default %} 路要一步一步走，知识也要慢慢啃  {% endnote %}\n{% note info %} 喜欢运动打篮球，欢迎各大球友结识，还喜欢搞搞摄影视频剪辑，喜欢看到的色彩，等等还要就是美食烹饪  {% endnote %}\n\n{% note primary %} 好吧就这样吧！  {% endnote %}\n\n","slug":"第一篇blog","published":1,"updated":"2018-12-13T08:40:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnfc0049kt89uf1cld6k","content":"<p>欢迎来到我的blog，这里是我记录生活和一些事情的地方，这里会收录一些好的文章，值得学习的东西；也是一个随记的地方。我们的遇到就是缘分的开始，互相学习，互相认识。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/drlong.png\" alt=\"wo\"></p>\n<h1 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我\"></a>我</h1><div class=\"note danger\"><p>来自七彩云南  </p></div>\n<div class=\"note danger\"><p>读书于古都西安</p></div>\n<div class=\"note warning\"><p>现在坐标上海  </p></div>\n<a id=\"more\"></a>\n<div class=\"note danger\"><p>耕织于前端开发，菜鸟到大神的过程是漫长的，不断学习，不断进步，说不定哪一天……  </p></div>\n<div class=\"note default\"><p>路要一步一步走，知识也要慢慢啃  </p></div>\n<div class=\"note info\"><p>喜欢运动打篮球，欢迎各大球友结识，还喜欢搞搞摄影视频剪辑，喜欢看到的色彩，等等还要就是美食烹饪  </p></div>\n<div class=\"note primary\"><p>好吧就这样吧！  </p></div>\n","site":{"data":{}},"excerpt":"<p>欢迎来到我的blog，这里是我记录生活和一些事情的地方，这里会收录一些好的文章，值得学习的东西；也是一个随记的地方。我们的遇到就是缘分的开始，互相学习，互相认识。</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/drlong.png\" alt=\"wo\"></p>\n<h1 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我\"></a>我</h1><div class=\"note danger\"><p>来自七彩云南  </p></div>\n<div class=\"note danger\"><p>读书于古都西安</p></div>\n<div class=\"note warning\"><p>现在坐标上海  </p></div>","more":"<div class=\"note danger\"><p>耕织于前端开发，菜鸟到大神的过程是漫长的，不断学习，不断进步，说不定哪一天……  </p></div>\n<div class=\"note default\"><p>路要一步一步走，知识也要慢慢啃  </p></div>\n<div class=\"note info\"><p>喜欢运动打篮球，欢迎各大球友结识，还喜欢搞搞摄影视频剪辑，喜欢看到的色彩，等等还要就是美食烹饪  </p></div>\n<div class=\"note primary\"><p>好吧就这样吧！  </p></div>"},{"title":"Hexo搭建博客问题收集器","date":"2018-05-05T16:46:29.000Z","description":null,"copyright":true,"top":null,"_content":"记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n# First\n1 把主页配置文件`_config.yml` 里的`post_asset_folder:`这个选项设置为true\n\n2 在你的hexo目录下执行这样一句话`npm install hexo-asset-image --save`，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git\n\n3 等待一小段时间后，再运行`hexo n \"xxxx\"`来生成md博文时，`/source/_posts`文件夹内除了`xxxx.md`文件还有一个同名的文件夹\n\n# Second\n4 最后在`xxxx.md`中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：\n\n`![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)`\n![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)\n`![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)`\n![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)\n\n\n{% asset_img long.png 记一次Hexo文章里的图片不显示问题 %}\n\n也可以直接使用如下方式：\n```hash\n{% asset_img long.png 记一次Hexo文章里的图片不显示问题 %}\n```\n注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。\n\n5 最后检查一下，`hexo g`生成页面后，进入`public\\2017\\02\\26\\index.html`文件中查看相关字段，可以发现，html标签内的语句是`<img src=\"2017/02/26/xxxx/图片名.jpg\">`，而不是`<img src=\"xxxx/图片名.jpg>`。这很重要，关乎你的网页是否可以真正加载你想插入的图片。\n\n\n***\n\n# Hexo Next 解决 Busuanzi 统计浏览失效\n\n由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题时统计浏览数失效.\n\n不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/\n\n解决方法:\n\n到hexo的themes文件夹下, 进入\n\n`\\themes\\next\\layout_third-party\\analytics`\n\n打开: `busuanzi-counter.swig`\n\n将`src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”`\n\n修改为`src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”``\n\n\n","source":"_posts/记一次Hexo文章里的图片不显示问题.md","raw":"---\ntitle: Hexo搭建博客问题收集器\ndate: 2018-05-06 00:46:29\ntags: 编程\ndescription: \ncopyright: true\ncategories: Hexo\ntop:\n---\n记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！\n\n![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png)\n\n<!-- more -->\n# First\n1 把主页配置文件`_config.yml` 里的`post_asset_folder:`这个选项设置为true\n\n2 在你的hexo目录下执行这样一句话`npm install hexo-asset-image --save`，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git\n\n3 等待一小段时间后，再运行`hexo n \"xxxx\"`来生成md博文时，`/source/_posts`文件夹内除了`xxxx.md`文件还有一个同名的文件夹\n\n# Second\n4 最后在`xxxx.md`中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：\n\n`![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)`\n![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)\n`![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)`\n![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)\n\n\n{% asset_img long.png 记一次Hexo文章里的图片不显示问题 %}\n\n也可以直接使用如下方式：\n```hash\n{% asset_img long.png 记一次Hexo文章里的图片不显示问题 %}\n```\n注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。\n\n5 最后检查一下，`hexo g`生成页面后，进入`public\\2017\\02\\26\\index.html`文件中查看相关字段，可以发现，html标签内的语句是`<img src=\"2017/02/26/xxxx/图片名.jpg\">`，而不是`<img src=\"xxxx/图片名.jpg>`。这很重要，关乎你的网页是否可以真正加载你想插入的图片。\n\n\n***\n\n# Hexo Next 解决 Busuanzi 统计浏览失效\n\n由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题时统计浏览数失效.\n\n不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/\n\n解决方法:\n\n到hexo的themes文件夹下, 进入\n\n`\\themes\\next\\layout_third-party\\analytics`\n\n打开: `busuanzi-counter.swig`\n\n将`src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”`\n\n修改为`src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”``\n\n\n","slug":"记一次Hexo文章里的图片不显示问题","published":1,"updated":"2018-10-12T10:03:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpmctnfe004ekt89hgk6fzxm","content":"<p>记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>\n<a id=\"more\"></a>\n<h1 id=\"First\"><a href=\"#First\" class=\"headerlink\" title=\"First\"></a>First</h1><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为true</p>\n<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p>\n<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>\n<h1 id=\"Second\"><a href=\"#Second\" class=\"headerlink\" title=\"Second\"></a>Second</h1><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>\n<p><code>![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)</code><br><img src=\"/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png\" alt=\"你想输入的替代文字\"><br><code>![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)</code><br><img src=\"http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg\" alt=\"直接给地址咋样\"></p>\n<img src=\"/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png\" title=\"记一次Hexo文章里的图片不显示问题\">\n<p>也可以直接使用如下方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img long.png 记一次Hexo文章里的图片不显示问题 %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>\n<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\\2017\\02\\26\\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>\n<hr>\n<h1 id=\"Hexo-Next-解决-Busuanzi-统计浏览失效\"><a href=\"#Hexo-Next-解决-Busuanzi-统计浏览失效\" class=\"headerlink\" title=\"Hexo Next 解决 Busuanzi 统计浏览失效\"></a>Hexo Next 解决 Busuanzi 统计浏览失效</h1><p>由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题时统计浏览数失效.</p>\n<p>不蒜子官网:<a href=\"http://ibruce.info/2015/04/04/busuanzi/\" target=\"_blank\" rel=\"noopener\">http://ibruce.info/2015/04/04/busuanzi/</a></p>\n<p>解决方法:</p>\n<p>到hexo的themes文件夹下, 进入</p>\n<p><code>\\themes\\next\\layout_third-party\\analytics</code></p>\n<p>打开: <code>busuanzi-counter.swig</code></p>\n<p>将<code>src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”</code></p>\n<p>修改为<code>src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”`</code></p>\n","site":{"data":{}},"excerpt":"<p>记一次Hexo文章里的图片不显示问题，不然超级麻烦！！！！</p>\n<p><img src=\"https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/hexo_d.png\" alt=\"js\"></p>","more":"<h1 id=\"First\"><a href=\"#First\" class=\"headerlink\" title=\"First\"></a>First</h1><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为true</p>\n<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p>\n<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>\n<h1 id=\"Second\"><a href=\"#Second\" class=\"headerlink\" title=\"Second\"></a>Second</h1><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>\n<p><code>![你想输入的替代文字](记一次Hexo文章里的图片不显示问题/long.png)</code><br><img src=\"/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png\" alt=\"你想输入的替代文字\"><br><code>![直接给地址咋样](http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg)</code><br><img src=\"http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg\" alt=\"直接给地址咋样\"></p>\n<img src=\"/blog/2018/05/06/记一次Hexo文章里的图片不显示问题/long.png\" title=\"记一次Hexo文章里的图片不显示问题\">\n<p>也可以直接使用如下方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img long.png 记一次Hexo文章里的图片不显示问题 %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>\n<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\\2017\\02\\26\\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>\n<hr>\n<h1 id=\"Hexo-Next-解决-Busuanzi-统计浏览失效\"><a href=\"#Hexo-Next-解决-Busuanzi-统计浏览失效\" class=\"headerlink\" title=\"Hexo Next 解决 Busuanzi 统计浏览失效\"></a>Hexo Next 解决 Busuanzi 统计浏览失效</h1><p>由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题时统计浏览数失效.</p>\n<p>不蒜子官网:<a href=\"http://ibruce.info/2015/04/04/busuanzi/\" target=\"_blank\" rel=\"noopener\">http://ibruce.info/2015/04/04/busuanzi/</a></p>\n<p>解决方法:</p>\n<p>到hexo的themes文件夹下, 进入</p>\n<p><code>\\themes\\next\\layout_third-party\\analytics</code></p>\n<p>打开: <code>busuanzi-counter.swig</code></p>\n<p>将<code>src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”</code></p>\n<p>修改为<code>src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”`</code></p>"}],"PostAsset":[{"_id":"source/_posts/React-开发常用设计模式-前言/cover1.png","slug":"cover1.png","post":"cjpmctndm000tkt89uhajn44m","modified":1,"renderable":0},{"_id":"source/_posts/React开发常用设计模式-Flux/flex.png","slug":"flex.png","post":"cjpmctne00014kt89s0zcsbb5","modified":1,"renderable":0},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1.png","slug":"xcx1.png","post":"cjpmctnf2003vkt89uv06x72r","modified":1,"renderable":0},{"_id":"source/_posts/小程序之旅——个人申请/xcx_2.png","slug":"xcx_2.png","post":"cjpmctnf50040kt89nic2y5rf","modified":1,"renderable":0},{"_id":"source/_posts/小程序之旅——个人申请/xcx_7.png","slug":"xcx_7.png","post":"cjpmctnf50040kt89nic2y5rf","modified":1,"renderable":0},{"_id":"source/_posts/ES6攻略/01.png","post":"cjpmctnd5000bkt89ml6ilgpv","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-事件处理/react_3.png","post":"cjpmctne2001ckt89nm0clzop","slug":"react_3.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-事件处理/react_4.png","post":"cjpmctne2001ckt89nm0clzop","slug":"react_4.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-单向数据流/react_store.jpg","post":"cjpmctne4001jkt8986vjcr98","slug":"react_store.jpg","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-单向数据流/react_store1.jpg","post":"cjpmctne4001jkt8986vjcr98","slug":"react_store1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/记一次Hexo文章里的图片不显示问题/alipay.png","post":"cjpmctnfe004ekt89hgk6fzxm","slug":"alipay.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次Hexo文章里的图片不显示问题/long.png","post":"cjpmctnfe004ekt89hgk6fzxm","slug":"long.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组件通讯/react_1.png","post":"cjpmctnec001ykt89v0vm5wh6","slug":"react_1.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组件通讯/react_2.png","post":"cjpmctnec001ykt89v0vm5wh6","slug":"react_2.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组件通讯/reactput.png","post":"cjpmctnec001ykt89v0vm5wh6","slug":"reactput.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1-1.png","post":"cjpmctnf2003vkt89uv06x72r","slug":"xcx1-1.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅—-认识一下/xcx1-2.png","post":"cjpmctnf2003vkt89uv06x72r","slug":"xcx1-2.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_5.png","post":"cjpmctned0021kt89ws444o90","slug":"react_5.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_6.png","post":"cjpmctned0021kt89ws444o90","slug":"react_6.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_7.png","post":"cjpmctned0021kt89ws444o90","slug":"react_7.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-组合-composition/react_8.png","post":"cjpmctned0021kt89ws444o90","slug":"react_8.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-Redux/react.jpg","post":"cjpmctne10019kt89w3i17dlt","slug":"react.jpg","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-architecture.jpg","post":"cjpmctne10019kt89w3i17dlt","slug":"redux-architecture.jpg","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-counter-app.png","post":"cjpmctne10019kt89w3i17dlt","slug":"redux-counter-app.png","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-Redux/redux-reallife.jpg","post":"cjpmctne10019kt89w3i17dlt","slug":"redux-reallife.jpg","modified":1,"renderable":1},{"_id":"source/_posts/React开发常用设计模式-Redux/tag-it.png","post":"cjpmctne10019kt89w3i17dlt","slug":"tag-it.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅——个人申请/xcx.png","post":"cjpmctnf50040kt89nic2y5rf","slug":"xcx.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅——个人申请/xcx_1.png","slug":"xcx_1.png","post":"cjpmctnf50040kt89nic2y5rf","modified":1,"renderable":0},{"_id":"source/_posts/小程序之旅——个人申请/xcx_3.png","post":"cjpmctnf50040kt89nic2y5rf","slug":"xcx_3.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅——个人申请/xcx_4.png","post":"cjpmctnf50040kt89nic2y5rf","slug":"xcx_4.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅——个人申请/xcx_5.png","post":"cjpmctnf50040kt89nic2y5rf","slug":"xcx_5.png","modified":1,"renderable":1},{"_id":"source/_posts/小程序之旅——个人申请/xcx_6.png","post":"cjpmctnf50040kt89nic2y5rf","slug":"xcx_6.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjpmctncp0000kt89niw1niuk","category_id":"cjpmctncy0003kt89hf5co7l2","_id":"cjpmctnd6000ckt89zedmu899"},{"post_id":"cjpmctnd3000akt893hlnzd63","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctnde000ikt89u7lllh66"},{"post_id":"cjpmctncv0002kt892kpj20if","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctndg000nkt8909jb1hlv"},{"post_id":"cjpmctnd5000bkt89ml6ilgpv","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctndj000pkt89jlgewiat"},{"post_id":"cjpmctnd8000fkt89o0luwjwa","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctndn000ukt897xqqaptg"},{"post_id":"cjpmctnd00005kt89wmgbwhzc","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctndt000xkt89j7458g1y"},{"post_id":"cjpmctndf000mkt89yv8o8df0","category_id":"cjpmctncy0003kt89hf5co7l2","_id":"cjpmctndx0012kt89c5okaj5r"},{"post_id":"cjpmctnd10006kt896it1x44i","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctne10015kt89t2ftyrse"},{"post_id":"cjpmctndi000okt89w7peutqw","category_id":"cjpmctncy0003kt89hf5co7l2","_id":"cjpmctne2001akt89reyw9sg0"},{"post_id":"cjpmctnd20007kt89tu4qjt90","category_id":"cjpmctnd20008kt8975xi7wwx","_id":"cjpmctne3001dkt893wr02ajg"},{"post_id":"cjpmctnde000hkt897y28h0kd","category_id":"cjpmctndu000ykt89fxa8gt46","_id":"cjpmctne4001ikt89avshav1b"},{"post_id":"cjpmctne10019kt89w3i17dlt","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctne5001kkt89533kozww"},{"post_id":"cjpmctndm000tkt89uhajn44m","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctne7001okt89t4vrbxw7"},{"post_id":"cjpmctne2001ckt89nm0clzop","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctne9001rkt89riz8niib"},{"post_id":"cjpmctne3001hkt89q8xtq97z","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnec001wkt895syzkxfv"},{"post_id":"cjpmctnds000wkt896s2zjpz1","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctned001zkt89jr02ih15"},{"post_id":"cjpmctne4001jkt8986vjcr98","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnee0022kt89trnyodjq"},{"post_id":"cjpmctne6001nkt89sfnsf6ea","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnef0025kt89qz36rj2r"},{"post_id":"cjpmctndx0011kt89bw27fknb","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctneg0029kt897kq28gxz"},{"post_id":"cjpmctne8001qkt89p6z04gbm","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctneh002ckt89ilpjjrwr"},{"post_id":"cjpmctneb001vkt89c9zivkph","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnej002gkt89x7jc13cb"},{"post_id":"cjpmctne00014kt89s0zcsbb5","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnek002jkt8975z50yf9"},{"post_id":"cjpmctnec001ykt89v0vm5wh6","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnel002okt89efv5o12i"},{"post_id":"cjpmctned0021kt89ws444o90","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnen002rkt89phsbd9uf"},{"post_id":"cjpmctnee0024kt89zn8g8t8w","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctner002vkt898s9zdsvv"},{"post_id":"cjpmctneg002bkt89bs4oz5jr","category_id":"cjpmctndu000ykt89fxa8gt46","_id":"cjpmctnes002ykt893qp69zp0"},{"post_id":"cjpmctnej002ikt89abm9nvum","category_id":"cjpmctnei002ekt8926loc2cg","_id":"cjpmctneu0033kt89za5rl11k"},{"post_id":"cjpmctnef0028kt895an3mmo6","category_id":"cjpmctnei002ekt8926loc2cg","_id":"cjpmctnev0036kt89ilicbfvd"},{"post_id":"cjpmctnel002mkt89t5t9avtl","category_id":"cjpmctne10016kt89bwrhjqxy","_id":"cjpmctnew003bkt89pxh8rqie"},{"post_id":"cjpmctnem002qkt89kvuy1vg2","category_id":"cjpmctnei002ekt8926loc2cg","_id":"cjpmctnex003ekt89snqyeriw"},{"post_id":"cjpmctnej002fkt895cgwv1wk","category_id":"cjpmctnel002nkt890x4caiez","_id":"cjpmctney003ikt893sxkymx3"},{"post_id":"cjpmctneq002ukt89j4z6363x","category_id":"cjpmctnet0031kt89ays0yr8h","_id":"cjpmctnez003mkt89gkdjg0ui"},{"post_id":"cjpmctnes002xkt89p7jmxtts","category_id":"cjpmctnet0031kt89ays0yr8h","_id":"cjpmctnf0003pkt894c3masy2"},{"post_id":"cjpmctnet0032kt89nnz5i1to","category_id":"cjpmctney003hkt89rirlnm02","_id":"cjpmctnf4003ykt89xbmstq0t"},{"post_id":"cjpmctneu0035kt89pzunw278","category_id":"cjpmctney003hkt89rirlnm02","_id":"cjpmctnfa0044kt89kp5079pp"},{"post_id":"cjpmctnf50040kt89nic2y5rf","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfd004akt89qbzu663w"},{"post_id":"cjpmctnev0039kt89yvuj6u7i","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfe004fkt89rehhiv3z"},{"post_id":"cjpmctnf80042kt89yqk852c7","category_id":"cjpmctnet0031kt89ays0yr8h","_id":"cjpmctnff004hkt897dg37p75"},{"post_id":"cjpmctnfa0047kt89dj7v17mx","category_id":"cjpmctncy0003kt89hf5co7l2","_id":"cjpmctnfg004lkt89ppp2xl4i"},{"post_id":"cjpmctnew003dkt8980f2ag28","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfg004nkt89ga0f207m"},{"post_id":"cjpmctnfe004ekt89hgk6fzxm","category_id":"cjpmctnei002ekt8926loc2cg","_id":"cjpmctnfh004rkt89mbd5p4cy"},{"post_id":"cjpmctnex003gkt89rgoliccq","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfh004tkt89aykv4k7n"},{"post_id":"cjpmctney003lkt89skyuijsa","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfi004xkt89qr1m0joc"},{"post_id":"cjpmctnez003okt89ph4gjgfz","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfi0052kt89waz4nf5o"},{"post_id":"cjpmctnf1003tkt89b7q4kn3f","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfj0057kt89xdz70oi3"},{"post_id":"cjpmctnf2003vkt89uv06x72r","category_id":"cjpmctnf3003xkt89i7xae341","_id":"cjpmctnfk005bkt89lpf9s634"},{"post_id":"cjpmctnfc0049kt89uf1cld6k","category_id":"cjpmctnfj0056kt8980egdfbh","_id":"cjpmctnfl005fkt89ew08ffgt"}],"PostTag":[{"post_id":"cjpmctncp0000kt89niw1niuk","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctndd000gkt89ovg2r4ce"},{"post_id":"cjpmctncp0000kt89niw1niuk","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnde000jkt89ly9pma0g"},{"post_id":"cjpmctndf000mkt89yv8o8df0","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctndm000skt893vk30rci"},{"post_id":"cjpmctndf000mkt89yv8o8df0","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctndr000vkt890i48qdpz"},{"post_id":"cjpmctndi000okt89w7peutqw","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctndw0010kt89huu384wd"},{"post_id":"cjpmctndi000okt89w7peutqw","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctne00013kt89v5w6yd4w"},{"post_id":"cjpmctncv0002kt892kpj20if","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctne10018kt896jhs1fxl"},{"post_id":"cjpmctncv0002kt892kpj20if","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctne2001bkt896l06pnhw"},{"post_id":"cjpmctncv0002kt892kpj20if","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctne3001fkt891o17bs1w"},{"post_id":"cjpmctnd00005kt89wmgbwhzc","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctne7001pkt89z2yiihoe"},{"post_id":"cjpmctnd00005kt89wmgbwhzc","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnea001skt893jkteyis"},{"post_id":"cjpmctnd00005kt89wmgbwhzc","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnec001xkt898elxqnx2"},{"post_id":"cjpmctnd10006kt896it1x44i","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnee0023kt89sd2z8aqc"},{"post_id":"cjpmctnd10006kt896it1x44i","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnef0026kt897hn70oy4"},{"post_id":"cjpmctnd10006kt896it1x44i","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctneg002akt89wy1538ev"},{"post_id":"cjpmctnd20007kt89tu4qjt90","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnej002hkt89gepf0uhh"},{"post_id":"cjpmctnd20007kt89tu4qjt90","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnek002kkt89deq8g30q"},{"post_id":"cjpmctnd20007kt89tu4qjt90","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnem002pkt892pbcgb1a"},{"post_id":"cjpmctnd3000akt893hlnzd63","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnen002skt890ryykj9j"},{"post_id":"cjpmctnd3000akt893hlnzd63","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctner002wkt89echuo1b4"},{"post_id":"cjpmctnd3000akt893hlnzd63","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnet002zkt89jobgtc0g"},{"post_id":"cjpmctnej002ikt89abm9nvum","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctneu0034kt89uawadqb9"},{"post_id":"cjpmctnd5000bkt89ml6ilgpv","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnev0037kt89jwxy7ezw"},{"post_id":"cjpmctnd5000bkt89ml6ilgpv","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnew003ckt89dwgvqosi"},{"post_id":"cjpmctnd5000bkt89ml6ilgpv","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnex003fkt89pcvwc0v8"},{"post_id":"cjpmctnd8000fkt89o0luwjwa","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctney003kkt89sh3m5dge"},{"post_id":"cjpmctnd8000fkt89o0luwjwa","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnez003nkt89c3wxmmpn"},{"post_id":"cjpmctnd8000fkt89o0luwjwa","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnf1003skt893dk82rqo"},{"post_id":"cjpmctnde000hkt897y28h0kd","tag_id":"cjpmctnet0030kt89lw4z7xbe","_id":"cjpmctnf2003ukt89f87idtcp"},{"post_id":"cjpmctnde000hkt897y28h0kd","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnf4003zkt89u90pzaxp"},{"post_id":"cjpmctndm000tkt89uhajn44m","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnf70041kt89aeblez0e"},{"post_id":"cjpmctndm000tkt89uhajn44m","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfa0045kt89yylski1q"},{"post_id":"cjpmctnds000wkt896s2zjpz1","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfc0048kt89ljw39183"},{"post_id":"cjpmctnds000wkt896s2zjpz1","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfd004ckt89z6pm30g1"},{"post_id":"cjpmctndx0011kt89bw27fknb","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnff004gkt891tfzd0q4"},{"post_id":"cjpmctndx0011kt89bw27fknb","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnff004jkt897jaat7i9"},{"post_id":"cjpmctne00014kt89s0zcsbb5","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfg004mkt89ydxkce3a"},{"post_id":"cjpmctne00014kt89s0zcsbb5","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfg004pkt89toye52rx"},{"post_id":"cjpmctnfa0047kt89dj7v17mx","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfh004skt89ue6g74we"},{"post_id":"cjpmctnfa0047kt89dj7v17mx","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfh004vkt89xbgn7fbd"},{"post_id":"cjpmctne10019kt89w3i17dlt","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfi004ykt89mwenhe98"},{"post_id":"cjpmctne10019kt89w3i17dlt","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfi0050kt897fygw9jg"},{"post_id":"cjpmctnfe004ekt89hgk6fzxm","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfj0053kt89y98gv5mt"},{"post_id":"cjpmctne2001ckt89nm0clzop","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfj0055kt89nt9gzgv5"},{"post_id":"cjpmctne2001ckt89nm0clzop","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfj0058kt89rjcl1ibj"},{"post_id":"cjpmctne3001hkt89q8xtq97z","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfk005akt8926mvotdf"},{"post_id":"cjpmctne3001hkt89q8xtq97z","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfk005ckt89opfg98ft"},{"post_id":"cjpmctne4001jkt8986vjcr98","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfl005ekt89jkc4shn5"},{"post_id":"cjpmctne4001jkt8986vjcr98","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfl005gkt89knpcbfft"},{"post_id":"cjpmctne6001nkt89sfnsf6ea","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfl005ikt89aigusqoh"},{"post_id":"cjpmctne6001nkt89sfnsf6ea","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfm005jkt89qhzfr1jq"},{"post_id":"cjpmctne8001qkt89p6z04gbm","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfm005lkt89e3cx9ygq"},{"post_id":"cjpmctne8001qkt89p6z04gbm","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfn005mkt89z3pundem"},{"post_id":"cjpmctneb001vkt89c9zivkph","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfn005okt8955wlqr6j"},{"post_id":"cjpmctneb001vkt89c9zivkph","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfo005pkt89ovn8pppq"},{"post_id":"cjpmctnec001ykt89v0vm5wh6","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfp005rkt896sq6g610"},{"post_id":"cjpmctnec001ykt89v0vm5wh6","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfp005skt89ps5sp5ib"},{"post_id":"cjpmctned0021kt89ws444o90","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfp005tkt89qtegx2of"},{"post_id":"cjpmctned0021kt89ws444o90","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfq005vkt899rxeys8a"},{"post_id":"cjpmctnee0024kt89zn8g8t8w","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfq005wkt89p7ykraoh"},{"post_id":"cjpmctnee0024kt89zn8g8t8w","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfq005ykt89qkdo1au7"},{"post_id":"cjpmctnef0028kt895an3mmo6","tag_id":"cjpmctnfm005kkt89jxx0ie7s","_id":"cjpmctnfq005zkt89b2zplglv"},{"post_id":"cjpmctneg002bkt89bs4oz5jr","tag_id":"cjpmctnet0030kt89lw4z7xbe","_id":"cjpmctnfr0061kt89j5bxahla"},{"post_id":"cjpmctneg002bkt89bs4oz5jr","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfr0062kt89o78y3eru"},{"post_id":"cjpmctnej002fkt895cgwv1wk","tag_id":"cjpmctnfo005qkt89t6kyznmy","_id":"cjpmctnfr0064kt89kyzk87cm"},{"post_id":"cjpmctnej002fkt895cgwv1wk","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfr0065kt89ytdjdq3x"},{"post_id":"cjpmctnej002fkt895cgwv1wk","tag_id":"cjpmctnfp005ukt89g1kw3u2k","_id":"cjpmctnfr0067kt89oirx6j4r"},{"post_id":"cjpmctnel002mkt89t5t9avtl","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfr0068kt89gcbenjoo"},{"post_id":"cjpmctnel002mkt89t5t9avtl","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfs006akt89oedwm2go"},{"post_id":"cjpmctnem002qkt89kvuy1vg2","tag_id":"cjpmctnfm005kkt89jxx0ie7s","_id":"cjpmctnfs006bkt89hundk98j"},{"post_id":"cjpmctneq002ukt89j4z6363x","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfs006dkt899cngiqqw"},{"post_id":"cjpmctneq002ukt89j4z6363x","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfs006ekt899vlvq8ki"},{"post_id":"cjpmctneq002ukt89j4z6363x","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfs006fkt8970axpmhz"},{"post_id":"cjpmctneq002ukt89j4z6363x","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctnfs006hkt89saqvppgm"},{"post_id":"cjpmctnes002xkt89p7jmxtts","tag_id":"cjpmctnfr0069kt89v5mhw5no","_id":"cjpmctnfs006ikt895wadrvov"},{"post_id":"cjpmctnes002xkt89p7jmxtts","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnft006kkt8935x93qt7"},{"post_id":"cjpmctnes002xkt89p7jmxtts","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnft006lkt89n0kwr91r"},{"post_id":"cjpmctnes002xkt89p7jmxtts","tag_id":"cjpmctndj000rkt89paj5l721","_id":"cjpmctnft006nkt895rdix5mt"},{"post_id":"cjpmctnet0032kt89nnz5i1to","tag_id":"cjpmctnfs006ckt89vf0xk0re","_id":"cjpmctnft006okt89yb1xsmpz"},{"post_id":"cjpmctnet0032kt89nnz5i1to","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfu006qkt897vy2aha6"},{"post_id":"cjpmctnet0032kt89nnz5i1to","tag_id":"cjpmctnfs006gkt89liqc1f0t","_id":"cjpmctnfu006rkt89nivtaj1a"},{"post_id":"cjpmctneu0035kt89pzunw278","tag_id":"cjpmctnfs006ckt89vf0xk0re","_id":"cjpmctnfu006tkt89w4ec5ofx"},{"post_id":"cjpmctneu0035kt89pzunw278","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfu006ukt89weizpx9c"},{"post_id":"cjpmctneu0035kt89pzunw278","tag_id":"cjpmctnfs006gkt89liqc1f0t","_id":"cjpmctnfv006wkt892znik3x1"},{"post_id":"cjpmctnev0039kt89yvuj6u7i","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfv006xkt89srexhzmk"},{"post_id":"cjpmctnev0039kt89yvuj6u7i","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfv006zkt89yu0gkude"},{"post_id":"cjpmctnev0039kt89yvuj6u7i","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfv0070kt89ogxs1ypd"},{"post_id":"cjpmctnew003dkt8980f2ag28","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfw0072kt89a4qk7800"},{"post_id":"cjpmctnew003dkt8980f2ag28","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfw0073kt898cubzk90"},{"post_id":"cjpmctnew003dkt8980f2ag28","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfw0075kt89dl8908nd"},{"post_id":"cjpmctnex003gkt89rgoliccq","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfw0076kt8930f3qiqe"},{"post_id":"cjpmctnex003gkt89rgoliccq","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfx0078kt89nqjjeu8l"},{"post_id":"cjpmctnex003gkt89rgoliccq","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfx0079kt89u2nf2o2w"},{"post_id":"cjpmctney003lkt89skyuijsa","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfx007bkt896ub5jg9n"},{"post_id":"cjpmctney003lkt89skyuijsa","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfx007ckt89nhvztkv8"},{"post_id":"cjpmctney003lkt89skyuijsa","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfy007ekt89jtswy0hf"},{"post_id":"cjpmctnez003okt89ph4gjgfz","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfy007fkt897pr7h975"},{"post_id":"cjpmctnez003okt89ph4gjgfz","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfz007hkt89sae8vxgr"},{"post_id":"cjpmctnez003okt89ph4gjgfz","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfz007ikt891yw3fkbc"},{"post_id":"cjpmctnf1003tkt89b7q4kn3f","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfz007jkt89e6rya7kj"},{"post_id":"cjpmctnf1003tkt89b7q4kn3f","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfz007kkt89vfs2mirv"},{"post_id":"cjpmctnf1003tkt89b7q4kn3f","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfz007lkt89rr6164ks"},{"post_id":"cjpmctnf2003vkt89uv06x72r","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfz007mkt893edjra0v"},{"post_id":"cjpmctnf2003vkt89uv06x72r","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfz007nkt89a6br47sd"},{"post_id":"cjpmctnf2003vkt89uv06x72r","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctnfz007okt89efjzlv4z"},{"post_id":"cjpmctnf50040kt89nic2y5rf","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctnfz007pkt89lw8guewh"},{"post_id":"cjpmctnf50040kt89nic2y5rf","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctnfz007qkt895jgt9kwf"},{"post_id":"cjpmctnf50040kt89nic2y5rf","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctng0007rkt89mb4lhcyz"},{"post_id":"cjpmctnf80042kt89yqk852c7","tag_id":"cjpmctncz0004kt89y9ivq8ft","_id":"cjpmctng0007skt89ul9cz1bl"},{"post_id":"cjpmctnf80042kt89yqk852c7","tag_id":"cjpmctnfr0063kt89e9yf1e7a","_id":"cjpmctng0007tkt89fyl5gn7x"},{"post_id":"cjpmctnf80042kt89yqk852c7","tag_id":"cjpmctnd20009kt89ldgwrm12","_id":"cjpmctng0007ukt89f2o440rw"},{"post_id":"cjpmctnf80042kt89yqk852c7","tag_id":"cjpmctnev0038kt89bw9ken28","_id":"cjpmctng0007vkt89w2osa1d6"},{"post_id":"cjpmctnfc0049kt89uf1cld6k","tag_id":"cjpmctnfm005kkt89jxx0ie7s","_id":"cjpmctng0007wkt89cbfqnpkw"}],"Tag":[{"name":"Javascript","_id":"cjpmctncz0004kt89y9ivq8ft"},{"name":"编程","_id":"cjpmctnd20009kt89ldgwrm12"},{"name":"ES6","_id":"cjpmctndj000rkt89paj5l721"},{"name":"软件","_id":"cjpmctnet0030kt89lw4z7xbe"},{"name":"React","_id":"cjpmctnev0038kt89bw9ken28"},{"name":"生活","_id":"cjpmctnfm005kkt89jxx0ie7s"},{"name":"mongoDB","_id":"cjpmctnfo005qkt89t6kyznmy"},{"name":"Node","_id":"cjpmctnfp005ukt89g1kw3u2k"},{"name":"小程序","_id":"cjpmctnfr0063kt89e9yf1e7a"},{"name":"CSS","_id":"cjpmctnfr0069kt89v5mhw5no"},{"name":"PHP","_id":"cjpmctnfs006ckt89vf0xk0re"},{"name":"后端","_id":"cjpmctnfs006gkt89liqc1f0t"}]}}