---
title: 前端面试集锦
date: 2018-05-24 22:30:17
tags: [CSS,编程,Javascript,ES6]
description: 
copyright: true
categories: 编程
top: 9
---

这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。

![js](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/blog/webtry_d.png)

<!--more-->

# 前言

> 一些更新从最新的开始

# Ract

## React生命周期?
### React 生命周期分为三种状态 `1. 初始化` `2.更新` `3.销毁`

![react生命周期](https://raw.githubusercontent.com/Duanruilong/phone_drl/master/image/react/reactSMZQ.png)

<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->

> 初始化

1、`getDefaultProps()` 设置默认的props，也可以使用`dufaultProps`设置组件的默认属性
2、`getInitialState()`在es6的class语法里是没有这个函数的，可直接在`construction`里去定义`this.state`也就可以访问到`this.props`
3、`compontentWillMount()`整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改`state`值
4、`render` 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了
5、`compontentDidMount()` 组件渲染完成之后调用，且只调用一次

> 更新

6、`componentWillReceiverProps(nextProps)` 在组件初始化的时候不会触发，组件接收到新的`props`时触发
7、`shouldCompontUpdate(nextProps, nextState)` 这里是`React`性能优化非常重要的生命周期。在组件接收到新的`props`或者`state`时可以触发这个生命周期，可以对比前后`props`和`state`是否一样，如果相同一样则返回`false`去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行`diff`算法对比，极大地节省性能。
8、`componentWillUpdate(nextProps, nextState)` 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改`state`
9、`render()` 渲染组件
10、 `componentDidUpdate()` 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取`dom`节点

> 卸载


11、`componentWillUnmount()` 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等
***



# 前端的一些知识模块
** HTML **
对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储

** CSS **
flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性

** JavaScript **
数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE

** 其他 **
移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作

作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。

# HTML
##  Doctype作用？标准模式与兼容模式各有什么区别?

1、`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于 `<html> `标签之前。告知浏览器的解析器用什么文档标准解析这个文档。`DOCTYPE`不存在或格式不正确会导致文档以兼容模式呈现。

2、`标准模式的排版` 和 `JS运作模式`都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。
***
## HTML5 为什么只需要写 <!DOCTYPE HTML>？
HTML5不基于`SGML`,所以不需要对DTD进行引用，但是他也需要`DOCTYPE`来规范浏览器的行为。
***
## 常见的浏览器有哪些，及其浏览器的内核是啥？
Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]
Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]
Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]
***
## 浏览器内核的理解？
主要分为两部分：`渲染引擎（Layout engineer或Rendering Engine）`和`JS引擎`
> 渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。

> JS引擎：解析和执行JavaScript实现网页动态效果。
***
## 页面样式引入，`link`与``@import`的区别？
1、`link`属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；
2、`@import`是CSS提供的，只能用于加载CSS;
3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
4、`import`是CSS2.1 提出的，只在IE5以上才能被识别，而`link`是XHTML标签，`无兼容问题`;
***
## 行内元素有哪些，块级元素有哪些，空元素有哪些？
> CSS规范规定，每个元素都有`display`属性，确定该元素的类型，每个元素都有默认的`display`值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

行内元素: `a b span img input select strong(强调的语气)`
块级元素：`div p ul ol li dl dt dd h1 h2 h3 h4 ...`
常见的空元素: `<br> <hr> <img> <input> <link> <meta>`和`<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>`
***
## HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
```h
HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
    - 绘画 canvas;
    - 用于媒介回放的 video 和 audio 元素;
    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
    - sessionStorage 的数据在浏览器关闭后自动删除;
    - 语意化更好的内容元素，比如 article、footer、header、nav、section;
    - 表单控件，calendar、date、time、email、url、search;
    - 新的技术webworker, websocket, Geolocation;

    - 移除的元素：
        纯表现的元素：basefont，big，center，font, s，strike，tt，u;
        对可用性产生负面影响的元素：frame，frameset，noframes；

   - 支持HTML5新标签：
        IE8/IE7/IE6支持通过document.createElement方法产生的标签，
        可以利用这一特性让这些浏览器支持HTML5新标签，
        浏览器支持新标签后，还需要添加标签默认的样式。

        当然也可以直接使用成熟的框架、比如html5shim;
        <!--[if lt IE 9]>
            <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
        <![endif]-->

如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素
```
***
## 简述一下你对HTML语义化的理解？
`用正确的标签做正确的事情。`
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
***
## HTML5的离线储存怎么使用，工作原理能不能解释一下？
>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用：
1、页面头部像下面一样加入一个`manifest`的属性；
2、在`cache.manifest`文件的编写离线存储的资源；
    `CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html`
3、在离线状态时，操作`window.applicationCache`进行需求实现。

详细的使用请参考：[HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/),[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)
***
## 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
在线的情况下，浏览器发现html头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。
详细请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)
***
## 描述一下 `Cookies`，`SessionStorage` 和 `LocalStorage` 的区别？
`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。
存储大小：
* cookie数据大小不能超过4k。
* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

有期时间：
* localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
* sessionStorage  数据在当前浏览器窗口关闭后自动删除。
* cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
***
## **Iframe有那些缺点？**
iframe会阻塞主页面的Onload事件；
搜索引擎的检索程序无法解读这种页面，不利于SEO;

iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
> 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。
***
## Label的作用是什么？是怎么用的？
> `label`标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

```
<label for="Name">Number:</label>
<input type=“text“name="Name" id="Name"/>

<label>Date:<input type="text" name="B"/></label>
```
***


# CSS

## 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？
（1）有两种， `IE 盒子模型`、`W3C 盒子模型`；
（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；
（3）区  别： IE的content部分把 border 和 padding计算了进去;
***



# 算法题

### 快速排序

思路:
- 随机选择数组中的一个数 A，以这个数为基准
- 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边
- 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的
- 这时候将左边和右边的数再递归上面的过程
```h
const Arr = [85, 24, 63, 45, 17, 31, 96, 50];
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    let pivotIndex = Math.floor(arr.length / 2);
    let pivot = arr.splice(pivotIndex, 1)[0];
    let left = [];
    let right = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    // 递归
    return quickSort(left).concat([pivot], quickSort(right));
}

console.log(quickSort(Arr));
```
ps:
这是阮老师的一个快排写法，网上对于这个的争论很多，第一说了阮老师不应该用splice去取值，应该用下标，还有就是不应该每次都从新开俩个新数组。
其实我觉得算法题重要的是思路，实现的方式有很多，不一定说谁对谁错，效率越好的算法的确是我们想要的，但是更多的理解一些不同的实现思路，我觉得也是可以的～。

这里是不同的声音： [面试官：阮一峰版的快速排序完全是错的](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5af4902a6fb9a07abf728c40)

***

### 二分排序法

二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。
二分查找是一种「分治」思想的算法，大概流程如下：

- 数组中排在中间的数字 A，与要找的数字比较大小
- 因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A
- 较小则说明应该从查找数字的后半部分查找
- 这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止


题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```h

function Find(target, array) {
    let i = 0;
    let j = array[i].length - 1;
    while (i < array.length && j >= 0) {
        if (array[i][j] < target) {
            i++;
        } else if (array[i][j] > target) {
            j--;
        } else {
            return true;
        }
    }
    return false;
}

//测试用例
console.log(Find(10, [
    [1, 2, 3, 4], 
    [5, 9, 10, 11], 
    [13, 20, 21, 23]
    ])
);

```
***

### 解析url后的参数

```h
function parseParam(url) {
  let obj = {};
  let arr = url.split("?");
  if (arr.length == 1) { //判断没有问号
    return "无参数"
  }
  let total = arr[1].split("&");
  for (let i = 0; i < total.length; i++) {
    let single = total[i].split("=");
    if (single[0] == '') { //判断有？但是没有参数
      return '无参数'
    }
    if (!single[1]) {
      obj[single[0]] = true;
    } else {
      if (obj[single[0]]) {
        let concat
        if (!Array.isArray(obj[single[0]])) { //判断是否数组
          concat = [obj[single[0]]]
        } else {
          concat = obj[single[0]];
        }
        concat.push(single[1]);
        concat = new Set(concat);
        concat = Array.from(concat) //数组去重
        obj[single[0]] = concat
      } else {
        obj[single[0]] = decodeURI(single[1]) //进行转码
      }
    }
  }
  return obj
}

var url = 'http://www.baidu.com/?user=huixin&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';

var params = parseParam(url)

console.log(params)

```
***

### 实现一个简单的模版引擎：

例如：我叫a,年龄b，性别c； let data = { name: '小明', age: 18, } 没有定义的返回undefined

```h

let template = '我是{name}，年龄{age}，性别{sex}';
let data = {
    name: '小明',
    age: 18,
}
const  reg= /({([a-zA-Z]+)})/g;
var r= '',regrounp={};
while( r = reg.exec(template) ){
    Object.defineProperty(regrounp,r[2],{
        enumerable:true,
        value:r[2]
    })
}

var render = (template,regrounp)=>{
    var result='';
    for( key in regrounp){
        if(data[key] == undefined){
            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,"g"),undefined);
        }else{		
            result  = (result || template).replace(new RegExp(`{${regrounp[key]}}`,"g"),data[key]);
        }
    }
    return result
}
let newtemple = render(template, regrounp);
console.log(newtemple) // 结果： 我是小明，年龄18，性别undefined

```

对于{}这样声明的对象，可以直接枚举，Object.defineProperty声明出的对象，如果不定义enumerable:true的话，是不能用for-in 枚举的。


这里有一片很好的文章 推荐 [编写一个简单的JavaScript模板引擎](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b3b93115188251afa62ad46)

***

### 如何快速让字符串变成已千为精度的数字

```h
function exchange(num) {
    num += ''; //转成字符串
    if (num.length <= 3) {
        return num;
    }

    num = num.replace(/\d{1,3}(?=(\d{3})+$)/g, (v) => {
        console.log(v)
        return v + ',';
    });
    return num;
}

console.log(exchange(1234567));
```
***

### 实现 JS 对象的深拷贝

深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。
分析下怎么做 深拷贝 ：

- 首先假设深拷贝这个方法已经完成，为 deepClo
- 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复

```h
function deepClo(o1, o2) {
    for (let k in o2) {
        if (typeof o2[k] === 'object') {
            o1[k] = {};
            deepClo(o1[k], o2[k]);
        } else {
            o1[k] = o2[k];
        }
    }
}
// 测试用例
let obj = {
    a: 1,
    b: [1, 2, 3],
    c: {}
};
let emptyObj = Object.create(null);
deepClo(emptyObj, obj);
console.log(emptyObj.a == obj.a);
console.log(emptyObj.b == obj.b);

```
递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。

***

### 求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项

```h
下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值：
 let count = 0;
 function fn(n) {
    let cache = {};
    function _fn(n) {
        if (cache[n]) {
            return cache[n];
        }
        count++;
        if (n == 1 || n == 2) {
            return 1;
        }
        let prev = _fn(n - 1);
        cache[n - 1] = prev;
        let next = _fn(n - 2);
        cache[n - 2] = next;
        return prev + next;
    }
    return _fn(n);
}

let count2 = 0;
function fn2(n) {
    count2++;
    if (n == 1 || n == 2) {
        return 1;
    }
    return fn2(n - 1) + fn2(n - 2);
}

console.log(fn(20), count); // 6765 20
console.log(fn2(20), count2); // 6765 13529

```
***

### 算法的效率

算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。
常见的时间复杂度有：

- 常数阶 O(1)
- 对数阶 O(logN)
- 线性阶 O(n)
- 线性对数阶 O(nlogN)
- 平方阶 O(n^2)
- 立方阶 O(n^3)
- !k次方阶 O(n^k)
- 指数阶 O(2^n)

随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。
一般做算法复杂度分析的时候，遵循下面的技巧：

- 看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推
- 如果有二分，则为O(logN)
- 保留最高项，去除常数项

题目：分析下面代码的算法复杂度

```h
let i =0; // 语句执行一次 
while (i < n) { // 语句执行 n 次 
  console.log(`Current i is ${i}`); //语句执行 n 次
  i++; // 语句执行 n 次
}
根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。

```
更多阅读：
[在 JavaScript 中学习数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F594dfe795188250d725a220a%23heading-18)
[我接触过的前端数据结构与算法](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5958bac35188250d892f5c91%3Futm_source%3Dgold_browser_extension)


