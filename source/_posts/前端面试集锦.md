---
title: 前端面试集锦
date: 2018-05-24 22:30:17
tags: [CSS,编程,Javascript,ES6]
description: 
copyright: true
categories: 编程
top:
---

这是一份关于面试的集锦，会收集广泛的面试点或者热点资讯，及时掌握前端的动态和储备自己的面试库，才可以在面试过程里游刃有余，持续积累。

![React](https://coding.net/u/DRuilong/p/phone_drl/git/raw/master/image/webtry_d.png)

<!--more-->

# 前言

> 一些更新从最新的开始

# Ract

## React生命周期?
### React 生命周期分为三种状态 `1. 初始化` `2.更新` `3.销毁`

![react生命周期](https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg)

<!-- ![react生命周期](https://segmentfault.com/img/bVLyCB?w=2803&h=2945) -->

> 初始化

1、`getDefaultProps()` 设置默认的props，也可以使用`dufaultProps`设置组件的默认属性
2、`getInitialState()`在es6的class语法里是没有这个函数的，可直接在`construction`里去定义`this.state`也就可以访问到`this.props`
3、`compontentWillMount()`整个生命周期只调用一次，在组件初始化时调用，之后就不会再调用，此时可以修改`state`值
4、`render` 这个时期是最重要的步骤，创建虚拟DOM，进行diff算法，更新DOM树，此时不可以修改state了
5、`compontentDidMount()` 组件渲染完成之后调用，且只调用一次

> 更新

6、`componentWillReceiverProps(nextProps)` 在组件初始化的时候不会触发，组件接收到新的`props`时触发
7、`shouldCompontUpdate(nextProps, nextState)` 这里是`React`性能优化非常重要的生命周期。在组件接收到新的`props`或者`state`时可以触发这个生命周期，可以对比前后`props`和`state`是否一样，如果相同一样则返回`false`去阻止组件更新，这样就避免了重新生成相同DOM树的过程，也就不需要创建新的DOM树和旧的DOM树进行`diff`算法对比，极大地节省性能。
8、`componentWillUpdate(nextProps, nextState)` 在组件初始化的时候不调用，在组件将要更新的时候才会调用，此时可以去修改`state`
9、`render()` 渲染组件
10、 `componentDidUpdate()` 在组件初始化的时候不调用，在组件更新完之后调用，这里可以去获取`dom`节点

> 卸载


11、`componentWillUnmount()` 在组件将要卸载的时候调用，这里可以去清理一些页面的定时器任务和事件监听等
***



# 前端的一些知识模块
** HTML **
对Web理解，不同浏览器的内核区分和兼容性，选择器的优先级，标签元素类型，HTML5，HTML网页缓存与存储

** CSS **
flex布局，简单布局，圣杯布局和双飞翼布局，响应式布局，动画，编译工具（Sass,Less,Stylus），盒子模型，定位机制，iconfont字体，CSS3常见新特性

** JavaScript **
数据类型，对象操作，算法运算，继承，闭包，作用域，原型链，事件，function，JSON，AJax，RegExp，跨域，异步操作，DOM，BOM，内存泄漏，前端MVC，模块化，路由，Canvas，ES6，NodeJs，React，VUE

** 其他 **
移动端，自动化构建，WEB安全，项目优化，项目重构，职业规划，学习，团队协作

作为一名前端工程师，应该有一颗随时学习的心态，学会总结，对于有些知识点我们应该时常记住。

# HTML
##  Doctype作用？标准模式与兼容模式各有什么区别?

1、`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于 `<html> `标签之前。告知浏览器的解析器用什么文档标准解析这个文档。`DOCTYPE`不存在或格式不正确会导致文档以兼容模式呈现。

2、`标准模式的排版` 和 `JS运作模式`都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的形式向后兼容的方式显示,模拟老式浏览器的行为防止页面渲染失败。
***
## HTML5 为什么只需要写 <!DOCTYPE HTML>？
HTML5不基于`SGML`,所以不需要对DTD进行引用，但是他也需要`DOCTYPE`来规范浏览器的行为。
***
## 常见的浏览器有哪些，及其浏览器的内核是啥？
Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。  [又称MSHTML]
Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
Presto内核：Opera7及以上。          [Opera内核原为：Presto，现为：Blink;]
Webkit内核：Safari,Chrome等。      [ Chrome的：Blink（WebKit的分支）]
***
## 浏览器内核的理解？
主要分为两部分：`渲染引擎（Layout engineer或Rendering Engine）`和`JS引擎`
> 渲染引擎:负责网页的内容（HTML、XML、图像等）、整理讯息（引入CSS、JS等），计算网页的显示方式，输出显示。不同的浏览器内核对于网页的语法解释也就不同，就存在网页渲染的效果不同，这也就是兼容性。

> JS引擎：解析和执行JavaScript实现网页动态效果。
***
## 页面样式引入，`link`与``@import`的区别？
1、`link`属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；
2、`@import`是CSS提供的，只能用于加载CSS;
3、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
4、`import`是CSS2.1 提出的，只在IE5以上才能被识别，而`link`是XHTML标签，`无兼容问题`;
***
## 行内元素有哪些，块级元素有哪些，空元素有哪些？
> CSS规范规定，每个元素都有`display`属性，确定该元素的类型，每个元素都有默认的`display`值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

行内元素: `a b span img input select strong(强调的语气)`
块级元素：`div p ul ol li dl dt dd h1 h2 h3 h4 ...`
常见的空元素: `<br> <hr> <img> <input> <link> <meta>`和`<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>`
***
## HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
```h
HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
    - 绘画 canvas;
    - 用于媒介回放的 video 和 audio 元素;
    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
    - sessionStorage 的数据在浏览器关闭后自动删除;
    - 语意化更好的内容元素，比如 article、footer、header、nav、section;
    - 表单控件，calendar、date、time、email、url、search;
    - 新的技术webworker, websocket, Geolocation;

    - 移除的元素：
        纯表现的元素：basefont，big，center，font, s，strike，tt，u;
        对可用性产生负面影响的元素：frame，frameset，noframes；

   - 支持HTML5新标签：
        IE8/IE7/IE6支持通过document.createElement方法产生的标签，
        可以利用这一特性让这些浏览器支持HTML5新标签，
        浏览器支持新标签后，还需要添加标签默认的样式。

        当然也可以直接使用成熟的框架、比如html5shim;
        <!--[if lt IE 9]>
            <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
        <![endif]-->

如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素
```
***
## 简述一下你对HTML语义化的理解？
`用正确的标签做正确的事情。`
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
***
## HTML5的离线储存怎么使用，工作原理能不能解释一下？
>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用：
1、页面头部像下面一样加入一个`manifest`的属性；
2、在`cache.manifest`文件的编写离线存储的资源；
    `CACHE  MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html`
3、在离线状态时，操作`window.applicationCache`进行需求实现。

详细的使用请参考：[HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/),[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)
***
## 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
在线的情况下，浏览器发现html头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。
详细请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)
***
## 描述一下 `Cookies`，`SessionStorage` 和 `LocalStorage` 的区别？
`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。
存储大小：
* cookie数据大小不能超过4k。
* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

有期时间：
* localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
* sessionStorage  数据在当前浏览器窗口关闭后自动删除。
* cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
***
## **Iframe有那些缺点？**
iframe会阻塞主页面的Onload事件；
搜索引擎的检索程序无法解读这种页面，不利于SEO;

iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
> 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。
***
## Label的作用是什么？是怎么用的？
> `label`标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

```
<label for="Name">Number:</label>
<input type=“text“name="Name" id="Name"/>

<label>Date:<input type="text" name="B"/></label>
```
***


# CSS

## 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？
（1）有两种， `IE 盒子模型`、`W3C 盒子模型`；
（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；
（3）区  别： IE的content部分把 border 和 padding计算了进去;
***


